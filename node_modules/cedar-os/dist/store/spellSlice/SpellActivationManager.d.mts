import { ActivationConditions, ActivationState, ActivationEvent } from './SpellTypes.mjs';

type ActivationCallback = (state: ActivationState) => void;
type DeactivationCallback = () => void;
interface SpellRegistration {
    spellId: string;
    conditions: ActivationConditions;
    onActivate?: ActivationCallback;
    onDeactivate?: DeactivationCallback;
    preventDefaultEvents?: boolean;
    ignoreInputElements?: boolean;
    isActive: boolean;
    lastTriggerTime: number;
    isOnCooldown: boolean;
    heldKeys: Set<string>;
    activeHoldEvent: ActivationEvent | null;
}
/**
 * Centralized manager for spell activations.
 * Maintains a single set of event listeners and routes events to registered spells.
 */
declare class SpellActivationManager {
    private static instance;
    private registrations;
    private isListening;
    private lastMousePosition;
    private boundHandlers;
    private selectionTimeout;
    private constructor();
    static getInstance(): SpellActivationManager;
    /**
     * Destroy the singleton instance (primarily for testing)
     * This allows complete reset of the manager between tests
     */
    static destroyInstance(): void;
    /**
     * Register a spell with its activation conditions
     */
    register(spellId: string, conditions: ActivationConditions, callbacks: {
        onActivate?: ActivationCallback;
        onDeactivate?: DeactivationCallback;
        preventDefaultEvents?: boolean;
        ignoreInputElements?: boolean;
    }): void;
    /**
     * Reset the manager (primarily for testing)
     * Clears all registrations and stops listening
     */
    reset(): void;
    /**
     * Get registrations (primarily for testing)
     */
    getRegistrations(): Map<string, SpellRegistration>;
    /**
     * Unregister a spell
     */
    unregister(spellId: string): void;
    /**
     * Get activation state for a spell
     */
    getActivationState(spellId: string): ActivationState;
    /**
     * Start listening to events (if not already)
     */
    private startListening;
    /**
     * Stop listening to events
     */
    private stopListening;
    /**
     * Helper to check if event target is an input element
     */
    private isInputElement;
    /**
     * Parse hotkey combo string
     */
    private parseHotkeyCombo;
    /**
     * Check if keyboard event matches hotkey
     */
    private matchesHotkey;
    /**
     * Check if a string is a keyboard combo
     */
    private isKeyboardCombo;
    /**
     * Extract event types from conditions
     */
    private extractEventTypes;
    /**
     * Activate a spell
     */
    private activateSpell;
    /**
     * Deactivate a spell
     */
    private deactivateSpell;
    private handleMouseMove;
    private handleKeyDown;
    private handleKeyUp;
    private handleClick;
    private handleContextMenu;
    private handleDoubleClick;
    private handleAuxClick;
    private handleMouseUp;
    private handleSelectionChange;
}

export { SpellActivationManager as default };
