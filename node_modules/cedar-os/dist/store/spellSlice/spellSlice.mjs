var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/store/spellSlice/SpellTypes.ts
var Hotkey = /* @__PURE__ */ ((Hotkey2) => {
  Hotkey2["A"] = "a";
  Hotkey2["B"] = "b";
  Hotkey2["C"] = "c";
  Hotkey2["D"] = "d";
  Hotkey2["E"] = "e";
  Hotkey2["F"] = "f";
  Hotkey2["G"] = "g";
  Hotkey2["H"] = "h";
  Hotkey2["I"] = "i";
  Hotkey2["J"] = "j";
  Hotkey2["K"] = "k";
  Hotkey2["L"] = "l";
  Hotkey2["M"] = "m";
  Hotkey2["N"] = "n";
  Hotkey2["O"] = "o";
  Hotkey2["P"] = "p";
  Hotkey2["Q"] = "q";
  Hotkey2["R"] = "r";
  Hotkey2["S"] = "s";
  Hotkey2["T"] = "t";
  Hotkey2["U"] = "u";
  Hotkey2["V"] = "v";
  Hotkey2["W"] = "w";
  Hotkey2["X"] = "x";
  Hotkey2["Y"] = "y";
  Hotkey2["Z"] = "z";
  Hotkey2["F1"] = "f1";
  Hotkey2["F2"] = "f2";
  Hotkey2["F3"] = "f3";
  Hotkey2["F4"] = "f4";
  Hotkey2["F5"] = "f5";
  Hotkey2["F6"] = "f6";
  Hotkey2["F7"] = "f7";
  Hotkey2["F8"] = "f8";
  Hotkey2["F9"] = "f9";
  Hotkey2["F10"] = "f10";
  Hotkey2["F11"] = "f11";
  Hotkey2["F12"] = "f12";
  Hotkey2["ESCAPE"] = "escape";
  Hotkey2["ENTER"] = "enter";
  Hotkey2["SPACE"] = "space";
  Hotkey2["TAB"] = "tab";
  Hotkey2["DELETE"] = "delete";
  Hotkey2["BACKSPACE"] = "backspace";
  Hotkey2["ARROW_UP"] = "arrowup";
  Hotkey2["ARROW_DOWN"] = "arrowdown";
  Hotkey2["ARROW_LEFT"] = "arrowleft";
  Hotkey2["ARROW_RIGHT"] = "arrowright";
  Hotkey2["CTRL"] = "ctrl";
  Hotkey2["CMD"] = "cmd";
  Hotkey2["META"] = "meta";
  Hotkey2["ALT"] = "alt";
  Hotkey2["SHIFT"] = "shift";
  return Hotkey2;
})(Hotkey || {});
var MouseEvent = /* @__PURE__ */ ((MouseEvent2) => {
  MouseEvent2["RIGHT_CLICK"] = "right-click";
  MouseEvent2["DOUBLE_CLICK"] = "double-click";
  MouseEvent2["MIDDLE_CLICK"] = "middle-click";
  MouseEvent2["MOUSE_SCROLL"] = "mouse-scroll";
  MouseEvent2["SHIFT_CLICK"] = "shift+click";
  MouseEvent2["CTRL_CLICK"] = "ctrl+click";
  MouseEvent2["CMD_CLICK"] = "cmd+click";
  MouseEvent2["ALT_CLICK"] = "alt+click";
  return MouseEvent2;
})(MouseEvent || {});
var SelectionEvent = /* @__PURE__ */ ((SelectionEvent2) => {
  SelectionEvent2["TEXT_SELECT"] = "text-select";
  return SelectionEvent2;
})(SelectionEvent || {});

// src/store/spellSlice/SpellActivationManager.ts
var _SpellActivationManager = class _SpellActivationManager {
  constructor() {
    __publicField(this, "registrations", /* @__PURE__ */ new Map());
    __publicField(this, "isListening", false);
    __publicField(this, "lastMousePosition", { x: 0, y: 0 });
    // Bound event handlers (for proper removal)
    __publicField(this, "boundHandlers", {
      keydown: this.handleKeyDown.bind(this),
      keyup: this.handleKeyUp.bind(this),
      mousemove: this.handleMouseMove.bind(this),
      mouseup: this.handleMouseUp.bind(this),
      click: this.handleClick.bind(this),
      contextmenu: this.handleContextMenu.bind(this),
      dblclick: this.handleDoubleClick.bind(this),
      auxclick: this.handleAuxClick.bind(this),
      selectionchange: this.handleSelectionChange.bind(this)
    });
    __publicField(this, "selectionTimeout", null);
  }
  static getInstance() {
    if (!_SpellActivationManager.instance) {
      _SpellActivationManager.instance = new _SpellActivationManager();
    }
    return _SpellActivationManager.instance;
  }
  /**
   * Destroy the singleton instance (primarily for testing)
   * This allows complete reset of the manager between tests
   */
  static destroyInstance() {
    if (_SpellActivationManager.instance) {
      _SpellActivationManager.instance.reset();
      _SpellActivationManager.instance = null;
    }
  }
  /**
   * Register a spell with its activation conditions
   */
  register(spellId, conditions, callbacks) {
    const registration = {
      spellId,
      conditions,
      onActivate: callbacks.onActivate,
      onDeactivate: callbacks.onDeactivate,
      preventDefaultEvents: callbacks.preventDefaultEvents ?? true,
      ignoreInputElements: callbacks.ignoreInputElements ?? true,
      isActive: false,
      lastTriggerTime: 0,
      isOnCooldown: false,
      heldKeys: /* @__PURE__ */ new Set(),
      activeHoldEvent: null
    };
    this.registrations.set(spellId, registration);
    this.startListening();
  }
  /**
   * Reset the manager (primarily for testing)
   * Clears all registrations and stops listening
   */
  reset() {
    for (const registration of this.registrations.values()) {
      if (registration.isActive) {
        this.deactivateSpell(registration);
      }
    }
    this.registrations.clear();
    this.stopListening();
    this.isListening = false;
    this.lastMousePosition = { x: 0, y: 0 };
    if (this.selectionTimeout) {
      clearTimeout(this.selectionTimeout);
      this.selectionTimeout = null;
    }
  }
  /**
   * Get registrations (primarily for testing)
   */
  getRegistrations() {
    return this.registrations;
  }
  /**
   * Unregister a spell
   */
  unregister(spellId) {
    const registration = this.registrations.get(spellId);
    if (registration && registration.isActive) {
      this.deactivateSpell(registration);
    }
    this.registrations.delete(spellId);
    if (this.registrations.size === 0) {
      this.stopListening();
    }
  }
  /**
   * Get activation state for a spell
   */
  getActivationState(spellId) {
    const registration = this.registrations.get(spellId);
    return {
      isActive: registration?.isActive ?? false
    };
  }
  /**
   * Start listening to events (if not already)
   */
  startListening() {
    if (this.isListening) return;
    this.isListening = true;
    window.addEventListener("keydown", this.boundHandlers.keydown);
    window.addEventListener("keyup", this.boundHandlers.keyup);
    window.addEventListener("mousemove", this.boundHandlers.mousemove);
    window.addEventListener("mouseup", this.boundHandlers.mouseup);
    window.addEventListener("click", this.boundHandlers.click);
    window.addEventListener("contextmenu", this.boundHandlers.contextmenu);
    window.addEventListener("dblclick", this.boundHandlers.dblclick);
    window.addEventListener("auxclick", this.boundHandlers.auxclick);
    document.addEventListener(
      "selectionchange",
      this.boundHandlers.selectionchange
    );
  }
  /**
   * Stop listening to events
   */
  stopListening() {
    if (!this.isListening) return;
    this.isListening = false;
    window.removeEventListener("keydown", this.boundHandlers.keydown);
    window.removeEventListener("keyup", this.boundHandlers.keyup);
    window.removeEventListener("mousemove", this.boundHandlers.mousemove);
    window.removeEventListener("mouseup", this.boundHandlers.mouseup);
    window.removeEventListener("click", this.boundHandlers.click);
    window.removeEventListener("contextmenu", this.boundHandlers.contextmenu);
    window.removeEventListener("dblclick", this.boundHandlers.dblclick);
    window.removeEventListener("auxclick", this.boundHandlers.auxclick);
    document.removeEventListener(
      "selectionchange",
      this.boundHandlers.selectionchange
    );
    if (this.selectionTimeout) {
      clearTimeout(this.selectionTimeout);
      this.selectionTimeout = null;
    }
  }
  /**
   * Helper to check if event target is an input element
   */
  isInputElement(target, ignoreInputElements) {
    if (!ignoreInputElements) return false;
    if (!target || !(target instanceof HTMLElement)) return false;
    return target.closest('input, textarea, [contenteditable="true"]') !== null;
  }
  /**
   * Parse hotkey combo string
   */
  parseHotkeyCombo(combo) {
    const parts = combo.toLowerCase().split("+");
    const key = parts[parts.length - 1];
    return {
      key,
      modifiers: {
        ctrl: parts.includes("ctrl"),
        cmd: parts.includes("cmd"),
        meta: parts.includes("meta") || parts.includes("cmd"),
        alt: parts.includes("alt"),
        shift: parts.includes("shift")
      }
    };
  }
  /**
   * Check if keyboard event matches hotkey
   */
  matchesHotkey(event, hotkey) {
    if (typeof hotkey === "string" && hotkey.includes("+")) {
      const combo = this.parseHotkeyCombo(hotkey);
      const keyMatches = event.key.toLowerCase() === combo.key;
      const modifiersMatch = event.ctrlKey === combo.modifiers.ctrl && event.metaKey === combo.modifiers.meta && event.altKey === combo.modifiers.alt && event.shiftKey === combo.modifiers.shift;
      return keyMatches && modifiersMatch;
    } else {
      const hasUnexpectedModifiers = event.ctrlKey || event.metaKey || event.altKey;
      if (hasUnexpectedModifiers) {
        return false;
      }
      return event.key.toLowerCase() === hotkey.toLowerCase();
    }
  }
  /**
   * Check if a string is a keyboard combo
   */
  isKeyboardCombo(value) {
    return value.includes("+") && !value.includes("click");
  }
  /**
   * Extract event types from conditions
   */
  extractEventTypes(events) {
    const hotkeyEvents = events.filter(
      (c) => Object.values(Hotkey).includes(c) || typeof c === "string" && this.isKeyboardCombo(c)
    );
    const mouseEvents = events.filter(
      (c) => Object.values(MouseEvent).includes(c)
    );
    const selectionEvents = events.filter(
      (c) => Object.values(SelectionEvent).includes(c)
    );
    return { hotkeyEvents, mouseEvents, selectionEvents };
  }
  /**
   * Activate a spell
   */
  activateSpell(registration, triggerData, event) {
    const mode = registration.conditions.mode || "toggle" /* TOGGLE */;
    const cooldown = registration.conditions.cooldown || 0;
    if (mode === "trigger" /* TRIGGER */) {
      const now = Date.now();
      if (registration.isOnCooldown || now - registration.lastTriggerTime < cooldown) {
        return;
      }
      registration.lastTriggerTime = now;
      if (cooldown > 0) {
        registration.isOnCooldown = true;
        setTimeout(() => {
          registration.isOnCooldown = false;
        }, cooldown);
      }
    }
    if (mode === "hold" /* HOLD */ && event) {
      registration.activeHoldEvent = event;
    }
    registration.isActive = true;
    const state = {
      isActive: true,
      triggerData
    };
    registration.onActivate?.(state);
    if (mode === "trigger" /* TRIGGER */) {
      setTimeout(() => {
        this.deactivateSpell(registration);
      }, 100);
    }
  }
  /**
   * Deactivate a spell
   */
  deactivateSpell(registration) {
    registration.activeHoldEvent = null;
    registration.heldKeys.clear();
    registration.isActive = false;
    registration.onDeactivate?.();
  }
  // Event Handlers
  handleMouseMove(event) {
    this.lastMousePosition = { x: event.clientX, y: event.clientY };
  }
  handleKeyDown(event) {
    for (const registration of this.registrations.values()) {
      if (this.isInputElement(
        event.target,
        registration.ignoreInputElements ?? true
      )) {
        continue;
      }
      const { hotkeyEvents } = this.extractEventTypes(
        registration.conditions.events
      );
      const mode = registration.conditions.mode || "toggle" /* TOGGLE */;
      for (const hotkey of hotkeyEvents) {
        if (this.matchesHotkey(event, hotkey)) {
          if (registration.preventDefaultEvents) {
            event.preventDefault();
            event.stopPropagation();
          }
          const keyString = typeof hotkey === "string" ? hotkey : hotkey;
          if (mode === "toggle" /* TOGGLE */) {
            if (registration.isActive) {
              this.deactivateSpell(registration);
            } else {
              this.activateSpell(
                registration,
                {
                  type: "hotkey",
                  event: hotkey,
                  mousePosition: this.lastMousePosition,
                  originalEvent: event
                },
                hotkey
              );
            }
          } else if (mode === "hold" /* HOLD */) {
            if (!registration.heldKeys.has(keyString)) {
              registration.heldKeys.add(keyString);
              if (!registration.isActive) {
                this.activateSpell(
                  registration,
                  {
                    type: "hotkey",
                    event: hotkey,
                    mousePosition: this.lastMousePosition,
                    originalEvent: event
                  },
                  hotkey
                );
              }
            }
          } else if (mode === "trigger" /* TRIGGER */) {
            if (!registration.isActive) {
              this.activateSpell(
                registration,
                {
                  type: "hotkey",
                  event: hotkey,
                  mousePosition: this.lastMousePosition,
                  originalEvent: event
                },
                hotkey
              );
            }
          }
          break;
        }
      }
    }
  }
  handleKeyUp(event) {
    for (const registration of this.registrations.values()) {
      const mode = registration.conditions.mode || "toggle" /* TOGGLE */;
      if (mode !== "hold" /* HOLD */) continue;
      const { hotkeyEvents } = this.extractEventTypes(
        registration.conditions.events
      );
      for (const hotkey of hotkeyEvents) {
        if (this.matchesHotkey(event, hotkey)) {
          const keyString = typeof hotkey === "string" ? hotkey : hotkey;
          registration.heldKeys.delete(keyString);
          if (registration.heldKeys.size === 0 && registration.isActive) {
            this.deactivateSpell(registration);
          }
          break;
        }
      }
    }
  }
  handleClick(event) {
    for (const registration of this.registrations.values()) {
      const { mouseEvents } = this.extractEventTypes(
        registration.conditions.events
      );
      const mode = registration.conditions.mode || "toggle" /* TOGGLE */;
      let matchedEvent = null;
      if (event.shiftKey && mouseEvents.includes("shift+click" /* SHIFT_CLICK */)) {
        matchedEvent = "shift+click" /* SHIFT_CLICK */;
      } else if (event.ctrlKey && mouseEvents.includes("ctrl+click" /* CTRL_CLICK */)) {
        matchedEvent = "ctrl+click" /* CTRL_CLICK */;
      } else if (event.metaKey && mouseEvents.includes("cmd+click" /* CMD_CLICK */)) {
        matchedEvent = "cmd+click" /* CMD_CLICK */;
      } else if (event.altKey && mouseEvents.includes("alt+click" /* ALT_CLICK */)) {
        matchedEvent = "alt+click" /* ALT_CLICK */;
      }
      if (matchedEvent) {
        if (registration.preventDefaultEvents) {
          event.preventDefault();
          event.stopPropagation();
        }
        if (mode === "toggle" /* TOGGLE */) {
          if (registration.isActive) {
            this.deactivateSpell(registration);
          } else {
            this.activateSpell(
              registration,
              {
                type: "mouse",
                event: matchedEvent,
                mousePosition: { x: event.clientX, y: event.clientY },
                originalEvent: event
              },
              matchedEvent
            );
          }
        } else {
          this.activateSpell(
            registration,
            {
              type: "mouse",
              event: matchedEvent,
              mousePosition: { x: event.clientX, y: event.clientY },
              originalEvent: event
            },
            matchedEvent
          );
        }
      }
    }
  }
  handleContextMenu(event) {
    for (const registration of this.registrations.values()) {
      const { mouseEvents } = this.extractEventTypes(
        registration.conditions.events
      );
      const mode = registration.conditions.mode || "toggle" /* TOGGLE */;
      if (mouseEvents.includes("right-click" /* RIGHT_CLICK */)) {
        if (registration.preventDefaultEvents) {
          event.preventDefault();
        }
        if (mode === "hold" /* HOLD */) {
          this.activateSpell(
            registration,
            {
              type: "mouse",
              event: "right-click" /* RIGHT_CLICK */,
              mousePosition: { x: event.clientX, y: event.clientY },
              originalEvent: event
            },
            "right-click" /* RIGHT_CLICK */
          );
          const handleMouseUp = () => {
            if (registration.activeHoldEvent === "right-click" /* RIGHT_CLICK */) {
              this.deactivateSpell(registration);
            }
            window.removeEventListener("mouseup", handleMouseUp);
          };
          window.addEventListener("mouseup", handleMouseUp);
        } else {
          if (mode === "toggle" /* TOGGLE */ && registration.isActive) {
            this.deactivateSpell(registration);
          } else {
            this.activateSpell(
              registration,
              {
                type: "mouse",
                event: "right-click" /* RIGHT_CLICK */,
                mousePosition: { x: event.clientX, y: event.clientY },
                originalEvent: event
              },
              "right-click" /* RIGHT_CLICK */
            );
          }
        }
      }
    }
  }
  handleDoubleClick(event) {
    for (const registration of this.registrations.values()) {
      const { mouseEvents } = this.extractEventTypes(
        registration.conditions.events
      );
      const mode = registration.conditions.mode || "toggle" /* TOGGLE */;
      if (mouseEvents.includes("double-click" /* DOUBLE_CLICK */)) {
        if (mode === "toggle" /* TOGGLE */ && registration.isActive) {
          this.deactivateSpell(registration);
        } else {
          this.activateSpell(
            registration,
            {
              type: "mouse",
              event: "double-click" /* DOUBLE_CLICK */,
              mousePosition: { x: event.clientX, y: event.clientY },
              originalEvent: event
            },
            "double-click" /* DOUBLE_CLICK */
          );
        }
      }
    }
  }
  handleAuxClick(event) {
    if (event.button !== 1) return;
    for (const registration of this.registrations.values()) {
      const { mouseEvents } = this.extractEventTypes(
        registration.conditions.events
      );
      const mode = registration.conditions.mode || "toggle" /* TOGGLE */;
      if (mouseEvents.includes("middle-click" /* MIDDLE_CLICK */)) {
        if (registration.preventDefaultEvents) {
          event.preventDefault();
        }
        if (mode === "toggle" /* TOGGLE */ && registration.isActive) {
          this.deactivateSpell(registration);
        } else {
          this.activateSpell(
            registration,
            {
              type: "mouse",
              event: "middle-click" /* MIDDLE_CLICK */,
              mousePosition: { x: event.clientX, y: event.clientY },
              originalEvent: event
            },
            "middle-click" /* MIDDLE_CLICK */
          );
        }
      }
    }
  }
  handleMouseUp() {
  }
  handleSelectionChange() {
    if (this.selectionTimeout) {
      clearTimeout(this.selectionTimeout);
    }
    this.selectionTimeout = setTimeout(() => {
      const selection = window.getSelection();
      const selectedText = selection?.toString().trim();
      for (const registration of this.registrations.values()) {
        const { selectionEvents } = this.extractEventTypes(
          registration.conditions.events
        );
        if (selectionEvents.includes("text-select" /* TEXT_SELECT */)) {
          if (selectedText && selectedText.length > 0) {
            this.activateSpell(
              registration,
              {
                type: "selection",
                event: "text-select" /* TEXT_SELECT */,
                selectedText
              },
              "text-select" /* TEXT_SELECT */
            );
          } else if (registration.isActive) {
            this.deactivateSpell(registration);
          }
        }
      }
    }, 200);
  }
};
__publicField(_SpellActivationManager, "instance", null);
var SpellActivationManager = _SpellActivationManager;
var SpellActivationManager_default = SpellActivationManager;

// src/store/spellSlice/spellSlice.ts
var initialSpells = {};
var createSpellSlice = (set, get) => {
  return {
    // -----------------------------------------------------------------
    // State
    // -----------------------------------------------------------------
    spells: initialSpells,
    // -----------------------------------------------------------------
    // Actions
    // -----------------------------------------------------------------
    registerSpell: (registration) => {
      const manager = SpellActivationManager_default.getInstance();
      const { id, activationConditions, onActivate, onDeactivate, ...options } = registration;
      set((state) => ({
        spells: {
          ...state.spells,
          [id]: {
            isActive: false,
            registration
          }
        }
      }));
      manager.register(id, activationConditions, {
        onActivate: (state) => {
          set((store) => ({
            spells: {
              ...store.spells,
              [id]: {
                ...store.spells[id],
                isActive: true
              }
            }
          }));
          onActivate?.(state);
        },
        onDeactivate: () => {
          set((store) => ({
            spells: {
              ...store.spells,
              [id]: {
                ...store.spells[id],
                isActive: false
              }
            }
          }));
          onDeactivate?.();
        },
        preventDefaultEvents: options.preventDefaultEvents,
        ignoreInputElements: options.ignoreInputElements
      });
    },
    unregisterSpell: (spellId) => {
      const manager = SpellActivationManager_default.getInstance();
      manager.unregister(spellId);
      set((state) => {
        const newSpells = { ...state.spells };
        delete newSpells[spellId];
        return { spells: newSpells };
      });
    },
    activateSpell: (spellId, triggerData) => {
      const spell = get().spells[spellId];
      if (!spell) return;
      set((state) => ({
        spells: {
          ...state.spells,
          [spellId]: {
            ...spell,
            isActive: true
          }
        }
      }));
      spell.registration.onActivate?.({
        isActive: true,
        triggerData
      });
    },
    deactivateSpell: (spellId) => {
      const spell = get().spells[spellId];
      if (!spell) return;
      set((state) => ({
        spells: {
          ...state.spells,
          [spellId]: {
            ...spell,
            isActive: false
          }
        }
      }));
      spell.registration.onDeactivate?.();
    },
    toggleSpell: (spellId) => {
      const state = get();
      const spell = state.spells[spellId];
      if (!spell) return;
      if (spell.isActive) {
        state.deactivateSpell(spellId);
      } else {
        state.activateSpell(spellId);
      }
    },
    clearSpells: () => {
      const manager = SpellActivationManager_default.getInstance();
      manager.reset();
      set({ spells: {} });
    }
  };
};
export {
  createSpellSlice
};
//# sourceMappingURL=spellSlice.mjs.map