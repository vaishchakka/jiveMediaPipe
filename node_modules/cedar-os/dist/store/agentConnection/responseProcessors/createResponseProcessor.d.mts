import { z } from 'zod';
import { a5 as CustomStructuredResponseType, a3 as BaseStructuredResponseType, aO as ResponseProcessorExecute, a6 as StructuredResponseType, a7 as ResponseProcessor } from '../../../index-XdHpD8cC.mjs';
import 'zustand';
import '../../agentContext/AgentContextTypes.mjs';
import 'react';
import '@tiptap/core';
import '../../spellSlice/SpellTypes.mjs';
import 'fast-json-patch';
import '../../toolsSlice/ToolsTypes.mjs';

declare function createResponseProcessor<T extends StructuredResponseType>(p: ResponseProcessor<T>): ResponseProcessor<StructuredResponseType>;
type SetStateResponsePayload = {
    stateKey: string;
    setterKey: string;
    args?: unknown;
};
type SetStateResponse = CustomStructuredResponseType<'setState', SetStateResponsePayload>;
type SetStateResponseFor<StateKey extends string, SetterKey extends string, Args = unknown> = BaseStructuredResponseType & {
    type: 'setState';
    stateKey: StateKey;
    setterKey: SetterKey;
    args: Args;
};
type LegacyActionResponsePayload = SetStateResponsePayload;
type LegacyActionResponse = CustomStructuredResponseType<'action', LegacyActionResponsePayload>;
type LegacyActionResponseFor<StateKey extends string, SetterKey extends string, Args = unknown> = BaseStructuredResponseType & {
    type: 'action';
    stateKey: StateKey;
    setterKey: SetterKey;
    args: Args;
};
declare function createSetStateResponseProcessor<T extends SetStateResponse>(config: {
    namespace?: string;
    /** Optional setterKey. If provided the processor only handles msgs with this key */
    setterKey?: string;
    execute?: ResponseProcessorExecute<T>;
    validate?: (obj: StructuredResponseType) => obj is T;
}): ResponseProcessor<StructuredResponseType>;
declare function createLegacyActionResponseProcessor<T extends LegacyActionResponse>(config: {
    namespace?: string;
    /** Optional setterKey. If provided the processor only handles msgs with this key */
    setterKey?: string;
    execute?: ResponseProcessorExecute<T>;
    validate?: (obj: StructuredResponseType) => obj is T;
}): ResponseProcessor<StructuredResponseType>;
/**
 * Zod schema for SetStateResponse
 */
declare const SetStateResponseSchema: z.ZodIntersection<z.ZodObject<{
    type: z.ZodLiteral<"setState">;
    content: z.ZodOptional<z.ZodString>;
}, "passthrough", z.ZodTypeAny, z.objectOutputType<{
    type: z.ZodLiteral<"setState">;
    content: z.ZodOptional<z.ZodString>;
}, z.ZodTypeAny, "passthrough">, z.objectInputType<{
    type: z.ZodLiteral<"setState">;
    content: z.ZodOptional<z.ZodString>;
}, z.ZodTypeAny, "passthrough">>, z.ZodObject<{
    stateKey: z.ZodString;
    setterKey: z.ZodString;
    args: z.ZodOptional<z.ZodUnknown>;
}, "strip", z.ZodTypeAny, {
    setterKey: string;
    stateKey: string;
    args?: unknown;
}, {
    setterKey: string;
    stateKey: string;
    args?: unknown;
}>>;
/**
 * Zod schema for LegacyActionResponse
 */
declare const LegacyActionResponseSchema: z.ZodIntersection<z.ZodObject<{
    type: z.ZodLiteral<"action">;
    content: z.ZodOptional<z.ZodString>;
}, "passthrough", z.ZodTypeAny, z.objectOutputType<{
    type: z.ZodLiteral<"action">;
    content: z.ZodOptional<z.ZodString>;
}, z.ZodTypeAny, "passthrough">, z.objectInputType<{
    type: z.ZodLiteral<"action">;
    content: z.ZodOptional<z.ZodString>;
}, z.ZodTypeAny, "passthrough">>, z.ZodObject<{
    stateKey: z.ZodString;
    setterKey: z.ZodString;
    args: z.ZodOptional<z.ZodUnknown>;
}, "strip", z.ZodTypeAny, {
    setterKey: string;
    stateKey: string;
    args?: unknown;
}, {
    setterKey: string;
    stateKey: string;
    args?: unknown;
}>>;

export { type LegacyActionResponse, type LegacyActionResponseFor, type LegacyActionResponsePayload, LegacyActionResponseSchema, type SetStateResponse, type SetStateResponseFor, type SetStateResponsePayload, SetStateResponseSchema, createLegacyActionResponseProcessor, createResponseProcessor, createSetStateResponseProcessor };
