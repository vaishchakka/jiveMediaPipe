{"version":3,"sources":["../../../src/store/diffHistoryStateSlice/diffHistorySlice.ts"],"sourcesContent":["import { StateCreator } from 'zustand';\nimport { compare, Operation, applyPatch } from 'fast-json-patch';\nimport { isEqual, cloneDeep } from 'lodash';\nimport type { CedarStore } from '@/store/CedarOSTypes';\nimport type {\n\tBasicStateValue,\n\tBaseSetter,\n\tSetter,\n} from '@/store/stateSlice/stateSlice';\nimport type { ZodSchema } from 'zod';\n\n/**\n * DiffHistorySlice manages diffs so that we can render changes and let the user accept, reject, and manage them.\n * For example, if an agent makes a change to a state, we want the user to be able to see what changed\n * and what they have to accept. To do this, we have to allow behaviour such as rollback,\n * accepting specific diffs, and saving them to the history.\n */\n\nexport type DiffMode = 'defaultAccept' | 'holdAccept';\n\n/**\n * Configuration for selective diff checking based on JSON paths.\n *\n * @example\n * // Ignore position changes (and all child fields)\n * { type: 'ignore', fields: ['/positionAbsolute'] }\n *\n * // Only consider changes if positionAbsolute changes\n * { type: 'listen', fields: ['/positionAbsolute'] }\n */\nexport interface DiffChecker {\n\t/**\n\t * 'ignore': Ignore changes to specified fields and their children\n\t * 'listen': Only consider changes to specified fields\n\t */\n\ttype: 'ignore' | 'listen';\n\t/** Array of JSON paths to ignore or listen to */\n\tfields: string[];\n}\n\n/**\n * Function that computes the final state based on old and new states.\n * Can be used to add diff markers or transform the state before setting.\n */\nexport type ComputeStateFunction<T = unknown> = (\n\toldState: T,\n\tnewState: T,\n\tpatches: Operation[]\n) => T;\n\nexport interface DiffState<T = any> {\n\toldState: T;\n\tnewState: T;\n\tcomputedState: T; // The computed state based on computeState function or fallback to appropriate state\n\tisDiffMode: boolean;\n\tpatches?: Operation[]; // JSON patches describing the changes from oldState to newState\n}\n\nexport interface DiffHistoryState<T = any> {\n\tdiffState: DiffState<T>;\n\thistory: DiffState<T>[];\n\tredoStack: DiffState<T>[];\n\tdiffMode: DiffMode;\n\tcomputeState?: ComputeStateFunction<T>;\n}\n\n/**\n * Configuration for registerDiffState\n */\nexport interface RegisterDiffStateConfig<T extends BasicStateValue> {\n\tkey: string;\n\tvalue: T;\n\tsetValue?: BaseSetter<T>;\n\tdescription?: string;\n\tschema?: ZodSchema<T>;\n\tstateSetters?: Record<string, Setter<T>>;\n\tdiffMode?: DiffMode;\n\tcomputeState?: ComputeStateFunction<T>;\n}\n\nexport interface DiffHistorySlice {\n\tdiffHistoryStates: Record<string, DiffHistoryState>;\n\n\t// Core methods\n\tgetDiffHistoryState: <T>(key: string) => DiffHistoryState<T> | undefined;\n\tgetDiffState: <T>(key: string) => DiffState<T> | undefined;\n\tsetDiffState: <T>(key: string, diffHistoryState: DiffHistoryState<T>) => void;\n\tgetCleanState: <T>(key: string) => T | undefined;\n\n\t// Get computed state (with computeState applied if available)\n\tgetComputedState: <T>(key: string) => T | undefined;\n\n\t// Register computeState function for a key\n\tsetComputeStateFunction: <T>(\n\t\tkey: string,\n\t\tcomputeState: ComputeStateFunction<T> | undefined\n\t) => void;\n\n\t// Register a diff-tracked state (handles all initialization and setup)\n\tregisterDiffState: <T extends BasicStateValue>(\n\t\tconfig: RegisterDiffStateConfig<T>\n\t) => void;\n\n\t// New newDiffState method\n\tnewDiffState: <T>(key: string, newState: T, isDiffChange?: boolean) => void;\n\n\t// Execute custom setter for diff-tracked states\n\texecuteDiffSetter: (\n\t\tkey: string,\n\t\tsetterKey: string,\n\t\toptions?: { isDiff?: boolean },\n\t\targs?: unknown\n\t) => void;\n\n\t// Apply patches to diff state\n\tapplyPatchesToDiffState: (\n\t\tkey: string,\n\t\tpatches: Operation[],\n\t\tisDiffChange: boolean\n\t) => void;\n\n\t// Diff management methods\n\tacceptAllDiffs: (key: string) => boolean;\n\trejectAllDiffs: (key: string) => boolean;\n\tacceptDiff: <T>(\n\t\tkey: string,\n\t\tjsonPath: string,\n\t\tidentificationField: string | ((item: T) => unknown),\n\t\ttargetId?: unknown,\n\t\tdiffMarkerPaths?: string[]\n\t) => boolean;\n\t/**\n\t * Reject a specific diff change\n\t * @param key - The state key\n\t * @param jsonPath - JSON path to the array or field\n\t * @param identificationField - Field name or function to identify array items (ignored for primitive arrays)\n\t * @param targetId - The specific item/value to reject\n\t * @param diffMarkerPaths - Optional paths where diff markers are located\n\t *\n\t * For primitive arrays (strings, numbers, booleans):\n\t * - identificationField is ignored\n\t * - targetId should be the primitive value to remove\n\t * - The function will detect primitive arrays automatically\n\t *\n\t * @example\n\t * // For object arrays:\n\t * rejectDiff('nodes', '/0/data/items', 'id', 'item-123');\n\t *\n\t * // For primitive arrays:\n\t * rejectDiff('nodes', '/0/data/attributeIds', 'value', 'attribute-id-456');\n\t */\n\trejectDiff: <T>(\n\t\tkey: string,\n\t\tjsonPath: string,\n\t\tidentificationField: string | ((item: T) => unknown),\n\t\ttargetId?: unknown,\n\t\tdiffMarkerPaths?: string[]\n\t) => boolean;\n\n\t// Undo/Redo methods\n\tundo: (key: string) => boolean;\n\tredo: (key: string) => boolean;\n}\n\n/**\n * Helper function to get value at a JSON path\n */\nfunction getValueAtPath<T>(obj: T, path: string): unknown {\n\tif (!path || path === '' || path === '/') {\n\t\treturn obj;\n\t}\n\n\tconst pathParts = path.startsWith('/')\n\t\t? path.slice(1).split('/')\n\t\t: path.split('/');\n\n\tlet current: unknown = obj;\n\tfor (const part of pathParts) {\n\t\tif (current == null || typeof current !== 'object') {\n\t\t\treturn undefined;\n\t\t}\n\t\tcurrent = (current as Record<string, unknown>)[part];\n\t}\n\n\treturn current;\n}\n\n/**\n * Helper function to set value at a JSON path\n */\nfunction setValueAtPathForDiff<T>(obj: T, path: string, value: unknown): T {\n\tif (!path || path === '' || path === '/') {\n\t\treturn value as T;\n\t}\n\n\tconst pathParts = path.startsWith('/')\n\t\t? path.slice(1).split('/')\n\t\t: path.split('/');\n\n\tconst result = cloneDeep(obj) as Record<string, unknown>;\n\tlet current: Record<string, unknown> = result;\n\n\tfor (let i = 0; i < pathParts.length - 1; i++) {\n\t\tconst part = pathParts[i];\n\t\tif (!(part in current)) {\n\t\t\tcurrent[part] = {};\n\t\t}\n\t\tcurrent = current[part] as Record<string, unknown>;\n\t}\n\n\tconst lastPart = pathParts[pathParts.length - 1];\n\tcurrent[lastPart] = value;\n\n\treturn result as T;\n}\n\n/**\n * Helper function to identify an item using either a field name or function\n */\nfunction getItemIdentifier<T>(\n\titem: T,\n\tidentificationField: string | ((item: T) => unknown)\n): unknown {\n\tif (typeof identificationField === 'function') {\n\t\treturn identificationField(item);\n\t}\n\treturn (item as Record<string, unknown>)[identificationField];\n}\n\n/**\n * Handle primitive array diff operations (strings, numbers, booleans)\n */\nfunction handlePrimitiveArrayDiff<T>(params: {\n\tget: () => CedarStore;\n\tkey: string;\n\tjsonPath: string;\n\toldArray: T[];\n\tnewArray: T[];\n\taction: 'accept' | 'reject';\n\tcurrentDiffHistoryState: DiffHistoryState<T>;\n\ttargetId: unknown;\n\tdiffMode: DiffMode;\n\tcomputeState?: ComputeStateFunction<T>;\n}): boolean {\n\tconst {\n\t\tget,\n\t\tkey,\n\t\tjsonPath,\n\t\toldArray,\n\t\tnewArray,\n\t\taction,\n\t\tcurrentDiffHistoryState,\n\t\ttargetId,\n\t\tdiffMode,\n\t\tcomputeState,\n\t} = params;\n\n\tconst { diffState, history } = currentDiffHistoryState;\n\n\tlet resultNewArray: T[];\n\tlet resultOldArray: T[];\n\n\tif (action === 'accept') {\n\t\t// For accept, keep the new array as is and add the accepted item to oldArray\n\t\tresultNewArray = [...newArray];\n\t\t// Add the accepted item to oldArray if it's not already there\n\t\tif (!oldArray.includes(targetId as T)) {\n\t\t\tresultOldArray = [...oldArray, targetId as T];\n\t\t} else {\n\t\t\tresultOldArray = [...oldArray];\n\t\t}\n\t} else if (action === 'reject') {\n\t\t// For reject, we need to remove only the NEWLY ADDED occurrences of targetId\n\t\t// Strategy: Keep all items from oldArray, then add items from newArray that are NOT the targetId\n\n\t\t// Count how many times targetId appears in oldArray vs newArray\n\t\tconst oldCount = oldArray.filter((item) => item === targetId).length;\n\t\tconst newCount = newArray.filter((item) => item === targetId).length;\n\n\t\tif (newCount <= oldCount) {\n\t\t\t// No new instances of targetId were added, so nothing to reject\n\t\t\tresultNewArray = [...newArray];\n\t\t} else {\n\t\t\t// There are new instances of targetId - remove only the excess ones\n\t\t\tconst itemsToKeep = oldCount; // Keep the original count\n\t\t\tlet keptCount = 0;\n\t\t\tresultNewArray = newArray.filter((item) => {\n\t\t\t\tif (item === targetId) {\n\t\t\t\t\tif (keptCount < itemsToKeep) {\n\t\t\t\t\t\tkeptCount++;\n\t\t\t\t\t\treturn true; // Keep this occurrence\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn false; // Remove this occurrence (it's newly added)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true; // Keep non-target items\n\t\t\t});\n\t\t}\n\t\tresultOldArray = [...oldArray];\n\t} else {\n\t\treturn false;\n\t}\n\n\t// Update the state with the modified arrays\n\tconst newStateWithUpdatedArray = setValueAtPathForDiff(\n\t\tdiffState.newState,\n\t\tjsonPath,\n\t\tresultNewArray\n\t);\n\n\tconst finalOldState = setValueAtPathForDiff(\n\t\tdiffState.oldState,\n\t\tjsonPath,\n\t\tresultOldArray\n\t);\n\n\tconst finalNewState = newStateWithUpdatedArray;\n\n\t// Compute the final state\n\tlet finalComputedState: T;\n\tlet stillInDiffMode = false;\n\n\tif (computeState) {\n\t\tfinalComputedState = computeState(finalOldState, finalNewState, []);\n\t\t// Check if there are still differences\n\t\tstillInDiffMode = !areStatesEquivalent(finalOldState, finalNewState);\n\t} else {\n\t\tfinalComputedState = finalNewState;\n\t\tstillInDiffMode = !areStatesEquivalent(finalOldState, finalNewState);\n\t}\n\n\tconst updatedDiffState: DiffState<T> = {\n\t\toldState: finalOldState,\n\t\tnewState: finalNewState,\n\t\tcomputedState: finalComputedState,\n\t\tisDiffMode: stillInDiffMode,\n\t\tpatches: [],\n\t};\n\n\tconst updatedHistory = [...history, diffState];\n\n\tconst updatedDiffHistoryState: DiffHistoryState<T> = {\n\t\tdiffState: updatedDiffState,\n\t\thistory: updatedHistory,\n\t\tredoStack: [],\n\t\tdiffMode,\n\t\tcomputeState,\n\t};\n\n\t// Update the store\n\tget().setDiffState(key, updatedDiffHistoryState);\n\n\treturn true;\n}\n\n/**\n * Helper function to check if oldState and newState are equivalent\n */\nfunction areStatesEquivalent<T>(oldState: T, newState: T): boolean {\n\treturn isEqual(oldState, newState);\n}\n\n/**\n * Helper function to handle single diff accept/reject operations\n */\n// Helper function to remove diff markers from an object at various paths\nfunction removeDiffMarkers<T>(item: T, diffMarkerPaths?: string[]): T {\n\tlet cleanedItem = { ...item } as T;\n\n\t// Default paths if not specified\n\tconst pathsToCheck = diffMarkerPaths || ['/data/diff', '/diff', '/meta/diff'];\n\n\tfor (const path of pathsToCheck) {\n\t\tconst diffValue = getValueAtPath(cleanedItem, path);\n\t\tif (diffValue) {\n\t\t\t// Parse the path to determine how to remove the diff marker\n\t\t\tconst pathParts = path.split('/').filter((p) => p);\n\n\t\t\tif (pathParts.length === 1) {\n\t\t\t\t// Root level diff\n\t\t\t\tconst itemRecord = cleanedItem as Record<string, unknown>;\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\t\t\tconst { [pathParts[0]]: _, ...itemWithoutDiff } = itemRecord;\n\t\t\t\tcleanedItem = itemWithoutDiff as T;\n\t\t\t} else {\n\t\t\t\t// Nested diff - use setValueAtPathForDiff to remove it\n\t\t\t\t// Build the parent path\n\t\t\t\tconst parentPathStr = '/' + pathParts.slice(0, -1).join('/');\n\t\t\t\tconst parentValue = getValueAtPath(cleanedItem, parentPathStr);\n\n\t\t\t\tif (parentValue && typeof parentValue === 'object') {\n\t\t\t\t\tconst parentRecord = parentValue as Record<string, unknown>;\n\t\t\t\t\tconst diffField = pathParts[pathParts.length - 1];\n\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\t\t\t\tconst { [diffField]: _, ...parentWithoutDiff } = parentRecord;\n\t\t\t\t\tcleanedItem = setValueAtPathForDiff(\n\t\t\t\t\t\tcleanedItem,\n\t\t\t\t\t\tparentPathStr,\n\t\t\t\t\t\tparentWithoutDiff\n\t\t\t\t\t) as T;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cleanedItem;\n}\n\nfunction handleSingleDiff<T>(\n\tget: () => CedarStore,\n\tkey: string,\n\tjsonPath: string,\n\tidentificationField: string | ((item: T) => unknown),\n\taction: 'accept' | 'reject',\n\ttargetId?: unknown,\n\tdiffMarkerPaths?: string[]\n): boolean {\n\tconst currentDiffHistoryState = get().getDiffHistoryState<T>(key);\n\n\t// If no existing state or not in diff mode, return false\n\tif (\n\t\t!currentDiffHistoryState ||\n\t\t!currentDiffHistoryState.diffState.isDiffMode\n\t) {\n\t\treturn false;\n\t}\n\n\tconst { diffState } = currentDiffHistoryState;\n\n\t// Get the value at the specified path from both old and new states\n\tconst oldValue = getValueAtPath(diffState.oldState, jsonPath);\n\tconst newValue = getValueAtPath(diffState.newState, jsonPath);\n\n\t// Check if we're dealing with arrays or single objects/fields\n\tconst isArray = Array.isArray(oldValue) || Array.isArray(newValue);\n\n\tif (isArray) {\n\t\t// Handle array case (existing logic)\n\t\tconst oldArray = oldValue as T[];\n\t\tconst newArray = newValue as T[];\n\n\t\tif (!Array.isArray(oldArray) || !Array.isArray(newArray)) {\n\t\t\tconsole.warn(`Value at path \"${jsonPath}\" is not consistently an array`);\n\t\t\treturn false;\n\t\t}\n\t\treturn handleArrayDiff({\n\t\t\tget,\n\t\t\tkey,\n\t\t\tjsonPath,\n\t\t\toldArray,\n\t\t\tnewArray,\n\t\t\tidentificationField,\n\t\t\taction,\n\t\t\tcurrentDiffHistoryState,\n\t\t\ttargetId,\n\t\t\tdiffMarkerPaths,\n\t\t});\n\t} else {\n\t\t// Handle single object/field case\n\t\treturn handleObjectFieldDiff({\n\t\t\tget,\n\t\t\tkey,\n\t\t\tjsonPath,\n\t\t\toldValue,\n\t\t\tnewValue,\n\t\t\taction,\n\t\t\tcurrentDiffHistoryState,\n\t\t\tdiffMarkerPaths,\n\t\t});\n\t}\n}\n\n// Handle single object/field accept/reject\nfunction handleObjectFieldDiff<T>(params: {\n\tget: () => CedarStore;\n\tkey: string;\n\tjsonPath: string;\n\toldValue: unknown;\n\tnewValue: unknown;\n\taction: 'accept' | 'reject';\n\tcurrentDiffHistoryState: DiffHistoryState<T>;\n\tdiffMarkerPaths?: string[];\n}): boolean {\n\tconst {\n\t\tget,\n\t\tkey,\n\t\tjsonPath,\n\t\toldValue,\n\t\tnewValue,\n\t\taction,\n\t\tcurrentDiffHistoryState,\n\t\tdiffMarkerPaths,\n\t} = params;\n\tconst { diffState, history, diffMode, computeState } =\n\t\tcurrentDiffHistoryState;\n\n\t// For object fields, we accept or reject the entire value at the path\n\tlet finalValue: unknown;\n\n\tif (action === 'accept') {\n\t\t// Accept the new value and remove any diff markers if it's an object\n\t\tfinalValue =\n\t\t\ttypeof newValue === 'object' && newValue !== null\n\t\t\t\t? removeDiffMarkers(newValue, diffMarkerPaths)\n\t\t\t\t: newValue;\n\t} else {\n\t\t// Reject - use the old value\n\t\tfinalValue = oldValue;\n\t}\n\n\t// Update the state with the new value at the path\n\tconst updatedNewState = setValueAtPathForDiff(\n\t\tdiffState.newState,\n\t\tjsonPath,\n\t\tfinalValue\n\t);\n\n\t// For accept, also update oldState to prevent re-diffing\n\tconst updatedOldState =\n\t\taction === 'accept'\n\t\t\t? setValueAtPathForDiff(diffState.oldState, jsonPath, finalValue)\n\t\t\t: diffState.oldState;\n\n\t// Determine if we're still in diff mode by checking if there are other differences\n\tlet finalComputedState: T;\n\tlet stillInDiffMode = false;\n\n\tif (computeState) {\n\t\tfinalComputedState = computeState(updatedOldState, updatedNewState, []);\n\t\t// Check if computed state has any remaining diff markers\n\t\tconst checkForDiffs = (obj: unknown): boolean => {\n\t\t\tif (!obj || typeof obj !== 'object') return false;\n\n\t\t\tconst pathsToCheck = diffMarkerPaths || [\n\t\t\t\t'/data/diff',\n\t\t\t\t'/diff',\n\t\t\t\t'/meta/diff',\n\t\t\t];\n\t\t\tfor (const path of pathsToCheck) {\n\t\t\t\tif (getValueAtPath(obj, path)) return true;\n\t\t\t}\n\n\t\t\t// Recursively check nested objects and arrays\n\t\t\tfor (const value of Object.values(obj)) {\n\t\t\t\tif (checkForDiffs(value)) return true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t};\n\n\t\tstillInDiffMode = checkForDiffs(finalComputedState);\n\t} else {\n\t\tfinalComputedState = updatedNewState;\n\t}\n\n\t// Check if oldState and newState are equivalent - if so, set isDiffMode to false regardless of other checks\n\tconst statesAreEquivalent = areStatesEquivalent(\n\t\tupdatedOldState,\n\t\tupdatedNewState\n\t);\n\tconst finalIsDiffMode = statesAreEquivalent ? false : stillInDiffMode;\n\n\tconst updatedDiffState: DiffState<T> = {\n\t\toldState: updatedOldState,\n\t\tnewState: updatedNewState,\n\t\tcomputedState: finalComputedState,\n\t\tisDiffMode: finalIsDiffMode,\n\t\tpatches: [],\n\t};\n\n\tconst updatedHistory = [...history, diffState];\n\n\tconst updatedDiffHistoryState: DiffHistoryState<T> = {\n\t\tdiffState: updatedDiffState,\n\t\thistory: updatedHistory,\n\t\tredoStack: [],\n\t\tdiffMode,\n\t\tcomputeState,\n\t};\n\n\t// Update the store\n\tget().setDiffState(key, updatedDiffHistoryState);\n\n\treturn true;\n}\n\n// Handle array-based accept/reject (existing logic refactored)\nfunction handleArrayDiff<T>(params: {\n\tget: () => CedarStore;\n\tkey: string;\n\tjsonPath: string;\n\toldArray: T[];\n\tnewArray: T[];\n\tidentificationField: string | ((item: T) => unknown);\n\taction: 'accept' | 'reject';\n\tcurrentDiffHistoryState: DiffHistoryState<T>;\n\ttargetId?: unknown;\n\tdiffMarkerPaths?: string[];\n}): boolean {\n\tconst {\n\t\tget,\n\t\tkey,\n\t\tjsonPath,\n\t\toldArray,\n\t\tnewArray,\n\t\tidentificationField,\n\t\taction,\n\t\tcurrentDiffHistoryState,\n\t\ttargetId,\n\t\tdiffMarkerPaths,\n\t} = params;\n\tconst { diffState, history, diffMode, computeState } =\n\t\tcurrentDiffHistoryState;\n\n\t// Check if we're dealing with primitive arrays\n\tconst isPrimitiveArray =\n\t\t(oldArray.length > 0 &&\n\t\t\t(typeof oldArray[0] === 'string' ||\n\t\t\t\ttypeof oldArray[0] === 'number' ||\n\t\t\t\ttypeof oldArray[0] === 'boolean')) ||\n\t\t(newArray.length > 0 &&\n\t\t\t(typeof newArray[0] === 'string' ||\n\t\t\t\ttypeof newArray[0] === 'number' ||\n\t\t\t\ttypeof newArray[0] === 'boolean'));\n\n\t// Handle primitive arrays differently\n\tif (isPrimitiveArray && targetId !== undefined) {\n\t\treturn handlePrimitiveArrayDiff({\n\t\t\tget,\n\t\t\tkey,\n\t\t\tjsonPath,\n\t\t\toldArray,\n\t\t\tnewArray,\n\t\t\taction,\n\t\t\tcurrentDiffHistoryState,\n\t\t\ttargetId,\n\t\t\tdiffMode,\n\t\t\tcomputeState,\n\t\t});\n\t}\n\n\t// Create maps for easier lookup\n\tconst oldMap = new Map(\n\t\toldArray.map((item) => [getItemIdentifier(item, identificationField), item])\n\t);\n\tconst newMap = new Map(\n\t\tnewArray.map((item) => [getItemIdentifier(item, identificationField), item])\n\t);\n\n\t// Identify all items that have differences between old and new state\n\tconst allIds = new Set([...oldMap.keys(), ...newMap.keys()]);\n\tconst changedIds = new Set<unknown>();\n\n\t// Find which items have changed\n\tfor (const id of allIds) {\n\t\t// If targetId is specified, only process that specific item\n\t\tif (targetId !== undefined && id !== targetId) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst oldItem = oldMap.get(id);\n\t\tconst newItem = newMap.get(id);\n\n\t\tif (!oldItem && newItem) {\n\t\t\t// Item was added\n\t\t\tchangedIds.add(id);\n\t\t} else if (oldItem && !newItem) {\n\t\t\t// Item was removed (shouldn't happen in newState, but handle it)\n\t\t\tchangedIds.add(id);\n\t\t} else if (oldItem && newItem) {\n\t\t\t// Check if item has changed\n\t\t\tif (JSON.stringify(oldItem) !== JSON.stringify(newItem)) {\n\t\t\t\tchangedIds.add(id);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (changedIds.size === 0) {\n\t\treturn false; // No differences to process (or targetId not found)\n\t}\n\n\t// Process based on action\n\tlet resultArray: T[] = [];\n\n\tif (action === 'accept') {\n\t\t// Accept changes - use the new state but remove any diff markers\n\t\tresultArray = newArray.map((item) => {\n\t\t\tconst itemId = getItemIdentifier(item, identificationField);\n\n\t\t\t// When targetId is specified, only process that item\n\t\t\tif (targetId !== undefined && itemId !== targetId) {\n\t\t\t\t// Not the target - keep as is (don't remove diff markers)\n\t\t\t\treturn item;\n\t\t\t}\n\n\t\t\t// If targetId is specified, only process the target item\n\t\t\t// If no targetId, process all changed items\n\t\t\tconst shouldProcessItem = targetId === undefined || itemId === targetId;\n\n\t\t\tif (!shouldProcessItem || !changedIds.has(itemId)) {\n\t\t\t\t// Item hasn't changed or shouldn't be processed, keep as is\n\t\t\t\treturn item;\n\t\t\t}\n\t\t\t// Item has changed and should be processed, remove any diff markers if they exist\n\t\t\treturn removeDiffMarkers(item, diffMarkerPaths);\n\t\t});\n\t} else if (action === 'reject') {\n\t\t// Reject changes - revert to old state for changed items\n\n\t\t// When targetId is specified, we need to handle single-item rejection differently\n\t\tif (targetId !== undefined) {\n\t\t\t// Process all items from newArray, but only revert the targeted one\n\t\t\tfor (const item of newArray) {\n\t\t\t\tconst itemId = getItemIdentifier(item, identificationField);\n\n\t\t\t\tif (itemId === targetId && changedIds.has(itemId)) {\n\t\t\t\t\t// This is the targeted item with changes\n\t\t\t\t\tconst oldItem = oldMap.get(itemId);\n\t\t\t\t\tif (oldItem) {\n\t\t\t\t\t\t// Item was changed - revert to old version\n\t\t\t\t\t\tresultArray.push(oldItem);\n\t\t\t\t\t}\n\t\t\t\t\t// If oldItem doesn't exist, it means this was added - exclude it\n\t\t\t\t} else {\n\t\t\t\t\t// Not the target item - keep as is in new state\n\t\t\t\t\tresultArray.push(item);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Original logic for rejecting all changes\n\t\t\tfor (const item of oldArray) {\n\t\t\t\tconst itemId = getItemIdentifier(item, identificationField);\n\t\t\t\tif (changedIds.has(itemId)) {\n\t\t\t\t\t// This item has changes, use the old version\n\t\t\t\t\tresultArray.push(item);\n\t\t\t\t} else {\n\t\t\t\t\t// No changes, keep the current version (which should be same as old)\n\t\t\t\t\tconst newItem = newMap.get(itemId);\n\t\t\t\t\tif (newItem) {\n\t\t\t\t\t\tresultArray.push(newItem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Don't include items that were added (not in oldArray)\n\t\t\t// They will be excluded naturally since we're iterating over oldArray\n\t\t}\n\t}\n\n\t// Update the state with the modified array\n\tconst newStateWithUpdatedArray = setValueAtPathForDiff(\n\t\tdiffState.newState,\n\t\tjsonPath,\n\t\tresultArray\n\t);\n\n\t// For single-item operations, we need to carefully preserve diff markers\n\tlet finalOldState = diffState.oldState;\n\tconst finalNewState = newStateWithUpdatedArray;\n\tlet finalComputedState: T;\n\n\tif (targetId !== undefined) {\n\t\t// Single-item operation - we need to preserve diff markers for other items\n\t\t// Get the current computed state with all diff markers\n\t\tconst currentComputedArray = getValueAtPath(\n\t\t\tdiffState.computedState,\n\t\t\tjsonPath\n\t\t) as T[];\n\n\t\t// Build the final computed array by:\n\t\t// 1. Taking the processed item from resultArray (with diff marker removed if accepted)\n\t\t// 2. Keeping all other items from currentComputedArray (with their diff markers intact)\n\t\tconst finalComputedArray = currentComputedArray\n\t\t\t.map((item: T) => {\n\t\t\t\tconst itemId = getItemIdentifier(item, identificationField);\n\t\t\t\tif (itemId === targetId) {\n\t\t\t\t\t// This is the target item - use the processed version from resultArray\n\t\t\t\t\tconst processedItem = resultArray.find(\n\t\t\t\t\t\t(i) => getItemIdentifier(i, identificationField) === targetId\n\t\t\t\t\t);\n\t\t\t\t\treturn processedItem || item;\n\t\t\t\t}\n\t\t\t\t// Not the target - keep as is with diff markers\n\t\t\t\treturn item;\n\t\t\t})\n\t\t\t.filter((item: T) => {\n\t\t\t\t// For reject action on added items, filter out the rejected item\n\t\t\t\tif (action === 'reject') {\n\t\t\t\t\tconst itemId = getItemIdentifier(item, identificationField);\n\t\t\t\t\tif (itemId === targetId) {\n\t\t\t\t\t\t// Check if this was an added item that should be removed\n\t\t\t\t\t\tconst oldItem = oldMap.get(itemId);\n\t\t\t\t\t\tif (!oldItem) {\n\t\t\t\t\t\t\t// Item was added and is being rejected - remove it\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t});\n\n\t\t// Set the final computed state directly\n\t\tfinalComputedState = setValueAtPathForDiff(\n\t\t\tdiffState.computedState,\n\t\t\tjsonPath,\n\t\t\tfinalComputedArray\n\t\t) as T;\n\n\t\t// Update oldState for accepted items to prevent re-diffing\n\t\tif (action === 'accept') {\n\t\t\tconst updatedOldArray = [...oldArray];\n\t\t\tconst targetIndex = updatedOldArray.findIndex(\n\t\t\t\t(item) => getItemIdentifier(item, identificationField) === targetId\n\t\t\t);\n\t\t\tconst acceptedItem = resultArray.find(\n\t\t\t\t(item) => getItemIdentifier(item, identificationField) === targetId\n\t\t\t);\n\n\t\t\tif (acceptedItem) {\n\t\t\t\tif (targetIndex >= 0) {\n\t\t\t\t\tupdatedOldArray[targetIndex] = acceptedItem;\n\t\t\t\t} else {\n\t\t\t\t\tupdatedOldArray.push(acceptedItem);\n\t\t\t\t}\n\t\t\t\tfinalOldState = setValueAtPathForDiff(\n\t\t\t\t\tdiffState.oldState,\n\t\t\t\t\tjsonPath,\n\t\t\t\t\tupdatedOldArray\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Accept/reject all - bypass computeState to avoid re-adding diff markers\n\t\tfinalComputedState = newStateWithUpdatedArray;\n\t\tif (action === 'accept') {\n\t\t\tfinalOldState = newStateWithUpdatedArray;\n\t\t}\n\t}\n\n\t// Check if we're still in diff mode\n\tconst stillInDiffMode =\n\t\ttargetId !== undefined\n\t\t\t? // For single-item, check if computed state has any remaining diff markers\n\t\t\t  (() => {\n\t\t\t\t\tconst computedArray = getValueAtPath(\n\t\t\t\t\t\tfinalComputedState,\n\t\t\t\t\t\tjsonPath\n\t\t\t\t\t) as T[];\n\t\t\t\t\tconst pathsToCheck = diffMarkerPaths || [\n\t\t\t\t\t\t'/data/diff',\n\t\t\t\t\t\t'/diff',\n\t\t\t\t\t\t'/meta/diff',\n\t\t\t\t\t];\n\t\t\t\t\treturn (\n\t\t\t\t\t\tcomputedArray?.some((item: T) => {\n\t\t\t\t\t\t\tfor (const path of pathsToCheck) {\n\t\t\t\t\t\t\t\tconst diffValue = getValueAtPath(item, path);\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tdiffValue === 'added' ||\n\t\t\t\t\t\t\t\t\tdiffValue === 'changed' ||\n\t\t\t\t\t\t\t\t\tdiffValue === 'removed'\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}) || false\n\t\t\t\t\t);\n\t\t\t  })()\n\t\t\t: false; // For accept/reject all, no more diffs\n\n\t// Check if oldState and newState are equivalent - if so, set isDiffMode to false regardless of other checks\n\tconst statesAreEquivalent = areStatesEquivalent(finalOldState, finalNewState);\n\tconst finalIsDiffMode = statesAreEquivalent ? false : stillInDiffMode;\n\n\tconst updatedDiffState: DiffState<T> = {\n\t\toldState: finalOldState,\n\t\tnewState: finalNewState,\n\t\tcomputedState: finalComputedState,\n\t\tisDiffMode: finalIsDiffMode,\n\t\tpatches: [],\n\t};\n\n\t// Save current state to history\n\tconst updatedHistory = [...history, diffState];\n\n\tconst updatedDiffHistoryState: DiffHistoryState<T> = {\n\t\tdiffState: updatedDiffState,\n\t\thistory: updatedHistory,\n\t\tredoStack: [], // Clear redo stack on changes\n\t\tdiffMode,\n\t\tcomputeState,\n\t};\n\n\t// Update the store\n\tget().setDiffState(key, updatedDiffHistoryState);\n\n\treturn true;\n}\n\nexport const createDiffHistorySlice: StateCreator<\n\tCedarStore,\n\t[],\n\t[],\n\tDiffHistorySlice\n> = (set, get) => ({\n\tdiffHistoryStates: {},\n\n\tgetDiffHistoryState: <T>(key: string): DiffHistoryState<T> | undefined => {\n\t\treturn get().diffHistoryStates[key] as DiffHistoryState<T> | undefined;\n\t},\n\n\tgetDiffState: <T>(key: string): DiffState<T> | undefined => {\n\t\tconst diffHistoryState = get().diffHistoryStates[key] as\n\t\t\t| DiffHistoryState<T>\n\t\t\t| undefined;\n\t\treturn diffHistoryState?.diffState;\n\t},\n\n\tregisterDiffState: <T extends BasicStateValue>(\n\t\tconfig: RegisterDiffStateConfig<T>\n\t) => {\n\t\tconst {\n\t\t\tkey,\n\t\t\tvalue,\n\t\t\tsetValue,\n\t\t\tdescription,\n\t\t\tschema,\n\t\t\tstateSetters,\n\t\t\tdiffMode = 'defaultAccept',\n\t\t\tcomputeState,\n\t\t} = config;\n\t\t// Step 1: Initialize or update diff history state\n\t\tconst existingDiffState = get().getDiffHistoryState<T>(key);\n\n\t\tif (!existingDiffState) {\n\t\t\t// Step 1: Register the state in stateSlice\n\t\t\tget().registerState({\n\t\t\t\tkey,\n\t\t\t\tvalue,\n\t\t\t\tsetValue,\n\t\t\t\tdescription,\n\t\t\t\tschema,\n\t\t\t\tstateSetters,\n\t\t\t});\n\n\t\t\tconst initialDiffHistoryState: DiffHistoryState<T> = {\n\t\t\t\tdiffState: {\n\t\t\t\t\toldState: value,\n\t\t\t\t\tnewState: value,\n\t\t\t\t\tcomputedState: value, // Initial state is the same for all\n\t\t\t\t\tisDiffMode: false,\n\t\t\t\t\tpatches: [],\n\t\t\t\t},\n\t\t\t\thistory: [],\n\t\t\t\tredoStack: [],\n\t\t\t\tdiffMode,\n\t\t\t\tcomputeState,\n\t\t\t};\n\t\t\t// This will also register the state in stateSlice via setDiffState\n\t\t\tget().setDiffState(key, initialDiffHistoryState);\n\t\t} else {\n\t\t\t// Technically I don't think we need to check the newState since computedState should equal newState in some situations, but just in case\n\t\t\tconst currentNewState = existingDiffState.diffState.newState;\n\t\t\tconst currentComputedState = existingDiffState.diffState.computedState;\n\t\t\tif (\n\t\t\t\t!isEqual(currentNewState, value) &&\n\t\t\t\t!isEqual(currentComputedState, value)\n\t\t\t) {\n\t\t\t\tget().newDiffState(key, value);\n\t\t\t}\n\t\t}\n\t},\n\n\tsetDiffState: <T>(key: string, diffHistoryState: DiffHistoryState<T>) => {\n\t\t// Check if oldState and newState are equivalent - if so, ensure isDiffMode is false\n\t\tconst oldState = diffHistoryState.diffState?.oldState;\n\t\tconst diffNewState = diffHistoryState.diffState?.newState;\n\t\tconst statesAreEquivalent =\n\t\t\toldState && diffNewState\n\t\t\t\t? areStatesEquivalent(oldState, diffNewState)\n\t\t\t\t: false;\n\n\t\t// Create a corrected diff history state if needed\n\t\tconst correctedDiffHistoryState =\n\t\t\tstatesAreEquivalent && diffHistoryState.diffState?.isDiffMode\n\t\t\t\t? {\n\t\t\t\t\t\t...diffHistoryState,\n\t\t\t\t\t\tdiffState: {\n\t\t\t\t\t\t\t...diffHistoryState.diffState,\n\t\t\t\t\t\t\tisDiffMode: false,\n\t\t\t\t\t\t},\n\t\t\t\t  }\n\t\t\t\t: diffHistoryState;\n\n\t\tset((state) => ({\n\t\t\tdiffHistoryStates: {\n\t\t\t\t...state.diffHistoryStates,\n\t\t\t\t[key]: correctedDiffHistoryState as DiffHistoryState<unknown>,\n\t\t\t},\n\t\t}));\n\n\t\t// Register or update the state in stateSlice with the clean state\n\t\tconst newState = correctedDiffHistoryState.diffState?.computedState\n\t\t\t? correctedDiffHistoryState.diffState?.computedState\n\t\t\t: correctedDiffHistoryState.computeState\n\t\t\t? correctedDiffHistoryState.computeState(\n\t\t\t\t\tcorrectedDiffHistoryState.diffState?.oldState,\n\t\t\t\t\tcorrectedDiffHistoryState.diffState?.newState,\n\t\t\t\t\tcorrectedDiffHistoryState.diffState?.patches || []\n\t\t\t  )\n\t\t\t: correctedDiffHistoryState.diffState?.newState;\n\t\tif (newState !== undefined) {\n\t\t\t// Get the registered state to check if it exists\n\t\t\tconst registeredState = get().registeredStates?.[key];\n\t\t\tif (!registeredState) {\n\t\t\t\t// // Register the state if it doesn't exist\n\t\t\t\tget().registerState({\n\t\t\t\t\tkey,\n\t\t\t\t\tvalue: newState,\n\t\t\t\t\t// Change\n\t\t\t\t\tdescription: `Diff-tracked state: ${key}`,\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Only update if the value has actually changed\n\t\t\t\t// This prevents unnecessary re-renders and potential loops\n\t\t\t\tconst currentValue = registeredState.value;\n\n\t\t\t\tif (!isEqual(currentValue, newState)) {\n\t\t\t\t\t// Update the value in registeredStates\n\t\t\t\t\tset(\n\t\t\t\t\t\t(state) =>\n\t\t\t\t\t\t\t({\n\t\t\t\t\t\t\t\tregisteredStates: {\n\t\t\t\t\t\t\t\t\t...state.registeredStates,\n\t\t\t\t\t\t\t\t\t[key]: {\n\t\t\t\t\t\t\t\t\t\t...state.registeredStates[key],\n\t\t\t\t\t\t\t\t\t\tvalue: newState as BasicStateValue,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t} as Partial<CedarStore>)\n\t\t\t\t\t);\n\t\t\t\t\tregisteredState.setValue?.(newState as BasicStateValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tnewDiffState: <T>(key: string, newState: T, isDiffChange?: boolean) => {\n\t\tconst currentDiffHistoryState = get().getDiffHistoryState<T>(key);\n\n\t\t// If no existing state, we can't proceed\n\t\tif (!currentDiffHistoryState) {\n\t\t\tconsole.warn(`No diff history state found for key: ${key}`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst {\n\t\t\tdiffState: originalDiffState,\n\t\t\thistory,\n\t\t\tdiffMode,\n\t\t\tcomputeState,\n\t\t} = currentDiffHistoryState;\n\n\t\t// If isDiffChange is not provided, use the current diff state's isDiffMode\n\t\tconst effectiveIsDiffChange = isDiffChange ?? originalDiffState.isDiffMode;\n\n\t\t// Step 1: Save the original diffState to history\n\t\tconst updatedHistory = [...history, originalDiffState];\n\n\t\t// Step 3: Create the new diffState based on isDiffChange flag\n\t\tlet oldStateForDiff: T;\n\t\tif (!effectiveIsDiffChange) {\n\t\t\t// Not in diff mode, use current newState\n\t\t\toldStateForDiff = newState;\n\t\t} else {\n\t\t\toldStateForDiff = originalDiffState.isDiffMode\n\t\t\t\t? originalDiffState.oldState\n\t\t\t\t: originalDiffState.newState;\n\t\t}\n\n\t\t// Generate patches to describe the changes\n\t\tconst patches = compare(oldStateForDiff as object, newState as object);\n\n\t\t// Determine computedState: call computeState function if it exists, otherwise use appropriate state based on diffMode\n\t\tconst computedStateValue = computeState\n\t\t\t? computeState(oldStateForDiff, newState, patches)\n\t\t\t: diffMode === 'defaultAccept'\n\t\t\t? newState\n\t\t\t: oldStateForDiff;\n\n\t\t// Check if oldState and newState are equivalent - if so, set isDiffMode to false regardless of source\n\t\tconst statesAreEquivalent = areStatesEquivalent(oldStateForDiff, newState);\n\t\tconst finalIsDiffMode = statesAreEquivalent ? false : effectiveIsDiffChange;\n\n\t\tconst newDiffState: DiffState<T> = {\n\t\t\toldState: oldStateForDiff,\n\t\t\tnewState: newState,\n\t\t\tcomputedState: computedStateValue,\n\t\t\tisDiffMode: finalIsDiffMode,\n\t\t\tpatches,\n\t\t};\n\n\t\t// Create the updated diff history state\n\t\tconst updatedDiffHistoryState: DiffHistoryState<T> = {\n\t\t\tdiffState: newDiffState,\n\t\t\thistory: updatedHistory,\n\t\t\tredoStack: [], // Clear redo stack on new changes\n\t\t\tdiffMode: diffMode, // Keep the same diff mode\n\t\t\tcomputeState, // Preserve the computeState function\n\t\t};\n\n\t\t// Update the store directly without side effects\n\t\tset((state) => ({\n\t\t\tdiffHistoryStates: {\n\t\t\t\t...state.diffHistoryStates,\n\t\t\t\t[key]: updatedDiffHistoryState as DiffHistoryState<unknown>,\n\t\t\t},\n\t\t}));\n\n\t\t// Propagate the computed state to stateSlice\n\t\t// Update the value in registeredStates only (do NOT call setValue to avoid circular dependency)\n\t\tconst registeredState = get().registeredStates?.[key];\n\t\tif (registeredState) {\n\t\t\t// Check if the clean state has actually changed before updating\n\t\t\tconst currentValue = registeredState.value;\n\n\t\t\tif (!isEqual(currentValue, computedStateValue)) {\n\t\t\t\t// Update the stored value\n\t\t\t\tset(\n\t\t\t\t\t(state) =>\n\t\t\t\t\t\t({\n\t\t\t\t\t\t\tregisteredStates: {\n\t\t\t\t\t\t\t\t...state.registeredStates,\n\t\t\t\t\t\t\t\t[key]: {\n\t\t\t\t\t\t\t\t\t...state.registeredStates[key],\n\t\t\t\t\t\t\t\t\tvalue: computedStateValue as BasicStateValue,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t} as Partial<CedarStore>)\n\t\t\t\t);\n\t\t\t\t// Call setValue to update the external state\n\t\t\t\tregisteredState.setValue?.(newState as BasicStateValue);\n\t\t\t}\n\t\t}\n\t},\n\n\tgetCleanState: <T>(key: string): T | undefined => {\n\t\tconst diffHistoryState = get().getDiffHistoryState<T>(key);\n\t\tif (!diffHistoryState || !diffHistoryState.diffState) return undefined;\n\n\t\tconst { diffState, diffMode } = diffHistoryState;\n\n\t\t// Return the appropriate state based on diffMode\n\t\tif (diffMode === 'defaultAccept') {\n\t\t\treturn diffState.newState;\n\t\t} else {\n\t\t\t// holdAccept\n\t\t\treturn diffState.oldState;\n\t\t}\n\t},\n\n\tgetComputedState: <T>(key: string): T | undefined => {\n\t\tconst diffHistoryState = get().getDiffHistoryState<T>(key);\n\t\tif (!diffHistoryState) return undefined;\n\n\t\t// Return the pre-computed state that was calculated during newDiffState\n\t\treturn diffHistoryState.diffState.computedState;\n\t},\n\n\tsetComputeStateFunction: <T>(\n\t\tkey: string,\n\t\tcomputeState: ComputeStateFunction<T> | undefined\n\t) => {\n\t\tconst currentDiffHistoryState = get().getDiffHistoryState<T>(key);\n\t\tif (!currentDiffHistoryState) {\n\t\t\tconsole.warn(`No diff history state found for key: ${key}`);\n\t\t\treturn;\n\t\t}\n\n\t\t// Update the diff history state with the new computeState function\n\t\tconst updatedDiffHistoryState: DiffHistoryState<T> = {\n\t\t\t...currentDiffHistoryState,\n\t\t\tcomputeState,\n\t\t};\n\n\t\tget().setDiffState(key, updatedDiffHistoryState);\n\t},\n\n\texecuteDiffSetter: (\n\t\tkey: string,\n\t\tsetterKey: string,\n\t\toptions: { isDiff?: boolean } = {},\n\t\targs?: unknown\n\t) => {\n\t\tconst isDiff = options.isDiff ?? false;\n\t\tconst currentDiffHistoryState = get().getDiffHistoryState(key);\n\n\t\t// If no diff history state exists for this key, we can't proceed\n\t\tif (!currentDiffHistoryState) {\n\t\t\tconsole.warn(`No diff history state found for key: ${key}`);\n\t\t\treturn;\n\t\t}\n\n\t\t// Get the current newState to execute the setter on\n\t\tconst currentNewState = currentDiffHistoryState.diffState.newState;\n\n\t\t// We need to get the registered state to access the custom setter\n\t\tconst registeredState = get().registeredStates?.[key];\n\t\tif (!registeredState) {\n\t\t\tconsole.warn(`No registered state found for key: ${key}`);\n\t\t\treturn;\n\t\t}\n\n\t\t// Try stateSetters first, then fall back to customSetters for backward compatibility\n\t\tconst stateSetters =\n\t\t\tregisteredState.stateSetters || registeredState.customSetters;\n\t\tif (!stateSetters || !stateSetters[setterKey]) {\n\t\t\tconsole.warn(`State setter \"${setterKey}\" not found for state \"${key}\"`);\n\t\t\treturn;\n\t\t}\n\n\t\t// Create a temporary state holder to capture the result\n\t\tlet resultState: BasicStateValue = currentNewState as BasicStateValue;\n\n\t\t// Create a setValue function that will be passed to the custom setter\n\t\tconst setValueFunc = (newValue: BasicStateValue) => {\n\t\t\tresultState = newValue;\n\t\t};\n\n\t\ttry {\n\t\t\t// Execute the state setter with current state, setValue, and args\n\t\t\tconst setter = stateSetters[setterKey];\n\t\t\tsetter.execute(currentNewState as BasicStateValue, setValueFunc, args);\n\n\t\t\t// Now call newDiffState with the captured result\n\t\t\tget().newDiffState(key, resultState, isDiff);\n\t\t} catch (error) {\n\t\t\tconsole.error(`Error executing diff setter for \"${key}\":`, error);\n\t\t}\n\t},\n\n\tapplyPatchesToDiffState: <T>(\n\t\tkey: string,\n\t\tpatches: Operation[],\n\t\tisDiffChange: boolean\n\t) => {\n\t\tconst currentDiffHistoryState = get().getDiffHistoryState<T>(key);\n\n\t\t// If no existing state, we can't proceed\n\t\tif (!currentDiffHistoryState) {\n\t\t\tconsole.warn(`No diff history state found for key: ${key}`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst {\n\t\t\tdiffState: originalDiffState,\n\t\t\thistory,\n\t\t\tdiffMode,\n\t\t\tcomputeState,\n\t\t} = currentDiffHistoryState;\n\n\t\t// Step 1: Save the original diffState to history\n\t\tconst updatedHistory = [...history, originalDiffState];\n\n\t\t// Step 2: Apply patches to the current newState to get the updated state\n\t\t// Create a deep copy of the current newState to avoid mutations\n\t\tconst currentNewState = cloneDeep(originalDiffState.newState);\n\n\t\t// Apply the patches to get the new state\n\t\tconst patchResult = applyPatch(\n\t\t\tcurrentNewState,\n\t\t\tpatches,\n\t\t\tfalse, // Don't validate (for performance)\n\t\t\tfalse // Don't mutate the original\n\t\t).newDocument;\n\n\t\t// Step 3: Create the new diffState based on isDiffChange flag\n\t\t// Determine oldState based on new logic:\n\t\t// - If isDiffChange is false (not a diff change), keep the original oldState unchanged\n\t\t// - If isDiffChange is true (is a diff change), check previous history state\n\t\tlet oldStateForDiff: T;\n\n\t\tif (!isDiffChange) {\n\t\t\t// Let's keep the oldState just to keep track of diffs\n\t\t\toldStateForDiff = currentNewState;\n\t\t} else {\n\t\t\toldStateForDiff = originalDiffState.isDiffMode\n\t\t\t\t? originalDiffState.oldState\n\t\t\t\t: originalDiffState.newState;\n\t\t}\n\n\t\t// Generate patches to describe the changes from oldState to the new patched state\n\t\tconst diffPatches = compare(\n\t\t\toldStateForDiff as object,\n\t\t\tpatchResult as object\n\t\t);\n\n\t\t// Determine computedState: call computeState function if it exists, otherwise use appropriate state based on diffMode\n\t\tconst computedStateValue = computeState\n\t\t\t? computeState(oldStateForDiff, patchResult, diffPatches)\n\t\t\t: diffMode === 'defaultAccept'\n\t\t\t? patchResult\n\t\t\t: oldStateForDiff;\n\n\t\t// Check if oldState and newState are equivalent - if so, set isDiffMode to false regardless of source\n\t\tconst statesAreEquivalent = areStatesEquivalent(\n\t\t\toldStateForDiff,\n\t\t\tpatchResult\n\t\t);\n\t\tconst finalIsDiffMode = statesAreEquivalent ? false : isDiffChange;\n\n\t\tconst newDiffState: DiffState<T> = {\n\t\t\toldState: oldStateForDiff,\n\t\t\tnewState: patchResult,\n\t\t\tcomputedState: computedStateValue,\n\t\t\tisDiffMode: finalIsDiffMode,\n\t\t\tpatches: diffPatches,\n\t\t};\n\n\t\t// Create the updated diff history state\n\t\tconst updatedDiffHistoryState: DiffHistoryState<T> = {\n\t\t\tdiffState: newDiffState,\n\t\t\thistory: updatedHistory,\n\t\t\tredoStack: [], // Clear redo stack on new changes\n\t\t\tdiffMode: diffMode, // Keep the same diff mode\n\t\t\tcomputeState, // Preserve the computeState function\n\t\t};\n\n\t\t// Update the store\n\t\tget().setDiffState(key, updatedDiffHistoryState);\n\t},\n\n\tacceptAllDiffs: (key: string): boolean => {\n\t\tconst currentDiffHistoryState = get().getDiffHistoryState(key);\n\n\t\t// If no existing state or not in diff mode, return false\n\t\tif (\n\t\t\t!currentDiffHistoryState ||\n\t\t\t!currentDiffHistoryState.diffState.isDiffMode\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst { diffState, history, diffMode, computeState } =\n\t\t\tcurrentDiffHistoryState;\n\n\t\t// Accept changes by copying newState into oldState (sync states)\n\t\t// No patches needed as states are now identical\n\t\tconst acceptedComputedState = computeState\n\t\t\t? computeState(diffState.newState, diffState.newState, [])\n\t\t\t: diffState.newState;\n\n\t\tconst acceptedDiffState: DiffState = {\n\t\t\toldState: diffState.newState, // Copy newState to oldState\n\t\t\tnewState: diffState.newState, // Keep newState as is\n\t\t\tcomputedState: acceptedComputedState, // Call computeState if available\n\t\t\tisDiffMode: false, // No longer in diff mode\n\t\t\tpatches: [], // Empty patches as states are synced\n\t\t};\n\n\t\t// Save the current diff state to history before accepting\n\t\tconst updatedHistory = [...history, diffState];\n\n\t\tconst updatedDiffHistoryState: DiffHistoryState = {\n\t\t\tdiffState: acceptedDiffState,\n\t\t\thistory: updatedHistory,\n\t\t\tredoStack: currentDiffHistoryState.redoStack || [], // Preserve redo stack\n\t\t\tdiffMode: diffMode,\n\t\t\tcomputeState, // Preserve the computeState function\n\t\t};\n\n\t\t// Update the store\n\t\tget().setDiffState(key, updatedDiffHistoryState);\n\n\t\treturn true; // Successfully accepted diffs\n\t},\n\n\trejectAllDiffs: (key: string): boolean => {\n\t\tconst currentDiffHistoryState = get().getDiffHistoryState(key);\n\n\t\t// If no existing state or not in diff mode, return false\n\t\tif (\n\t\t\t!currentDiffHistoryState ||\n\t\t\t!currentDiffHistoryState.diffState.isDiffMode\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst { diffState, history, diffMode, computeState } =\n\t\t\tcurrentDiffHistoryState;\n\n\t\t// Reject changes by copying oldState into newState (revert to old state)\n\t\t// No patches needed as states are now identical\n\t\tconst rejectedComputedState = computeState\n\t\t\t? computeState(diffState.oldState, diffState.oldState, [])\n\t\t\t: diffState.oldState;\n\n\t\tconst rejectedDiffState: DiffState = {\n\t\t\toldState: diffState.oldState, // Keep oldState as is\n\t\t\tnewState: diffState.oldState, // Copy oldState to newState\n\t\t\tcomputedState: rejectedComputedState, // Call computeState if available\n\t\t\tisDiffMode: false, // No longer in diff mode\n\t\t\tpatches: [], // Empty patches as states are synced\n\t\t};\n\n\t\t// Save the current diff state to history before rejecting\n\t\tconst updatedHistory = [...history, diffState];\n\n\t\tconst updatedDiffHistoryState: DiffHistoryState = {\n\t\t\tdiffState: rejectedDiffState,\n\t\t\thistory: updatedHistory,\n\t\t\tredoStack: currentDiffHistoryState.redoStack || [], // Preserve redo stack\n\t\t\tdiffMode: diffMode,\n\t\t\tcomputeState, // Preserve the computeState function\n\t\t};\n\n\t\t// Update the store\n\t\tget().setDiffState(key, updatedDiffHistoryState);\n\n\t\treturn true; // Successfully rejected diffs\n\t},\n\n\tundo: (key: string): boolean => {\n\t\tconst currentDiffHistoryState = get().getDiffHistoryState(key);\n\n\t\t// If no existing state or no history to undo, return false\n\t\tif (\n\t\t\t!currentDiffHistoryState ||\n\t\t\tcurrentDiffHistoryState.history.length === 0\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst {\n\t\t\tdiffState: currentDiffState,\n\t\t\thistory,\n\t\t\tredoStack = [],\n\t\t\tdiffMode,\n\t\t\tcomputeState,\n\t\t} = currentDiffHistoryState;\n\n\t\t// Pop the last state from history\n\t\tconst newHistory = [...history];\n\t\tconst previousState = newHistory.pop();\n\n\t\tif (!previousState) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Push current state to redo stack\n\t\tconst newRedoStack = [...redoStack, currentDiffState];\n\n\t\tconst updatedDiffHistoryState: DiffHistoryState = {\n\t\t\tdiffState: previousState,\n\t\t\thistory: newHistory,\n\t\t\tredoStack: newRedoStack,\n\t\t\tdiffMode: diffMode,\n\t\t\tcomputeState, // Preserve the computeState function\n\t\t};\n\n\t\t// Update the store\n\t\tget().setDiffState(key, updatedDiffHistoryState);\n\n\t\treturn true; // Successfully performed undo\n\t},\n\n\tredo: (key: string): boolean => {\n\t\tconst currentDiffHistoryState = get().getDiffHistoryState(key);\n\n\t\t// If no existing state or no redo stack, return false\n\t\tif (\n\t\t\t!currentDiffHistoryState ||\n\t\t\t!currentDiffHistoryState.redoStack ||\n\t\t\tcurrentDiffHistoryState.redoStack.length === 0\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst {\n\t\t\tdiffState: currentDiffState,\n\t\t\thistory,\n\t\t\tredoStack,\n\t\t\tdiffMode,\n\t\t\tcomputeState,\n\t\t} = currentDiffHistoryState;\n\n\t\t// Pop the last state from redo stack\n\t\tconst newRedoStack = [...redoStack];\n\t\tconst redoState = newRedoStack.pop();\n\n\t\tif (!redoState) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Push current state to history\n\t\tconst newHistory = [...history, currentDiffState];\n\n\t\tconst updatedDiffHistoryState: DiffHistoryState = {\n\t\t\tdiffState: redoState,\n\t\t\thistory: newHistory,\n\t\t\tredoStack: newRedoStack,\n\t\t\tdiffMode: diffMode,\n\t\t\tcomputeState, // Preserve the computeState function\n\t\t};\n\n\t\t// Update the store\n\t\tget().setDiffState(key, updatedDiffHistoryState);\n\n\t\treturn true; // Successfully performed redo\n\t},\n\n\tacceptDiff: <T>(\n\t\tkey: string,\n\t\tjsonPath: string,\n\t\tidentificationField: string | ((item: T) => unknown),\n\t\ttargetId?: unknown,\n\t\tdiffMarkerPaths?: string[]\n\t): boolean => {\n\t\treturn handleSingleDiff(\n\t\t\tget,\n\t\t\tkey,\n\t\t\tjsonPath,\n\t\t\tidentificationField,\n\t\t\t'accept',\n\t\t\ttargetId,\n\t\t\tdiffMarkerPaths\n\t\t);\n\t},\n\n\trejectDiff: <T>(\n\t\tkey: string,\n\t\tjsonPath: string,\n\t\tidentificationField: string | ((item: T) => unknown),\n\t\ttargetId?: unknown,\n\t\tdiffMarkerPaths?: string[]\n\t): boolean => {\n\t\treturn handleSingleDiff(\n\t\t\tget,\n\t\t\tkey,\n\t\t\tjsonPath,\n\t\t\tidentificationField,\n\t\t\t'reject',\n\t\t\ttargetId,\n\t\t\tdiffMarkerPaths\n\t\t);\n\t},\n});\n"],"mappings":"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","names":[]}