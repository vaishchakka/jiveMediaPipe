// src/store/messages/createTypedMessagesSlice.ts
function createTypedMessagesSlice() {
  return (set, get) => ({
    messages: [],
    isProcessing: false,
    showChat: false,
    messageRenderers: /* @__PURE__ */ new Map(),
    setMessages: (messages) => set({ messages }),
    setShowChat: (showChat) => set({ showChat }),
    addMessage: (messageData) => {
      const id = `message-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
      const createdAt = (/* @__PURE__ */ new Date()).toISOString();
      const newMessage = {
        ...messageData,
        id,
        createdAt
      };
      set((state) => ({
        // TypeScript can't prove that MessageByType<T, M> is assignable to M
        // because M could be instantiated with a different subtype. This is safe
        // because we know the message types are part of the union M.
        messages: [...state.messages, newMessage]
      }));
      return newMessage;
    },
    addMessages: (messagesData) => {
      const newMessages = messagesData.map((messageData) => {
        const id = `message-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
        const createdAt = (/* @__PURE__ */ new Date()).toISOString();
        return {
          ...messageData,
          id,
          createdAt
        };
      });
      set((state) => ({
        messages: [...state.messages, ...newMessages]
      }));
      return newMessages;
    },
    updateMessage: (id, updates) => {
      set((state) => ({
        messages: state.messages.map(
          (msg) => msg.id === id ? { ...msg, ...updates } : msg
        )
      }));
    },
    deleteMessage: (id) => {
      set((state) => ({
        messages: state.messages.filter((msg) => msg.id !== id)
      }));
    },
    clearMessages: () => set({ messages: [] }),
    setIsProcessing: (isProcessing) => set({ isProcessing }),
    // Renderer management
    registerMessageRenderer: (config) => {
      set((state) => {
        const newRenderers = new Map(state.messageRenderers);
        newRenderers.set(config.type, config);
        return { messageRenderers: newRenderers };
      });
    },
    unregisterMessageRenderer: (type) => {
      set((state) => {
        const newRenderers = new Map(state.messageRenderers);
        newRenderers.delete(type);
        return { messageRenderers: newRenderers };
      });
    },
    getMessageRenderer: (type) => {
      return get().messageRenderers.get(type);
    },
    // Utility methods
    getMessageById: (id) => {
      return get().messages.find((msg) => msg.id === id);
    },
    getMessagesByRole: (role) => {
      return get().messages.filter((msg) => msg.role === role);
    }
  });
}
export {
  createTypedMessagesSlice
};
//# sourceMappingURL=createTypedMessagesSlice.mjs.map