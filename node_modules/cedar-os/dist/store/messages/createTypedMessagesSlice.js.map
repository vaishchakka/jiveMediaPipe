{"version":3,"sources":["../../../src/store/messages/createTypedMessagesSlice.ts"],"sourcesContent":["import { StateCreator } from 'zustand';\nimport type {\n\tBaseMessage,\n\tDefaultMessage,\n\tMessageByType,\n\tMessageRenderer,\n\tMessageRole,\n} from '@/store/messages/MessageTypes';\n\n/**\n * Type Safety Note:\n *\n * This slice uses type assertions (as unknown as X) in several places. This is\n * intentional and necessary due to TypeScript's limitations with generic constraints\n * and conditional types.\n *\n * The issue: When you have a generic type M that extends BaseMessage (a union of\n * message types), and you try to extract a specific type using MessageByType<T, M>,\n * TypeScript cannot prove that this extracted type is assignable back to M.\n *\n * This is because M could theoretically be instantiated with a different subtype\n * of BaseMessage than what we're working with. Even though we know at runtime\n * that our message types are part of the union M, TypeScript's type system\n * cannot make this guarantee at compile time.\n *\n * The type assertions are safe because:\n * 1. We control the message creation and ensure type consistency\n * 2. The type parameter T is constrained to M['type']\n * 3. The MessageByType helper correctly extracts the matching type from the union\n *\n * Alternative approaches like using function overloads or removing the generic\n * constraints would sacrifice the type inference benefits that make this API\n * ergonomic to use.\n */\n\n// Typed messages slice interface\nexport interface TypedMessagesSlice<M extends BaseMessage = DefaultMessage> {\n\t// State\n\tmessages: M[];\n\tisProcessing: boolean;\n\tshowChat: boolean;\n\n\t// Message renderer registry\n\tmessageRenderers: Map<string, MessageRenderer<any>>;\n\n\t// Fully typed actions\n\taddMessage: <T extends M['type']>(\n\t\tmessage: Omit<MessageByType<T, M>, 'id'> & { type: T }\n\t) => MessageByType<T, M>;\n\n\taddMessages: (messages: Array<Omit<M, 'id'>>) => M[];\n\n\tupdateMessage: <T extends M['type']>(\n\t\tid: string,\n\t\tupdates: Partial<MessageByType<T, M>>\n\t) => void;\n\n\tdeleteMessage: (id: string) => void;\n\tclearMessages: () => void;\n\tsetIsProcessing: (isProcessing: boolean) => void;\n\tsetShowChat: (showChat: boolean) => void;\n\tsetMessages: (messages: M[]) => void;\n\n\t// Renderer management\n\tregisterMessageRenderer: <T extends M['type']>(\n\t\tconfig: MessageRenderer<MessageByType<T, M>>\n\t) => void;\n\n\tunregisterMessageRenderer: (type: string) => void;\n\tgetMessageRenderer: (type: string) => MessageRenderer | undefined;\n\n\t// Utility methods\n\tgetMessageById: (id: string) => M | undefined;\n\tgetMessagesByRole: (role: MessageRole) => M[];\n}\n\n// Generic typed message slice creator\nexport function createTypedMessagesSlice<\n\tM extends BaseMessage = DefaultMessage\n>(): StateCreator<TypedMessagesSlice<M>, [], [], TypedMessagesSlice<M>> {\n\treturn (set, get) => ({\n\t\tmessages: [],\n\t\tisProcessing: false,\n\t\tshowChat: false,\n\t\tmessageRenderers: new Map(),\n\n\t\tsetMessages: (messages: M[]) => set({ messages }),\n\n\t\tsetShowChat: (showChat: boolean) => set({ showChat }),\n\n\t\taddMessage: <T extends M['type']>(\n\t\t\tmessageData: Omit<MessageByType<T, M>, 'id'> & { type: T }\n\t\t): MessageByType<T, M> => {\n\t\t\tconst id = `message-${Date.now()}-${Math.random()\n\t\t\t\t.toString(36)\n\t\t\t\t.substring(2, 9)}`;\n\t\t\tconst createdAt = new Date().toISOString();\n\n\t\t\t// Create the full message\n\t\t\tconst newMessage = {\n\t\t\t\t...messageData,\n\t\t\t\tid,\n\t\t\t\tcreatedAt,\n\t\t\t};\n\n\t\t\tset((state: TypedMessagesSlice<M>) => ({\n\t\t\t\t// TypeScript can't prove that MessageByType<T, M> is assignable to M\n\t\t\t\t// because M could be instantiated with a different subtype. This is safe\n\t\t\t\t// because we know the message types are part of the union M.\n\t\t\t\tmessages: [...state.messages, newMessage as unknown as M],\n\t\t\t}));\n\n\t\t\t// Return with type assertion - safe because input type matches output type\n\t\t\treturn newMessage as unknown as MessageByType<T, M>;\n\t\t},\n\n\t\taddMessages: (messagesData: Array<Omit<M, 'id'>>) => {\n\t\t\tconst newMessages = messagesData.map((messageData) => {\n\t\t\t\tconst id = `message-${Date.now()}-${Math.random()\n\t\t\t\t\t.toString(36)\n\t\t\t\t\t.substring(2, 9)}`;\n\t\t\t\tconst createdAt = new Date().toISOString();\n\n\t\t\t\treturn {\n\t\t\t\t\t...messageData,\n\t\t\t\t\tid,\n\t\t\t\t\tcreatedAt,\n\t\t\t\t} as M;\n\t\t\t});\n\n\t\t\tset((state: TypedMessagesSlice<M>) => ({\n\t\t\t\tmessages: [...state.messages, ...newMessages],\n\t\t\t}));\n\n\t\t\treturn newMessages;\n\t\t},\n\n\t\tupdateMessage: <T extends M['type']>(\n\t\t\tid: string,\n\t\t\tupdates: Partial<MessageByType<T, M>>\n\t\t) => {\n\t\t\tset((state: TypedMessagesSlice<M>) => ({\n\t\t\t\tmessages: state.messages.map((msg) =>\n\t\t\t\t\tmsg.id === id ? ({ ...msg, ...updates } as M) : msg\n\t\t\t\t),\n\t\t\t}));\n\t\t},\n\n\t\tdeleteMessage: (id: string) => {\n\t\t\tset((state: TypedMessagesSlice<M>) => ({\n\t\t\t\tmessages: state.messages.filter((msg) => msg.id !== id),\n\t\t\t}));\n\t\t},\n\n\t\tclearMessages: () => set({ messages: [] }),\n\n\t\tsetIsProcessing: (isProcessing: boolean) => set({ isProcessing }),\n\n\t\t// Renderer management\n\t\tregisterMessageRenderer: <T extends M['type']>(\n\t\t\tconfig: MessageRenderer<MessageByType<T, M>>\n\t\t) => {\n\t\t\tset((state: TypedMessagesSlice<M>) => {\n\t\t\t\tconst newRenderers = new Map(state.messageRenderers);\n\t\t\t\tnewRenderers.set(config.type, config);\n\t\t\t\treturn { messageRenderers: newRenderers };\n\t\t\t});\n\t\t},\n\n\t\tunregisterMessageRenderer: (type: string) => {\n\t\t\tset((state: TypedMessagesSlice<M>) => {\n\t\t\t\tconst newRenderers = new Map(state.messageRenderers);\n\t\t\t\tnewRenderers.delete(type);\n\t\t\t\treturn { messageRenderers: newRenderers };\n\t\t\t});\n\t\t},\n\n\t\tgetMessageRenderer: (type: string) => {\n\t\t\treturn get().messageRenderers.get(type);\n\t\t},\n\n\t\t// Utility methods\n\t\tgetMessageById: (id: string) => {\n\t\t\treturn get().messages.find((msg: M) => msg.id === id);\n\t\t},\n\n\t\tgetMessagesByRole: (role: MessageRole) => {\n\t\t\treturn get().messages.filter((msg: M) => msg.role === role);\n\t\t},\n\t});\n}\n"],"mappings":"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","names":[]}