import { StateCreator } from 'zustand';
import { m as BaseMessage, D as DefaultMessage, t as MessageRenderer, q as MessageByType, w as MessageRole } from '../../index-XdHpD8cC.mjs';
import 'zod';
import '../agentContext/AgentContextTypes.mjs';
import 'react';
import '@tiptap/core';
import '../spellSlice/SpellTypes.mjs';
import 'fast-json-patch';
import '../toolsSlice/ToolsTypes.mjs';

/**
 * Type Safety Note:
 *
 * This slice uses type assertions (as unknown as X) in several places. This is
 * intentional and necessary due to TypeScript's limitations with generic constraints
 * and conditional types.
 *
 * The issue: When you have a generic type M that extends BaseMessage (a union of
 * message types), and you try to extract a specific type using MessageByType<T, M>,
 * TypeScript cannot prove that this extracted type is assignable back to M.
 *
 * This is because M could theoretically be instantiated with a different subtype
 * of BaseMessage than what we're working with. Even though we know at runtime
 * that our message types are part of the union M, TypeScript's type system
 * cannot make this guarantee at compile time.
 *
 * The type assertions are safe because:
 * 1. We control the message creation and ensure type consistency
 * 2. The type parameter T is constrained to M['type']
 * 3. The MessageByType helper correctly extracts the matching type from the union
 *
 * Alternative approaches like using function overloads or removing the generic
 * constraints would sacrifice the type inference benefits that make this API
 * ergonomic to use.
 */
interface TypedMessagesSlice<M extends BaseMessage = DefaultMessage> {
    messages: M[];
    isProcessing: boolean;
    showChat: boolean;
    messageRenderers: Map<string, MessageRenderer<any>>;
    addMessage: <T extends M['type']>(message: Omit<MessageByType<T, M>, 'id'> & {
        type: T;
    }) => MessageByType<T, M>;
    addMessages: (messages: Array<Omit<M, 'id'>>) => M[];
    updateMessage: <T extends M['type']>(id: string, updates: Partial<MessageByType<T, M>>) => void;
    deleteMessage: (id: string) => void;
    clearMessages: () => void;
    setIsProcessing: (isProcessing: boolean) => void;
    setShowChat: (showChat: boolean) => void;
    setMessages: (messages: M[]) => void;
    registerMessageRenderer: <T extends M['type']>(config: MessageRenderer<MessageByType<T, M>>) => void;
    unregisterMessageRenderer: (type: string) => void;
    getMessageRenderer: (type: string) => MessageRenderer | undefined;
    getMessageById: (id: string) => M | undefined;
    getMessagesByRole: (role: MessageRole) => M[];
}
declare function createTypedMessagesSlice<M extends BaseMessage = DefaultMessage>(): StateCreator<TypedMessagesSlice<M>, [], [], TypedMessagesSlice<M>>;

export { type TypedMessagesSlice, createTypedMessagesSlice };
