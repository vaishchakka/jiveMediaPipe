{"version":3,"sources":["../../../src/store/debugger/debuggerSlice.ts"],"sourcesContent":["import type { StateCreator } from 'zustand';\nimport type { CedarStore } from '@/store/CedarOSTypes';\nimport type {\n\tLLMResponse,\n\tBaseParams,\n\tResponseProcessor,\n\tStructuredResponseType,\n} from '@/store/agentConnection/AgentConnectionTypes';\n\nexport interface DebugLogEntry {\n\tid: string;\n\ttimestamp: Date;\n\ttype:\n\t\t| 'request'\n\t\t| 'response'\n\t\t| 'error'\n\t\t| 'stream-start'\n\t\t| 'stream-complete' // Changed from stream-end to be clearer\n\t\t| 'stream-error' // Added for stream errors\n\t\t| 'handler'; // Added for response processor executions\n\tprovider?: string;\n\tapiRoute?: string; // API route/endpoint (e.g., Mastra route)\n\tprocessorName?: string; // Name of the response processor that handled this\n\tdata: {\n\t\tparams?: BaseParams;\n\t\tresponse?: LLMResponse;\n\t\terror?: Error;\n\t\t// For consolidated stream data\n\t\tstreamContent?: string; // All text chunks concatenated\n\t\tstreamObjects?: object[]; // All objects collected\n\t\tcompletedItems?: (string | object)[];\n\t\t// For handler logs\n\t\thandledObject?: StructuredResponseType;\n\t\t// For tracking handlers within a request/stream\n\t\thandlers?: Array<{\n\t\t\tprocessorName: string;\n\t\t\thandledObject: StructuredResponseType;\n\t\t}>;\n\t};\n\tduration?: number; // milliseconds for request-response pairs\n}\n\n// Internal tracking for active streams\ninterface StreamTracker {\n\tstreamId: string;\n\tstartTime: Date;\n\tprovider?: string;\n\tparams?: BaseParams;\n\tchunks: string[];\n\tobjects: object[];\n\thandlers: Array<{\n\t\tprocessorName: string;\n\t\thandledObject: StructuredResponseType;\n\t}>;\n}\n\n// Internal tracking for active requests (non-streaming)\ninterface RequestTracker {\n\trequestId: string;\n\tstartTime: Date;\n\thandlers: Array<{\n\t\tprocessorName: string;\n\t\thandledObject: StructuredResponseType;\n\t}>;\n}\n\nexport interface DebuggerSlice {\n\t// State\n\tagentConnectionLogs: DebugLogEntry[];\n\tmaxLogs: number;\n\tisDebugEnabled: boolean;\n\t// Internal state for tracking active streams (not exposed)\n\tactiveStreams: Map<string, StreamTracker>;\n\tactiveRequests: Map<string, RequestTracker>;\n\t// Collapsible sections state\n\tcollapsedSections: {\n\t\t[stateKey: string]: {\n\t\t\tregisteredState?: boolean;\n\t\t\tdiffState?: boolean;\n\t\t};\n\t};\n\n\t// Actions\n\tlogAgentRequest: (params: BaseParams, provider: string) => string; // returns request ID\n\tlogAgentResponse: (requestId: string, response: LLMResponse) => void;\n\tlogAgentError: (requestId: string, error: Error) => void;\n\tlogStreamStart: (params: BaseParams, provider: string) => string; // returns stream ID\n\tlogStreamChunk: (streamId: string, chunk: string) => void;\n\tlogStreamObject: (streamId: string, object: object) => void;\n\tlogStreamEnd: (\n\t\tstreamId: string,\n\t\tcompletedItems?: (string | object)[]\n\t) => void;\n\tlogResponseProcessorExecution: (\n\t\tobj: StructuredResponseType,\n\t\tprocessor: ResponseProcessor,\n\t\trequestOrStreamId?: string\n\t) => void;\n\tclearDebugLogs: () => void;\n\tsetDebugEnabled: (enabled: boolean) => void;\n\tsetMaxLogs: (max: number) => void;\n\ttoggleSectionCollapse: (\n\t\tstateKey: string,\n\t\tsection: 'registeredState' | 'diffState'\n\t) => void;\n\tsetSectionCollapse: (\n\t\tstateKey: string,\n\t\tsection: 'registeredState' | 'diffState',\n\t\tcollapsed: boolean\n\t) => void;\n\tinitializeSectionCollapse: (stateKey: string, hasDiffStates: boolean) => void;\n}\n\nexport const createDebuggerSlice: StateCreator<\n\tCedarStore,\n\t[],\n\t[],\n\tDebuggerSlice\n> = (set, get) => ({\n\t// Default state\n\tagentConnectionLogs: [],\n\tmaxLogs: 50,\n\tisDebugEnabled: true,\n\tactiveStreams: new Map(),\n\tactiveRequests: new Map(),\n\tcollapsedSections: {},\n\n\t// Actions\n\tlogAgentRequest: (params, provider) => {\n\t\tconst state = get();\n\t\tif (!state.isDebugEnabled) return '';\n\n\t\tconst requestId = `req_${Date.now()}_${Math.random()\n\t\t\t.toString(36)\n\t\t\t.slice(2, 11)}`;\n\n\t\t// Extract API route for supported providers\n\t\tlet apiRoute: string | undefined;\n\t\tif (provider === 'mastra' && 'route' in params) {\n\t\t\tapiRoute = params.route as string;\n\t\t}\n\n\t\t// Initialize request tracker for non-streaming requests\n\t\tconst requestTracker: RequestTracker = {\n\t\t\trequestId,\n\t\t\tstartTime: new Date(),\n\t\t\thandlers: [],\n\t\t};\n\t\tconst newActiveRequests = new Map(state.activeRequests);\n\t\tnewActiveRequests.set(requestId, requestTracker);\n\n\t\tconst entry: DebugLogEntry = {\n\t\t\tid: requestId,\n\t\t\ttimestamp: new Date(),\n\t\t\ttype: 'request',\n\t\t\tprovider,\n\t\t\tapiRoute,\n\t\t\tdata: { params },\n\t\t};\n\n\t\tset((state) => ({\n\t\t\tagentConnectionLogs: [\n\t\t\t\t...state.agentConnectionLogs.slice(0, state.maxLogs - 1),\n\t\t\t\tentry,\n\t\t\t],\n\t\t\tactiveRequests: newActiveRequests,\n\t\t}));\n\n\t\treturn requestId;\n\t},\n\n\tlogAgentResponse: (requestId, response) => {\n\t\tconst state = get();\n\t\tif (!state.isDebugEnabled) return;\n\n\t\t// Find the original request\n\t\tconst requestLog = state.agentConnectionLogs.find(\n\t\t\t(log) => log.id === requestId && log.type === 'request'\n\t\t);\n\n\t\t// Get any handlers that were tracked for this request\n\t\tconst requestTracker = state.activeRequests.get(requestId);\n\t\tconst handlers = requestTracker?.handlers || [];\n\n\t\tconst entry: DebugLogEntry = {\n\t\t\tid: `res_${requestId}`,\n\t\t\ttimestamp: new Date(),\n\t\t\ttype: 'response',\n\t\t\tprovider: requestLog?.provider,\n\t\t\tapiRoute: requestLog?.apiRoute,\n\t\t\tdata: {\n\t\t\t\tresponse,\n\t\t\t\thandlers: handlers.length > 0 ? handlers : undefined,\n\t\t\t},\n\t\t\tduration: requestLog\n\t\t\t\t? new Date().getTime() - requestLog.timestamp.getTime()\n\t\t\t\t: undefined,\n\t\t};\n\n\t\t// Clean up the request tracker\n\t\tconst newActiveRequests = new Map(state.activeRequests);\n\t\tnewActiveRequests.delete(requestId);\n\n\t\tset((state) => ({\n\t\t\tagentConnectionLogs: [\n\t\t\t\t...state.agentConnectionLogs.slice(0, state.maxLogs - 1),\n\t\t\t\tentry,\n\t\t\t],\n\t\t\tactiveRequests: newActiveRequests,\n\t\t}));\n\t},\n\n\tlogAgentError: (requestId, error) => {\n\t\tconst state = get();\n\t\tif (!state.isDebugEnabled) return;\n\n\t\t// Check if this is a stream error\n\t\tconst isStreamError = state.activeStreams.has(requestId);\n\n\t\tif (isStreamError) {\n\t\t\t// Handle stream error\n\t\t\tconst tracker = state.activeStreams.get(requestId)!;\n\n\t\t\t// Extract API route from tracker params for stream errors\n\t\t\tlet apiRoute: string | undefined;\n\t\t\tif (\n\t\t\t\ttracker.provider === 'mastra' &&\n\t\t\t\ttracker.params &&\n\t\t\t\t'route' in tracker.params\n\t\t\t) {\n\t\t\t\tapiRoute = tracker.params.route as string;\n\t\t\t}\n\n\t\t\tconst entry: DebugLogEntry = {\n\t\t\t\tid: requestId,\n\t\t\t\ttimestamp: tracker.startTime,\n\t\t\t\ttype: 'stream-error',\n\t\t\t\tprovider: tracker.provider,\n\t\t\t\tapiRoute,\n\t\t\t\tdata: {\n\t\t\t\t\tparams: tracker.params,\n\t\t\t\t\terror,\n\t\t\t\t\tstreamContent: tracker.chunks.join(''),\n\t\t\t\t\tstreamObjects: tracker.objects,\n\t\t\t\t},\n\t\t\t\tduration: new Date().getTime() - tracker.startTime.getTime(),\n\t\t\t};\n\n\t\t\t// Remove from active streams\n\t\t\tconst newActiveStreams = new Map(state.activeStreams);\n\t\t\tnewActiveStreams.delete(requestId);\n\n\t\t\tset((state) => ({\n\t\t\t\tagentConnectionLogs: [\n\t\t\t\t\t...state.agentConnectionLogs.slice(0, state.maxLogs - 1),\n\t\t\t\t\tentry,\n\t\t\t\t],\n\t\t\t\tactiveStreams: newActiveStreams,\n\t\t\t}));\n\t\t} else {\n\t\t\t// Handle regular request error\n\t\t\tconst requestLog = state.agentConnectionLogs.find(\n\t\t\t\t(log) => log.id === requestId && log.type === 'request'\n\t\t\t);\n\n\t\t\tconst entry: DebugLogEntry = {\n\t\t\t\tid: `err_${requestId}`,\n\t\t\t\ttimestamp: new Date(),\n\t\t\t\ttype: 'error',\n\t\t\t\tprovider: requestLog?.provider,\n\t\t\t\tapiRoute: requestLog?.apiRoute,\n\t\t\t\tdata: { error },\n\t\t\t\tduration: requestLog\n\t\t\t\t\t? new Date().getTime() - requestLog.timestamp.getTime()\n\t\t\t\t\t: undefined,\n\t\t\t};\n\n\t\t\tset((state) => ({\n\t\t\t\tagentConnectionLogs: [\n\t\t\t\t\t...state.agentConnectionLogs.slice(0, state.maxLogs - 1),\n\t\t\t\t\tentry,\n\t\t\t\t],\n\t\t\t}));\n\t\t}\n\t},\n\n\tlogStreamStart: (params, provider) => {\n\t\tconst state = get();\n\t\tif (!state.isDebugEnabled) return '';\n\n\t\tconst streamId = `stream_${Date.now()}_${Math.random()\n\t\t\t.toString(36)\n\t\t\t.slice(2, 11)}`;\n\n\t\t// Create tracker for this stream\n\t\tconst tracker: StreamTracker = {\n\t\t\tstreamId,\n\t\t\tstartTime: new Date(),\n\t\t\tprovider,\n\t\t\tparams,\n\t\t\tchunks: [],\n\t\t\tobjects: [],\n\t\t\thandlers: [],\n\t\t};\n\n\t\t// Add to active streams\n\t\tconst newActiveStreams = new Map(state.activeStreams);\n\t\tnewActiveStreams.set(streamId, tracker);\n\n\t\tset({ activeStreams: newActiveStreams });\n\n\t\t// Don't log stream-start events anymore, we'll log the complete stream at the end\n\t\treturn streamId;\n\t},\n\n\tlogStreamChunk: (streamId, chunk) => {\n\t\tconst state = get();\n\t\tif (!state.isDebugEnabled) return;\n\n\t\tconst tracker = state.activeStreams.get(streamId);\n\t\tif (!tracker) return;\n\n\t\t// Just accumulate the chunk, don't create a log entry\n\t\ttracker.chunks.push(chunk);\n\t},\n\n\tlogStreamObject: (streamId, object) => {\n\t\tconst state = get();\n\t\tif (!state.isDebugEnabled) return;\n\n\t\tconst tracker = state.activeStreams.get(streamId);\n\t\tif (!tracker) return;\n\n\t\t// Just accumulate the object, don't create a log entry\n\t\ttracker.objects.push(object);\n\t},\n\n\tlogStreamEnd: (streamId, completedItems) => {\n\t\tconst state = get();\n\t\tif (!state.isDebugEnabled) return;\n\n\t\tconst tracker = state.activeStreams.get(streamId);\n\t\tif (!tracker) return;\n\n\t\t// Extract API route from tracker params\n\t\tlet apiRoute: string | undefined;\n\t\tif (\n\t\t\ttracker.provider === 'mastra' &&\n\t\t\ttracker.params &&\n\t\t\t'route' in tracker.params\n\t\t) {\n\t\t\tapiRoute = tracker.params.route as string;\n\t\t}\n\n\t\t// Create a single consolidated log entry for the entire stream\n\t\tconst entry: DebugLogEntry = {\n\t\t\tid: streamId,\n\t\t\ttimestamp: tracker.startTime,\n\t\t\ttype: 'stream-complete',\n\t\t\tprovider: tracker.provider,\n\t\t\tapiRoute,\n\t\t\tdata: {\n\t\t\t\tparams: tracker.params,\n\t\t\t\tstreamContent: tracker.chunks.join(''),\n\t\t\t\tstreamObjects: tracker.objects,\n\t\t\t\tcompletedItems: completedItems || [\n\t\t\t\t\t...(tracker.chunks.length > 0 ? [tracker.chunks.join('')] : []),\n\t\t\t\t\t...tracker.objects,\n\t\t\t\t],\n\t\t\t\thandlers: tracker.handlers.length > 0 ? tracker.handlers : undefined,\n\t\t\t},\n\t\t\tduration: new Date().getTime() - tracker.startTime.getTime(),\n\t\t};\n\n\t\t// Remove from active streams\n\t\tconst newActiveStreams = new Map(state.activeStreams);\n\t\tnewActiveStreams.delete(streamId);\n\n\t\tset((state) => ({\n\t\t\tagentConnectionLogs: [\n\t\t\t\t...state.agentConnectionLogs.slice(0, state.maxLogs - 1),\n\t\t\t\tentry,\n\t\t\t],\n\t\t\tactiveStreams: newActiveStreams,\n\t\t}));\n\t},\n\n\tlogResponseProcessorExecution: (obj, processor, requestOrStreamId) => {\n\t\tconst state = get();\n\t\tif (!state.isDebugEnabled) return;\n\n\t\t// Build a descriptive name for the processor\n\t\tconst processorName = processor.namespace\n\t\t\t? `${processor.namespace}:${processor.type}`\n\t\t\t: processor.type;\n\n\t\tconst handlerInfo = { processorName, handledObject: obj };\n\n\t\t// Check if this is part of an active stream\n\t\tconst streamTracker = requestOrStreamId\n\t\t\t? state.activeStreams.get(requestOrStreamId)\n\t\t\t: null;\n\n\t\tif (streamTracker) {\n\t\t\t// Special handling for text handlers - merge consecutive ones\n\t\t\tif (processorName === 'builtin:text') {\n\t\t\t\tconst lastHandler =\n\t\t\t\t\tstreamTracker.handlers[streamTracker.handlers.length - 1];\n\n\t\t\t\t// If the last handler is also a text handler, merge them\n\t\t\t\tif (lastHandler && lastHandler.processorName === 'builtin:text') {\n\t\t\t\t\t// Combine the text content\n\t\t\t\t\tconst existingContent =\n\t\t\t\t\t\t'content' in lastHandler.handledObject\n\t\t\t\t\t\t\t? String(lastHandler.handledObject.content)\n\t\t\t\t\t\t\t: '';\n\t\t\t\t\tconst newContent = 'content' in obj ? String(obj.content) : '';\n\t\t\t\t\tlastHandler.handledObject = {\n\t\t\t\t\t\ttype: 'text',\n\t\t\t\t\t\tcontent: existingContent + newContent,\n\t\t\t\t\t} as StructuredResponseType;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to stream's handler list (for non-text or first text handler)\n\t\t\tstreamTracker.handlers.push(handlerInfo);\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if this is part of an active request\n\t\tconst requestTracker = requestOrStreamId\n\t\t\t? state.activeRequests.get(requestOrStreamId)\n\t\t\t: null;\n\n\t\tif (requestTracker) {\n\t\t\t// Special handling for text handlers in non-streaming context (though less common)\n\t\t\tif (processorName === 'builtin:text') {\n\t\t\t\tconst lastHandler =\n\t\t\t\t\trequestTracker.handlers[requestTracker.handlers.length - 1];\n\n\t\t\t\t// If the last handler is also a text handler, merge them\n\t\t\t\tif (lastHandler && lastHandler.processorName === 'builtin:text') {\n\t\t\t\t\t// Combine the text content\n\t\t\t\t\tconst existingContent =\n\t\t\t\t\t\t'content' in lastHandler.handledObject\n\t\t\t\t\t\t\t? String(lastHandler.handledObject.content)\n\t\t\t\t\t\t\t: '';\n\t\t\t\t\tconst newContent = 'content' in obj ? String(obj.content) : '';\n\t\t\t\t\tlastHandler.handledObject = {\n\t\t\t\t\t\ttype: 'text',\n\t\t\t\t\t\tcontent: existingContent + newContent,\n\t\t\t\t\t} as StructuredResponseType;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to request's handler list\n\t\t\trequestTracker.handlers.push(handlerInfo);\n\t\t\treturn;\n\t\t}\n\n\t\t// If no active request/stream, create a new request tracker\n\t\t// This happens for non-streaming requests\n\t\tif (requestOrStreamId) {\n\t\t\tconst newTracker: RequestTracker = {\n\t\t\t\trequestId: requestOrStreamId,\n\t\t\t\tstartTime: new Date(),\n\t\t\t\thandlers: [handlerInfo],\n\t\t\t};\n\t\t\tconst newActiveRequests = new Map(state.activeRequests);\n\t\t\tnewActiveRequests.set(requestOrStreamId, newTracker);\n\t\t\tset({ activeRequests: newActiveRequests });\n\t\t}\n\t},\n\n\tclearDebugLogs: () => set({ agentConnectionLogs: [] }),\n\n\tsetDebugEnabled: (enabled) => set({ isDebugEnabled: enabled }),\n\n\tsetMaxLogs: (max) => set({ maxLogs: max }),\n\n\ttoggleSectionCollapse: (stateKey, section) => {\n\t\tconst state = get();\n\t\tconst currentCollapsed =\n\t\t\tstate.collapsedSections[stateKey]?.[section] || false;\n\n\t\tset((state) => ({\n\t\t\tcollapsedSections: {\n\t\t\t\t...state.collapsedSections,\n\t\t\t\t[stateKey]: {\n\t\t\t\t\t...state.collapsedSections[stateKey],\n\t\t\t\t\t[section]: !currentCollapsed,\n\t\t\t\t},\n\t\t\t},\n\t\t}));\n\t},\n\n\tsetSectionCollapse: (stateKey, section, collapsed) => {\n\t\tset((state) => ({\n\t\t\tcollapsedSections: {\n\t\t\t\t...state.collapsedSections,\n\t\t\t\t[stateKey]: {\n\t\t\t\t\t...state.collapsedSections[stateKey],\n\t\t\t\t\t[section]: collapsed,\n\t\t\t\t},\n\t\t\t},\n\t\t}));\n\t},\n\n\tinitializeSectionCollapse: (stateKey, hasDiffStates) => {\n\t\tconst state = get();\n\n\t\t// Only initialize if not already set for this state\n\t\tif (!state.collapsedSections[stateKey]) {\n\t\t\tset((state) => ({\n\t\t\t\tcollapsedSections: {\n\t\t\t\t\t...state.collapsedSections,\n\t\t\t\t\t[stateKey]: {\n\t\t\t\t\t\t// Collapse registered state by default if diff states are present\n\t\t\t\t\t\tregisteredState: hasDiffStates,\n\t\t\t\t\t\t// Keep diff state expanded by default when present\n\t\t\t\t\t\tdiffState: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}));\n\t\t}\n\t},\n});\n"],"mappings":"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","names":["state"]}