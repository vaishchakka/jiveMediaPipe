import { useState, useEffect } from 'react';
import { onlyMouse, onlyLeftClicks } from '../utils/only-mouse-events.mjs';
import { findTarget } from './find-target.mjs';

let listener = null;
let state = {
    type: "default",
    isPressed: false,
    fontSize: null,
    targetBoundingBox: null,
    target: null,
    zone: null,
};
function getZone(target) {
    let zone = null;
    if ("closest" in target) {
        const zoneElement = target.closest("[data-cursor-zone]");
        if (zoneElement instanceof HTMLElement) {
            zone = zoneElement.dataset.cursorZone || null;
        }
    }
    return zone;
}
function startPointerOverListener() {
    const listeners = new Set();
    function updateState(newState) {
        state = { ...state, ...newState };
        listeners.forEach((listener) => listener(state));
    }
    const handlePointerDown = onlyLeftClicks(() => {
        if (!state.isPressed) {
            updateState({ isPressed: true });
        }
    });
    const handlePointerUp = onlyLeftClicks(() => {
        if (state.isPressed) {
            updateState({ isPressed: false });
        }
    });
    const handlePointerOver = onlyMouse(({ target }) => {
        if (!target)
            return;
        const [type, cursorTarget] = findTarget(target);
        let hasUpdated = false;
        let newState = {
            target: cursorTarget,
            zone: getZone(target),
        };
        if (type !== state.type) {
            newState.type = type;
            hasUpdated = true;
        }
        if (newState.zone !== state.zone) {
            newState.zone = newState.zone;
            hasUpdated = true;
        }
        const size = type === "pointer" && cursorTarget
            ? cursorTarget.getBoundingClientRect()
            : null;
        if (size !== state.targetBoundingBox) {
            newState.targetBoundingBox = size;
            hasUpdated = true;
        }
        if (type === "text") {
            const { fontSize: computedFontSize } = window.getComputedStyle(target);
            const newFontSize = computedFontSize
                ? parseInt(computedFontSize)
                : null;
            if (newFontSize !== state.fontSize) {
                newState.fontSize = newFontSize;
                hasUpdated = true;
            }
        }
        else {
            if (state.fontSize) {
                newState.fontSize = null;
                hasUpdated = true;
            }
        }
        if (hasUpdated) {
            updateState(newState);
        }
    });
    function addEventListeners() {
        window.addEventListener("pointerover", handlePointerOver);
        window.addEventListener("pointerdown", handlePointerDown);
        window.addEventListener("pointerup", handlePointerUp);
    }
    function removeEventListeners() {
        window.removeEventListener("pointerover", handlePointerOver);
        window.removeEventListener("pointerdown", handlePointerDown);
        window.removeEventListener("pointerup", handlePointerUp);
    }
    return {
        onChange: (callback) => {
            if (!listeners.size) {
                addEventListeners();
            }
            listeners.add(callback);
            return () => {
                listeners.delete(callback);
                if (!listeners.size) {
                    removeEventListeners();
                }
            };
        },
    };
}
function getPointerOverListener() {
    if (!listener) {
        listener = startPointerOverListener();
    }
    return listener;
}
function useCursorState() {
    const [latestState, setLatestState] = useState({ ...state });
    useEffect(() => {
        return getPointerOverListener().onChange((newState) => {
            setLatestState(newState);
        });
    }, [latestState]);
    return latestState;
}

export { useCursorState };
