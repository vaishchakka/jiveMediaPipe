import React, { useEffect, useState } from 'react';
import { 
  useRegisterFrontendTool,
  useCedarState,
  useTools
} from 'cedar-os';
import { poseActions, diffActions, aiCoachingActions } from '../store/cedarStore';
import './CedarPoseTools.css';

const CedarPoseTools = ({ currentPose, referencePose, onToolResult }) => {
  const [poseState, poseDispatch] = useCedarState('poseState');
  const [diffState, diffDispatch] = useCedarState('diffState');
  const [aiState, aiDispatch] = useCedarState('aiCoaching');
  
  const [analysisResults, setAnalysisResults] = useState(null);
  const [selectedTool, setSelectedTool] = useState(null);
  
  // Register custom frontend tools with CedarOS
  const poseAnalyzerTool = useRegisterFrontendTool({\n    name: 'poseAnalyzer',\n    description: 'Analyze current pose and provide detailed feedback on form and accuracy',\n    parameters: {\n      pose: { type: 'object', description: 'Current pose landmarks' },\n      reference: { type: 'object', description: 'Reference pose landmarks' },\n      analysisType: { \n        type: 'string', \n        enum: ['basic', 'detailed', 'joints', 'symmetry'],\n        description: 'Type of analysis to perform'\n      }\n    },\n    handler: analyzePoseDetails\n  });\n  \n  const formCorrectorTool = useRegisterFrontendTool({\n    name: 'formCorrector',\n    description: 'Provide specific corrections for pose form and alignment',\n    parameters: {\n      pose: { type: 'object', description: 'Current pose landmarks' },\n      reference: { type: 'object', description: 'Reference pose landmarks' },\n      focusArea: {\n        type: 'string',\n        enum: ['arms', 'legs', 'torso', 'head', 'balance', 'all'],\n        description: 'Body area to focus corrections on'\n      }\n    },\n    handler: generateFormCorrections\n  });\n  \n  const movementScorerTool = useRegisterFrontendTool({\n    name: 'movementScorer',\n    description: 'Score movement quality and provide improvement suggestions',\n    parameters: {\n      poseHistory: { type: 'array', description: 'History of poses' },\n      scoreType: {\n        type: 'string',\n        enum: ['accuracy', 'fluidity', 'timing', 'overall'],\n        description: 'Type of scoring to perform'\n      }\n    },\n    handler: scoreMovement\n  });\n  \n  const symmetryAnalyzerTool = useRegisterFrontendTool({\n    name: 'symmetryAnalyzer',\n    description: 'Analyze body symmetry and balance in poses',\n    parameters: {\n      pose: { type: 'object', description: 'Pose landmarks to analyze' },\n      symmetryType: {\n        type: 'string',\n        enum: ['bilateral', 'balance', 'alignment'],\n        description: 'Type of symmetry analysis'\n      }\n    },\n    handler: analyzeSymmetry\n  });\n  \n  // Get registered tools from CedarOS\n  const tools = useTools();\n  \n  // Pose analysis implementation\n  async function analyzePoseDetails(params) {\n    const { pose, reference, analysisType = 'basic' } = params;\n    \n    if (!pose || !reference) {\n      return { error: 'Missing pose data for analysis' };\n    }\n    \n    const analysis = {\n      timestamp: Date.now(),\n      type: analysisType,\n      results: {}\n    };\n    \n    switch (analysisType) {\n      case 'basic':\n        analysis.results = await performBasicAnalysis(pose, reference);\n        break;\n      case 'detailed':\n        analysis.results = await performDetailedAnalysis(pose, reference);\n        break;\n      case 'joints':\n        analysis.results = await performJointAnalysis(pose, reference);\n        break;\n      case 'symmetry':\n        analysis.results = await analyzeSymmetry({ pose, symmetryType: 'bilateral' });\n        break;\n      default:\n        analysis.results = await performBasicAnalysis(pose, reference);\n    }\n    \n    setAnalysisResults(analysis);\n    onToolResult && onToolResult('poseAnalyzer', analysis);\n    \n    return analysis;\n  }\n  \n  async function performBasicAnalysis(pose, reference) {\n    const landmarks = pose.kp || [];\n    const refLandmarks = reference.kp || [];\n    \n    if (landmarks.length === 0 || refLandmarks.length === 0) {\n      return { error: 'Insufficient landmark data' };\n    }\n    \n    // Calculate overall similarity\n    const similarity = calculatePoseSimilarity(landmarks, refLandmarks);\n    \n    // Analyze key body parts\n    const bodyParts = analyzeBodyParts(landmarks, refLandmarks);\n    \n    // Generate recommendations\n    const recommendations = generateBasicRecommendations(similarity, bodyParts);\n    \n    return {\n      overallSimilarity: similarity,\n      bodyParts,\n      recommendations,\n      confidence: calculateConfidence(landmarks)\n    };\n  }\n  \n  async function performDetailedAnalysis(pose, reference) {\n    const basic = await performBasicAnalysis(pose, reference);\n    \n    // Add detailed joint angles analysis\n    const jointAngles = calculateJointAngles(pose.kp);\n    const referenceAngles = calculateJointAngles(reference.kp);\n    const angleDifferences = compareAngles(jointAngles, referenceAngles);\n    \n    // Add posture analysis\n    const postureAnalysis = analyzePosture(pose.kp);\n    \n    // Add movement quality metrics\n    const movementQuality = analyzeMovementQuality(poseState.poseHistory);\n    \n    return {\n      ...basic,\n      jointAngles,\n      angleDifferences,\n      postureAnalysis,\n      movementQuality,\n      detailedRecommendations: generateDetailedRecommendations({\n        ...basic,\n        angleDifferences,\n        postureAnalysis\n      })\n    };\n  }\n  \n  async function performJointAnalysis(pose, reference) {\n    const landmarks = pose.kp || [];\n    const refLandmarks = reference.kp || [];\n    \n    const jointAccuracy = {};\n    const criticalJoints = [\n      { name: 'leftShoulder', index: 11 },\n      { name: 'rightShoulder', index: 12 },\n      { name: 'leftElbow', index: 13 },\n      { name: 'rightElbow', index: 14 },\n      { name: 'leftWrist', index: 15 },\n      { name: 'rightWrist', index: 16 },\n      { name: 'leftHip', index: 23 },\n      { name: 'rightHip', index: 24 },\n      { name: 'leftKnee', index: 25 },\n      { name: 'rightKnee', index: 26 },\n      { name: 'leftAnkle', index: 27 },\n      { name: 'rightAnkle', index: 28 }\n    ];\n    \n    criticalJoints.forEach(joint => {\n      if (landmarks[joint.index] && refLandmarks[joint.index]) {\n        const distance = calculateDistance(\n          landmarks[joint.index],\n          refLandmarks[joint.index]\n        );\n        const accuracy = Math.max(0, 100 - (distance * 1000));\n        jointAccuracy[joint.name] = {\n          accuracy: Math.round(accuracy),\n          distance: distance,\n          status: accuracy > 80 ? 'excellent' : accuracy > 60 ? 'good' : 'needsWork'\n        };\n      }\n    });\n    \n    return {\n      jointAccuracy,\n      averageAccuracy: Object.values(jointAccuracy).reduce(\n        (sum, joint) => sum + joint.accuracy, 0\n      ) / Object.keys(jointAccuracy).length,\n      problematicJoints: Object.entries(jointAccuracy)\n        .filter(([_, data]) => data.accuracy < 60)\n        .map(([name, data]) => ({ name, ...data }))\n    };\n  }\n  \n  async function generateFormCorrections(params) {\n    const { pose, reference, focusArea = 'all' } = params;\n    \n    const corrections = {\n      focusArea,\n      timestamp: Date.now(),\n      corrections: []\n    };\n    \n    const analysis = await performDetailedAnalysis(pose, reference);\n    \n    // Generate specific corrections based on focus area\n    switch (focusArea) {\n      case 'arms':\n        corrections.corrections = generateArmCorrections(analysis);\n        break;\n      case 'legs':\n        corrections.corrections = generateLegCorrections(analysis);\n        break;\n      case 'torso':\n        corrections.corrections = generateTorsoCorrections(analysis);\n        break;\n      case 'balance':\n        corrections.corrections = generateBalanceCorrections(analysis);\n        break;\n      default:\n        corrections.corrections = generateAllCorrections(analysis);\n    }\n    \n    // Add corrections to AI coaching state\n    corrections.corrections.forEach(correction => {\n      aiDispatch(aiCoachingActions.addImprovementSuggestion({\n        joint: correction.bodyPart,\n        suggestion: correction.instruction,\n        priority: correction.priority\n      }));\n    });\n    \n    return corrections;\n  }\n  \n  async function scoreMovement(params) {\n    const { poseHistory, scoreType = 'overall' } = params;\n    \n    if (!poseHistory || poseHistory.length < 5) {\n      return { error: 'Insufficient pose history for movement scoring' };\n    }\n    \n    const scores = {\n      timestamp: Date.now(),\n      scoreType,\n      scores: {},\n      overallScore: 0\n    };\n    \n    switch (scoreType) {\n      case 'accuracy':\n        scores.scores.accuracy = calculateAccuracyScore(poseHistory);\n        scores.overallScore = scores.scores.accuracy;\n        break;\n      case 'fluidity':\n        scores.scores.fluidity = calculateFluidityScore(poseHistory);\n        scores.overallScore = scores.scores.fluidity;\n        break;\n      case 'timing':\n        scores.scores.timing = calculateTimingScore(poseHistory);\n        scores.overallScore = scores.scores.timing;\n        break;\n      default:\n        scores.scores = {\n          accuracy: calculateAccuracyScore(poseHistory),\n          fluidity: calculateFluidityScore(poseHistory),\n          timing: calculateTimingScore(poseHistory)\n        };\n        scores.overallScore = Object.values(scores.scores).reduce(\n          (sum, score) => sum + score, 0\n        ) / Object.keys(scores.scores).length;\n    }\n    \n    // Update pose state with scores\n    diffDispatch(diffActions.updateJointScores(scores));\n    \n    return scores;\n  }\n  \n  async function analyzeSymmetry(params) {\n    const { pose, symmetryType = 'bilateral' } = params;\n    \n    const landmarks = pose.kp || [];\n    if (landmarks.length < 33) {\n      return { error: 'Insufficient landmarks for symmetry analysis' };\n    }\n    \n    const symmetry = {\n      type: symmetryType,\n      timestamp: Date.now(),\n      analysis: {}\n    };\n    \n    switch (symmetryType) {\n      case 'bilateral':\n        symmetry.analysis = analyzeBilateralSymmetry(landmarks);\n        break;\n      case 'balance':\n        symmetry.analysis = analyzeBalance(landmarks);\n        break;\n      case 'alignment':\n        symmetry.analysis = analyzeAlignment(landmarks);\n        break;\n    }\n    \n    return symmetry;\n  }\n  \n  // Helper functions for calculations\n  function calculatePoseSimilarity(landmarks, refLandmarks) {\n    // Implementation of pose similarity calculation\n    let totalDistance = 0;\n    let validPoints = 0;\n    \n    for (let i = 0; i < Math.min(landmarks.length, refLandmarks.length); i++) {\n      if (landmarks[i][3] > 0.5 && refLandmarks[i][3] > 0.5) {\n        const distance = calculateDistance(landmarks[i], refLandmarks[i]);\n        totalDistance += distance;\n        validPoints++;\n      }\n    }\n    \n    if (validPoints === 0) return 0;\n    const avgDistance = totalDistance / validPoints;\n    return Math.max(0, 100 - (avgDistance * 1000));\n  }\n  \n  function calculateDistance(point1, point2) {\n    const dx = point1[0] - point2[0];\n    const dy = point1[1] - point2[1];\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n  \n  function analyzeBodyParts(landmarks, refLandmarks) {\n    return {\n      arms: analyzeArms(landmarks, refLandmarks),\n      legs: analyzeLegs(landmarks, refLandmarks),\n      torso: analyzeTorso(landmarks, refLandmarks)\n    };\n  }\n  \n  function analyzeArms(landmarks, refLandmarks) {\n    // Analyze arm positioning\n    const leftArm = calculateArmAccuracy(landmarks, refLandmarks, 'left');\n    const rightArm = calculateArmAccuracy(landmarks, refLandmarks, 'right');\n    \n    return {\n      left: leftArm,\n      right: rightArm,\n      overall: (leftArm.accuracy + rightArm.accuracy) / 2\n    };\n  }\n  \n  function analyzeLegs(landmarks, refLandmarks) {\n    // Similar to arms analysis\n    const leftLeg = calculateLegAccuracy(landmarks, refLandmarks, 'left');\n    const rightLeg = calculateLegAccuracy(landmarks, refLandmarks, 'right');\n    \n    return {\n      left: leftLeg,\n      right: rightLeg,\n      overall: (leftLeg.accuracy + rightLeg.accuracy) / 2\n    };\n  }\n  \n  function analyzeTorso(landmarks, refLandmarks) {\n    // Analyze torso positioning\n    const shoulderAlignment = calculateShoulderAlignment(landmarks, refLandmarks);\n    const hipAlignment = calculateHipAlignment(landmarks, refLandmarks);\n    \n    return {\n      shoulders: shoulderAlignment,\n      hips: hipAlignment,\n      overall: (shoulderAlignment.accuracy + hipAlignment.accuracy) / 2\n    };\n  }\n  \n  function calculateArmAccuracy(landmarks, refLandmarks, side) {\n    const indices = side === 'left' ? [11, 13, 15] : [12, 14, 16]; // shoulder, elbow, wrist\n    let totalAccuracy = 0;\n    let validJoints = 0;\n    \n    indices.forEach(index => {\n      if (landmarks[index] && refLandmarks[index]) {\n        const distance = calculateDistance(landmarks[index], refLandmarks[index]);\n        const accuracy = Math.max(0, 100 - (distance * 1000));\n        totalAccuracy += accuracy;\n        validJoints++;\n      }\n    });\n    \n    return {\n      accuracy: validJoints > 0 ? totalAccuracy / validJoints : 0,\n      jointsAnalyzed: validJoints\n    };\n  }\n  \n  function calculateLegAccuracy(landmarks, refLandmarks, side) {\n    const indices = side === 'left' ? [23, 25, 27] : [24, 26, 28]; // hip, knee, ankle\n    let totalAccuracy = 0;\n    let validJoints = 0;\n    \n    indices.forEach(index => {\n      if (landmarks[index] && refLandmarks[index]) {\n        const distance = calculateDistance(landmarks[index], refLandmarks[index]);\n        const accuracy = Math.max(0, 100 - (distance * 1000));\n        totalAccuracy += accuracy;\n        validJoints++;\n      }\n    });\n    \n    return {\n      accuracy: validJoints > 0 ? totalAccuracy / validJoints : 0,\n      jointsAnalyzed: validJoints\n    };\n  }\n  \n  function calculateShoulderAlignment(landmarks, refLandmarks) {\n    const leftShoulder = landmarks[11];\n    const rightShoulder = landmarks[12];\n    const refLeftShoulder = refLandmarks[11];\n    const refRightShoulder = refLandmarks[12];\n    \n    if (!leftShoulder || !rightShoulder || !refLeftShoulder || !refRightShoulder) {\n      return { accuracy: 0, error: 'Missing shoulder landmarks' };\n    }\n    \n    const currentAngle = Math.atan2(\n      rightShoulder[1] - leftShoulder[1],\n      rightShoulder[0] - leftShoulder[0]\n    );\n    \n    const refAngle = Math.atan2(\n      refRightShoulder[1] - refLeftShoulder[1],\n      refRightShoulder[0] - refLeftShoulder[0]\n    );\n    \n    const angleDiff = Math.abs(currentAngle - refAngle);\n    const accuracy = Math.max(0, 100 - (angleDiff * 100));\n    \n    return { accuracy, angleDifference: angleDiff };\n  }\n  \n  function calculateHipAlignment(landmarks, refLandmarks) {\n    // Similar to shoulder alignment but for hips\n    const leftHip = landmarks[23];\n    const rightHip = landmarks[24];\n    const refLeftHip = refLandmarks[23];\n    const refRightHip = refLandmarks[24];\n    \n    if (!leftHip || !rightHip || !refLeftHip || !refRightHip) {\n      return { accuracy: 0, error: 'Missing hip landmarks' };\n    }\n    \n    const currentAngle = Math.atan2(\n      rightHip[1] - leftHip[1],\n      rightHip[0] - leftHip[0]\n    );\n    \n    const refAngle = Math.atan2(\n      refRightHip[1] - refLeftHip[1],\n      refRightHip[0] - refLeftHip[0]\n    );\n    \n    const angleDiff = Math.abs(currentAngle - refAngle);\n    const accuracy = Math.max(0, 100 - (angleDiff * 100));\n    \n    return { accuracy, angleDifference: angleDiff };\n  }\n  \n  // Additional helper functions...\n  function calculateJointAngles(landmarks) {\n    // Calculate angles for key joints\n    return {\n      leftElbow: calculateAngle(landmarks[11], landmarks[13], landmarks[15]),\n      rightElbow: calculateAngle(landmarks[12], landmarks[14], landmarks[16]),\n      leftKnee: calculateAngle(landmarks[23], landmarks[25], landmarks[27]),\n      rightKnee: calculateAngle(landmarks[24], landmarks[26], landmarks[28])\n    };\n  }\n  \n  function calculateAngle(p1, p2, p3) {\n    if (!p1 || !p2 || !p3) return null;\n    \n    const v1 = [p1[0] - p2[0], p1[1] - p2[1]];\n    const v2 = [p3[0] - p2[0], p3[1] - p2[1]];\n    \n    const dot = v1[0] * v2[0] + v1[1] * v2[1];\n    const mag1 = Math.sqrt(v1[0] * v1[0] + v1[1] * v1[1]);\n    const mag2 = Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1]);\n    \n    if (mag1 === 0 || mag2 === 0) return null;\n    \n    const cos = dot / (mag1 * mag2);\n    return Math.acos(Math.max(-1, Math.min(1, cos)));\n  }\n  \n  function compareAngles(current, reference) {\n    const differences = {};\n    \n    Object.keys(current).forEach(joint => {\n      if (current[joint] && reference[joint]) {\n        differences[joint] = Math.abs(current[joint] - reference[joint]);\n      }\n    });\n    \n    return differences;\n  }\n  \n  function generateBasicRecommendations(similarity, bodyParts) {\n    const recommendations = [];\n    \n    if (similarity < 70) {\n      recommendations.push({\n        priority: 'high',\n        message: 'Focus on matching the overall pose shape more closely'\n      });\n    }\n    \n    if (bodyParts.arms.overall < 60) {\n      recommendations.push({\n        priority: 'high',\n        message: 'Adjust your arm positioning to better match the reference'\n      });\n    }\n    \n    if (bodyParts.legs.overall < 60) {\n      recommendations.push({\n        priority: 'high',\n        message: 'Work on your leg stance and positioning'\n      });\n    }\n    \n    return recommendations;\n  }\n  \n  function generateDetailedRecommendations(analysis) {\n    // Generate more detailed recommendations based on comprehensive analysis\n    const recommendations = [...generateBasicRecommendations(analysis.overallSimilarity, analysis.bodyParts)];\n    \n    // Add angle-based recommendations\n    Object.entries(analysis.angleDifferences || {}).forEach(([joint, diff]) => {\n      if (diff > 0.3) { // Significant angle difference\n        recommendations.push({\n          priority: 'medium',\n          message: `Adjust your ${joint} angle - try to bend ${diff > 0.5 ? 'less' : 'more'}`\n        });\n      }\n    });\n    \n    return recommendations;\n  }\n  \n  function generateArmCorrections(analysis) {\n    const corrections = [];\n    \n    if (analysis.bodyParts.arms.left.accuracy < 70) {\n      corrections.push({\n        bodyPart: 'leftArm',\n        instruction: 'Raise your left arm higher and adjust the angle',\n        priority: 'high'\n      });\n    }\n    \n    if (analysis.bodyParts.arms.right.accuracy < 70) {\n      corrections.push({\n        bodyPart: 'rightArm',\n        instruction: 'Adjust your right arm position to match the reference',\n        priority: 'high'\n      });\n    }\n    \n    return corrections;\n  }\n  \n  function generateLegCorrections(analysis) {\n    const corrections = [];\n    \n    if (analysis.bodyParts.legs.left.accuracy < 70) {\n      corrections.push({\n        bodyPart: 'leftLeg',\n        instruction: 'Adjust your left leg stance and positioning',\n        priority: 'high'\n      });\n    }\n    \n    if (analysis.bodyParts.legs.right.accuracy < 70) {\n      corrections.push({\n        bodyPart: 'rightLeg',\n        instruction: 'Modify your right leg position to better match',\n        priority: 'high'\n      });\n    }\n    \n    return corrections;\n  }\n  \n  function generateTorsoCorrections(analysis) {\n    const corrections = [];\n    \n    if (analysis.bodyParts.torso.shoulders.accuracy < 70) {\n      corrections.push({\n        bodyPart: 'shoulders',\n        instruction: 'Adjust your shoulder alignment and posture',\n        priority: 'medium'\n      });\n    }\n    \n    if (analysis.bodyParts.torso.hips.accuracy < 70) {\n      corrections.push({\n        bodyPart: 'hips',\n        instruction: 'Work on your hip positioning and alignment',\n        priority: 'medium'\n      });\n    }\n    \n    return corrections;\n  }\n  \n  function generateBalanceCorrections(analysis) {\n    return [\n      {\n        bodyPart: 'balance',\n        instruction: 'Focus on your center of gravity and weight distribution',\n        priority: 'medium'\n      }\n    ];\n  }\n  \n  function generateAllCorrections(analysis) {\n    return [\n      ...generateArmCorrections(analysis),\n      ...generateLegCorrections(analysis),\n      ...generateTorsoCorrections(analysis),\n      ...generateBalanceCorrections(analysis)\n    ];\n  }\n  \n  // Movement scoring functions\n  function calculateAccuracyScore(poseHistory) {\n    if (poseHistory.length === 0) return 0;\n    \n    const scores = poseHistory.map(pose => pose.similarity || 0);\n    return scores.reduce((sum, score) => sum + score, 0) / scores.length;\n  }\n  \n  function calculateFluidityScore(poseHistory) {\n    if (poseHistory.length < 2) return 0;\n    \n    let fluidityScore = 0;\n    for (let i = 1; i < poseHistory.length; i++) {\n      const current = poseHistory[i];\n      const previous = poseHistory[i - 1];\n      \n      if (current.pose && previous.pose) {\n        const smoothness = calculateMovementSmoothness(current.pose, previous.pose);\n        fluidityScore += smoothness;\n      }\n    }\n    \n    return fluidityScore / (poseHistory.length - 1);\n  }\n  \n  function calculateTimingScore(poseHistory) {\n    // Mock implementation - would need reference timing data\n    return 75; // Placeholder score\n  }\n  \n  function calculateMovementSmoothness(currentPose, previousPose) {\n    // Calculate how smooth the transition is between poses\n    const currentLandmarks = currentPose.kp || [];\n    const previousLandmarks = previousPose.kp || [];\n    \n    if (currentLandmarks.length === 0 || previousLandmarks.length === 0) {\n      return 0;\n    }\n    \n    let totalMovement = 0;\n    let validPoints = 0;\n    \n    for (let i = 0; i < Math.min(currentLandmarks.length, previousLandmarks.length); i++) {\n      if (currentLandmarks[i][3] > 0.5 && previousLandmarks[i][3] > 0.5) {\n        const movement = calculateDistance(currentLandmarks[i], previousLandmarks[i]);\n        totalMovement += movement;\n        validPoints++;\n      }\n    }\n    \n    if (validPoints === 0) return 0;\n    \n    const avgMovement = totalMovement / validPoints;\n    // Score based on reasonable movement range (not too jerky, not too static)\n    const idealMovement = 0.02; // Adjust based on frame rate and expected movement\n    const smoothness = Math.max(0, 100 - Math.abs(avgMovement - idealMovement) * 1000);\n    \n    return smoothness;\n  }\n  \n  // Symmetry analysis functions\n  function analyzeBilateralSymmetry(landmarks) {\n    const symmetryPairs = [\n      [11, 12], // shoulders\n      [13, 14], // elbows\n      [15, 16], // wrists\n      [23, 24], // hips\n      [25, 26], // knees\n      [27, 28]  // ankles\n    ];\n    \n    let totalSymmetry = 0;\n    let validPairs = 0;\n    const pairAnalysis = {};\n    \n    symmetryPairs.forEach(([leftIndex, rightIndex], pairIndex) => {\n      const leftPoint = landmarks[leftIndex];\n      const rightPoint = landmarks[rightIndex];\n      \n      if (leftPoint && rightPoint && leftPoint[3] > 0.5 && rightPoint[3] > 0.5) {\n        // Calculate symmetry based on y-coordinate difference (assuming horizontal symmetry)\n        const heightDiff = Math.abs(leftPoint[1] - rightPoint[1]);\n        const symmetryScore = Math.max(0, 100 - (heightDiff * 1000));\n        \n        const pairNames = ['shoulders', 'elbows', 'wrists', 'hips', 'knees', 'ankles'];\n        pairAnalysis[pairNames[pairIndex]] = {\n          score: symmetryScore,\n          difference: heightDiff,\n          status: symmetryScore > 80 ? 'excellent' : symmetryScore > 60 ? 'good' : 'needsWork'\n        };\n        \n        totalSymmetry += symmetryScore;\n        validPairs++;\n      }\n    });\n    \n    return {\n      overallSymmetry: validPairs > 0 ? totalSymmetry / validPairs : 0,\n      pairAnalysis,\n      validPairs\n    };\n  }\n  \n  function analyzeBalance(landmarks) {\n    // Analyze balance based on center of mass and base of support\n    const leftAnkle = landmarks[27];\n    const rightAnkle = landmarks[28];\n    const nose = landmarks[0];\n    \n    if (!leftAnkle || !rightAnkle || !nose) {\n      return { error: 'Insufficient landmarks for balance analysis' };\n    }\n    \n    // Calculate center of mass approximation (using nose as proxy)\n    const centerX = nose[0];\n    \n    // Calculate base of support (between ankles)\n    const baseLeft = leftAnkle[0];\n    const baseRight = rightAnkle[0];\n    const baseCenter = (baseLeft + baseRight) / 2;\n    \n    // Calculate balance score based on how centered the mass is over the base\n    const balanceOffset = Math.abs(centerX - baseCenter);\n    const balanceScore = Math.max(0, 100 - (balanceOffset * 1000));\n    \n    return {\n      balanceScore,\n      balanceOffset,\n      centerOfMass: centerX,\n      baseOfSupport: { left: baseLeft, right: baseRight, center: baseCenter },\n      status: balanceScore > 80 ? 'stable' : balanceScore > 60 ? 'moderate' : 'unstable'\n    };\n  }\n  \n  function analyzeAlignment(landmarks) {\n    // Analyze overall body alignment (spine, etc.)\n    const nose = landmarks[0];\n    const leftShoulder = landmarks[11];\n    const rightShoulder = landmarks[12];\n    const leftHip = landmarks[23];\n    const rightHip = landmarks[24];\n    \n    if (!nose || !leftShoulder || !rightShoulder || !leftHip || !rightHip) {\n      return { error: 'Insufficient landmarks for alignment analysis' };\n    }\n    \n    // Calculate vertical alignment\n    const shoulderCenter = [(leftShoulder[0] + rightShoulder[0]) / 2, (leftShoulder[1] + rightShoulder[1]) / 2];\n    const hipCenter = [(leftHip[0] + rightHip[0]) / 2, (leftHip[1] + rightHip[1]) / 2];\n    \n    const verticalAlignment = Math.abs(nose[0] - shoulderCenter[0]) + Math.abs(shoulderCenter[0] - hipCenter[0]);\n    const alignmentScore = Math.max(0, 100 - (verticalAlignment * 2000));\n    \n    return {\n      alignmentScore,\n      verticalDeviation: verticalAlignment,\n      keyPoints: {\n        head: nose,\n        shoulderCenter,\n        hipCenter\n      },\n      status: alignmentScore > 80 ? 'excellent' : alignmentScore > 60 ? 'good' : 'poor'\n    };\n  }\n  \n  function calculateConfidence(landmarks) {\n    // Calculate confidence based on landmark visibility scores\n    const visibilityScores = landmarks.map(landmark => landmark[3] || 0);\n    const avgVisibility = visibilityScores.reduce((sum, score) => sum + score, 0) / visibilityScores.length;\n    return Math.round(avgVisibility * 100);\n  }\n  \n  // Component render\n  return (\n    <div className=\"cedar-pose-tools\">\n      <h3>üîß CedarOS Pose Analysis Tools</h3>\n      \n      <div className=\"tool-buttons\">\n        <button \n          onClick={() => analyzePoseDetails({ \n            pose: currentPose, \n            reference: referencePose, \n            analysisType: 'detailed' \n          })}\n          className=\"tool-button\"\n        >\n          üìä Detailed Analysis\n        </button>\n        \n        <button \n          onClick={() => generateFormCorrections({ \n            pose: currentPose, \n            reference: referencePose, \n            focusArea: 'all' \n          })}\n          className=\"tool-button\"\n        >\n          üéØ Form Corrections\n        </button>\n        \n        <button \n          onClick={() => scoreMovement({ \n            poseHistory: poseState.poseHistory, \n            scoreType: 'overall' \n          })}\n          className=\"tool-button\"\n        >\n          üìà Score Movement\n        </button>\n        \n        <button \n          onClick={() => analyzeSymmetry({ \n            pose: currentPose, \n            symmetryType: 'bilateral' \n          })}\n          className=\"tool-button\"\n        >\n          ‚öñÔ∏è Symmetry Check\n        </button>\n      </div>\n      \n      {analysisResults && (\n        <div className=\"analysis-results\">\n          <h4>Analysis Results</h4>\n          <pre>{JSON.stringify(analysisResults, null, 2)}</pre>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default CedarPoseTools;