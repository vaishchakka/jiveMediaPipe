'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('react/jsx-runtime');
var react = require('motion/react');
var React = require('react');
var reactDom = require('react-dom');
var motionUtils = require('motion-utils');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);

const DEFAULT_SIZE = 17;
const POINTER_SIZE = 31;
const TEXT_WIDTH = 4;
const TEXT_HEIGHT = 20;
function withDefaultSize(width, height, style) {
    return {
        width: style?.width ?? width,
        height: style?.height ?? height,
    };
}
function getCursorSize({ type, state, hasChildren, style, isMagnetic, magneticOptions, matchTextSize, }) {
    const shouldMatchTargetSize = isMagnetic && state.targetBoundingBox;
    if (hasChildren && !shouldMatchTargetSize) {
        return withDefaultSize("auto", "auto", style);
    }
    switch (type) {
        case "pointer":
            const { padding, morph } = magneticOptions;
            if (isMagnetic && morph && state.targetBoundingBox) {
                const { width, height } = state.targetBoundingBox;
                return {
                    width: width + padding * 2,
                    height: height + padding * 2,
                };
            }
            return withDefaultSize(POINTER_SIZE, POINTER_SIZE, style);
        case "text":
            if (matchTextSize && state.fontSize) {
                return { width: TEXT_WIDTH, height: state.fontSize };
            }
            return withDefaultSize(TEXT_WIDTH, TEXT_HEIGHT, style);
        default:
            return withDefaultSize(DEFAULT_SIZE, DEFAULT_SIZE, style);
    }
}

function useBodyPortal(children) {
    const [hostElement, setHostElement] = React.useState(null);
    React.useLayoutEffect(() => {
        setHostElement(document.body);
    }, []);
    return hostElement ? reactDom.createPortal(children, hostElement) : null;
}

let listener$1 = null;
function startInViewListener() {
    const listeners = new Set();
    function showCursor() {
        listeners.forEach((listener) => listener.show());
    }
    function hideCursor() {
        listeners.forEach((listener) => listener.hide());
    }
    function addEventListeners() {
        document.body.addEventListener("mouseenter", showCursor);
        document.body.addEventListener("mouseleave", hideCursor);
    }
    function removeEventListeners() {
        document.body.removeEventListener("mouseenter", showCursor);
        document.body.removeEventListener("mouseleave", hideCursor);
    }
    return {
        on: (callbacks) => {
            if (!listeners.size) {
                addEventListeners();
            }
            listeners.add(callbacks);
            return () => {
                listeners.delete(callbacks);
                if (listeners.size === 0) {
                    removeEventListeners();
                }
            };
        },
    };
}
function getInViewListener() {
    if (!listener$1) {
        listener$1 = startInViewListener();
    }
    return listener$1;
}
function useCursorIsInView(resetSpring) {
    const [isVisible, setIsVisible] = React.useState(true);
    React.useEffect(() => {
        return getInViewListener().on({
            show: () => {
                if (isVisible)
                    return;
                resetSpring();
                setIsVisible(true);
            },
            hide: () => setIsVisible(false),
        });
    }, [isVisible]);
    return isVisible;
}

function onlyMouse(callback) {
    return (event) => {
        if (event.pointerType === "mouse") {
            callback(event);
        }
    };
}
function onlyLeftClicks(callback) {
    return onlyMouse((event) => {
        if (event.button === 0) {
            callback(event);
        }
    });
}

function findCustomTarget(target) {
    return target.closest("[data-cursor]");
}
function findPointerTarget(element) {
    return element.closest('a, button, input[type="button"]:not(:disabled)');
}
function findTextTarget(element) {
    if (window.getComputedStyle(element).userSelect === "none")
        return null;
    return element.closest("p, textarea:not(:disabled), input[type='text']:not(:disabled), h1, h2, h3, h4, h5, h6");
}
function findTarget(eventTarget) {
    let target = findCustomTarget(eventTarget);
    if (target)
        return [target.dataset.cursor, target];
    target = findPointerTarget(eventTarget);
    if (target)
        return ["pointer", target];
    target = findTextTarget(eventTarget);
    if (target)
        return ["text", target];
    return ["default", null];
}

let listener = null;
let state = {
    type: "default",
    isPressed: false,
    fontSize: null,
    targetBoundingBox: null,
    target: null,
    zone: null,
};
function getZone(target) {
    let zone = null;
    if ("closest" in target) {
        const zoneElement = target.closest("[data-cursor-zone]");
        if (zoneElement instanceof HTMLElement) {
            zone = zoneElement.dataset.cursorZone || null;
        }
    }
    return zone;
}
function startPointerOverListener() {
    const listeners = new Set();
    function updateState(newState) {
        state = { ...state, ...newState };
        listeners.forEach((listener) => listener(state));
    }
    const handlePointerDown = onlyLeftClicks(() => {
        if (!state.isPressed) {
            updateState({ isPressed: true });
        }
    });
    const handlePointerUp = onlyLeftClicks(() => {
        if (state.isPressed) {
            updateState({ isPressed: false });
        }
    });
    const handlePointerOver = onlyMouse(({ target }) => {
        if (!target)
            return;
        const [type, cursorTarget] = findTarget(target);
        let hasUpdated = false;
        let newState = {
            target: cursorTarget,
            zone: getZone(target),
        };
        if (type !== state.type) {
            newState.type = type;
            hasUpdated = true;
        }
        if (newState.zone !== state.zone) {
            newState.zone = newState.zone;
            hasUpdated = true;
        }
        const size = type === "pointer" && cursorTarget
            ? cursorTarget.getBoundingClientRect()
            : null;
        if (size !== state.targetBoundingBox) {
            newState.targetBoundingBox = size;
            hasUpdated = true;
        }
        if (type === "text") {
            const { fontSize: computedFontSize } = window.getComputedStyle(target);
            const newFontSize = computedFontSize
                ? parseInt(computedFontSize)
                : null;
            if (newFontSize !== state.fontSize) {
                newState.fontSize = newFontSize;
                hasUpdated = true;
            }
        }
        else {
            if (state.fontSize) {
                newState.fontSize = null;
                hasUpdated = true;
            }
        }
        if (hasUpdated) {
            updateState(newState);
        }
    });
    function addEventListeners() {
        window.addEventListener("pointerover", handlePointerOver);
        window.addEventListener("pointerdown", handlePointerDown);
        window.addEventListener("pointerup", handlePointerUp);
    }
    function removeEventListeners() {
        window.removeEventListener("pointerover", handlePointerOver);
        window.removeEventListener("pointerdown", handlePointerDown);
        window.removeEventListener("pointerup", handlePointerUp);
    }
    return {
        onChange: (callback) => {
            if (!listeners.size) {
                addEventListeners();
            }
            listeners.add(callback);
            return () => {
                listeners.delete(callback);
                if (!listeners.size) {
                    removeEventListeners();
                }
            };
        },
    };
}
function getPointerOverListener() {
    if (!listener) {
        listener = startPointerOverListener();
    }
    return listener;
}
function useCursorState() {
    const [latestState, setLatestState] = React.useState({ ...state });
    React.useEffect(() => {
        return getPointerOverListener().onChange((newState) => {
            setLatestState(newState);
        });
    }, [latestState]);
    return latestState;
}

function useHasPointerMoved({ x, y, }, resetSpring) {
    const [pointerHasMoved, setPointerHasMoved] = React.useState(x.prev !== undefined || y.prev !== undefined);
    React.useInsertionEffect(() => {
        if (pointerHasMoved)
            return;
        const setHasMoved = () => {
            setPointerHasMoved(true);
            resetSpring();
            stop();
        };
        const stop = react.pipe(x.on("change", setHasMoved), y.on("change", setHasMoved));
        return () => stop();
    }, [x, y, pointerHasMoved]);
    return pointerHasMoved;
}

function useOffset$1(position, offset) {
    return {
        x: react.useTransform(() => position.x.get() + offset.x),
        y: react.useTransform(() => position.y.get() + offset.y),
    };
}

let x;
let y;
function initPointerTracking() {
    x = react.motionValue(0);
    y = react.motionValue(0);
    // Cached pointer
    let pointerX = 0;
    let pointerY = 0;
    function updatePointer() {
        x.set(pointerX);
        y.set(pointerY);
    }
    if (typeof window !== "undefined") {
        window.addEventListener("pointermove", onlyMouse((event) => {
            pointerX = event.clientX;
            pointerY = event.clientY;
            /**
             * Don't update pointer until the next render frame to
             * avoid
             *
             * TODO: Update motion values to cache rendered value
             * and use that in projection measurements
             * instead of using this approach
             */
            react.frame.update(updatePointer);
        }));
    }
}
function usePointerPosition() {
    if (!x)
        initPointerTracking();
    return { x: x, y: y };
}

function useMixed(a, b, p) {
    return react.useTransform(() => react.mix(a.get(), b.get(), p.get()));
}

function useSnappedValue(pointer, snap, target) {
    const snapped = react.useSpring(0, {
        stiffness: 600,
        damping: 50,
    });
    const crossfade = react.useMotionValue(0);
    const mixed = useMixed(pointer, snapped, crossfade);
    const prevTarget = React.useRef(target);
    react.useIsomorphicLayoutEffect(() => {
        if (target) {
            if (!prevTarget.current && !crossfade.isAnimating()) {
                snapped.jump(target);
            }
            else {
                snapped.set(target);
            }
            react.animate(crossfade, snap);
        }
        else {
            react.animate(crossfade, 0);
        }
        prevTarget.current = target;
    }, [target]);
    return mixed;
}

function useMagneticTarget(pointer, isEnabled, state, snap) {
    const x = useSnappedValue(pointer.x, snap, state.targetBoundingBox
        ? state.targetBoundingBox.left + state.targetBoundingBox.width / 2
        : undefined);
    const y = useSnappedValue(pointer.y, snap, state.targetBoundingBox
        ? state.targetBoundingBox.top + state.targetBoundingBox.height / 2
        : undefined);
    return isEnabled ? { x, y } : pointer;
}

function makeStyles() {
    const style = document.createElement("style");
    style.textContent = `
      * {
          cursor: none !important;
      }
          
      [data-motion-cursor="pointer"] {
          background-color: #333;
      }
    `;
    document.head.appendChild(style);
    return () => {
        document.head.removeChild(style);
    };
}
function useCursorStyles(isCursor) {
    React.useInsertionEffect(isCursor ? makeStyles : motionUtils.noop, [
        isCursor,
    ]);
}

const topLeftPoint = { x: 0, y: 0 };
const centerPoint = { x: 0.5, y: 0.5 };
const skipTransition = { duration: 0 };
const defaults = {
    followSpring: { stiffness: 1000, damping: 100 },
    magneticOptions: { morph: true, padding: 5, snap: 0.8 },
};
function Cursor({ follow = false, center = follow ? topLeftPoint : centerPoint, offset: offsetPoint = topLeftPoint, spring = follow ? defaults.followSpring : false, magnetic = false, matchTextSize = true, children, style, ...props }) {
    const shouldReduceMotion = react.useReducedMotion();
    useCursorStyles(!shouldReduceMotion && !follow);
    const position = usePointerPosition();
    const offset = useOffset$1(position, offsetPoint);
    const springX = react.useSpring(offset.x, spring || undefined);
    const springY = react.useSpring(offset.y, spring || undefined);
    const magneticOptions = typeof magnetic === "object"
        ? { ...defaults.magneticOptions, ...magnetic }
        : defaults.magneticOptions;
    const resetSpring = () => {
        const removeX = offset.x.on("change", (v) => {
            springX.jump(v);
            removeX();
        });
        const removeY = offset.y.on("change", (v) => {
            springY.jump(v);
            removeY();
        });
    };
    const state = useCursorState();
    const isInView = useCursorIsInView(resetSpring);
    const { x, y } = useMagneticTarget(spring ? { x: springX, y: springY } : position, Boolean(magnetic), state, magneticOptions.snap);
    const { width, height } = getCursorSize({
        type: state.type,
        state,
        hasChildren: Boolean(children),
        style,
        isMagnetic: Boolean(magnetic),
        magneticOptions,
        matchTextSize,
    });
    // TODO: Set center to 0.5 if state.targetBoundingBox && magnetic
    const pointerHasMoved = useHasPointerMoved(position, resetSpring);
    return useBodyPortal(pointerHasMoved ? (jsxRuntime.jsx(react.LayoutGroup, { children: jsxRuntime.jsx(react.MotionConfig, { transition: shouldReduceMotion
                ? skipTransition
                : props.transition || defaultTransition, children: jsxRuntime.jsx(react.motion.div, { layout: true, "data-motion-cursor": follow ? "follow" : "pointer", "data-framer-portal-id": "motion-cursor", initial: "exit", exit: "exit", ...props, variants: {
                    pressed: follow ? {} : { scale: 0.9 },
                    ...props.variants,
                    default: {
                        opacity: 1,
                        scale: 1,
                        ...props.variants?.default,
                    },
                    exit: {
                        opacity: 0,
                        scale: 0,
                        ...props.variants?.exit,
                    },
                }, animate: [
                    "default",
                    state.type,
                    magnetic && state.targetBoundingBox
                        ? "magnetic"
                        : "",
                    !isInView
                        ? "exit"
                        : state.isPressed
                            ? "pressed"
                            : "",
                ], transformTemplate: positionTransform(center), style: {
                    borderRadius: follow ? 0 : 20,
                    zIndex: follow ? 99998 : 99999,
                    willChange: "transform",
                    contain: "layout",
                    originX: center.x,
                    originY: center.y,
                    ...style,
                    width,
                    height,
                    x,
                    y,
                    top: 0,
                    left: 0,
                    position: "fixed",
                    pointerEvents: "none",
                }, children: jsxRuntime.jsx(react.AnimatePresence, { children: children }) }) }) })) : null);
}
function positionTransform(origin) {
    return (_, generated) => `translate(-${origin.x * 100}%, -${origin.y * 100}%) ${generated}`;
}
const defaultTransition = { duration: 0.15, ease: [0.38, 0.12, 0.29, 1] };

function useOffset(pointer, pull, target) {
    const rest = react.useMotionValue(0);
    const offset = react.useMotionValue(0);
    const crossfade = react.useMotionValue(0);
    React.useEffect(() => {
        if (typeof target === "number") {
            react.animate(crossfade, 1);
            const updateOffset = () => {
                offset.set(pull * (pointer.get() - target));
            };
            updateOffset();
            return pointer.on("change", updateOffset);
        }
        else {
            react.animate(crossfade, 0);
        }
    }, [target]);
    return react.useTransform(() => react.mix(rest.get(), offset.get(), crossfade.get()));
}
function useMagneticPull(ref, pull = 0.1) {
    const state = useCursorState();
    const pointer = usePointerPosition();
    const isActive = React.useMemo(() => {
        return state.targetBoundingBox && state.target === ref.current;
    }, [state.targetBoundingBox, state.target, ref.current]);
    const x = useOffset(pointer.x, pull, isActive
        ? state.targetBoundingBox.left + state.targetBoundingBox.width / 2
        : undefined);
    const y = useOffset(pointer.y, pull, isActive
        ? state.targetBoundingBox.top + state.targetBoundingBox.height / 2
        : undefined);
    return { x, y };
}

// Build the mask for the numbers. Technique taken from:
// https://expensive.toys/blog/blur-vignette
const maskHeight = "var(--mask-height, 0.15em)";
const maskWidth = "var(--mask-width, 0.5em)";
const correctedMaskWidth = `calc(${maskWidth} / var(--invert-x, 1))`;
const cornerGradient = `#000 0, transparent 71%`; // or transparent ${maskWidth}
const mask = 
// Horizontal:
`linear-gradient(to right, transparent 0, #000 ${correctedMaskWidth}, #000 calc(100% - ${correctedMaskWidth}), transparent),` +
    // Vertical:
    `linear-gradient(to bottom, transparent 0, #000 ${maskHeight}, #000 calc(100% - ${maskHeight}), transparent 100%),` +
    // TL corner
    `radial-gradient(at bottom right, ${cornerGradient}),` +
    // TR corner
    `radial-gradient(at bottom left, ${cornerGradient}), ` +
    // BR corner
    `radial-gradient(at top left, ${cornerGradient}), ` +
    // BL corner
    `radial-gradient(at top right, ${cornerGradient})`;
const maskSize = `100% calc(100% - ${maskHeight} * 2),` +
    `calc(100% - ${correctedMaskWidth} * 2) 100%,` +
    `${correctedMaskWidth} ${maskHeight},` +
    `${correctedMaskWidth} ${maskHeight},` +
    `${correctedMaskWidth} ${maskHeight},` +
    `${correctedMaskWidth} ${maskHeight}`;
react.addScaleCorrector({
    "--invert-x": {
        correct: (_, { treeScale, projectionDelta }) => projectionDelta.x.scale * treeScale.x,
    },
});
function Mask({ children, layoutDependency, }) {
    return (jsxRuntime.jsx(react.motion.span, { layout: true, layoutDependency: layoutDependency, "aria-hidden": true, style: {
            display: "inline-flex",
            // Activates the scale correction, which gets stored in --invert-xion
            "--invert-x": 1,
            margin: `0 calc(-1*${maskWidth})`,
            padding: `calc(${maskHeight}/2) ${maskWidth}`,
            position: "relative", // for zIndex
            zIndex: -1, // should be underneath everything else
            overflow: "clip", // important so it doesn't affect page layout
            // Prefixed properties have better support than unprefixed ones:
            WebkitMaskImage: mask,
            WebkitMaskSize: maskSize,
            WebkitMaskPosition: "center, center, top left, top right, bottom right, bottom left",
            WebkitMaskRepeat: "no-repeat",
        }, children: children }));
}

function useIsInitialRender() {
    /**
     * If `initial={false}` we only want to pass this to components in the first render.
     */
    const isInitialRender = React.useRef(true);
    React.useEffect(() => {
        isInitialRender.current = false;
    }, []);
    return isInitialRender.current;
}

function getWidthInEm(element) {
    const { width, fontSize } = getComputedStyle(element);
    return `${parseFloat(width) / parseFloat(fontSize)}em`;
}

const targetWidths = new WeakMap();

const NumberDigit = React.forwardRef(function NumberDigit({ value: _value, initialValue: _initialValue = _value, ...rest }, _ref) {
    const { transition } = React.useContext(react.MotionConfigContext);
    const initialValue = React.useRef(_initialValue).current; // non-reactive, like React's defaultValue props
    const isInitialRender = useIsInitialRender();
    const scope = React.useRef(null);
    const ref = React.useRef(null);
    React.useImperativeHandle(_ref, () => ref.current, []);
    const numberRefs = React.useRef(new Array(10));
    // Don't use a normal exit animation for this because we want it to trigger a resize:
    const isPresent = react.useIsPresent();
    const value = isPresent ? _value : 0;
    // Set the width to the width of the initial value immediately, so on the next render we animate from that:
    React.useLayoutEffect(() => {
        if (!scope.current || !numberRefs.current[initialValue])
            return;
        scope.current.style.width = getWidthInEm(numberRefs.current[initialValue]);
    }, []);
    // Animate the y in a layout effect, because it's a FLIP
    const prevValue = React.useRef(_initialValue);
    React.useLayoutEffect(() => {
        if (!scope.current || value === prevValue.current)
            return;
        const box = scope.current.getBoundingClientRect();
        const refBox = ref.current?.getBoundingClientRect();
        // Using a number seems to ensure Motion ends with "none", which we want:
        // Add the offset between the top of the inner and outer elements to account for
        // any current animation state:
        const initialY = box.height * (value - prevValue.current) +
            (box.top - (refBox ? refBox.top || 0 : box.top));
        react.animate(scope.current, { y: [initialY, 0] }, transition);
        return () => {
            prevValue.current = value;
        };
    }, [value]);
    const [width, setWidth] = React.useState();
    React.useEffect(() => {
        // Skip setting the width if this is the first render and it's not going to animate:
        if (isInitialRender && initialValue === value)
            return;
        if (!numberRefs.current[value])
            return;
        const w = getWidthInEm(numberRefs.current[value]);
        // Store the target width immediately, so it can be used for the section resize:
        if (ref.current)
            targetWidths.set(ref.current, w);
        // Trigger the actual layout animation by causing another render:
        setWidth(w);
    }, [value]);
    const renderNumber = (i) => (jsxRuntime.jsx("span", { style: {
            display: "inline-block",
            padding: `calc(${maskHeight}/2) 0`,
        }, ref: (r) => void (numberRefs.current[i] = r), children: i }, i));
    return (jsxRuntime.jsx(react.motion.span, { ...rest, ref: ref, layout: "position", "data-state": isPresent ? undefined : "exiting", style: {
            display: "inline-flex",
            justifyContent: "center",
            width,
        }, children: jsxRuntime.jsxs("span", { ref: scope, style: {
                display: "inline-flex",
                justifyContent: "center",
                flexDirection: "column",
                alignItems: "center",
                position: "relative",
            }, children: [value !== 0 && (jsxRuntime.jsx("span", { style: {
                        ...digitFillStyle,
                        bottom: `100%`,
                        left: 0,
                    }, children: new Array(value)
                        .fill(null)
                        .map((_, i) => renderNumber(i)) })), renderNumber(value), value !== 9 && (jsxRuntime.jsx("span", { style: {
                        ...digitFillStyle,
                        top: `100%`,
                        left: 0,
                    }, children: new Array(9 - value)
                        .fill(null)
                        .map((_, i) => renderNumber(value + i + 1)) }))] }) }));
});
const digitFillStyle = {
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
    position: "absolute",
    width: "100%",
};

const SectionContext = React.createContext({
    justify: "left",
});

const NumberSymbol = React.forwardRef(function NumberSymbol({ partKey, type, children, layoutDependency, ...rest }, ref) {
    const isPresent = react.useIsPresent();
    const { justify } = React.useContext(SectionContext);
    return (jsxRuntime.jsx(react.motion.span, { ...rest, "data-state": isPresent ? undefined : "exiting", style: {
            display: "inline-flex",
            justifyContent: justify,
            padding: `calc(${maskHeight}/2) 0`, // match digits
            position: "relative", // needed for AnimatePresent popLayout
        }, layout: "position", layoutDependency: layoutDependency, ref: ref, children: jsxRuntime.jsx(react.AnimatePresence, { mode: "popLayout", anchorX: justify, initial: false, children: jsxRuntime.jsx(react.motion.span, { layout: justify === "right" ? "position" : false, layoutDependency: layoutDependency, initial: { opacity: 0 }, animate: { opacity: [null, 1] }, exit: { opacity: [null, 0] }, style: {
                    display: "inline-block",
                    whiteSpace: "pre", // some symbols are spaces or thin spaces
                }, children: children }, children) }) }));
});

const NumberSection = React.forwardRef(function NumberSection({ parts, justify = "left", mode, style, name, layoutDependency, ...rest }, _ref) {
    const ref = React.useRef(null);
    React.useImperativeHandle(_ref, () => ref.current, []);
    const context = React.useMemo(() => ({ justify }), [justify]);
    const measuredRef = React.useRef(null);
    const isInitialRender = useIsInitialRender();
    // Keep a fixed width for the section, so that new characters get added to the end before the layout
    // animation starts, which makes them look like they were there already:
    const [width, setWidth] = React.useState();
    React.useEffect(() => {
        if (!measuredRef.current)
            return;
        if (isInitialRender) {
            if (ref.current)
                ref.current.style.width = getWidthInEm(measuredRef.current);
            return;
        }
        // Find the new width by removing exiting elements, measuring the measuredRef, and re-adding them
        // This better handles i.e. negative margins between elements.
        // We query the DOM because AnimatePresence overwrites ref props if the mode=popLayout
        const undos = Array.from(measuredRef.current.children).map((child) => {
            if (!(child instanceof HTMLElement))
                return;
            if (child.dataset.state === "exiting") {
                const next = child.nextSibling;
                child.remove();
                return () => {
                    // insertBefore() appends if next is null:
                    if (measuredRef.current) {
                        measuredRef.current.insertBefore(child, next);
                    }
                };
            }
            const newWidth = targetWidths.get(child);
            if (!newWidth)
                return;
            const oldWidth = child.style.width;
            child.style.width = newWidth;
            return () => {
                child.style.width = oldWidth;
            };
        });
        // Measure the resulting width:
        setWidth(getWidthInEm(measuredRef.current));
        // Then undo immediately:
        for (let i = undos.length - 1; i >= 0; i--) {
            const undo = undos[i];
            if (undo)
                undo();
        }
        // Trigger a parent render/layout:
    }, [parts.map((p) => p.value).join("")]);
    return (jsxRuntime.jsx(SectionContext.Provider, { value: context, children: jsxRuntime.jsx(react.motion.span, { layoutDependency: layoutDependency, ...rest, ref: ref, className: `number-section-${name}`, style: {
                ...style,
                display: "inline-flex",
                justifyContent: justify,
                width,
            }, children: jsxRuntime.jsxs("span", { ref: measuredRef, style: {
                    display: "inline-flex",
                    justifyContent: "inherit",
                    position: "relative", // needed for AnimatePresent popLayout
                }, children: ["\u200B", jsxRuntime.jsx(react.AnimatePresence, { mode: mode, anchorX: justify, initial: false, children: parts.map((part) => part.type === "integer" ||
                            part.type === "fraction" ? (jsxRuntime.jsx(NumberDigit, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, value: part.value, initialValue: isInitialRender ? undefined : 0, layoutDependency: layoutDependency }, part.key)) : (jsxRuntime.jsx(NumberSymbol, { type: part.type, partKey: part.key, initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, layoutDependency: layoutDependency, children: part.value }, part.type === "literal"
                            ? `${part.key}:${part.value}`
                            : part.key))) })] }) }) }));
});

const formatToParts = (value, { locales, format, }, prefix, suffix) => {
    const formatter = new Intl.NumberFormat(locales, format);
    const parts = formatter.formatToParts(Number(value));
    if (prefix)
        parts.unshift({ type: "prefix", value: prefix });
    if (suffix)
        parts.push({ type: "suffix", value: suffix });
    const pre = [];
    const _integer = []; // we do a second pass to key these from RTL
    const fraction = [];
    const post = [];
    const counts = {};
    const generateKey = (type) => `${type}:${(counts[type] = (counts[type] ?? -1) + 1)}`;
    let formatted = "";
    let seenInteger = false, seenDecimal = false;
    for (const part of parts) {
        formatted += part.value;
        // Merge plus and minus sign types (doing it this way appeases TypeScript)
        const type = part.type === "minusSign" || part.type === "plusSign"
            ? "sign"
            : part.type;
        switch (type) {
            case "integer":
                seenInteger = true;
                _integer.push(...part.value
                    .split("")
                    .map((d) => ({ type, value: parseInt(d) })));
                break;
            case "group":
                _integer.push({ type, value: part.value });
                break;
            case "decimal":
                seenDecimal = true;
                fraction.push({
                    type,
                    value: part.value,
                    key: generateKey(type),
                });
                break;
            case "fraction":
                fraction.push(...part.value.split("").map((d) => ({
                    type,
                    value: parseInt(d),
                    key: generateKey(type),
                })));
                break;
            // case 'nan':
            // case 'infinity':
            // 	// TODO: handle these
            // 	break
            // case 'exponentSeparator':
            // 	break
            // case 'exponentMinusSign':
            // case 'exponentInteger':
            // 	break
            default:
                (seenInteger || seenDecimal ? post : pre).push({
                    type,
                    value: part.value,
                    key: generateKey(type),
                });
        }
    }
    const integer = [];
    // Key the integer parts RTL, for better layout animations
    for (let i = _integer.length - 1; i >= 0; i--) {
        integer.unshift({
            ..._integer[i],
            key: generateKey(_integer[i].type),
        });
    }
    return { pre, integer, fraction, post, formatted };
};

const DEFAULT_TRANSITION = {
    // We use keyframes and times so the opacity/exit animations can last
    // as long as the layout animation, so Framer Motion doesn't have to
    // remove exiting elements until the layout animation is done.
    // This worked better in testing than safeToRemove() from usePresence()
    opacity: { duration: 1, ease: react.easeOut }, // perceptual duration of 0.5s
    layout: { type: "spring", duration: 1, bounce: 0 },
    y: { type: "spring", duration: 1, bounce: 0 },
};
const AnimateNumber = React.forwardRef(function AnimateNumber({ children: value, locales, format, transition, style, suffix, prefix, ...rest }, ref) {
    // Split the number into parts
    const parts = React.useMemo(() => formatToParts(value, { locales, format }, prefix, suffix), [value, locales, format]);
    const { pre, integer, fraction, post, formatted } = parts;
    const contextTransition = React.useContext(react.MotionConfigContext).transition;
    transition = transition ?? contextTransition ?? DEFAULT_TRANSITION;
    const { layoutDependency } = rest;
    const dependency = React.useMemo(() => {
        if (layoutDependency === undefined)
            return undefined;
        return { layoutDependency, value };
    }, [layoutDependency, value]);
    return (jsxRuntime.jsx(react.LayoutGroup, { children: jsxRuntime.jsx(react.MotionConfig, { transition: transition, children: jsxRuntime.jsx(react.motion.div, { ...rest, ref: ref, layout // For convenience, b/c it's basically implied
                : true, layoutDependency: dependency, style: {
                    lineHeight: 1, // make this one easy to override
                    ...style,
                    display: "inline-flex",
                    isolation: "isolate", // so number can be underneath first/last
                    whiteSpace: "nowrap",
                }, children: jsxRuntime.jsxs(react.motion.div, { layout: true, layoutDependency: dependency, "aria-label": formatted, style: {
                        display: "inline-flex",
                        direction: "ltr", // I think this is needed b/c numbers are always LTR?
                        isolation: "isolate", // so number can be underneath pre/post
                        position: "relative",
                        zIndex: -1, // so the whole number is under any first/last
                        // userSelect: "none", // I think adding this to the parent then undoing it on the selectable one might work a little better
                        // pointerEvents: "none",
                    }, children: [jsxRuntime.jsx(NumberSection, { style: { padding: `calc(${maskHeight}/2) 0` }, layoutDependency: dependency, "aria-hidden": true, justify: "right", mode: "popLayout", parts: pre, name: "pre" }), jsxRuntime.jsxs(Mask, { layoutDependency: dependency, children: [jsxRuntime.jsx(NumberSection, { layoutDependency: dependency, justify: "right", parts: integer, name: "integer" }), jsxRuntime.jsx(NumberSection, { layout: "position", layoutDependency: dependency, parts: fraction, name: "fraction" })] }), jsxRuntime.jsx(NumberSection, { style: { padding: `calc(${maskHeight}/2) 0` }, "aria-hidden": true, layout: "position", layoutDependency: dependency, mode: "popLayout", parts: post, name: "post" })] }) }) }) }));
});

const MotionFragment = react.motion.create(React__namespace.Fragment);
function splitText(text, { splitBy = " ", charClass = "split-char", wordClass = "split-word", variants, type, } = {}) {
    const words = text.split(splitBy);
    const elements = [];
    const delimiter = splitBy === " " ? "\u00A0" : splitBy;
    for (let wordIndex = 0; wordIndex < words.length; wordIndex++) {
        const word = words[wordIndex];
        const characterElements = [];
        const chars = Array.from(word);
        for (let charIndex = 0; charIndex < chars.length; charIndex++) {
            let char = chars[charIndex];
            if (wordIndex < words.length - 1 &&
                charIndex === chars.length - 1) {
                char += delimiter;
            }
            const Component = type === "char" ? react.motion.span : "span";
            characterElements.push(jsxRuntime.jsx(Component, { className: `${charClass} ${charClass}-${charIndex + 1}`, style: { display: "inline-block" }, ...(type === "char" ? { variants } : {}), children: char }, `${wordIndex}-${charIndex}`));
        }
        const WordComponent = type === "word" ? react.motion.span : "span";
        elements.push(jsxRuntime.jsx(WordComponent, { className: `${wordClass} ${wordClass}-${wordIndex + 1}`, style: { display: "inline-block" }, ...(type === "word" ? { variants } : {}), children: characterElements }, `word-${wordIndex}`));
    }
    return elements;
}
function AnimateText({ children, splitBy = " ", charClass = "split-char", wordClass = "split-word", lineClass = "split-line", type = "char", variants, ...props }) {
    const elements = React.useMemo(() => {
        return splitText(children, {
            splitBy,
            charClass,
            wordClass,
            variants,
            type,
        });
    }, [children, splitBy, charClass, wordClass]);
    return jsxRuntime.jsx(MotionFragment, { ...props, children: elements });
}

const TickerItemContext = React.createContext(undefined);

/**
 * Represents an individual item within the Ticker.
 *
 * This component handles the logic for repositioning items to create the infinite scroll effect.
 *
 * @param offset - The current scroll offset of the ticker.
 * @param axis - The scroll axis ("x" or "y").
 * @param listSize - The total size of the list including all clones.
 * @param itemIndex - The original index of the item.
 * @param cloneIndex - The index of the clone, if this is a cloned item.
 * @param props - HTML attributes to pass to the list item li element.
 * @returns A ListItem React component.
 */
function TickerItem({ offset, axis, listSize = 0, itemIndex, cloneIndex, bounds, containerPaddingStart, ...props }) {
    const ref = React.useRef(null);
    const { start, end } = bounds;
    const transform = react.useTransform(() => {
        const currentOffset = offset.get();
        if ((!start && !end) || !listSize)
            return 0;
        if (currentOffset + end <= -containerPaddingStart) {
            return listSize;
        }
        return 0;
    });
    const itemOffset = react.useTransform(() => {
        const currentOffset = offset.get();
        const currentTransform = transform.get();
        if ((!start && !end) || !listSize)
            return 0;
        return currentOffset + start + currentTransform;
    });
    return (jsxRuntime.jsx(TickerItemContext.Provider, { value: { offset: itemOffset }, children: jsxRuntime.jsx(react.motion.li, { ref: ref, ...props, className: cloneIndex === undefined ? "ticker-item" : "clone-item", style: {
                flexShrink: 0,
                flexGrow: 0,
                x: axis === "x" ? transform : 0,
                y: axis === "y" ? transform : 0,
            }, "aria-hidden": cloneIndex !== undefined ? true : undefined }) }));
}

function useFocusNavigation(containerRef, axis, focusOffset, offset, setHasFocus) {
    const isFocusTrapped = React.useRef(false);
    React.useEffect(() => {
        const container = containerRef.current;
        if (!container)
            return;
        let detectionEnabled = false;
        const abortController = new AbortController();
        const eventOptions = {
            signal: abortController.signal,
        };
        const eventOptionsWithCapture = {
            ...eventOptions,
            capture: true,
        };
        const scrollProp = axis === "x" ? "scrollLeft" : "scrollTop";
        const offsetProp = axis === "x" ? "offsetLeft" : "offsetTop";
        const leftKey = axis === "x" ? "ArrowLeft" : "ArrowUp";
        const rightKey = axis === "x" ? "ArrowRight" : "ArrowDown";
        let focusableElements = [];
        let focusIndex = 0;
        const applyFocusOffset = () => {
            const nextFocusableElement = focusableElements[focusIndex];
            nextFocusableElement.focus();
            // Move the ticker offset to the focused item
            focusOffset.set(-nextFocusableElement[offsetProp]);
            // Override the default browser scroll into view behaviour
            container[scrollProp] = 0;
            react.frame.render(() => {
                container[scrollProp] = 0;
            });
        };
        const handleFocusNavigation = (event) => {
            if (event.key === "Tab") {
                event.preventDefault();
                // Focus the next selectable element in the DOM outside the container
                endFocusTrap();
                // Find the next focusable element after the container
                const allFocusableElements = Array.from(document.querySelectorAll('a, button, input, textarea, select, [tabindex]:not([tabindex="-1"]), [contenteditable="true"]')).filter(react.isHTMLElement);
                // Sort the focusable elements by their tabIndex
                allFocusableElements.sort(compareTabIndexes);
                const lastFocusableElement = allFocusableElements[event.shiftKey ? 0 : allFocusableElements.length - 1];
                const initialIndex = event.shiftKey
                    ? allFocusableElements.length - 1
                    : 0;
                /**
                 * If the last focusable element in the DOM is inside the container
                 * then we want to set focus on the first DOM element
                 */
                if (container.contains(lastFocusableElement)) {
                    allFocusableElements[initialIndex].focus();
                    return;
                }
                else {
                    const indexOfCurrentElement = allFocusableElements.indexOf(focusableElements[focusIndex]);
                    const delta = event.shiftKey ? -1 : 1;
                    for (let i = indexOfCurrentElement; i < allFocusableElements.length && i >= 0; i += delta) {
                        const element = allFocusableElements[i];
                        if (!container.contains(element)) {
                            element.focus();
                            return;
                        }
                    }
                }
                return;
            }
            else if (event.key === leftKey) {
                focusIndex--;
            }
            else if (event.key === rightKey) {
                focusIndex++;
            }
            focusIndex = react.wrap(0, focusableElements.length, focusIndex);
            applyFocusOffset();
        };
        const startFocusTrap = () => {
            if (isFocusTrapped.current)
                return;
            setHasFocus(true);
            isFocusTrapped.current = true;
            // Get all focusable elements within .ticker-item elements
            focusableElements = Array.from(container.querySelectorAll('.ticker-item a, .ticker-item button, .ticker-item input, .ticker-item textarea, .ticker-item select, .ticker-item [tabindex]:not([tabindex="-1"]), .ticker-item [contenteditable="true"]')).filter(react.isHTMLElement);
            focusIndex = 0;
            applyFocusOffset();
            window.addEventListener("focus", detectTrapEnd, eventOptionsWithCapture);
            window.addEventListener("blur", detectTrapEnd, eventOptionsWithCapture);
            container.addEventListener("keydown", handleFocusNavigation, eventOptions);
        };
        const detectTrapEnd = (event) => {
            if (!event.target ||
                !(event.target instanceof HTMLElement) ||
                !container.contains(event.target)) {
                endFocusTrap();
            }
        };
        const endFocusTrap = () => {
            if (!isFocusTrapped.current)
                return;
            isFocusTrapped.current = false;
            setHasFocus(false);
            offset.set(focusOffset.get());
            window.removeEventListener("focus", detectTrapEnd);
            window.removeEventListener("blur", detectTrapEnd);
            container.removeEventListener("keydown", handleFocusNavigation);
        };
        const handleFocus = (event) => {
            const { target } = event;
            if (!react.isHTMLElement(target))
                return;
            if (!isFocusTrapped.current) {
                startFocusTrap();
            }
        };
        const detectFocusTrapEnable = () => {
            if (detectionEnabled)
                return;
            detectionEnabled = true;
            container.addEventListener("focus", handleFocus, eventOptionsWithCapture);
            window.addEventListener("pointermove", handlePointerMove, eventOptions);
        };
        const handlePointerMove = () => {
            if (!detectionEnabled)
                return;
            detectionEnabled = false;
            container.removeEventListener("focus", handleFocus, true);
            window.removeEventListener("pointermove", handlePointerMove, eventOptions);
        };
        const handleAriaHiddenClicks = (event) => {
            const target = event.target;
            // Check if target is a descendant of an element with aria-hidden="true"
            let ariaHiddenAncestor = target.closest('[aria-hidden="true"]');
            if (ariaHiddenAncestor) {
                ariaHiddenAncestor.removeAttribute("aria-hidden");
            }
        };
        window.addEventListener("keydown", detectFocusTrapEnable, eventOptions);
        container.addEventListener("pointerdown", handleAriaHiddenClicks, eventOptions);
        return () => {
            abortController.abort();
            endFocusTrap();
        };
    }, []);
}
function compareTabIndexes(a, b) {
    // Elements with tabIndex >= 1 come first, ordered by tabIndex value
    if (a.tabIndex >= 1 && b.tabIndex >= 1) {
        return a.tabIndex - b.tabIndex;
    }
    // Elements with tabIndex >= 1 come before tabIndex 0 or -1
    if (a.tabIndex >= 1 && b.tabIndex <= 0) {
        return -1;
    }
    if (b.tabIndex >= 1 && a.tabIndex <= 0) {
        return 1;
    }
    // Both have tabIndex 0 or -1, maintain document order (return 0)
    // tabIndex -1 elements are focusable programmatically but not via tab navigation
    return 0;
}

/**
 * A performant, accessible, and infinitely scrolling ticker component.
 *
 * @param items - An array of React nodes to be rendered as ticker items.
 * @param velocity - The velocity of the ticker scroll in pixels per second. Defaults to 50.
 * @param hoverFactor - Factor by which the velocity is multiplied when the ticker is hovered. Defaults to 1 (no change).
 * @param gap - The gap between ticker items in pixels. Defaults to 10.
 * @param axis - The axis along which the ticker scrolls. Defaults to "x".
 * @param align - Alignment of items within the ticker. Defaults to "center".
 * @param offset - An optional MotionValue to control the ticker's offset externally.
 * @param isStatic - Whether the ticker should be static. This is a display mode suitable for
 * design canvases that disables animations, measurements and viewport tracking.
 * Defaults to false.
 * @param props - HTML attributes to pass to the ticker container div.
 * @returns A Ticker React component.
 */
function Ticker({ items, velocity = 50, hoverFactor = 1, gap = 10, axis = "x", align = "center", offset, isStatic = false, ...props }) {
    const [state, setState] = React.useState({
        listSize: 0,
        containerSize: 0,
        containerPaddingStart: 0,
        containerPaddingEnd: 0,
        itemSizes: [],
    });
    const alignItems = align === "start"
        ? "flex-start"
        : align === "center"
            ? "center"
            : "flex-end";
    if (isStatic) {
        const renderedOffset = react.useMotionValue(0);
        return (jsxRuntime.jsx(ListView, { containerProps: props, gap: gap, axis: axis, alignItems: alignItems, renderedOffset: renderedOffset, items: items, state: state, isStatic: true }));
    }
    const [hasFocus, setHasFocus] = React.useState(false);
    const velocityFactor = react.useMotionValue(1);
    const defaultOffset = react.useMotionValue(0);
    offset ?? (offset = defaultOffset);
    const wrappedOffset = react.useTransform(() => react.wrap(-state.listSize - gap - state.containerPaddingStart, -state.containerPaddingStart, offset.get()));
    const focusOffset = react.useMotionValue(0);
    const renderedOffset = hasFocus ? focusOffset : wrappedOffset;
    const containerRef = React.useRef(null);
    const listRef = React.useRef(null);
    const isInView = react.useInView(containerRef, { margin: "100px" });
    const isReducedMotion = react.useReducedMotion();
    const updateMeasurements = () => {
        if (!containerRef.current || !listRef.current)
            return;
        const viewportSizeProp = axis === "x" ? "innerWidth" : "innerHeight";
        const sizeProp = axis === "x" ? "offsetWidth" : "offsetHeight";
        const insetProp = axis === "x" ? "offsetLeft" : "offsetTop";
        const paddingStartProp = axis === "x" ? "paddingLeft" : "paddingTop";
        const paddingEndProp = axis === "x" ? "paddingRight" : "paddingBottom";
        const container = containerRef.current;
        const list = listRef.current;
        const allItems = list.querySelectorAll(".ticker-item");
        if (!allItems.length)
            return;
        let haveItemSizesChanged = false;
        const itemSizes = [];
        for (let i = 0; i < allItems.length; i++) {
            const item = allItems[i];
            itemSizes.push({
                start: item[insetProp],
                end: item[insetProp] + item[sizeProp],
            });
            if (!state.itemSizes[i] ||
                itemSizes[i].start !== state.itemSizes[i].start ||
                itemSizes[i].end !== state.itemSizes[i].end) {
                haveItemSizesChanged = true;
            }
        }
        /**
         * Measure the container size. Currently we cap this to the viewport
         * size to prevent infinite or wasteful cloning in the event that the
         * container width is reactive to the number of children rendered within it.
         */
        const containerSize = Math.min(container[sizeProp], window[viewportSizeProp]);
        const listSize = itemSizes[itemSizes.length - 1].end - itemSizes[0].start;
        const computedContainerStyle = window.getComputedStyle(container);
        const containerPaddingStart = parseInt(computedContainerStyle[paddingStartProp] ?? 0);
        const containerPaddingEnd = parseInt(computedContainerStyle[paddingEndProp] ?? 0);
        if (listSize !== state.listSize ||
            containerSize !== state.containerSize ||
            haveItemSizesChanged) {
            setState({
                listSize,
                containerSize,
                containerPaddingStart,
                containerPaddingEnd,
                itemSizes,
            });
        }
    };
    react.useIsomorphicLayoutEffect(() => {
        if (!isInView || !containerRef.current)
            return;
        updateMeasurements();
        return react.resize(containerRef.current, updateMeasurements);
    }, [items, isInView]);
    const isMeasured = state.containerSize > 0 && state.listSize > 0;
    react.useAnimationFrame(isMeasured && isInView && offset === defaultOffset && !isReducedMotion
        ? (_, delta) => {
            const frameOffset = (delta / 1000) * (velocity * velocityFactor.get());
            offset.set(offset.get() - frameOffset);
        }
        : react.noop);
    const cloneCount = React.useMemo(() => {
        let count = 0;
        if (!isMeasured || !state.containerSize)
            return 0;
        // The space that can be visible at once with the first item
        // off the start
        let safeVisibleSize = 0;
        const maxSize = Math.max(...state.itemSizes.map((item) => item.end - item.start));
        while (safeVisibleSize <
            state.containerSize + state.containerPaddingStart) {
            safeVisibleSize = (state.listSize + gap) * (count + 1) - maxSize;
            count++;
        }
        return Math.max(count - 1, 0);
    }, [isMeasured, state.containerSize, state.listSize]);
    const totalListSize = state.listSize === 0 ? 0 : (state.listSize + gap) * (cloneCount + 1);
    const clonedItems = [];
    for (let i = 0; i < cloneCount; i++) {
        items.forEach((item, itemIndex) => {
            const originalBounds = state.itemSizes[itemIndex];
            const cloneOffset = (state.listSize + gap) * (i + 1);
            const cloneBounds = originalBounds
                ? {
                    start: originalBounds.start + cloneOffset,
                    end: originalBounds.end + cloneOffset,
                }
                : defaultBounds;
            clonedItems.push(jsxRuntime.jsx(TickerItem, { offset: renderedOffset, axis: axis, listSize: totalListSize, cloneIndex: itemIndex, bounds: cloneBounds, containerPaddingStart: state.containerPaddingStart, children: item }, `clone-${i}-${itemIndex}`));
        });
    }
    useFocusNavigation(containerRef, axis, focusOffset, offset, setHasFocus);
    return (jsxRuntime.jsx(ListView, { containerProps: props, containerRef: containerRef, listRef: listRef, gap: gap, axis: axis, alignItems: alignItems, isMeasured: isMeasured, renderedOffset: renderedOffset, items: items, clonedItems: clonedItems, onPointerEnter: () => {
            react.animate(velocityFactor, hoverFactor);
        }, onPointerLeave: () => {
            react.animate(velocityFactor, 1);
        }, totalListSize: totalListSize, state: state }));
}
function ListView({ containerProps, containerRef, listRef, gap, axis, alignItems, isMeasured, isStatic, items, clonedItems, renderedOffset, onPointerEnter, onPointerLeave, totalListSize, state, }) {
    return (jsxRuntime.jsx(react.motion.div, { ...containerProps, ref: containerRef, style: { ...containerStyle, ...containerProps.style }, onPointerEnter: onPointerEnter, onPointerLeave: onPointerLeave, children: jsxRuntime.jsxs(react.motion.ul, { ref: listRef, style: {
                ...listStyle,
                flexDirection: axis === "x" ? "row" : "column",
                gap: `${gap}px`,
                alignItems,
                x: axis === "x" ? renderedOffset : 0,
                y: axis === "y" ? renderedOffset : 0,
                opacity: isMeasured || isStatic ? 1 : 0,
            }, children: [items.map((item, index) => (jsxRuntime.jsx(TickerItem, { axis: axis, offset: renderedOffset, listSize: totalListSize, itemIndex: index, bounds: state.itemSizes[index] ?? defaultBounds, containerPaddingStart: state.containerPaddingStart, children: item }, "original-" + index))), clonedItems || null] }) }));
}
const defaultBounds = { start: 0, end: 0 };
const containerStyle = {
    display: "flex",
    position: "relative",
    overflow: "hidden",
};
const listStyle = {
    display: "flex",
    position: "relative",
    willChange: "transform",
    listStyleType: "none",
    padding: 0,
    margin: 0,
    justifyContent: "flex-start",
};

function useItemOffset() {
    const itemContext = React.useContext(TickerItemContext);
    motionUtils.invariant(Boolean(itemContext), "useItemOffset must be used within a TickerItem");
    return itemContext.offset;
}

exports.AnimateNumber = AnimateNumber;
exports.AnimateText = AnimateText;
exports.Cursor = Cursor;
exports.Ticker = Ticker;
exports.useCursorIsInView = useCursorIsInView;
exports.useCursorState = useCursorState;
exports.useFocusNavigation = useFocusNavigation;
exports.useItemOffset = useItemOffset;
exports.useMagneticPull = useMagneticPull;
exports.usePointerPosition = usePointerPosition;
