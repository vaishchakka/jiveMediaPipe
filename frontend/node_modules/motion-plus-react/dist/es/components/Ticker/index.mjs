"use client";
import { jsx, jsxs } from 'react/jsx-runtime';
import { useMotionValue, useTransform, wrap, useInView, useReducedMotion, useIsomorphicLayoutEffect, resize, useAnimationFrame, noop, animate, motion } from 'motion/react';
import { useState, useRef, useMemo } from 'react';
import { TickerItem } from './TickerItem.mjs';
import { useFocusNavigation } from './use-focus-navigation.mjs';

/**
 * A performant, accessible, and infinitely scrolling ticker component.
 *
 * @param items - An array of React nodes to be rendered as ticker items.
 * @param velocity - The velocity of the ticker scroll in pixels per second. Defaults to 50.
 * @param hoverFactor - Factor by which the velocity is multiplied when the ticker is hovered. Defaults to 1 (no change).
 * @param gap - The gap between ticker items in pixels. Defaults to 10.
 * @param axis - The axis along which the ticker scrolls. Defaults to "x".
 * @param align - Alignment of items within the ticker. Defaults to "center".
 * @param offset - An optional MotionValue to control the ticker's offset externally.
 * @param isStatic - Whether the ticker should be static. This is a display mode suitable for
 * design canvases that disables animations, measurements and viewport tracking.
 * Defaults to false.
 * @param props - HTML attributes to pass to the ticker container div.
 * @returns A Ticker React component.
 */
function Ticker({ items, velocity = 50, hoverFactor = 1, gap = 10, axis = "x", align = "center", offset, isStatic = false, ...props }) {
    const [state, setState] = useState({
        listSize: 0,
        containerSize: 0,
        containerPaddingStart: 0,
        containerPaddingEnd: 0,
        itemSizes: [],
    });
    const alignItems = align === "start"
        ? "flex-start"
        : align === "center"
            ? "center"
            : "flex-end";
    if (isStatic) {
        const renderedOffset = useMotionValue(0);
        return (jsx(ListView, { containerProps: props, gap: gap, axis: axis, alignItems: alignItems, renderedOffset: renderedOffset, items: items, state: state, isStatic: true }));
    }
    const [hasFocus, setHasFocus] = useState(false);
    const velocityFactor = useMotionValue(1);
    const defaultOffset = useMotionValue(0);
    offset ?? (offset = defaultOffset);
    const wrappedOffset = useTransform(() => wrap(-state.listSize - gap - state.containerPaddingStart, -state.containerPaddingStart, offset.get()));
    const focusOffset = useMotionValue(0);
    const renderedOffset = hasFocus ? focusOffset : wrappedOffset;
    const containerRef = useRef(null);
    const listRef = useRef(null);
    const isInView = useInView(containerRef, { margin: "100px" });
    const isReducedMotion = useReducedMotion();
    const updateMeasurements = () => {
        if (!containerRef.current || !listRef.current)
            return;
        const viewportSizeProp = axis === "x" ? "innerWidth" : "innerHeight";
        const sizeProp = axis === "x" ? "offsetWidth" : "offsetHeight";
        const insetProp = axis === "x" ? "offsetLeft" : "offsetTop";
        const paddingStartProp = axis === "x" ? "paddingLeft" : "paddingTop";
        const paddingEndProp = axis === "x" ? "paddingRight" : "paddingBottom";
        const container = containerRef.current;
        const list = listRef.current;
        const allItems = list.querySelectorAll(".ticker-item");
        if (!allItems.length)
            return;
        let haveItemSizesChanged = false;
        const itemSizes = [];
        for (let i = 0; i < allItems.length; i++) {
            const item = allItems[i];
            itemSizes.push({
                start: item[insetProp],
                end: item[insetProp] + item[sizeProp],
            });
            if (!state.itemSizes[i] ||
                itemSizes[i].start !== state.itemSizes[i].start ||
                itemSizes[i].end !== state.itemSizes[i].end) {
                haveItemSizesChanged = true;
            }
        }
        /**
         * Measure the container size. Currently we cap this to the viewport
         * size to prevent infinite or wasteful cloning in the event that the
         * container width is reactive to the number of children rendered within it.
         */
        const containerSize = Math.min(container[sizeProp], window[viewportSizeProp]);
        const listSize = itemSizes[itemSizes.length - 1].end - itemSizes[0].start;
        const computedContainerStyle = window.getComputedStyle(container);
        const containerPaddingStart = parseInt(computedContainerStyle[paddingStartProp] ?? 0);
        const containerPaddingEnd = parseInt(computedContainerStyle[paddingEndProp] ?? 0);
        if (listSize !== state.listSize ||
            containerSize !== state.containerSize ||
            haveItemSizesChanged) {
            setState({
                listSize,
                containerSize,
                containerPaddingStart,
                containerPaddingEnd,
                itemSizes,
            });
        }
    };
    useIsomorphicLayoutEffect(() => {
        if (!isInView || !containerRef.current)
            return;
        updateMeasurements();
        return resize(containerRef.current, updateMeasurements);
    }, [items, isInView]);
    const isMeasured = state.containerSize > 0 && state.listSize > 0;
    useAnimationFrame(isMeasured && isInView && offset === defaultOffset && !isReducedMotion
        ? (_, delta) => {
            const frameOffset = (delta / 1000) * (velocity * velocityFactor.get());
            offset.set(offset.get() - frameOffset);
        }
        : noop);
    const cloneCount = useMemo(() => {
        let count = 0;
        if (!isMeasured || !state.containerSize)
            return 0;
        // The space that can be visible at once with the first item
        // off the start
        let safeVisibleSize = 0;
        const maxSize = Math.max(...state.itemSizes.map((item) => item.end - item.start));
        while (safeVisibleSize <
            state.containerSize + state.containerPaddingStart) {
            safeVisibleSize = (state.listSize + gap) * (count + 1) - maxSize;
            count++;
        }
        return Math.max(count - 1, 0);
    }, [isMeasured, state.containerSize, state.listSize]);
    const totalListSize = state.listSize === 0 ? 0 : (state.listSize + gap) * (cloneCount + 1);
    const clonedItems = [];
    for (let i = 0; i < cloneCount; i++) {
        items.forEach((item, itemIndex) => {
            const originalBounds = state.itemSizes[itemIndex];
            const cloneOffset = (state.listSize + gap) * (i + 1);
            const cloneBounds = originalBounds
                ? {
                    start: originalBounds.start + cloneOffset,
                    end: originalBounds.end + cloneOffset,
                }
                : defaultBounds;
            clonedItems.push(jsx(TickerItem, { offset: renderedOffset, axis: axis, listSize: totalListSize, cloneIndex: itemIndex, bounds: cloneBounds, containerPaddingStart: state.containerPaddingStart, children: item }, `clone-${i}-${itemIndex}`));
        });
    }
    useFocusNavigation(containerRef, axis, focusOffset, offset, setHasFocus);
    return (jsx(ListView, { containerProps: props, containerRef: containerRef, listRef: listRef, gap: gap, axis: axis, alignItems: alignItems, isMeasured: isMeasured, renderedOffset: renderedOffset, items: items, clonedItems: clonedItems, onPointerEnter: () => {
            animate(velocityFactor, hoverFactor);
        }, onPointerLeave: () => {
            animate(velocityFactor, 1);
        }, totalListSize: totalListSize, state: state }));
}
function ListView({ containerProps, containerRef, listRef, gap, axis, alignItems, isMeasured, isStatic, items, clonedItems, renderedOffset, onPointerEnter, onPointerLeave, totalListSize, state, }) {
    return (jsx(motion.div, { ...containerProps, ref: containerRef, style: { ...containerStyle, ...containerProps.style }, onPointerEnter: onPointerEnter, onPointerLeave: onPointerLeave, children: jsxs(motion.ul, { ref: listRef, style: {
                ...listStyle,
                flexDirection: axis === "x" ? "row" : "column",
                gap: `${gap}px`,
                alignItems,
                x: axis === "x" ? renderedOffset : 0,
                y: axis === "y" ? renderedOffset : 0,
                opacity: isMeasured || isStatic ? 1 : 0,
            }, children: [items.map((item, index) => (jsx(TickerItem, { axis: axis, offset: renderedOffset, listSize: totalListSize, itemIndex: index, bounds: state.itemSizes[index] ?? defaultBounds, containerPaddingStart: state.containerPaddingStart, children: item }, "original-" + index))), clonedItems || null] }) }));
}
const defaultBounds = { start: 0, end: 0 };
const containerStyle = {
    display: "flex",
    position: "relative",
    overflow: "hidden",
};
const listStyle = {
    display: "flex",
    position: "relative",
    willChange: "transform",
    listStyleType: "none",
    padding: 0,
    margin: 0,
    justifyContent: "flex-start",
};

export { Ticker };
