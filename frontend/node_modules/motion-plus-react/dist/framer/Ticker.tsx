import { useTransform, motion, isHTMLElement, wrap, frame, useMotionValue, useInView, useReducedMotion, useIsomorphicLayoutEffect, resize, useAnimationFrame, noop, animate } from 'framer-motion';
import { createContext, useRef, useEffect, useState, useMemo } from 'react';

const TickerItemContext = createContext(undefined);

/**
 * Represents an individual item within the Ticker.
 *
 * This component handles the logic for repositioning items to create the infinite scroll effect.
 *
 * @param offset - The current scroll offset of the ticker.
 * @param axis - The scroll axis ("x" or "y").
 * @param listSize - The total size of the list including all clones.
 * @param itemIndex - The original index of the item.
 * @param cloneIndex - The index of the clone, if this is a cloned item.
 * @param props - HTML attributes to pass to the list item li element.
 * @returns A ListItem React component.
 */
function TickerItem({ offset, axis, listSize = 0, itemIndex, cloneIndex, bounds, containerPaddingStart, ...props }) {
    const ref = useRef(null);
    const { start, end } = bounds;
    const transform = useTransform(() => {
        const currentOffset = offset.get();
        if ((!start && !end) || !listSize)
            return 0;
        if (currentOffset + end <= -containerPaddingStart) {
            return listSize;
        }
        return 0;
    });
    const itemOffset = useTransform(() => {
        const currentOffset = offset.get();
        const currentTransform = transform.get();
        if ((!start && !end) || !listSize)
            return 0;
        return currentOffset + start + currentTransform;
    });
    return (<TickerItemContext.Provider value={{ offset: itemOffset }}>
            <motion.li ref={ref} {...props} className={cloneIndex === undefined ? "ticker-item" : "clone-item"} style={{
            flexShrink: 0,
            flexGrow: 0,
            x: axis === "x" ? transform : 0,
            y: axis === "y" ? transform : 0,
        }} aria-hidden={cloneIndex !== undefined ? true : undefined}/>
        </TickerItemContext.Provider>);
}

function useFocusNavigation(containerRef, axis, focusOffset, offset, setHasFocus) {
    const isFocusTrapped = useRef(false);
    useEffect(() => {
        const container = containerRef.current;
        if (!container)
            return;
        let detectionEnabled = false;
        const abortController = new AbortController();
        const eventOptions = {
            signal: abortController.signal,
        };
        const eventOptionsWithCapture = {
            ...eventOptions,
            capture: true,
        };
        const scrollProp = axis === "x" ? "scrollLeft" : "scrollTop";
        const offsetProp = axis === "x" ? "offsetLeft" : "offsetTop";
        const leftKey = axis === "x" ? "ArrowLeft" : "ArrowUp";
        const rightKey = axis === "x" ? "ArrowRight" : "ArrowDown";
        let focusableElements = [];
        let focusIndex = 0;
        const applyFocusOffset = () => {
            const nextFocusableElement = focusableElements[focusIndex];
            nextFocusableElement.focus();
            // Move the ticker offset to the focused item
            focusOffset.set(-nextFocusableElement[offsetProp]);
            // Override the default browser scroll into view behaviour
            container[scrollProp] = 0;
            frame.render(() => {
                container[scrollProp] = 0;
            });
        };
        const handleFocusNavigation = (event) => {
            if (event.key === "Tab") {
                event.preventDefault();
                // Focus the next selectable element in the DOM outside the container
                endFocusTrap();
                // Find the next focusable element after the container
                const allFocusableElements = Array.from(document.querySelectorAll('a, button, input, textarea, select, [tabindex]:not([tabindex="-1"]), [contenteditable="true"]')).filter(isHTMLElement);
                // Sort the focusable elements by their tabIndex
                allFocusableElements.sort(compareTabIndexes);
                const lastFocusableElement = allFocusableElements[event.shiftKey ? 0 : allFocusableElements.length - 1];
                const initialIndex = event.shiftKey
                    ? allFocusableElements.length - 1
                    : 0;
                /**
                 * If the last focusable element in the DOM is inside the container
                 * then we want to set focus on the first DOM element
                 */
                if (container.contains(lastFocusableElement)) {
                    allFocusableElements[initialIndex].focus();
                    return;
                }
                else {
                    const indexOfCurrentElement = allFocusableElements.indexOf(focusableElements[focusIndex]);
                    const delta = event.shiftKey ? -1 : 1;
                    for (let i = indexOfCurrentElement; i < allFocusableElements.length && i >= 0; i += delta) {
                        const element = allFocusableElements[i];
                        if (!container.contains(element)) {
                            element.focus();
                            return;
                        }
                    }
                }
                return;
            }
            else if (event.key === leftKey) {
                focusIndex--;
            }
            else if (event.key === rightKey) {
                focusIndex++;
            }
            focusIndex = wrap(0, focusableElements.length, focusIndex);
            applyFocusOffset();
        };
        const startFocusTrap = () => {
            if (isFocusTrapped.current)
                return;
            setHasFocus(true);
            isFocusTrapped.current = true;
            // Get all focusable elements within .ticker-item elements
            focusableElements = Array.from(container.querySelectorAll('.ticker-item a, .ticker-item button, .ticker-item input, .ticker-item textarea, .ticker-item select, .ticker-item [tabindex]:not([tabindex="-1"]), .ticker-item [contenteditable="true"]')).filter(isHTMLElement);
            focusIndex = 0;
            applyFocusOffset();
            window.addEventListener("focus", detectTrapEnd, eventOptionsWithCapture);
            window.addEventListener("blur", detectTrapEnd, eventOptionsWithCapture);
            container.addEventListener("keydown", handleFocusNavigation, eventOptions);
        };
        const detectTrapEnd = (event) => {
            if (!event.target ||
                !(event.target instanceof HTMLElement) ||
                !container.contains(event.target)) {
                endFocusTrap();
            }
        };
        const endFocusTrap = () => {
            if (!isFocusTrapped.current)
                return;
            isFocusTrapped.current = false;
            setHasFocus(false);
            offset.set(focusOffset.get());
            window.removeEventListener("focus", detectTrapEnd);
            window.removeEventListener("blur", detectTrapEnd);
            container.removeEventListener("keydown", handleFocusNavigation);
        };
        const handleFocus = (event) => {
            const { target } = event;
            if (!isHTMLElement(target))
                return;
            if (!isFocusTrapped.current) {
                startFocusTrap();
            }
        };
        const detectFocusTrapEnable = () => {
            if (detectionEnabled)
                return;
            detectionEnabled = true;
            container.addEventListener("focus", handleFocus, eventOptionsWithCapture);
            window.addEventListener("pointermove", handlePointerMove, eventOptions);
        };
        const handlePointerMove = () => {
            if (!detectionEnabled)
                return;
            detectionEnabled = false;
            container.removeEventListener("focus", handleFocus, true);
            window.removeEventListener("pointermove", handlePointerMove, eventOptions);
        };
        const handleAriaHiddenClicks = (event) => {
            const target = event.target;
            // Check if target is a descendant of an element with aria-hidden="true"
            let ariaHiddenAncestor = target.closest('[aria-hidden="true"]');
            if (ariaHiddenAncestor) {
                ariaHiddenAncestor.removeAttribute("aria-hidden");
            }
        };
        window.addEventListener("keydown", detectFocusTrapEnable, eventOptions);
        container.addEventListener("pointerdown", handleAriaHiddenClicks, eventOptions);
        return () => {
            abortController.abort();
            endFocusTrap();
        };
    }, []);
}
function compareTabIndexes(a, b) {
    // Elements with tabIndex >= 1 come first, ordered by tabIndex value
    if (a.tabIndex >= 1 && b.tabIndex >= 1) {
        return a.tabIndex - b.tabIndex;
    }
    // Elements with tabIndex >= 1 come before tabIndex 0 or -1
    if (a.tabIndex >= 1 && b.tabIndex <= 0) {
        return -1;
    }
    if (b.tabIndex >= 1 && a.tabIndex <= 0) {
        return 1;
    }
    // Both have tabIndex 0 or -1, maintain document order (return 0)
    // tabIndex -1 elements are focusable programmatically but not via tab navigation
    return 0;
}

/**
 * A performant, accessible, and infinitely scrolling ticker component.
 *
 * @param items - An array of React nodes to be rendered as ticker items.
 * @param velocity - The velocity of the ticker scroll in pixels per second. Defaults to 50.
 * @param hoverFactor - Factor by which the velocity is multiplied when the ticker is hovered. Defaults to 1 (no change).
 * @param gap - The gap between ticker items in pixels. Defaults to 10.
 * @param axis - The axis along which the ticker scrolls. Defaults to "x".
 * @param align - Alignment of items within the ticker. Defaults to "center".
 * @param offset - An optional MotionValue to control the ticker's offset externally.
 * @param isStatic - Whether the ticker should be static. This is a display mode suitable for
 * design canvases that disables animations, measurements and viewport tracking.
 * Defaults to false.
 * @param props - HTML attributes to pass to the ticker container div.
 * @returns A Ticker React component.
 */
function Ticker({ items, velocity = 50, hoverFactor = 1, gap = 10, axis = "x", align = "center", offset, isStatic = false, ...props }) {
    const [state, setState] = useState({
        listSize: 0,
        containerSize: 0,
        containerPaddingStart: 0,
        containerPaddingEnd: 0,
        itemSizes: [],
    });
    const alignItems = align === "start"
        ? "flex-start"
        : align === "center"
            ? "center"
            : "flex-end";
    if (isStatic) {
        const renderedOffset = useMotionValue(0);
        return (<ListView containerProps={props} gap={gap} axis={axis} alignItems={alignItems} renderedOffset={renderedOffset} items={items} state={state} isStatic/>);
    }
    const [hasFocus, setHasFocus] = useState(false);
    const velocityFactor = useMotionValue(1);
    const defaultOffset = useMotionValue(0);
    offset ?? (offset = defaultOffset);
    const wrappedOffset = useTransform(() => wrap(-state.listSize - gap - state.containerPaddingStart, -state.containerPaddingStart, offset.get()));
    const focusOffset = useMotionValue(0);
    const renderedOffset = hasFocus ? focusOffset : wrappedOffset;
    const containerRef = useRef(null);
    const listRef = useRef(null);
    const isInView = useInView(containerRef, { margin: "100px" });
    const isReducedMotion = useReducedMotion();
    const updateMeasurements = () => {
        if (!containerRef.current || !listRef.current)
            return;
        const viewportSizeProp = axis === "x" ? "innerWidth" : "innerHeight";
        const sizeProp = axis === "x" ? "offsetWidth" : "offsetHeight";
        const insetProp = axis === "x" ? "offsetLeft" : "offsetTop";
        const paddingStartProp = axis === "x" ? "paddingLeft" : "paddingTop";
        const paddingEndProp = axis === "x" ? "paddingRight" : "paddingBottom";
        const container = containerRef.current;
        const list = listRef.current;
        const allItems = list.querySelectorAll(".ticker-item");
        if (!allItems.length)
            return;
        let haveItemSizesChanged = false;
        const itemSizes = [];
        for (let i = 0; i < allItems.length; i++) {
            const item = allItems[i];
            itemSizes.push({
                start: item[insetProp],
                end: item[insetProp] + item[sizeProp],
            });
            if (!state.itemSizes[i] ||
                itemSizes[i].start !== state.itemSizes[i].start ||
                itemSizes[i].end !== state.itemSizes[i].end) {
                haveItemSizesChanged = true;
            }
        }
        /**
         * Measure the container size. Currently we cap this to the viewport
         * size to prevent infinite or wasteful cloning in the event that the
         * container width is reactive to the number of children rendered within it.
         */
        const containerSize = Math.min(container[sizeProp], window[viewportSizeProp]);
        const listSize = itemSizes[itemSizes.length - 1].end - itemSizes[0].start;
        const computedContainerStyle = window.getComputedStyle(container);
        const containerPaddingStart = parseInt(computedContainerStyle[paddingStartProp] ?? 0);
        const containerPaddingEnd = parseInt(computedContainerStyle[paddingEndProp] ?? 0);
        if (listSize !== state.listSize ||
            containerSize !== state.containerSize ||
            haveItemSizesChanged) {
            setState({
                listSize,
                containerSize,
                containerPaddingStart,
                containerPaddingEnd,
                itemSizes,
            });
        }
    };
    useIsomorphicLayoutEffect(() => {
        if (!isInView || !containerRef.current)
            return;
        updateMeasurements();
        return resize(containerRef.current, updateMeasurements);
    }, [items, isInView]);
    const isMeasured = state.containerSize > 0 && state.listSize > 0;
    useAnimationFrame(isMeasured && isInView && offset === defaultOffset && !isReducedMotion
        ? (_, delta) => {
            const frameOffset = (delta / 1000) * (velocity * velocityFactor.get());
            offset.set(offset.get() - frameOffset);
        }
        : noop);
    const cloneCount = useMemo(() => {
        let count = 0;
        if (!isMeasured || !state.containerSize)
            return 0;
        // The space that can be visible at once with the first item
        // off the start
        let safeVisibleSize = 0;
        const maxSize = Math.max(...state.itemSizes.map((item) => item.end - item.start));
        while (safeVisibleSize <
            state.containerSize + state.containerPaddingStart) {
            safeVisibleSize = (state.listSize + gap) * (count + 1) - maxSize;
            count++;
        }
        return Math.max(count - 1, 0);
    }, [isMeasured, state.containerSize, state.listSize]);
    const totalListSize = state.listSize === 0 ? 0 : (state.listSize + gap) * (cloneCount + 1);
    const clonedItems = [];
    for (let i = 0; i < cloneCount; i++) {
        items.forEach((item, itemIndex) => {
            const originalBounds = state.itemSizes[itemIndex];
            const cloneOffset = (state.listSize + gap) * (i + 1);
            const cloneBounds = originalBounds
                ? {
                    start: originalBounds.start + cloneOffset,
                    end: originalBounds.end + cloneOffset,
                }
                : defaultBounds;
            clonedItems.push(<TickerItem key={`clone-${i}-${itemIndex}`} offset={renderedOffset} axis={axis} listSize={totalListSize} cloneIndex={itemIndex} bounds={cloneBounds} containerPaddingStart={state.containerPaddingStart}>
                    {item}
                </TickerItem>);
        });
    }
    useFocusNavigation(containerRef, axis, focusOffset, offset, setHasFocus);
    return (<ListView containerProps={props} containerRef={containerRef} listRef={listRef} gap={gap} axis={axis} alignItems={alignItems} isMeasured={isMeasured} renderedOffset={renderedOffset} items={items} clonedItems={clonedItems} onPointerEnter={() => {
            animate(velocityFactor, hoverFactor);
        }} onPointerLeave={() => {
            animate(velocityFactor, 1);
        }} totalListSize={totalListSize} state={state}/>);
}
function ListView({ containerProps, containerRef, listRef, gap, axis, alignItems, isMeasured, isStatic, items, clonedItems, renderedOffset, onPointerEnter, onPointerLeave, totalListSize, state, }) {
    return (<motion.div {...containerProps} ref={containerRef} style={{ ...containerStyle, ...containerProps.style }} onPointerEnter={onPointerEnter} onPointerLeave={onPointerLeave}>
            <motion.ul ref={listRef} style={{
            ...listStyle,
            flexDirection: axis === "x" ? "row" : "column",
            gap: `${gap}px`,
            alignItems,
            x: axis === "x" ? renderedOffset : 0,
            y: axis === "y" ? renderedOffset : 0,
            opacity: isMeasured || isStatic ? 1 : 0,
        }}>
                {items.map((item, index) => (<TickerItem key={"original-" + index} axis={axis} offset={renderedOffset} listSize={totalListSize} itemIndex={index} bounds={state.itemSizes[index] ?? defaultBounds} containerPaddingStart={state.containerPaddingStart}>
                        {item}
                    </TickerItem>))}
                {clonedItems || null}
            </motion.ul>
        </motion.div>);
}
const defaultBounds = { start: 0, end: 0 };
const containerStyle = {
    display: "flex",
    position: "relative",
    overflow: "hidden",
};
const listStyle = {
    display: "flex",
    position: "relative",
    willChange: "transform",
    listStyleType: "none",
    padding: 0,
    margin: 0,
    justifyContent: "flex-start",
};

export { Ticker as default };
