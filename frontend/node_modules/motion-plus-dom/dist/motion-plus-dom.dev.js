(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('motion-dom'), require('motion-utils')) :
    typeof define === 'function' && define.amd ? define(['exports', 'motion-dom', 'motion-utils'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.MotionPlus = {}, global.MotionDom, global.MotionUtils));
})(this, (function (exports, motionDom, motionUtils) { 'use strict';

    function createSpan(className, index) {
        const span = document.createElement("span");
        if (className) {
            span.className = className;
        }
        if (index !== undefined) {
            span.dataset.index = index.toString();
        }
        span.style.display = "inline-block";
        return span;
    }
    function addToken(element, token, className, index) {
        const charSpan = createSpan(className, index);
        charSpan.textContent = token;
        element.appendChild(charSpan);
        return charSpan;
    }
    /**
     * Splits text content of an element into characters, words, and lines.
     *
     * @param elementOrSelector - The element or selector of the element to split. If multiple elements are found, only the first will be split.
     * @param options - Options.
     * @returns An object the chars, words, and lines DOM nodes as a list.
     */
    function splitText(elementOrSelector, { splitBy = " ", charClass = "split-char", wordClass = "split-word", lineClass = "split-line", } = {}) {
        /**
         * We currently only support splitting a single element.
         * This could be changed in a future version.
         */
        const [element] = motionDom.resolveElements(elementOrSelector);
        motionUtils.invariant(Boolean(element), "Element not found");
        const text = element.textContent || "";
        element.setAttribute("aria-label", text);
        element.textContent = "";
        /**
         * Keep lists of split elements.
         */
        const splitElements = {
            chars: [],
            words: [],
            lines: [],
        };
        /**
         * Split the text into words using the provided delimiter.
         */
        const words = text.split(splitBy);
        const wordElements = [];
        const spacerElements = [];
        /**
         * Write: Create all word and character spans before measuring top offsets.
         */
        for (let wordIndex = 0; wordIndex < words.length; wordIndex++) {
            const word = words[wordIndex];
            const wordSpan = createSpan(wordClass, wordIndex);
            splitElements.words.push(wordSpan);
            wordElements.push(wordSpan);
            /**
             * Create a span for each character in the word.
             */
            const chars = Array.from(word);
            for (let charIndex = 0; charIndex < chars.length; charIndex++) {
                const char = chars[charIndex];
                const charSpan = addToken(wordSpan, char, charClass, charIndex);
                splitElements.chars.push(charSpan);
            }
            /**
             * Add the word span to the parent element.
             */
            element.appendChild(wordSpan);
            /**
             * Add the delimiter after the word. If the delimiter is a space,
             * add a space text node directly to the parent element, otherwise
             * add the delimited as a character to allow it to be animated.
             */
            if (wordIndex < words.length - 1) {
                if (splitBy === " ") {
                    const spaceNode = document.createTextNode(" ");
                    element.appendChild(spaceNode);
                    spacerElements.push(spaceNode);
                }
                else {
                    const delimiterSpan = addToken(wordSpan, splitBy, `${charClass}-delimiter`);
                    splitElements.chars.push(delimiterSpan);
                }
            }
        }
        // TODO: Would it be worth allowing early return without line splitting?
        /**
         * Read: Measure the top offset of each word.
         */
        const wordData = wordElements.map((wordSpan, index) => {
            return {
                element: wordSpan,
                top: wordSpan.offsetTop,
                index,
                spacer: index < spacerElements.length ? spacerElements[index] : null,
            };
        });
        /**
         * Write: Group words into lines based on measured top offsets.
         */
        const lines = [];
        let currentLine = [];
        let currentTop = wordData[0]?.top ?? 0;
        let lineIndex = 0;
        for (let i = 0; i < wordData.length; i++) {
            const { element, top, spacer } = wordData[i];
            // Check if word starts a new line
            if (top > currentTop && currentLine.length > 0) {
                // Complete current line and start a new one
                lines.push({ elements: currentLine, lineIndex: lineIndex++ });
                currentLine = [];
                currentTop = top;
            }
            // Add word to current line
            currentLine.push(element);
            // Add spacer if it exists
            if (spacer) {
                currentLine.push(spacer);
            }
        }
        // Add the last line if it has any elements
        if (currentLine.length > 0) {
            lines.push({ elements: currentLine, lineIndex });
        }
        /**
         * Write: Rebuild element with lines.
         */
        element.textContent = "";
        for (const { elements, lineIndex } of lines) {
            const lineSpan = createSpan(lineClass, lineIndex);
            lineSpan.style.display = "inline-block";
            splitElements.lines.push(lineSpan);
            // Build the line with the word elements.
            for (const node of elements) {
                lineSpan.appendChild(node);
            }
            element.appendChild(lineSpan);
        }
        return splitElements;
    }

    function needsBackspace(currentText, fullText) {
        return (currentText.length > fullText.length ||
            (currentText.length > 0 && !fullText.startsWith(currentText)));
    }

    /**
     * Natural typing variance patterns based on research
     * Returns delay as a multiple of the base interval using realistic typing patterns
     */
    function mix(a, b, t) {
        return a + (b - a) * t;
    }
    /**
     * Calculate a delay before typing the next character in the text.
     */
    function getTypewriterDelay(fullText, currentText, interval, variance, backspaceFactor) {
        if (needsBackspace(currentText, fullText)) {
            return interval * backspaceFactor;
        }
        if (variance === "natural") {
            return getNaturalDelay(fullText, currentText, interval);
        }
        if (typeof variance === "number" && variance > 0) {
            // Apply percentage-based random variance
            const varianceAmount = interval * (variance / 100);
            return interval + mix(-varianceAmount, varianceAmount, Math.random());
        }
        return interval;
    }
    function getNaturalDelay(fullText, currentText, interval) {
        const currentIndex = currentText.length;
        const char = fullText[currentIndex];
        const previousChar = fullText[currentIndex - 1];
        if (!char)
            return interval;
        // Find current position in word and full word boundaries
        const beforeText = fullText.slice(0, currentIndex);
        const lastSpaceIndex = beforeText.lastIndexOf(" ");
        const positionInWord = currentIndex - lastSpaceIndex - 1;
        // Find the full word boundaries (start and end)
        const wordStart = lastSpaceIndex + 1;
        const afterCurrentIndex = fullText.slice(currentIndex);
        const nextSpaceIndex = afterCurrentIndex.indexOf(" ");
        const wordEnd = nextSpaceIndex === -1 ? fullText.length : currentIndex + nextSpaceIndex;
        const wordLength = wordEnd - wordStart;
        // Start with base multiplier
        let delayMultiplier = 1.0;
        // Thinking pauses at sentence boundaries (major effect)
        if (previousChar && /[.!?]/.test(previousChar) && char === " ") {
            delayMultiplier *= 3; // 200% longer pause for thinking
        }
        // Short words (1-3 chars) are faster due to high frequency and muscle memory
        if (wordLength <= 3) {
            delayMultiplier *= 0.7; // 30% faster for short/common words
        }
        // Only apply start/end penalties to longer words (4+ characters)
        else {
            // Slower at beginning of words (muscle memory activation)
            if (positionInWord === 0 && char !== " ") {
                delayMultiplier *= 1.5;
            }
            // Slower at end of words (preparation for next word)
            if (positionInWord === wordLength - 1) {
                delayMultiplier *= 1.4;
            }
        }
        // Acceleration in word middle (people speed up mid-word) - only for longer words
        if (positionInWord > 0 &&
            positionInWord < wordLength - 1 &&
            wordLength > 3) {
            const middleBoost = Math.min(positionInWord / wordLength, 0.4);
            delayMultiplier *= 1.0 - middleBoost;
        }
        // Slower for punctuation (check the character being typed)
        if (punctuation.has(char)) {
            delayMultiplier *= 1.5;
        }
        // Extra slowdown for Shift-modifier characters (check the character being typed)
        if (shiftRequired.has(char)) {
            delayMultiplier *= 1.5;
        }
        // Numbers are slower to type (check the character being typed)
        if (/\d/.test(char)) {
            delayMultiplier *= 1.3;
        }
        // Long words slow down slightly (concentration required)
        if (wordLength > 8) {
            delayMultiplier *= 1.3;
        }
        // Slower for uppercase letters (check the character being typed)
        if (char !== char.toLowerCase()) {
            delayMultiplier *= 1.25;
        }
        // Fatigue over long texts (gradual slowdown)
        const fatigueThreshold = 200; // Start fatigue after 200 characters
        if (currentIndex > fatigueThreshold) {
            const fatigueAmount = Math.min((currentIndex - fatigueThreshold) / 1000, 0.3); // Up to 30% slower
            delayMultiplier *= 1.0 + fatigueAmount;
        }
        // Add random variance (±25% of current delay)
        const randomVariance = mix(-0.25, 0.25, Math.random());
        delayMultiplier *= 1.0 + randomVariance;
        // Apply multiplier to base interval
        const finalDelay = interval * delayMultiplier;
        // Minimum delay of 20% of base speed (prevent too fast typing)
        return Math.max(interval * 0.2, finalDelay);
    }
    const punctuation = new Set([
        ".",
        ",",
        "!",
        "?",
        ":",
        ";",
        "'",
        '"',
        "-",
        "(",
        ")",
    ]);
    const shiftRequired = new Set([
        "!",
        "@",
        "#",
        "$",
        "%",
        "^",
        "&",
        "*",
        "(",
        ")",
        "_",
        "+",
        "{",
        "}",
        "|",
        ":",
        '"',
        "<",
        ">",
        "?",
    ]);

    function findPreviousWordIndex(text, fromIndex) {
        // Start from the current position and go backwards
        let i = fromIndex - 1;
        // Skip any trailing whitespace
        while (i >= 0 && /\s/.test(text[i])) {
            i--;
        }
        // Find the start of the current word
        while (i >= 0 && !/\s/.test(text[i])) {
            i--;
        }
        // Return the position after the space (start of the word we want to keep)
        return Math.max(0, i + 1);
    }

    function findCommonPrefixIndex(current, target) {
        const commonPrefixLength = Math.min(current.length, target.length);
        let prefixLength = 0;
        for (let i = 0; i < commonPrefixLength; i++) {
            if (current[i] === target[i]) {
                prefixLength = i + 1;
            }
            else {
                break;
            }
        }
        return prefixLength;
    }

    function getNextText(current, target, replace, backspace) {
        if (replace === "type" && needsBackspace(current, target)) {
            if (backspace === "all") {
                return target.slice(0, findCommonPrefixIndex(current, target));
            }
            else if (backspace === "word") {
                // Backspace one word at a time
                const newLength = findPreviousWordIndex(current, current.length);
                return current.slice(0, newLength);
            }
            else {
                // backspace === "character" - backspace one character at a time
                return current.slice(0, -1);
            }
        }
        return target.slice(0, current.length + 1);
    }

    exports.findPreviousWordIndex = findPreviousWordIndex;
    exports.getNextText = getNextText;
    exports.getTypewriterDelay = getTypewriterDelay;
    exports.splitText = splitText;

}));
