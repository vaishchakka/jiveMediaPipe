import { StateCreator } from 'zustand';
import { ZodSchema, z } from 'zod';
import { AdditionalContext, ContextEntry, MentionProvider, AdditionalContextParam } from './store/agentContext/AgentContextTypes.mjs';
import { JSONContent } from '@tiptap/core';
import { ReactNode } from 'react';
import { ActivationConditions, ActivationState } from './store/spellSlice/SpellTypes.mjs';
import { Operation } from 'fast-json-patch';
import { ToolsSlice } from './store/toolsSlice/ToolsTypes.mjs';

type BasicStateValue = string | number | boolean | object | unknown[] | undefined | null | void;
interface ExecuteStateSetterOptions {
    isDiff?: boolean;
    [key: string]: unknown;
}
/** @deprecated Use ExecuteStateSetterOptions instead */
interface ExecuteCustomSetterOptions {
    isDiff?: boolean;
    [key: string]: unknown;
}
type SetterArgs = unknown;
interface ExecuteStateSetterParams {
    key: string;
    setterKey: string;
    options?: ExecuteStateSetterOptions;
    args?: SetterArgs;
}
/** @deprecated Use ExecuteStateSetterParams instead */
interface ExecuteCustomSetterParams {
    key: string;
    setterKey: string;
    options?: ExecuteCustomSetterOptions;
    args?: SetterArgs;
}
type BaseSetter<T = BasicStateValue> = (state: T) => void;
type SetterFunction<T = BasicStateValue, TArgs = SetterArgs> = TArgs extends void ? (state: T) => void : (state: T, setValue: (newValue: T) => void, args: TArgs) => void;
interface Setter<T = BasicStateValue, TArgsSchema = z.ZodTypeAny> {
    name: string;
    description: string;
    /** @deprecated Use argsSchema instead */
    schema?: TArgsSchema;
    /** Zod schema describing the input shape expected by this setter. */
    argsSchema?: TArgsSchema;
    execute: SetterFunction<T, TArgsSchema extends z.ZodTypeAny ? z.infer<TArgsSchema> : unknown>;
}
interface registeredState<T = BasicStateValue> {
    key: string;
    value: T;
    setValue?: BaseSetter<T>;
    description?: string;
    schema?: ZodSchema<T>;
    stateSetters?: Record<string, Setter<T, z.ZodTypeAny>>;
    /** @deprecated Use stateSetters instead */
    customSetters?: Record<string, Setter<T, z.ZodTypeAny>>;
}
interface StateSlice {
    registeredStates: Record<string, registeredState>;
    /**
     * Register a new state or replace an existing one.
     * @param config.setValue Optional React setState function for external state syncing.
     * @param config.stateSetters Optional state setters for this state.
     * @param config.customSetters Optional custom setters for this state (deprecated, use stateSetters).
     * @param config.key Unique key for the state.
     * @param config.value Initial value for the state.
     * @param config.description Optional description for AI metadata.
     * @param config.schema Zod schema for value validation.
     */
    registerState: <T extends BasicStateValue>(config: {
        key: string;
        value: T;
        setValue?: BaseSetter<T>;
        description?: string;
        schema?: ZodSchema<T>;
        stateSetters?: Record<string, Setter<T, z.ZodTypeAny>>;
        /** @deprecated Use stateSetters instead */
        customSetters?: Record<string, Setter<T, z.ZodTypeAny>>;
    }) => void;
    getState: (key: string) => registeredState | undefined;
    addStateSetters: (key: string, setters: Record<string, Setter<BasicStateValue, z.ZodTypeAny>>) => boolean;
    /** @deprecated Use addStateSetters instead */
    addCustomSetters: (key: string, setters: Record<string, Setter<BasicStateValue, z.ZodTypeAny>>) => boolean;
    /**
     * Execute a named state setter for a state.
     * @param params Object containing key, setterKey, optional options, and optional args
     */
    executeStateSetter: (params: ExecuteStateSetterParams) => void;
    /** @deprecated Use executeStateSetter instead */
    executeCustomSetter: (params: ExecuteCustomSetterParams) => void;
    /** Retrieves the stored value for a given state key */
    getCedarState: (key: string) => BasicStateValue | undefined;
    /**
     * Set a registered state value and call its external setter if provided.
     * @param key The state key.
     * @param value The new value to set.
     */
    setCedarState: <T extends BasicStateValue>(key: string, value: T) => void;
    /**
     * Unregister a state from the store.
     * @param key The state key to unregister.
     */
    unregisterState: (key: string) => void;
}
declare const createStateSlice: StateCreator<CedarStore, [], [], StateSlice>;
declare function isRegisteredState<T>(value: unknown): value is registeredState<T>;

type ChatInput = JSONContent;
interface AgentContextSlice {
    chatInputContent: ChatInput | null;
    setChatInputContent: (content: ChatInput) => void;
    overrideInputContent: {
        input: string | JSONContent[] | null;
    };
    setOverrideInputContent: (content: string | JSONContent[] | null) => void;
    additionalContext: AdditionalContext;
    addContextEntry: (key: string, entry: ContextEntry) => void;
    removeContextEntry: (key: string, entryId: string) => void;
    clearContextBySource: (source: ContextEntry['source']) => void;
    clearMentions: () => void;
    updateAdditionalContext: (context: Record<string, unknown>) => void;
    putAdditionalContext: <T>(key: string, value: unknown, options?: {
        icon?: ReactNode;
        color?: string;
        labelField?: string | ((item: T) => string);
        order?: number;
        showInChat?: boolean;
    }) => void;
    mentionProviders: Map<string, MentionProvider>;
    registerMentionProvider: (provider: MentionProvider) => void;
    unregisterMentionProvider: (providerId: string) => void;
    getMentionProvidersByTrigger: (trigger: string) => MentionProvider[];
    collapsingConfigs: Map<string, {
        threshold: number;
        label?: string;
        icon?: ReactNode;
    }>;
    collapsingConfigRefs: Map<string, Set<string>>;
    setCollapsingConfig: (key: string, config: boolean | number | {
        threshold: number;
        label?: string;
        icon?: ReactNode;
    }, componentId: string) => void;
    removeCollapsingConfig: (key: string, componentId: string) => void;
    stringifyEditor: () => string;
    stringifyInputContext: () => string;
    compileAdditionalContext: () => AdditionalContextParam<Record<string, never>>;
    compileFrontendTools: () => Record<string, {
        name: string;
        description?: string;
        argsSchema: Record<string, unknown>;
    }>;
    compileStateSetters: () => Record<string, unknown>;
}
declare const createAgentContextSlice: StateCreator<CedarStore, [
], [
], AgentContextSlice>;
type ElementType<T> = T extends readonly (infer E)[] ? E : T;
/**
 * Subscribe the agent's context to a Cedar state
 * @param stateKey - The key of the state to subscribe to
 * @param mapFn - A function that maps the state to a record of context entries
 * @param options - Optional configuration for the context entries
 */
declare function useSubscribeStateToAgentContext<T>(stateKey: string, mapFn: (state: T) => Record<string, unknown>, options?: {
    icon?: ReactNode | ((item: ElementType<T>) => ReactNode);
    color?: string;
    labelField?: string | ((item: ElementType<T>) => string);
    order?: number;
    /** If false, the generated context entries will not be rendered as badges in the chat UI. Can also be a function to filter specific entries. */
    showInChat?: boolean | ((entry: ContextEntry) => boolean);
    /** Collapse multiple entries into a single badge. Can be boolean (default threshold 5), number (custom threshold), or object with full configuration */
    collapse?: boolean | number | {
        threshold: number;
        label?: string;
        icon?: ReactNode;
    };
}): void;
declare function useRenderAdditionalContext(renderers: Record<string, (entry: ContextEntry) => ReactNode>): ReactNode[];

interface StylingConfig {
    darkMode: boolean;
    color: string;
    secondaryColor: string;
    accentColor: string;
}
interface StylingState {
    styling: StylingConfig;
}
interface StylingActions {
    setStyling: (styling: Partial<StylingConfig>) => void;
    toggleDarkMode: () => void;
}
type StylingSlice = StylingState & StylingActions;
declare const createStylingSlice: StateCreator<CedarStore, [
], [
], StylingSlice>;

interface ChatResponse {
    messages: Message[];
}
interface BaseMessage {
    id: string;
    role: MessageRole;
    content: string;
    createdAt?: string;
    metadata?: Record<string, unknown>;
    type: string;
}
type TypedMessage<T extends string, P = {}> = BaseMessage & {
    type: T;
} & P;
type MessageRole = 'bot' | 'user' | 'assistant';
type MessageInput = (Omit<TextMessage, 'id'> & {
    id?: string;
}) | (Omit<StorylineMessage, 'id'> & {
    id?: string;
}) | (Omit<MultipleChoiceMessage, 'id'> & {
    id?: string;
}) | (Omit<TodoListMessage, 'id'> & {
    id?: string;
}) | (Omit<DialogueOptionsMessage, 'id'> & {
    id?: string;
}) | (Omit<TickerMessage, 'id'> & {
    id?: string;
}) | (Omit<SliderMessage, 'id'> & {
    id?: string;
}) | (Omit<CustomMessage<string, Record<string, unknown>>, 'id'> & {
    id?: string;
});
type DefaultMessage = TextMessage | TodoListMessage | TickerMessage | DialogueOptionsMessage | MultipleChoiceMessage | StorylineMessage | SliderMessage;
type MessageByType<T extends string, M = DefaultMessage> = Extract<M, {
    type: T;
}>;
type Message = DefaultMessage | CustomMessage<string, object>;
type TextMessage = BaseMessage & {
    type: 'text';
};
type StorylineMessage = BaseMessage & {
    type: 'storyline';
    sections: StorylineSection[];
};
type StorylineSection = {
    type: 'storyline_section';
    title: string;
    icon?: string;
    description: string;
} | string;
interface TodoListItem {
    text: string;
    done: boolean;
    description?: string;
}
interface TodoListMessage extends BaseMessage {
    type: 'todolist';
    items: TodoListItem[];
}
interface MultipleChoiceMessage extends BaseMessage {
    type: 'multiple_choice';
    choices: string[];
    allowFreeInput?: boolean;
    multiselect?: boolean;
    /** Optional callback when a choice is selected */
    onChoice?: (choice: string, store: CedarStore) => void;
}
interface TickerButton {
    title: string;
    description: string;
    icon?: ReactNode;
    colour?: string;
}
/** Message type for ticker display */
interface TickerMessage extends BaseMessage {
    type: 'ticker';
    buttons: TickerButton[];
    /** Optional callback when Next is clicked */
    onChoice?: (store: CedarStore) => void;
}
interface DialogueOptionChoice {
    title: string;
    description?: string;
    icon?: ReactNode;
    hoverText?: string;
}
interface DialogueOptionsMessage extends BaseMessage {
    type: 'dialogue_options';
    options: DialogueOptionChoice[];
    allowFreeInput?: boolean;
    /** Optional callback when an option is selected */
    onChoice?: (choice: DialogueOptionChoice | string, store: CedarStore) => void;
}
interface SliderMessage extends BaseMessage {
    type: 'slider';
    min: number;
    max: number;
    onChange?: (value: number, store: CedarStore) => void;
}
type CustomMessage<T extends string, P extends object = Record<string, never>> = BaseMessage & {
    type: T;
} & P;
type MessageRenderer<T extends Message = Message> = {
    type: T['type'];
    render: (message: T) => ReactNode;
    namespace?: string;
    validateMessage?: (message: Message) => message is T;
};
type MessageRendererRegistry = Record<string, MessageRenderer | undefined>;
interface MessageThread {
    id: string;
    name?: string;
    lastLoaded: string;
    messages: Message[];
}
type MessageThreadMap = Record<string, MessageThread>;
declare const DEFAULT_THREAD_ID = "default-thread";

interface MessageStorageBaseAdapter {
    loadMessages?(userId: string, threadId: string): Promise<Message[]>;
    persistMessage?(userId: string, threadId: string, message: Message): Promise<Message>;
    listThreads?(userId: string): Promise<MessageThreadMeta[]>;
    createThread?(userId: string, threadId: string, meta: MessageThreadMeta): Promise<MessageThreadMeta>;
    updateThread?(userId: string, threadId: string, meta: MessageThreadMeta): Promise<MessageThreadMeta>;
    deleteThread?(userId: string, threadId: string): Promise<MessageThreadMeta | undefined>;
    updateMessage?(userId: string, threadId: string, message: Message): Promise<Message>;
    deleteMessage?(userId: string, threadId: string, messageId: string): Promise<Message | undefined>;
}
interface LocalAdapterOptions {
    key?: string;
}
type MessageStorageLocalAdapter = MessageStorageBaseAdapter & {
    type: 'local';
};
type MessageStorageNoopAdapter = MessageStorageBaseAdapter & {
    type: 'none';
};
type MessageStorageCustomAdapter = MessageStorageBaseAdapter & {
    type: 'custom';
};
type MessageStorageAdapter = MessageStorageLocalAdapter | MessageStorageNoopAdapter | MessageStorageCustomAdapter;
type MessageStorageConfig = {
    type: 'local';
    options?: LocalAdapterOptions;
} | {
    type: 'none';
} | {
    type: 'custom';
    adapter: MessageStorageBaseAdapter;
};
declare const createMessageStorageAdapter: (cfg?: MessageStorageConfig) => MessageStorageAdapter;
interface MessageThreadMeta {
    id: string;
    title: string;
    updatedAt: string;
}
interface MessageStorageState {
    messageStorageAdapter: MessageStorageAdapter | undefined;
    setMessageStorageAdapter: (cfg?: MessageStorageConfig) => void;
    persistMessageStorageMessage: (message: Message) => Promise<void>;
    initializeChat: (params?: {
        userId?: string | null;
        threadId?: string | null;
    }) => Promise<void>;
}
declare function getMessageStorageState(set: {
    (partial: CedarStore | Partial<CedarStore> | ((state: CedarStore) => CedarStore | Partial<CedarStore>), replace?: false): void;
    (state: CedarStore | ((state: CedarStore) => CedarStore), replace: true): void;
}, get: () => CedarStore & MessageStorageState): MessageStorageState;

type MessagesSlice = MessageStorageState & {
    threadMap: MessageThreadMap;
    mainThreadId: string;
    isProcessing: boolean;
    showChat: boolean;
    messageRenderers: MessageRendererRegistry;
    messages: Message[];
    setMessages: (messages: Message[], threadId?: string) => void;
    addMessage: (message: MessageInput, isComplete?: boolean, threadId?: string) => Message;
    appendToLatestMessage: (content: string, isComplete?: boolean, threadId?: string) => Message;
    updateMessage: (id: string, updates: Partial<Message>, threadId?: string) => void;
    deleteMessage: (id: string, threadId?: string) => void;
    clearMessages: (threadId?: string) => void;
    setMainThreadId: (threadId: string) => void;
    createThread: (threadId?: string, name?: string) => string;
    deleteThread: (threadId: string) => void;
    switchThread: (threadId: string, name?: string) => void;
    updateThreadName: (threadId: string, name: string) => void;
    getThread: (threadId?: string) => MessageThread | undefined;
    getThreadMessages: (threadId?: string) => Message[];
    getAllThreadIds: () => string[];
    getCurrentThreadId: () => string;
    getMessageById: (id: string, threadId?: string) => Message | undefined;
    getMessagesByRole: (role: Message['role'], threadId?: string) => Message[];
    registerMessageRenderer: <T extends Message>(config: MessageRenderer<T>) => void;
    unregisterMessageRenderer: (type: string, namespace?: string) => void;
    getMessageRenderers: (type: string) => MessageRenderer | undefined;
    setIsProcessing: (isProcessing: boolean) => void;
    setShowChat: (showChat: boolean) => void;
};
declare const createMessagesSlice: StateCreator<CedarStore, [
], [
], MessagesSlice>;

type SendMessageParams<T extends Record<string, z.ZodTypeAny> = Record<string, never>, // backend context data schemas
E = object> = BaseParams<T, E> & {
    model?: string;
    route?: string;
    resourceId?: string;
    userId?: string;
    threadId?: string;
};
type AnyProviderParams<T extends Record<string, z.ZodTypeAny> = Record<string, never>, E = object> = OpenAIParams | AnthropicParams | MastraParams<T, E> | AISDKParams | CustomParams<T, E>;
type GetParamsForConfig<T> = T extends {
    provider: 'openai';
} ? OpenAIParams : T extends {
    provider: 'anthropic';
} ? AnthropicParams : T extends {
    provider: 'mastra';
} ? MastraParams : T extends {
    provider: 'ai-sdk';
} ? AISDKParams : T extends {
    provider: 'custom';
} ? CustomParams : BaseParams;
interface AgentConnectionSlice {
    isConnected: boolean;
    isStreaming: boolean;
    providerConfig: ProviderConfig | null;
    currentAbortController: AbortController | null;
    responseProcessors: ResponseProcessorRegistry;
    currentRequestId: string | null;
    callLLM: <T extends Record<string, z.ZodTypeAny> = Record<string, never>, E = object>(params: AnyProviderParams<T, E>) => Promise<LLMResponse>;
    callLLMStructured: <T extends Record<string, z.ZodTypeAny> = Record<string, never>, E = object>(params: AnyProviderParams<T, E> & StructuredParams<T, E>) => Promise<LLMResponse>;
    streamLLM: <T extends Record<string, z.ZodTypeAny> = Record<string, never>, E = object>(params: AnyProviderParams<T, E>, handler: StreamHandler) => StreamResponse;
    voiceLLM: (params: VoiceParams) => Promise<VoiceLLMResponse>;
    voiceStreamLLM: (params: VoiceParams, handler: VoiceStreamHandler) => StreamResponse;
    sendMessage: <T extends Record<string, z.ZodTypeAny> = Record<string, never>, E = object>(params?: SendMessageParams<T, E>) => Promise<void>;
    handleLLMResponse: (items: (string | StructuredResponseType)[]) => Promise<void>;
    registerResponseProcessor: <T extends StructuredResponseType>(processor: ResponseProcessor<T>) => void;
    getResponseProcessors: (type: string) => ResponseProcessor | undefined;
    processStructuredResponse: (obj: StructuredResponseType) => Promise<boolean>;
    setProviderConfig: (config: ProviderConfig) => void;
    connect: () => Promise<void>;
    disconnect: () => void;
    cancelStream: () => void;
    notificationInterval?: number;
    subscribeToNotifications: () => void;
    unsubscribeFromNotifications: () => void;
}
type TypedAgentConnectionSlice<T extends ProviderConfig> = Omit<AgentConnectionSlice, 'callLLM' | 'streamLLM' | 'callLLMStructured' | 'voiceLLM' | 'voiceStreamLLM'> & {
    callLLM: (params: GetParamsForConfig<T>) => Promise<LLMResponse>;
    callLLMStructured: (params: GetParamsForConfig<T> & StructuredParams) => Promise<LLMResponse>;
    streamLLM: (params: GetParamsForConfig<T>, handler: StreamHandler) => StreamResponse;
    voiceLLM: (params: VoiceParams) => Promise<VoiceLLMResponse>;
    voiceStreamLLM: (params: VoiceParams, handler: VoiceStreamHandler) => StreamResponse;
};
declare const createAgentConnectionSlice: StateCreator<CedarStore, [
], [
], AgentConnectionSlice>;

interface VoiceState {
    isVoiceEnabled: boolean;
    isListening: boolean;
    isSpeaking: boolean;
    voicePermissionStatus: 'granted' | 'denied' | 'prompt' | 'not-supported';
    audioStream: MediaStream | null;
    audioContext: AudioContext | null;
    mediaRecorder: MediaRecorder | null;
    voiceError: string | null;
    voiceSettings: {
        language: string;
        voiceId?: string;
        pitch?: number;
        rate?: number;
        volume?: number;
        useBrowserTTS?: boolean;
        autoAddToMessages?: boolean;
        endpoint?: string;
        stream?: boolean;
    };
}
interface VoiceActions {
    requestVoicePermission: () => Promise<void>;
    checkVoiceSupport: () => boolean;
    startListening: () => Promise<void>;
    stopListening: () => void;
    toggleVoice: () => void;
    streamAudioToEndpoint: (audioData: Blob) => Promise<void>;
    streamAudioToEndpointStream: (audioData: Blob) => Promise<void>;
    handleLLMVoice: (response: VoiceLLMResponse) => Promise<void>;
    playAudioResponse: (audioUrl: string | ArrayBuffer) => Promise<void>;
    setVoiceEndpoint: (endpoint: string) => void;
    updateVoiceSettings: (settings: Partial<VoiceState['voiceSettings']>) => void;
    setVoiceError: (error: string | null) => void;
    resetVoiceState: () => void;
}
type VoiceSlice = VoiceState & VoiceActions;
declare const createVoiceSlice: StateCreator<CedarStore, [], [], VoiceSlice>;

interface DebugLogEntry {
    id: string;
    timestamp: Date;
    type: 'request' | 'response' | 'error' | 'stream-start' | 'stream-complete' | 'stream-error' | 'handler';
    provider?: string;
    apiRoute?: string;
    processorName?: string;
    data: {
        params?: BaseParams;
        response?: LLMResponse;
        error?: Error;
        streamContent?: string;
        streamObjects?: object[];
        completedItems?: (string | object)[];
        handledObject?: StructuredResponseType;
        handlers?: Array<{
            processorName: string;
            handledObject: StructuredResponseType;
        }>;
    };
    duration?: number;
}
interface StreamTracker {
    streamId: string;
    startTime: Date;
    provider?: string;
    params?: BaseParams;
    chunks: string[];
    objects: object[];
    handlers: Array<{
        processorName: string;
        handledObject: StructuredResponseType;
    }>;
}
interface RequestTracker {
    requestId: string;
    startTime: Date;
    handlers: Array<{
        processorName: string;
        handledObject: StructuredResponseType;
    }>;
}
interface DebuggerSlice {
    agentConnectionLogs: DebugLogEntry[];
    maxLogs: number;
    isDebugEnabled: boolean;
    activeStreams: Map<string, StreamTracker>;
    activeRequests: Map<string, RequestTracker>;
    collapsedSections: {
        [stateKey: string]: {
            registeredState?: boolean;
            diffState?: boolean;
        };
    };
    logAgentRequest: (params: BaseParams, provider: string) => string;
    logAgentResponse: (requestId: string, response: LLMResponse) => void;
    logAgentError: (requestId: string, error: Error) => void;
    logStreamStart: (params: BaseParams, provider: string) => string;
    logStreamChunk: (streamId: string, chunk: string) => void;
    logStreamObject: (streamId: string, object: object) => void;
    logStreamEnd: (streamId: string, completedItems?: (string | object)[]) => void;
    logResponseProcessorExecution: (obj: StructuredResponseType, processor: ResponseProcessor, requestOrStreamId?: string) => void;
    clearDebugLogs: () => void;
    setDebugEnabled: (enabled: boolean) => void;
    setMaxLogs: (max: number) => void;
    toggleSectionCollapse: (stateKey: string, section: 'registeredState' | 'diffState') => void;
    setSectionCollapse: (stateKey: string, section: 'registeredState' | 'diffState', collapsed: boolean) => void;
    initializeSectionCollapse: (stateKey: string, hasDiffStates: boolean) => void;
}
declare const createDebuggerSlice: StateCreator<CedarStore, [
], [
], DebuggerSlice>;

interface SpellRegistration {
    id: string;
    activationConditions: ActivationConditions;
    onActivate?: (state: ActivationState) => void;
    onDeactivate?: () => void;
    preventDefaultEvents?: boolean;
    ignoreInputElements?: boolean;
}
interface SpellState {
    isActive: boolean;
    registration: SpellRegistration;
}
type SpellMap = Record<string, SpellState>;
interface SpellSlice {
    /**
     * Map of spell IDs to their state and configuration
     */
    spells: Partial<SpellMap>;
    /**
     * Register a spell with activation conditions
     * This combines adding the spell and setting up activation conditions
     */
    registerSpell: (registration: SpellRegistration) => void;
    /**
     * Unregister a spell and clean up its activation conditions
     */
    unregisterSpell: (spellId: string) => void;
    /** Programmatically activate a spell */
    activateSpell: (spellId: string, triggerData?: ActivationState['triggerData']) => void;
    /** Programmatically deactivate a spell */
    deactivateSpell: (spellId: string) => void;
    /** Toggle a spell's active state programmatically */
    toggleSpell: (spellId: string) => void;
    /** Clear all spells */
    clearSpells: () => void;
}
declare const createSpellSlice: StateCreator<CedarStore, [], [], SpellSlice>;

/**
 * DiffHistorySlice manages diffs so that we can render changes and let the user accept, reject, and manage them.
 * For example, if an agent makes a change to a state, we want the user to be able to see what changed
 * and what they have to accept. To do this, we have to allow behaviour such as rollback,
 * accepting specific diffs, and saving them to the history.
 */
type DiffMode = 'defaultAccept' | 'holdAccept';
/**
 * Configuration for selective diff checking based on JSON paths.
 *
 * @example
 * // Ignore position changes (and all child fields)
 * { type: 'ignore', fields: ['/positionAbsolute'] }
 *
 * // Only consider changes if positionAbsolute changes
 * { type: 'listen', fields: ['/positionAbsolute'] }
 */
interface DiffChecker {
    /**
     * 'ignore': Ignore changes to specified fields and their children
     * 'listen': Only consider changes to specified fields
     */
    type: 'ignore' | 'listen';
    /** Array of JSON paths to ignore or listen to */
    fields: string[];
}
/**
 * Function that computes the final state based on old and new states.
 * Can be used to add diff markers or transform the state before setting.
 */
type ComputeStateFunction<T = unknown> = (oldState: T, newState: T, patches: Operation[]) => T;
interface DiffState<T = any> {
    oldState: T;
    newState: T;
    computedState: T;
    isDiffMode: boolean;
    patches?: Operation[];
}
interface DiffHistoryState<T = any> {
    diffState: DiffState<T>;
    history: DiffState<T>[];
    redoStack: DiffState<T>[];
    diffMode: DiffMode;
    computeState?: ComputeStateFunction<T>;
}
/**
 * Configuration for registerDiffState
 */
interface RegisterDiffStateConfig<T extends BasicStateValue> {
    key: string;
    value: T;
    setValue?: BaseSetter<T>;
    description?: string;
    schema?: ZodSchema<T>;
    stateSetters?: Record<string, Setter<T>>;
    diffMode?: DiffMode;
    computeState?: ComputeStateFunction<T>;
}
interface DiffHistorySlice {
    diffHistoryStates: Record<string, DiffHistoryState>;
    getDiffHistoryState: <T>(key: string) => DiffHistoryState<T> | undefined;
    getDiffState: <T>(key: string) => DiffState<T> | undefined;
    setDiffState: <T>(key: string, diffHistoryState: DiffHistoryState<T>) => void;
    getCleanState: <T>(key: string) => T | undefined;
    getComputedState: <T>(key: string) => T | undefined;
    setComputeStateFunction: <T>(key: string, computeState: ComputeStateFunction<T> | undefined) => void;
    registerDiffState: <T extends BasicStateValue>(config: RegisterDiffStateConfig<T>) => void;
    newDiffState: <T>(key: string, newState: T, isDiffChange?: boolean) => void;
    executeDiffSetter: (key: string, setterKey: string, options?: {
        isDiff?: boolean;
    }, args?: unknown) => void;
    applyPatchesToDiffState: (key: string, patches: Operation[], isDiffChange: boolean) => void;
    acceptAllDiffs: (key: string) => boolean;
    rejectAllDiffs: (key: string) => boolean;
    acceptDiff: <T>(key: string, jsonPath: string, identificationField: string | ((item: T) => unknown), targetId?: unknown, diffMarkerPaths?: string[]) => boolean;
    /**
     * Reject a specific diff change
     * @param key - The state key
     * @param jsonPath - JSON path to the array or field
     * @param identificationField - Field name or function to identify array items (ignored for primitive arrays)
     * @param targetId - The specific item/value to reject
     * @param diffMarkerPaths - Optional paths where diff markers are located
     *
     * For primitive arrays (strings, numbers, booleans):
     * - identificationField is ignored
     * - targetId should be the primitive value to remove
     * - The function will detect primitive arrays automatically
     *
     * @example
     * // For object arrays:
     * rejectDiff('nodes', '/0/data/items', 'id', 'item-123');
     *
     * // For primitive arrays:
     * rejectDiff('nodes', '/0/data/attributeIds', 'value', 'attribute-id-456');
     */
    rejectDiff: <T>(key: string, jsonPath: string, identificationField: string | ((item: T) => unknown), targetId?: unknown, diffMarkerPaths?: string[]) => boolean;
    undo: (key: string) => boolean;
    redo: (key: string) => boolean;
}
declare const createDiffHistorySlice: StateCreator<CedarStore, [
], [
], DiffHistorySlice>;

/**
 * The main Cedar store type that combines all slices
 */
interface CedarStore extends StylingSlice, AgentContextSlice, StateSlice, MessagesSlice, AgentConnectionSlice, VoiceSlice, DebuggerSlice, SpellSlice, DiffHistorySlice, ToolsSlice {
}

interface LLMResponse {
    content: string;
    usage?: {
        promptTokens: number;
        completionTokens: number;
        totalTokens: number;
    };
    metadata?: Record<string, unknown>;
    object?: StructuredResponseType | StructuredResponseType[];
}
interface VoiceLLMResponse extends LLMResponse {
    transcription?: string;
    audioData?: string;
    audioUrl?: string;
    audioFormat?: string;
}
type VoiceParams<T extends Record<string, z.ZodTypeAny> = Record<string, never>, E = object> = BaseParams<T, E> & {
    audioData: Blob;
    voiceSettings: {
        language: string;
        voiceId?: string;
        pitch?: number;
        rate?: number;
        volume?: number;
        useBrowserTTS?: boolean;
        autoAddToMessages?: boolean;
        endpoint?: string;
    };
    context?: object | string;
};
type StreamEvent = {
    type: 'chunk';
    content: string;
} | {
    type: 'object';
    object: StructuredResponseType | StructuredResponseType[];
} | {
    type: 'done';
    completedItems: (string | object)[];
} | {
    type: 'error';
    error: Error;
} | {
    type: 'metadata';
    data: unknown;
};
type VoiceStreamEvent = StreamEvent | {
    type: 'transcription';
    transcription: string;
} | {
    type: 'audio';
    audioData: string;
    audioFormat?: string;
    content: string;
};
type StreamHandler = (event: StreamEvent) => void | Promise<void>;
type VoiceStreamHandler = (event: VoiceStreamEvent) => void | Promise<void>;
interface StreamResponse {
    abort: () => void;
    completion: Promise<void>;
}
type BaseParams<T extends Record<string, z.ZodTypeAny> = Record<string, never>, E = object> = {
    prompt?: string;
    systemPrompt?: string;
    temperature?: number;
    maxTokens?: number;
    stream?: boolean;
    additionalContext?: AdditionalContextParam<T>;
} & E;
interface OpenAIParams extends BaseParams {
    model: string;
    messages?: Array<{
        role: 'system' | 'user' | 'assistant';
        content: string;
    }>;
}
interface AnthropicParams extends BaseParams {
    model: string;
    messages?: Array<{
        role: 'system' | 'user' | 'assistant';
        content: string;
    }>;
}
interface AISDKParams extends BaseParams {
    model: string;
}
type MastraParams<T extends Record<string, z.ZodTypeAny> = Record<string, never>, E = object> = BaseParams<T, E> & {
    route: string;
    resourceId?: string;
    threadId?: string;
};
type CustomParams<T extends Record<string, z.ZodTypeAny> = Record<string, never>, E = object> = BaseParams<T, E> & {
    userId?: string;
    threadId?: string;
};
type StructuredParams<T extends Record<string, z.ZodTypeAny> = Record<string, never>, E = object, TSchema = unknown> = BaseParams<T, E> & {
    schema?: TSchema;
    schemaName?: string;
    schemaDescription?: string;
};
interface AISDKStructuredParams extends BaseParams {
    model: string;
    schema: z.ZodType<unknown>;
    schemaName?: string;
    schemaDescription?: string;
}
type AISDKProviderConfig = {
    openai?: {
        apiKey: string;
    };
    anthropic?: {
        apiKey: string;
    };
    google?: {
        apiKey: string;
    };
    mistral?: {
        apiKey: string;
    };
    xai?: {
        apiKey: string;
    };
};
interface CustomProviderConfig {
    callLLM?: (params: CustomParams, config: {
        provider: 'custom';
        config: CustomProviderConfig;
    }) => Promise<LLMResponse>;
    callLLMStructured?: (params: CustomParams & StructuredParams, config: {
        provider: 'custom';
        config: CustomProviderConfig;
    }) => Promise<LLMResponse>;
    streamLLM?: (params: CustomParams, config: {
        provider: 'custom';
        config: CustomProviderConfig;
    }, handler: StreamHandler) => StreamResponse;
    voiceLLM?: (params: VoiceParams, config: {
        provider: 'custom';
        config: CustomProviderConfig;
    }) => Promise<VoiceLLMResponse>;
    handleResponse?: (response: Response) => Promise<LLMResponse>;
    [key: string]: unknown;
}
type ProviderConfig = {
    provider: 'openai';
    apiKey: string;
} | {
    provider: 'anthropic';
    apiKey: string;
} | {
    provider: 'mastra';
    apiKey?: string;
    baseURL: string;
    chatPath?: string;
    voiceRoute?: string;
    resumePath?: string;
} | {
    provider: 'ai-sdk';
    providers: AISDKProviderConfig;
} | {
    provider: 'custom';
    config: CustomProviderConfig;
};
type InferProviderType<T extends ProviderConfig> = T['provider'];
type InferProviderParams<T extends ProviderConfig> = T extends {
    provider: 'openai';
} ? OpenAIParams : T extends {
    provider: 'anthropic';
} ? AnthropicParams : T extends {
    provider: 'mastra';
} ? MastraParams : T extends {
    provider: 'ai-sdk';
} ? AISDKParams : T extends {
    provider: 'custom';
} ? CustomParams : never;
type InferProviderConfig<P extends ProviderConfig['provider']> = Extract<ProviderConfig, {
    provider: P;
}>;
interface ProviderImplementation<TParams extends BaseParams, TConfig extends ProviderConfig> {
    callLLM: (params: TParams, config: TConfig) => Promise<LLMResponse>;
    callLLMStructured: (params: TParams & StructuredParams, config: TConfig) => Promise<LLMResponse>;
    streamLLM: (params: TParams, config: TConfig, handler: StreamHandler) => StreamResponse;
    voiceLLM: (params: VoiceParams, config: TConfig) => Promise<VoiceLLMResponse>;
    voiceStreamLLM?: (params: VoiceParams, config: TConfig, handler: VoiceStreamHandler) => StreamResponse;
    handleResponse: (response: Response) => Promise<LLMResponse>;
}
interface BaseStructuredResponseType {
    type: string;
    content?: string;
}
interface DefaultStructuredResponseType extends BaseStructuredResponseType {
    content: string;
}
type CustomStructuredResponseType<T extends string, P extends object = Record<string, never>> = BaseStructuredResponseType & {
    type: T;
} & P;
type StructuredResponseType = DefaultStructuredResponseType | CustomStructuredResponseType<string, object>;
interface ResponseProcessor<T extends StructuredResponseType = StructuredResponseType> {
    type: string;
    namespace?: string;
    execute: (obj: T, store: CedarStore) => void | Promise<void>;
    validate?: (obj: StructuredResponseType) => obj is T;
}
type ResponseProcessorExecute<T extends StructuredResponseType = StructuredResponseType> = (obj: T, store: CedarStore) => void | Promise<void>;
type ResponseProcessorRegistry = Record<string, ResponseProcessor | undefined>;
declare const BaseParamsSchema: <TData extends Record<string, z.ZodTypeAny> = Record<string, never>, E extends z.ZodTypeAny = z.ZodType<object>>(dataSchemas?: TData, extraFieldsSchema?: E) => z.ZodIntersection<z.ZodObject<{
    prompt: z.ZodOptional<z.ZodString>;
    systemPrompt: z.ZodOptional<z.ZodString>;
    temperature: z.ZodOptional<z.ZodNumber>;
    maxTokens: z.ZodOptional<z.ZodNumber>;
    stream: z.ZodOptional<z.ZodBoolean>;
    additionalContext: z.ZodOptional<z.ZodUnknown> | z.ZodOptional<z.ZodObject<Record<string, z.ZodTypeAny>, "strip", z.ZodTypeAny, {
        [x: string]: any;
    }, {
        [x: string]: any;
    }>>;
}, "strip", z.ZodTypeAny, {
    systemPrompt?: string | undefined;
    temperature?: number | undefined;
    maxTokens?: number | undefined;
    stream?: boolean | undefined;
    additionalContext?: unknown;
    prompt?: string | undefined;
}, {
    systemPrompt?: string | undefined;
    temperature?: number | undefined;
    maxTokens?: number | undefined;
    stream?: boolean | undefined;
    additionalContext?: unknown;
    prompt?: string | undefined;
}>, E | z.ZodObject<{}, "strip", z.ZodTypeAny, {}, {}>>;
declare const MastraParamsSchema: <TData extends Record<string, z.ZodTypeAny> = Record<string, never>, E extends z.ZodTypeAny = z.ZodType<object>>(dataSchemas?: TData, extraFieldsSchema?: E) => z.ZodIntersection<z.ZodIntersection<z.ZodObject<{
    prompt: z.ZodOptional<z.ZodString>;
    systemPrompt: z.ZodOptional<z.ZodString>;
    temperature: z.ZodOptional<z.ZodNumber>;
    maxTokens: z.ZodOptional<z.ZodNumber>;
    stream: z.ZodOptional<z.ZodBoolean>;
    additionalContext: z.ZodOptional<z.ZodUnknown> | z.ZodOptional<z.ZodObject<Record<string, z.ZodTypeAny>, "strip", z.ZodTypeAny, {
        [x: string]: any;
    }, {
        [x: string]: any;
    }>>;
}, "strip", z.ZodTypeAny, {
    systemPrompt?: string | undefined;
    temperature?: number | undefined;
    maxTokens?: number | undefined;
    stream?: boolean | undefined;
    additionalContext?: unknown;
    prompt?: string | undefined;
}, {
    systemPrompt?: string | undefined;
    temperature?: number | undefined;
    maxTokens?: number | undefined;
    stream?: boolean | undefined;
    additionalContext?: unknown;
    prompt?: string | undefined;
}>, E | z.ZodObject<{}, "strip", z.ZodTypeAny, {}, {}>>, z.ZodObject<{
    route: z.ZodOptional<z.ZodString>;
    resourceId: z.ZodOptional<z.ZodString>;
    threadId: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
    route?: string | undefined;
    resourceId?: string | undefined;
    threadId?: string | undefined;
}, {
    route?: string | undefined;
    resourceId?: string | undefined;
    threadId?: string | undefined;
}>>;
declare const CustomParamsSchema: <TData extends Record<string, z.ZodTypeAny> = Record<string, never>, E extends z.ZodTypeAny = z.ZodType<object>>(dataSchemas?: TData, extraFieldsSchema?: E) => z.ZodIntersection<z.ZodIntersection<z.ZodObject<{
    prompt: z.ZodOptional<z.ZodString>;
    systemPrompt: z.ZodOptional<z.ZodString>;
    temperature: z.ZodOptional<z.ZodNumber>;
    maxTokens: z.ZodOptional<z.ZodNumber>;
    stream: z.ZodOptional<z.ZodBoolean>;
    additionalContext: z.ZodOptional<z.ZodUnknown> | z.ZodOptional<z.ZodObject<Record<string, z.ZodTypeAny>, "strip", z.ZodTypeAny, {
        [x: string]: any;
    }, {
        [x: string]: any;
    }>>;
}, "strip", z.ZodTypeAny, {
    systemPrompt?: string | undefined;
    temperature?: number | undefined;
    maxTokens?: number | undefined;
    stream?: boolean | undefined;
    additionalContext?: unknown;
    prompt?: string | undefined;
}, {
    systemPrompt?: string | undefined;
    temperature?: number | undefined;
    maxTokens?: number | undefined;
    stream?: boolean | undefined;
    additionalContext?: unknown;
    prompt?: string | undefined;
}>, E | z.ZodObject<{}, "strip", z.ZodTypeAny, {}, {}>>, z.ZodObject<{
    userId: z.ZodOptional<z.ZodString>;
    threadId: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
    userId?: string | undefined;
    threadId?: string | undefined;
}, {
    userId?: string | undefined;
    threadId?: string | undefined;
}>>;
declare const OpenAIParamsSchema: z.ZodIntersection<z.ZodIntersection<z.ZodObject<{
    prompt: z.ZodOptional<z.ZodString>;
    systemPrompt: z.ZodOptional<z.ZodString>;
    temperature: z.ZodOptional<z.ZodNumber>;
    maxTokens: z.ZodOptional<z.ZodNumber>;
    stream: z.ZodOptional<z.ZodBoolean>;
    additionalContext: z.ZodOptional<z.ZodUnknown> | z.ZodOptional<z.ZodObject<Record<string, z.ZodTypeAny>, "strip", z.ZodTypeAny, {
        [x: string]: any;
    }, {
        [x: string]: any;
    }>>;
}, "strip", z.ZodTypeAny, {
    systemPrompt?: string | undefined;
    temperature?: number | undefined;
    maxTokens?: number | undefined;
    stream?: boolean | undefined;
    additionalContext?: unknown;
    prompt?: string | undefined;
}, {
    systemPrompt?: string | undefined;
    temperature?: number | undefined;
    maxTokens?: number | undefined;
    stream?: boolean | undefined;
    additionalContext?: unknown;
    prompt?: string | undefined;
}>, z.ZodType<object, z.ZodTypeDef, object> | z.ZodObject<{}, "strip", z.ZodTypeAny, {}, {}>>, z.ZodObject<{
    model: z.ZodString;
}, "strip", z.ZodTypeAny, {
    model: string;
}, {
    model: string;
}>>;
declare const AnthropicParamsSchema: z.ZodIntersection<z.ZodIntersection<z.ZodObject<{
    prompt: z.ZodOptional<z.ZodString>;
    systemPrompt: z.ZodOptional<z.ZodString>;
    temperature: z.ZodOptional<z.ZodNumber>;
    maxTokens: z.ZodOptional<z.ZodNumber>;
    stream: z.ZodOptional<z.ZodBoolean>;
    additionalContext: z.ZodOptional<z.ZodUnknown> | z.ZodOptional<z.ZodObject<Record<string, z.ZodTypeAny>, "strip", z.ZodTypeAny, {
        [x: string]: any;
    }, {
        [x: string]: any;
    }>>;
}, "strip", z.ZodTypeAny, {
    systemPrompt?: string | undefined;
    temperature?: number | undefined;
    maxTokens?: number | undefined;
    stream?: boolean | undefined;
    additionalContext?: unknown;
    prompt?: string | undefined;
}, {
    systemPrompt?: string | undefined;
    temperature?: number | undefined;
    maxTokens?: number | undefined;
    stream?: boolean | undefined;
    additionalContext?: unknown;
    prompt?: string | undefined;
}>, z.ZodType<object, z.ZodTypeDef, object> | z.ZodObject<{}, "strip", z.ZodTypeAny, {}, {}>>, z.ZodObject<{
    model: z.ZodString;
}, "strip", z.ZodTypeAny, {
    model: string;
}, {
    model: string;
}>>;
declare const AISDKParamsSchema: z.ZodIntersection<z.ZodIntersection<z.ZodObject<{
    prompt: z.ZodOptional<z.ZodString>;
    systemPrompt: z.ZodOptional<z.ZodString>;
    temperature: z.ZodOptional<z.ZodNumber>;
    maxTokens: z.ZodOptional<z.ZodNumber>;
    stream: z.ZodOptional<z.ZodBoolean>;
    additionalContext: z.ZodOptional<z.ZodUnknown> | z.ZodOptional<z.ZodObject<Record<string, z.ZodTypeAny>, "strip", z.ZodTypeAny, {
        [x: string]: any;
    }, {
        [x: string]: any;
    }>>;
}, "strip", z.ZodTypeAny, {
    systemPrompt?: string | undefined;
    temperature?: number | undefined;
    maxTokens?: number | undefined;
    stream?: boolean | undefined;
    additionalContext?: unknown;
    prompt?: string | undefined;
}, {
    systemPrompt?: string | undefined;
    temperature?: number | undefined;
    maxTokens?: number | undefined;
    stream?: boolean | undefined;
    additionalContext?: unknown;
    prompt?: string | undefined;
}>, z.ZodType<object, z.ZodTypeDef, object> | z.ZodObject<{}, "strip", z.ZodTypeAny, {}, {}>>, z.ZodObject<{
    model: z.ZodString;
}, "strip", z.ZodTypeAny, {
    model: string;
}, {
    model: string;
}>>;
declare const BaseStructuredResponseSchema: z.ZodObject<{
    type: z.ZodString;
    content: z.ZodOptional<z.ZodString>;
}, "passthrough", z.ZodTypeAny, z.objectOutputType<{
    type: z.ZodString;
    content: z.ZodOptional<z.ZodString>;
}, z.ZodTypeAny, "passthrough">, z.objectInputType<{
    type: z.ZodString;
    content: z.ZodOptional<z.ZodString>;
}, z.ZodTypeAny, "passthrough">>;
declare const StructuredResponseSchema: <T extends string>(type: T) => z.ZodObject<{
    type: z.ZodLiteral<T>;
    content: z.ZodOptional<z.ZodString>;
}, "passthrough", z.ZodTypeAny, z.objectOutputType<{
    type: z.ZodLiteral<T>;
    content: z.ZodOptional<z.ZodString>;
}, z.ZodTypeAny, "passthrough">, z.objectInputType<{
    type: z.ZodLiteral<T>;
    content: z.ZodOptional<z.ZodString>;
}, z.ZodTypeAny, "passthrough">>;
declare const LLMResponseSchema: <T extends z.ZodTypeAny = z.ZodUnknown>(objectSchema?: T) => z.ZodObject<{
    content: z.ZodString;
    object: z.ZodOptional<z.ZodUnion<[z.ZodObject<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">>, z.ZodArray<z.ZodObject<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">>, "many">]>> | z.ZodOptional<z.ZodUnion<[T, z.ZodArray<T, "many">]>>;
    usage: z.ZodOptional<z.ZodObject<{
        promptTokens: z.ZodNumber;
        completionTokens: z.ZodNumber;
        totalTokens: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        promptTokens: number;
        completionTokens: number;
        totalTokens: number;
    }, {
        promptTokens: number;
        completionTokens: number;
        totalTokens: number;
    }>>;
    metadata: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>;
}, "strip", z.ZodTypeAny, z.objectUtil.addQuestionMarks<z.baseObjectOutputType<{
    content: z.ZodString;
    object: z.ZodOptional<z.ZodUnion<[z.ZodObject<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">>, z.ZodArray<z.ZodObject<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">>, "many">]>> | z.ZodOptional<z.ZodUnion<[T, z.ZodArray<T, "many">]>>;
    usage: z.ZodOptional<z.ZodObject<{
        promptTokens: z.ZodNumber;
        completionTokens: z.ZodNumber;
        totalTokens: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        promptTokens: number;
        completionTokens: number;
        totalTokens: number;
    }, {
        promptTokens: number;
        completionTokens: number;
        totalTokens: number;
    }>>;
    metadata: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>;
}>, any> extends infer T_1 ? { [k in keyof T_1]: z.objectUtil.addQuestionMarks<z.baseObjectOutputType<{
    content: z.ZodString;
    object: z.ZodOptional<z.ZodUnion<[z.ZodObject<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">>, z.ZodArray<z.ZodObject<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">>, "many">]>> | z.ZodOptional<z.ZodUnion<[T, z.ZodArray<T, "many">]>>;
    usage: z.ZodOptional<z.ZodObject<{
        promptTokens: z.ZodNumber;
        completionTokens: z.ZodNumber;
        totalTokens: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        promptTokens: number;
        completionTokens: number;
        totalTokens: number;
    }, {
        promptTokens: number;
        completionTokens: number;
        totalTokens: number;
    }>>;
    metadata: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>;
}>, any>[k]; } : never, z.baseObjectInputType<{
    content: z.ZodString;
    object: z.ZodOptional<z.ZodUnion<[z.ZodObject<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">>, z.ZodArray<z.ZodObject<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">>, "many">]>> | z.ZodOptional<z.ZodUnion<[T, z.ZodArray<T, "many">]>>;
    usage: z.ZodOptional<z.ZodObject<{
        promptTokens: z.ZodNumber;
        completionTokens: z.ZodNumber;
        totalTokens: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        promptTokens: number;
        completionTokens: number;
        totalTokens: number;
    }, {
        promptTokens: number;
        completionTokens: number;
        totalTokens: number;
    }>>;
    metadata: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>;
}> extends infer T_2 ? { [k_1 in keyof T_2]: z.baseObjectInputType<{
    content: z.ZodString;
    object: z.ZodOptional<z.ZodUnion<[z.ZodObject<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">>, z.ZodArray<z.ZodObject<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">>, "many">]>> | z.ZodOptional<z.ZodUnion<[T, z.ZodArray<T, "many">]>>;
    usage: z.ZodOptional<z.ZodObject<{
        promptTokens: z.ZodNumber;
        completionTokens: z.ZodNumber;
        totalTokens: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        promptTokens: number;
        completionTokens: number;
        totalTokens: number;
    }, {
        promptTokens: number;
        completionTokens: number;
        totalTokens: number;
    }>>;
    metadata: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>;
}>[k_1]; } : never>;
declare const StreamEventSchema: z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
    type: z.ZodLiteral<"chunk">;
    content: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "chunk";
    content: string;
}, {
    type: "chunk";
    content: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"object">;
    object: z.ZodUnion<[z.ZodObject<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">>, z.ZodArray<z.ZodObject<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">>, "many">]>;
}, "strip", z.ZodTypeAny, {
    object: z.objectOutputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough"> | z.objectOutputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">[];
    type: "object";
}, {
    object: z.objectInputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough"> | z.objectInputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">[];
    type: "object";
}>, z.ZodObject<{
    type: z.ZodLiteral<"done">;
    completedItems: z.ZodArray<z.ZodUnion<[z.ZodString, z.ZodRecord<z.ZodString, z.ZodUnknown>]>, "many">;
}, "strip", z.ZodTypeAny, {
    type: "done";
    completedItems: (string | Record<string, unknown>)[];
}, {
    type: "done";
    completedItems: (string | Record<string, unknown>)[];
}>, z.ZodObject<{
    type: z.ZodLiteral<"error">;
    error: z.ZodUnknown;
}, "strip", z.ZodTypeAny, {
    type: "error";
    error?: unknown;
}, {
    type: "error";
    error?: unknown;
}>]>;
declare const VoiceLLMResponseSchema: <T extends z.ZodTypeAny = z.ZodUnknown>(objectSchema?: T) => z.ZodIntersection<z.ZodObject<{
    content: z.ZodString;
    object: z.ZodOptional<z.ZodUnion<[z.ZodObject<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">>, z.ZodArray<z.ZodObject<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">>, "many">]>> | z.ZodOptional<z.ZodUnion<[T, z.ZodArray<T, "many">]>>;
    usage: z.ZodOptional<z.ZodObject<{
        promptTokens: z.ZodNumber;
        completionTokens: z.ZodNumber;
        totalTokens: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        promptTokens: number;
        completionTokens: number;
        totalTokens: number;
    }, {
        promptTokens: number;
        completionTokens: number;
        totalTokens: number;
    }>>;
    metadata: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>;
}, "strip", z.ZodTypeAny, z.objectUtil.addQuestionMarks<z.baseObjectOutputType<{
    content: z.ZodString;
    object: z.ZodOptional<z.ZodUnion<[z.ZodObject<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">>, z.ZodArray<z.ZodObject<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">>, "many">]>> | z.ZodOptional<z.ZodUnion<[T, z.ZodArray<T, "many">]>>;
    usage: z.ZodOptional<z.ZodObject<{
        promptTokens: z.ZodNumber;
        completionTokens: z.ZodNumber;
        totalTokens: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        promptTokens: number;
        completionTokens: number;
        totalTokens: number;
    }, {
        promptTokens: number;
        completionTokens: number;
        totalTokens: number;
    }>>;
    metadata: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>;
}>, any> extends infer T_1 ? { [k in keyof T_1]: z.objectUtil.addQuestionMarks<z.baseObjectOutputType<{
    content: z.ZodString;
    object: z.ZodOptional<z.ZodUnion<[z.ZodObject<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">>, z.ZodArray<z.ZodObject<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">>, "many">]>> | z.ZodOptional<z.ZodUnion<[T, z.ZodArray<T, "many">]>>;
    usage: z.ZodOptional<z.ZodObject<{
        promptTokens: z.ZodNumber;
        completionTokens: z.ZodNumber;
        totalTokens: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        promptTokens: number;
        completionTokens: number;
        totalTokens: number;
    }, {
        promptTokens: number;
        completionTokens: number;
        totalTokens: number;
    }>>;
    metadata: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>;
}>, any>[k]; } : never, z.baseObjectInputType<{
    content: z.ZodString;
    object: z.ZodOptional<z.ZodUnion<[z.ZodObject<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">>, z.ZodArray<z.ZodObject<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">>, "many">]>> | z.ZodOptional<z.ZodUnion<[T, z.ZodArray<T, "many">]>>;
    usage: z.ZodOptional<z.ZodObject<{
        promptTokens: z.ZodNumber;
        completionTokens: z.ZodNumber;
        totalTokens: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        promptTokens: number;
        completionTokens: number;
        totalTokens: number;
    }, {
        promptTokens: number;
        completionTokens: number;
        totalTokens: number;
    }>>;
    metadata: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>;
}> extends infer T_2 ? { [k_1 in keyof T_2]: z.baseObjectInputType<{
    content: z.ZodString;
    object: z.ZodOptional<z.ZodUnion<[z.ZodObject<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">>, z.ZodArray<z.ZodObject<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
        type: z.ZodString;
        content: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">>, "many">]>> | z.ZodOptional<z.ZodUnion<[T, z.ZodArray<T, "many">]>>;
    usage: z.ZodOptional<z.ZodObject<{
        promptTokens: z.ZodNumber;
        completionTokens: z.ZodNumber;
        totalTokens: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        promptTokens: number;
        completionTokens: number;
        totalTokens: number;
    }, {
        promptTokens: number;
        completionTokens: number;
        totalTokens: number;
    }>>;
    metadata: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>;
}>[k_1]; } : never>, z.ZodObject<{
    transcription: z.ZodOptional<z.ZodString>;
    audioData: z.ZodOptional<z.ZodString>;
    audioUrl: z.ZodOptional<z.ZodString>;
    audioFormat: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
    transcription?: string | undefined;
    audioData?: string | undefined;
    audioUrl?: string | undefined;
    audioFormat?: string | undefined;
}, {
    transcription?: string | undefined;
    audioData?: string | undefined;
    audioUrl?: string | undefined;
    audioFormat?: string | undefined;
}>>;

export { type ProviderConfig as $, type StorylineSection as A, type BasicStateValue as B, type ChatResponse as C, type DefaultMessage as D, type ExecuteStateSetterParams as E, type TickerButton as F, type TickerMessage as G, type TodoListItem as H, type TodoListMessage as I, type TypedMessage as J, type MessageThread as K, type MessageThreadMap as L, type Message as M, DEFAULT_THREAD_ID as N, type StylingSlice as O, type CedarStore as P, type AISDKParams as Q, type AnthropicParams as R, type Setter as S, type TextMessage as T, type BaseParams as U, type CustomParams as V, type InferProviderParams as W, type InferProviderType as X, type LLMResponse as Y, type MastraParams as Z, type OpenAIParams as _, createAgentContextSlice as a, type MessageStorageState as a$, type StreamEvent as a0, type StreamHandler as a1, type StreamResponse as a2, type BaseStructuredResponseType as a3, type DefaultStructuredResponseType as a4, type CustomStructuredResponseType as a5, type StructuredResponseType as a6, type ResponseProcessor as a7, type ResponseProcessorRegistry as a8, type SendMessageParams as a9, type ChatInput as aA, type DebugLogEntry as aB, type SpellMap as aC, type SpellRegistration as aD, type StylingConfig as aE, createVoiceSlice as aF, type VoiceSlice as aG, type VoiceActions as aH, createSpellSlice as aI, type SpellState as aJ, type BaseSetter as aK, type DiffChecker as aL, type ProviderImplementation as aM, type InferProviderConfig as aN, type ResponseProcessorExecute as aO, type AISDKStructuredParams as aP, type VoiceParams as aQ, type VoiceLLMResponse as aR, type VoiceStreamHandler as aS, type CustomProviderConfig as aT, isRegisteredState as aU, type AgentContextSlice as aV, type StylingState as aW, type StylingActions as aX, type MessageStorageBaseAdapter as aY, type LocalAdapterOptions as aZ, createMessageStorageAdapter as a_, BaseParamsSchema as aa, MastraParamsSchema as ab, CustomParamsSchema as ac, OpenAIParamsSchema as ad, AnthropicParamsSchema as ae, AISDKParamsSchema as af, LLMResponseSchema as ag, BaseStructuredResponseSchema as ah, StructuredResponseSchema as ai, StreamEventSchema as aj, VoiceLLMResponseSchema as ak, type MessageStorageConfig as al, type MessageThreadMeta as am, type MessageStorageCustomAdapter as an, type MessageStorageLocalAdapter as ao, type MessageStorageNoopAdapter as ap, type MessageStorageAdapter as aq, type VoiceState as ar, type SpellSlice as as, type DiffMode as at, type DiffState as au, type DiffHistoryState as av, type DiffHistorySlice as aw, type RegisterDiffStateConfig as ax, type ComputeStateFunction as ay, createDiffHistorySlice as az, createMessagesSlice as b, getMessageStorageState as b0, type MessagesSlice as b1, type AnyProviderParams as b2, type AgentConnectionSlice as b3, type TypedAgentConnectionSlice as b4, type DebuggerSlice as b5, createDebuggerSlice as b6, type VoiceStreamEvent as b7, type StructuredParams as b8, type AISDKProviderConfig as b9, createAgentConnectionSlice as c, createStateSlice as d, createStylingSlice as e, type SetterFunction as f, type SetterArgs as g, type StateSlice as h, type ExecuteStateSetterOptions as i, type ExecuteCustomSetterParams as j, type ExecuteCustomSetterOptions as k, useSubscribeStateToAgentContext as l, type BaseMessage as m, type CustomMessage as n, type DialogueOptionChoice as o, type DialogueOptionsMessage as p, type MessageByType as q, type registeredState as r, type MessageInput as s, type MessageRenderer as t, useRenderAdditionalContext as u, type MessageRendererRegistry as v, type MessageRole as w, type MultipleChoiceMessage as x, type SliderMessage as y, type StorylineMessage as z };
