{"version":3,"sources":["../../../src/store/voice/voiceSlice.ts"],"sourcesContent":["import { StateCreator } from 'zustand';\nimport type { CedarStore } from '@/store/CedarOSTypes';\nimport type {\n\tStructuredResponseType,\n\tVoiceLLMResponse,\n} from '@/store/agentConnection/AgentConnectionTypes';\n\nexport interface VoiceState {\n\t// Voice state\n\tisVoiceEnabled: boolean;\n\tisListening: boolean;\n\tisSpeaking: boolean;\n\tvoicePermissionStatus: 'granted' | 'denied' | 'prompt' | 'not-supported';\n\taudioStream: MediaStream | null;\n\taudioContext: AudioContext | null;\n\tmediaRecorder: MediaRecorder | null;\n\tvoiceError: string | null;\n\n\t// Voice settings\n\tvoiceSettings: {\n\t\tlanguage: string;\n\t\tvoiceId?: string;\n\t\tpitch?: number;\n\t\trate?: number;\n\t\tvolume?: number;\n\t\tuseBrowserTTS?: boolean;\n\t\tautoAddToMessages?: boolean;\n\t\tendpoint?: string; // Voice endpoint URL\n\t\tstream?: boolean; // Whether to use streaming voice processing\n\t};\n}\n\nexport interface VoiceActions {\n\t// Permission management\n\trequestVoicePermission: () => Promise<void>;\n\tcheckVoiceSupport: () => boolean;\n\n\t// Voice control\n\tstartListening: () => Promise<void>;\n\tstopListening: () => void;\n\ttoggleVoice: () => void;\n\n\t// Audio streaming\n\tstreamAudioToEndpoint: (audioData: Blob) => Promise<void>;\n\tstreamAudioToEndpointStream: (audioData: Blob) => Promise<void>;\n\thandleLLMVoice: (response: VoiceLLMResponse) => Promise<void>;\n\tplayAudioResponse: (audioUrl: string | ArrayBuffer) => Promise<void>;\n\n\t// Settings\n\tsetVoiceEndpoint: (endpoint: string) => void;\n\tupdateVoiceSettings: (settings: Partial<VoiceState['voiceSettings']>) => void;\n\n\t// State management\n\tsetVoiceError: (error: string | null) => void;\n\tresetVoiceState: () => void;\n}\n\nexport type VoiceSlice = VoiceState & VoiceActions;\n\nconst initialVoiceState: VoiceState = {\n\tisVoiceEnabled: false,\n\tisListening: false,\n\tisSpeaking: false,\n\tvoicePermissionStatus: 'prompt',\n\taudioStream: null,\n\taudioContext: null,\n\tmediaRecorder: null,\n\tvoiceError: null,\n\tvoiceSettings: {\n\t\tlanguage: 'en-US',\n\t\tpitch: 1.0,\n\t\trate: 1.0,\n\t\tvolume: 1.0,\n\t\tuseBrowserTTS: false,\n\t\tautoAddToMessages: true, // Default to true for automatic message integration\n\t\tstream: false, // Default to non-streaming\n\t},\n};\n\nexport const createVoiceSlice: StateCreator<CedarStore, [], [], VoiceSlice> = (\n\tset,\n\tget\n) => ({\n\t...initialVoiceState,\n\n\tcheckVoiceSupport: () => {\n\t\tif (typeof window === 'undefined') return false;\n\t\treturn !!(\n\t\t\tnavigator.mediaDevices &&\n\t\t\ttypeof navigator.mediaDevices.getUserMedia === 'function' &&\n\t\t\twindow.MediaRecorder &&\n\t\t\twindow.AudioContext\n\t\t);\n\t},\n\n\trequestVoicePermission: async () => {\n\t\ttry {\n\t\t\tif (!get().checkVoiceSupport()) {\n\t\t\t\tset({\n\t\t\t\t\tvoicePermissionStatus: 'not-supported',\n\t\t\t\t\tvoiceError: 'Voice features are not supported in this browser',\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n\n\t\t\t// Create audio context for processing\n\t\t\tconst audioContext = new AudioContext();\n\n\t\t\tset({\n\t\t\t\taudioStream: stream,\n\t\t\t\taudioContext,\n\t\t\t\tvoicePermissionStatus: 'granted',\n\t\t\t\tvoiceError: null,\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tset({\n\t\t\t\tvoicePermissionStatus: 'denied',\n\t\t\t\tvoiceError:\n\t\t\t\t\terror instanceof Error\n\t\t\t\t\t\t? error.message\n\t\t\t\t\t\t: 'Failed to get microphone permission',\n\t\t\t});\n\t\t}\n\t},\n\n\tstartListening: async () => {\n\t\tconst state = get();\n\n\t\tif (state.voicePermissionStatus !== 'granted') {\n\t\t\tawait get().requestVoicePermission();\n\t\t\tif (get().voicePermissionStatus !== 'granted') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (!state.audioStream) {\n\t\t\tset({ voiceError: 'No audio stream available' });\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tconst mediaRecorder = new MediaRecorder(state.audioStream, {\n\t\t\t\tmimeType: 'audio/webm;codecs=opus',\n\t\t\t});\n\n\t\t\tconst audioChunks: Blob[] = [];\n\n\t\t\tmediaRecorder.ondataavailable = (event) => {\n\t\t\t\tif (event.data.size > 0) {\n\t\t\t\t\taudioChunks.push(event.data);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tmediaRecorder.onstop = async () => {\n\t\t\t\tconst audioBlob = new Blob(audioChunks, { type: 'audio/webm' });\n\t\t\t\tconst { voiceSettings } = get();\n\n\t\t\t\t// Choose between streaming and non-streaming based on settings\n\t\t\t\tif (voiceSettings.stream) {\n\t\t\t\t\tawait get().streamAudioToEndpointStream(audioBlob);\n\t\t\t\t} else {\n\t\t\t\t\tawait get().streamAudioToEndpoint(audioBlob);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tmediaRecorder.start();\n\t\t\tset({\n\t\t\t\tmediaRecorder,\n\t\t\t\tisListening: true,\n\t\t\t\tvoiceError: null,\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tset({\n\t\t\t\tvoiceError:\n\t\t\t\t\terror instanceof Error ? error.message : 'Failed to start recording',\n\t\t\t});\n\t\t}\n\t},\n\n\tstopListening: () => {\n\t\tconst { mediaRecorder } = get();\n\n\t\tif (mediaRecorder && mediaRecorder.state !== 'inactive') {\n\t\t\tmediaRecorder.stop();\n\t\t}\n\n\t\tset({ isListening: false });\n\t},\n\n\ttoggleVoice: () => {\n\t\tconst { isListening } = get();\n\n\t\tif (isListening) {\n\t\t\tget().stopListening();\n\t\t} else {\n\t\t\tget().startListening();\n\t\t}\n\t},\n\n\tstreamAudioToEndpoint: async (audioData: Blob) => {\n\t\tconst { voiceSettings } = get();\n\n\t\ttry {\n\t\t\tset({ isSpeaking: false });\n\n\t\t\t// Set processing state to true when starting voice processing\n\t\t\tget().setIsProcessing(true);\n\n\t\t\t// Check if we have a provider configured\n\t\t\tconst providerConfig = get().providerConfig;\n\t\t\tif (!providerConfig) {\n\t\t\t\tthrow new Error('No provider configured for voice');\n\t\t\t}\n\n\t\t\t// For Mastra/custom providers with explicit endpoints, check if endpoint is configured\n\t\t\tif (\n\t\t\t\t(providerConfig.provider === 'mastra' ||\n\t\t\t\t\tproviderConfig.provider === 'custom') &&\n\t\t\t\t!voiceSettings.endpoint\n\t\t\t) {\n\t\t\t\tthrow new Error('Voice endpoint not configured');\n\t\t\t}\n\n\t\t\t// Get the stringified additional context from the store\n\t\t\tconst contextString = get().compileAdditionalContext();\n\n\t\t\t// Use the agent connection's voiceLLM method\n\t\t\tconst response = await get().voiceLLM({\n\t\t\t\taudioData,\n\t\t\t\tvoiceSettings,\n\t\t\t\tcontext: contextString,\n\t\t\t\tprompt: '',\n\t\t\t});\n\n\t\t\t// Handle the response using the new handleLLMVoice function\n\t\t\tawait get().handleLLMVoice(response);\n\t\t} catch (error) {\n\t\t\tset({\n\t\t\t\tvoiceError:\n\t\t\t\t\terror instanceof Error ? error.message : 'Failed to process voice',\n\t\t\t});\n\t\t\t// Set processing state to false on error\n\t\t\tget().setIsProcessing(false);\n\t\t}\n\t},\n\n\tstreamAudioToEndpointStream: async (audioData: Blob) => {\n\t\tconst { voiceSettings } = get();\n\n\t\ttry {\n\t\t\tset({ isSpeaking: false });\n\n\t\t\t// Set processing state to true when starting voice processing\n\t\t\tget().setIsProcessing(true);\n\n\t\t\t// Check if we have a provider configured\n\t\t\tconst providerConfig = get().providerConfig;\n\t\t\tif (!providerConfig) {\n\t\t\t\tthrow new Error('No provider configured for voice');\n\t\t\t}\n\n\t\t\t// For Mastra/custom providers with explicit endpoints, check if endpoint is configured\n\t\t\tif (\n\t\t\t\t(providerConfig.provider === 'mastra' ||\n\t\t\t\t\tproviderConfig.provider === 'custom') &&\n\t\t\t\t!voiceSettings.endpoint\n\t\t\t) {\n\t\t\t\tthrow new Error('Voice endpoint not configured');\n\t\t\t}\n\n\t\t\t// Get the stringified additional context from the store\n\t\t\tconst contextString = get().compileAdditionalContext();\n\n\t\t\t// Use the agent connection's voiceStreamLLM method\n\t\t\tconst streamResponse = get().voiceStreamLLM(\n\t\t\t\t{\n\t\t\t\t\taudioData,\n\t\t\t\t\tvoiceSettings,\n\t\t\t\t\tcontext: contextString,\n\t\t\t\t\tprompt: '',\n\t\t\t\t},\n\t\t\t\tasync (event) => {\n\t\t\t\t\t// Handle streaming voice events\n\t\t\t\t\tswitch (event.type) {\n\t\t\t\t\t\tcase 'transcription':\n\t\t\t\t\t\t\t// Handle transcription events\n\t\t\t\t\t\t\tif (voiceSettings.autoAddToMessages && event.transcription) {\n\t\t\t\t\t\t\t\tconst { addMessage } = get();\n\t\t\t\t\t\t\t\taddMessage({\n\t\t\t\t\t\t\t\t\ttype: 'text',\n\t\t\t\t\t\t\t\t\trole: 'user',\n\t\t\t\t\t\t\t\t\tcontent: event.transcription,\n\t\t\t\t\t\t\t\t\tmetadata: {\n\t\t\t\t\t\t\t\t\t\tsource: 'voice',\n\t\t\t\t\t\t\t\t\t\ttimestamp: new Date().toISOString(),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'audio':\n\t\t\t\t\t\t\t// Handle audio streaming\n\t\t\t\t\t\t\tif (event.audioData && event.audioFormat) {\n\t\t\t\t\t\t\t\tconst binaryString = atob(event.audioData);\n\t\t\t\t\t\t\t\tconst bytes = new Uint8Array(binaryString.length);\n\t\t\t\t\t\t\t\tfor (let i = 0; i < binaryString.length; i++) {\n\t\t\t\t\t\t\t\t\tbytes[i] = binaryString.charCodeAt(i);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst audioBuffer = bytes.buffer;\n\t\t\t\t\t\t\t\tawait get().playAudioResponse(audioBuffer);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Also add the text content to the chat\n\t\t\t\t\t\t\tif (event.content) {\n\t\t\t\t\t\t\t\tget().addMessage({\n\t\t\t\t\t\t\t\t\ttype: 'text',\n\t\t\t\t\t\t\t\t\trole: 'bot',\n\t\t\t\t\t\t\t\t\tcontent: event.content,\n\t\t\t\t\t\t\t\t\tmetadata: {\n\t\t\t\t\t\t\t\t\t\tsource: 'voice',\n\t\t\t\t\t\t\t\t\t\ttimestamp: new Date().toISOString(),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'chunk':\n\t\t\t\t\t\t\t// Handle text content chunks\n\t\t\t\t\t\t\tawait get().handleLLMResponse([event.content]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'object':\n\t\t\t\t\t\t\t// Handle structured objects\n\t\t\t\t\t\t\tawait get().handleLLMResponse(\n\t\t\t\t\t\t\t\tArray.isArray(event.object) ? event.object : [event.object]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'done':\n\t\t\t\t\t\t\t// Stream completed\n\t\t\t\t\t\t\tget().setIsProcessing(false);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'error':\n\t\t\t\t\t\t\tconsole.error('Voice stream error:', event.error);\n\t\t\t\t\t\t\tset({\n\t\t\t\t\t\t\t\tvoiceError:\n\t\t\t\t\t\t\t\t\tevent.error instanceof Error\n\t\t\t\t\t\t\t\t\t\t? event.error.message\n\t\t\t\t\t\t\t\t\t\t: 'Voice stream error',\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tget().setIsProcessing(false);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\n\t\t\t// Wait for stream to complete\n\t\t\tawait streamResponse.completion;\n\t\t} catch (error) {\n\t\t\tset({\n\t\t\t\tvoiceError:\n\t\t\t\t\terror instanceof Error\n\t\t\t\t\t\t? error.message\n\t\t\t\t\t\t: 'Failed to process voice stream',\n\t\t\t});\n\t\t\t// Set processing state to false on error\n\t\t\tget().setIsProcessing(false);\n\t\t}\n\t},\n\n\thandleLLMVoice: async (response: VoiceLLMResponse) => {\n\t\tconst { voiceSettings } = get();\n\n\t\ttry {\n\t\t\tset({ isSpeaking: false });\n\n\t\t\t// Handle audio playback (voice-specific)\n\t\t\tif (response.audioData && response.audioFormat) {\n\t\t\t\tconst binaryString = atob(response.audioData);\n\t\t\t\tconst bytes = new Uint8Array(binaryString.length);\n\t\t\t\tfor (let i = 0; i < binaryString.length; i++) {\n\t\t\t\t\tbytes[i] = binaryString.charCodeAt(i);\n\t\t\t\t}\n\t\t\t\tconst audioBuffer = bytes.buffer;\n\t\t\t\tawait get().playAudioResponse(audioBuffer);\n\t\t\t} else if (response.audioUrl) {\n\t\t\t\tawait get().playAudioResponse(response.audioUrl);\n\t\t\t} else if (response.content && voiceSettings.useBrowserTTS) {\n\t\t\t\tif ('speechSynthesis' in window) {\n\t\t\t\t\tconst utterance = new SpeechSynthesisUtterance(response.content);\n\t\t\t\t\tutterance.lang = voiceSettings.language;\n\t\t\t\t\tutterance.rate = voiceSettings.rate || 1;\n\t\t\t\t\tutterance.pitch = voiceSettings.pitch || 1;\n\t\t\t\t\tutterance.volume = voiceSettings.volume || 1;\n\n\t\t\t\t\tset({ isSpeaking: true });\n\t\t\t\t\tutterance.onend = () => set({ isSpeaking: false });\n\n\t\t\t\t\tspeechSynthesis.speak(utterance);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Handle transcription (voice-specific)\n\t\t\tif (voiceSettings.autoAddToMessages && response.transcription) {\n\t\t\t\tconst { addMessage } = get();\n\t\t\t\taddMessage({\n\t\t\t\t\ttype: 'text',\n\t\t\t\t\trole: 'user',\n\t\t\t\t\tcontent: response.transcription,\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\tsource: 'voice',\n\t\t\t\t\t\ttimestamp: new Date().toISOString(),\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Build items array for handleLLMResponse\n\t\t\tconst items: (string | StructuredResponseType)[] = [];\n\n\t\t\t// This should be fixed tbh. HandleLLMResponse should be able to handle this, but due to current streaming limitations.\n\n\t\t\t// Add content if present\n\t\t\tif (response.content) {\n\t\t\t\titems.push(response.content);\n\t\t\t}\n\n\t\t\t// Add object if present - cast to StructuredResponseType for compatibility\n\t\t\tif (response.object) {\n\t\t\t\tif (Array.isArray(response.object)) {\n\t\t\t\t\titems.push(...response.object);\n\t\t\t\t} else {\n\t\t\t\t\titems.push(response.object);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Delegate message parsing to handleLLMResponse if we have items\n\t\t\tif (items.length > 0) {\n\t\t\t\tconst { handleLLMResponse } = get();\n\t\t\t\tawait handleLLMResponse(items);\n\t\t\t}\n\n\t\t\t// Set processing state to false when voice processing completes successfully\n\t\t\tget().setIsProcessing(false);\n\t\t} catch (error) {\n\t\t\tset({\n\t\t\t\tvoiceError:\n\t\t\t\t\terror instanceof Error ? error.message : 'Failed to process voice',\n\t\t\t});\n\t\t\t// Set processing state to false on error\n\t\t\tget().setIsProcessing(false);\n\t\t}\n\t},\n\n\tplayAudioResponse: async (audioData: string | ArrayBuffer) => {\n\t\ttry {\n\t\t\tset({ isSpeaking: true });\n\n\t\t\tconst audio = new Audio();\n\n\t\t\tif (typeof audioData === 'string') {\n\t\t\t\taudio.src = audioData;\n\t\t\t} else {\n\t\t\t\tconst blob = new Blob([audioData], { type: 'audio/mpeg' });\n\t\t\t\taudio.src = URL.createObjectURL(blob);\n\t\t\t}\n\n\t\t\taudio.onended = () => {\n\t\t\t\tset({ isSpeaking: false });\n\t\t\t\tif (typeof audioData !== 'string') {\n\t\t\t\t\tURL.revokeObjectURL(audio.src);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tawait audio.play();\n\t\t} catch (error) {\n\t\t\tset({\n\t\t\t\tisSpeaking: false,\n\t\t\t\tvoiceError:\n\t\t\t\t\terror instanceof Error ? error.message : 'Failed to play audio',\n\t\t\t});\n\t\t}\n\t},\n\n\tsetVoiceEndpoint: (endpoint: string) => {\n\t\tset((state) => ({\n\t\t\tvoiceSettings: {\n\t\t\t\t...state.voiceSettings,\n\t\t\t\tendpoint,\n\t\t\t},\n\t\t}));\n\t},\n\n\tupdateVoiceSettings: (settings: Partial<VoiceState['voiceSettings']>) => {\n\t\tset((state) => ({\n\t\t\tvoiceSettings: {\n\t\t\t\t...state.voiceSettings,\n\t\t\t\t...settings,\n\t\t\t},\n\t\t}));\n\t},\n\n\tsetVoiceError: (error: string | null) => {\n\t\tset({ voiceError: error });\n\t},\n\n\tresetVoiceState: () => {\n\t\tconst { audioStream, audioContext, mediaRecorder } = get();\n\n\t\t// Clean up resources\n\t\tif (mediaRecorder && mediaRecorder.state !== 'inactive') {\n\t\t\tmediaRecorder.stop();\n\t\t}\n\n\t\tif (audioStream) {\n\t\t\taudioStream.getTracks().forEach((track) => track.stop());\n\t\t}\n\n\t\tif (audioContext && audioContext.state !== 'closed') {\n\t\t\taudioContext.close();\n\t\t}\n\n\t\tset(initialVoiceState);\n\t},\n});\n"],"mappings":"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","names":[]}