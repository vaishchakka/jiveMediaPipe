"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/store/messages/createTypedMessagesSlice.ts
var createTypedMessagesSlice_exports = {};
__export(createTypedMessagesSlice_exports, {
  createTypedMessagesSlice: () => createTypedMessagesSlice
});
module.exports = __toCommonJS(createTypedMessagesSlice_exports);
function createTypedMessagesSlice() {
  return (set, get) => ({
    messages: [],
    isProcessing: false,
    showChat: false,
    messageRenderers: /* @__PURE__ */ new Map(),
    setMessages: (messages) => set({ messages }),
    setShowChat: (showChat) => set({ showChat }),
    addMessage: (messageData) => {
      const id = `message-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
      const createdAt = (/* @__PURE__ */ new Date()).toISOString();
      const newMessage = {
        ...messageData,
        id,
        createdAt
      };
      set((state) => ({
        // TypeScript can't prove that MessageByType<T, M> is assignable to M
        // because M could be instantiated with a different subtype. This is safe
        // because we know the message types are part of the union M.
        messages: [...state.messages, newMessage]
      }));
      return newMessage;
    },
    addMessages: (messagesData) => {
      const newMessages = messagesData.map((messageData) => {
        const id = `message-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
        const createdAt = (/* @__PURE__ */ new Date()).toISOString();
        return {
          ...messageData,
          id,
          createdAt
        };
      });
      set((state) => ({
        messages: [...state.messages, ...newMessages]
      }));
      return newMessages;
    },
    updateMessage: (id, updates) => {
      set((state) => ({
        messages: state.messages.map(
          (msg) => msg.id === id ? { ...msg, ...updates } : msg
        )
      }));
    },
    deleteMessage: (id) => {
      set((state) => ({
        messages: state.messages.filter((msg) => msg.id !== id)
      }));
    },
    clearMessages: () => set({ messages: [] }),
    setIsProcessing: (isProcessing) => set({ isProcessing }),
    // Renderer management
    registerMessageRenderer: (config) => {
      set((state) => {
        const newRenderers = new Map(state.messageRenderers);
        newRenderers.set(config.type, config);
        return { messageRenderers: newRenderers };
      });
    },
    unregisterMessageRenderer: (type) => {
      set((state) => {
        const newRenderers = new Map(state.messageRenderers);
        newRenderers.delete(type);
        return { messageRenderers: newRenderers };
      });
    },
    getMessageRenderer: (type) => {
      return get().messageRenderers.get(type);
    },
    // Utility methods
    getMessageById: (id) => {
      return get().messages.find((msg) => msg.id === id);
    },
    getMessagesByRole: (role) => {
      return get().messages.filter((msg) => msg.role === role);
    }
  });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createTypedMessagesSlice
});
//# sourceMappingURL=createTypedMessagesSlice.js.map