// src/store/diffHistoryStateSlice/diffHistorySlice.ts
import { compare, applyPatch } from "fast-json-patch";
import { isEqual, cloneDeep } from "lodash";
function getValueAtPath(obj, path) {
  if (!path || path === "" || path === "/") {
    return obj;
  }
  const pathParts = path.startsWith("/") ? path.slice(1).split("/") : path.split("/");
  let current = obj;
  for (const part of pathParts) {
    if (current == null || typeof current !== "object") {
      return void 0;
    }
    current = current[part];
  }
  return current;
}
function setValueAtPathForDiff(obj, path, value) {
  if (!path || path === "" || path === "/") {
    return value;
  }
  const pathParts = path.startsWith("/") ? path.slice(1).split("/") : path.split("/");
  const result = cloneDeep(obj);
  let current = result;
  for (let i = 0; i < pathParts.length - 1; i++) {
    const part = pathParts[i];
    if (!(part in current)) {
      current[part] = {};
    }
    current = current[part];
  }
  const lastPart = pathParts[pathParts.length - 1];
  current[lastPart] = value;
  return result;
}
function getItemIdentifier(item, identificationField) {
  if (typeof identificationField === "function") {
    return identificationField(item);
  }
  return item[identificationField];
}
function handlePrimitiveArrayDiff(params) {
  const {
    get,
    key,
    jsonPath,
    oldArray,
    newArray,
    action,
    currentDiffHistoryState,
    targetId,
    diffMode,
    computeState
  } = params;
  const { diffState, history } = currentDiffHistoryState;
  let resultNewArray;
  let resultOldArray;
  if (action === "accept") {
    resultNewArray = [...newArray];
    if (!oldArray.includes(targetId)) {
      resultOldArray = [...oldArray, targetId];
    } else {
      resultOldArray = [...oldArray];
    }
  } else if (action === "reject") {
    const oldCount = oldArray.filter((item) => item === targetId).length;
    const newCount = newArray.filter((item) => item === targetId).length;
    if (newCount <= oldCount) {
      resultNewArray = [...newArray];
    } else {
      const itemsToKeep = oldCount;
      let keptCount = 0;
      resultNewArray = newArray.filter((item) => {
        if (item === targetId) {
          if (keptCount < itemsToKeep) {
            keptCount++;
            return true;
          } else {
            return false;
          }
        }
        return true;
      });
    }
    resultOldArray = [...oldArray];
  } else {
    return false;
  }
  const newStateWithUpdatedArray = setValueAtPathForDiff(
    diffState.newState,
    jsonPath,
    resultNewArray
  );
  const finalOldState = setValueAtPathForDiff(
    diffState.oldState,
    jsonPath,
    resultOldArray
  );
  const finalNewState = newStateWithUpdatedArray;
  let finalComputedState;
  let stillInDiffMode = false;
  if (computeState) {
    finalComputedState = computeState(finalOldState, finalNewState, []);
    stillInDiffMode = !areStatesEquivalent(finalOldState, finalNewState);
  } else {
    finalComputedState = finalNewState;
    stillInDiffMode = !areStatesEquivalent(finalOldState, finalNewState);
  }
  const updatedDiffState = {
    oldState: finalOldState,
    newState: finalNewState,
    computedState: finalComputedState,
    isDiffMode: stillInDiffMode,
    patches: []
  };
  const updatedHistory = [...history, diffState];
  const updatedDiffHistoryState = {
    diffState: updatedDiffState,
    history: updatedHistory,
    redoStack: [],
    diffMode,
    computeState
  };
  get().setDiffState(key, updatedDiffHistoryState);
  return true;
}
function areStatesEquivalent(oldState, newState) {
  return isEqual(oldState, newState);
}
function removeDiffMarkers(item, diffMarkerPaths) {
  let cleanedItem = { ...item };
  const pathsToCheck = diffMarkerPaths || ["/data/diff", "/diff", "/meta/diff"];
  for (const path of pathsToCheck) {
    const diffValue = getValueAtPath(cleanedItem, path);
    if (diffValue) {
      const pathParts = path.split("/").filter((p) => p);
      if (pathParts.length === 1) {
        const itemRecord = cleanedItem;
        const { [pathParts[0]]: _, ...itemWithoutDiff } = itemRecord;
        cleanedItem = itemWithoutDiff;
      } else {
        const parentPathStr = "/" + pathParts.slice(0, -1).join("/");
        const parentValue = getValueAtPath(cleanedItem, parentPathStr);
        if (parentValue && typeof parentValue === "object") {
          const parentRecord = parentValue;
          const diffField = pathParts[pathParts.length - 1];
          const { [diffField]: _, ...parentWithoutDiff } = parentRecord;
          cleanedItem = setValueAtPathForDiff(
            cleanedItem,
            parentPathStr,
            parentWithoutDiff
          );
        }
      }
    }
  }
  return cleanedItem;
}
function handleSingleDiff(get, key, jsonPath, identificationField, action, targetId, diffMarkerPaths) {
  const currentDiffHistoryState = get().getDiffHistoryState(key);
  if (!currentDiffHistoryState || !currentDiffHistoryState.diffState.isDiffMode) {
    return false;
  }
  const { diffState } = currentDiffHistoryState;
  const oldValue = getValueAtPath(diffState.oldState, jsonPath);
  const newValue = getValueAtPath(diffState.newState, jsonPath);
  const isArray = Array.isArray(oldValue) || Array.isArray(newValue);
  if (isArray) {
    const oldArray = oldValue;
    const newArray = newValue;
    if (!Array.isArray(oldArray) || !Array.isArray(newArray)) {
      console.warn(`Value at path "${jsonPath}" is not consistently an array`);
      return false;
    }
    return handleArrayDiff({
      get,
      key,
      jsonPath,
      oldArray,
      newArray,
      identificationField,
      action,
      currentDiffHistoryState,
      targetId,
      diffMarkerPaths
    });
  } else {
    return handleObjectFieldDiff({
      get,
      key,
      jsonPath,
      oldValue,
      newValue,
      action,
      currentDiffHistoryState,
      diffMarkerPaths
    });
  }
}
function handleObjectFieldDiff(params) {
  const {
    get,
    key,
    jsonPath,
    oldValue,
    newValue,
    action,
    currentDiffHistoryState,
    diffMarkerPaths
  } = params;
  const { diffState, history, diffMode, computeState } = currentDiffHistoryState;
  let finalValue;
  if (action === "accept") {
    finalValue = typeof newValue === "object" && newValue !== null ? removeDiffMarkers(newValue, diffMarkerPaths) : newValue;
  } else {
    finalValue = oldValue;
  }
  const updatedNewState = setValueAtPathForDiff(
    diffState.newState,
    jsonPath,
    finalValue
  );
  const updatedOldState = action === "accept" ? setValueAtPathForDiff(diffState.oldState, jsonPath, finalValue) : diffState.oldState;
  let finalComputedState;
  let stillInDiffMode = false;
  if (computeState) {
    finalComputedState = computeState(updatedOldState, updatedNewState, []);
    const checkForDiffs = (obj) => {
      if (!obj || typeof obj !== "object") return false;
      const pathsToCheck = diffMarkerPaths || [
        "/data/diff",
        "/diff",
        "/meta/diff"
      ];
      for (const path of pathsToCheck) {
        if (getValueAtPath(obj, path)) return true;
      }
      for (const value of Object.values(obj)) {
        if (checkForDiffs(value)) return true;
      }
      return false;
    };
    stillInDiffMode = checkForDiffs(finalComputedState);
  } else {
    finalComputedState = updatedNewState;
  }
  const statesAreEquivalent = areStatesEquivalent(
    updatedOldState,
    updatedNewState
  );
  const finalIsDiffMode = statesAreEquivalent ? false : stillInDiffMode;
  const updatedDiffState = {
    oldState: updatedOldState,
    newState: updatedNewState,
    computedState: finalComputedState,
    isDiffMode: finalIsDiffMode,
    patches: []
  };
  const updatedHistory = [...history, diffState];
  const updatedDiffHistoryState = {
    diffState: updatedDiffState,
    history: updatedHistory,
    redoStack: [],
    diffMode,
    computeState
  };
  get().setDiffState(key, updatedDiffHistoryState);
  return true;
}
function handleArrayDiff(params) {
  const {
    get,
    key,
    jsonPath,
    oldArray,
    newArray,
    identificationField,
    action,
    currentDiffHistoryState,
    targetId,
    diffMarkerPaths
  } = params;
  const { diffState, history, diffMode, computeState } = currentDiffHistoryState;
  const isPrimitiveArray = oldArray.length > 0 && (typeof oldArray[0] === "string" || typeof oldArray[0] === "number" || typeof oldArray[0] === "boolean") || newArray.length > 0 && (typeof newArray[0] === "string" || typeof newArray[0] === "number" || typeof newArray[0] === "boolean");
  if (isPrimitiveArray && targetId !== void 0) {
    return handlePrimitiveArrayDiff({
      get,
      key,
      jsonPath,
      oldArray,
      newArray,
      action,
      currentDiffHistoryState,
      targetId,
      diffMode,
      computeState
    });
  }
  const oldMap = new Map(
    oldArray.map((item) => [getItemIdentifier(item, identificationField), item])
  );
  const newMap = new Map(
    newArray.map((item) => [getItemIdentifier(item, identificationField), item])
  );
  const allIds = /* @__PURE__ */ new Set([...oldMap.keys(), ...newMap.keys()]);
  const changedIds = /* @__PURE__ */ new Set();
  for (const id of allIds) {
    if (targetId !== void 0 && id !== targetId) {
      continue;
    }
    const oldItem = oldMap.get(id);
    const newItem = newMap.get(id);
    if (!oldItem && newItem) {
      changedIds.add(id);
    } else if (oldItem && !newItem) {
      changedIds.add(id);
    } else if (oldItem && newItem) {
      if (JSON.stringify(oldItem) !== JSON.stringify(newItem)) {
        changedIds.add(id);
      }
    }
  }
  if (changedIds.size === 0) {
    return false;
  }
  let resultArray = [];
  if (action === "accept") {
    resultArray = newArray.map((item) => {
      const itemId = getItemIdentifier(item, identificationField);
      if (targetId !== void 0 && itemId !== targetId) {
        return item;
      }
      const shouldProcessItem = targetId === void 0 || itemId === targetId;
      if (!shouldProcessItem || !changedIds.has(itemId)) {
        return item;
      }
      return removeDiffMarkers(item, diffMarkerPaths);
    });
  } else if (action === "reject") {
    if (targetId !== void 0) {
      for (const item of newArray) {
        const itemId = getItemIdentifier(item, identificationField);
        if (itemId === targetId && changedIds.has(itemId)) {
          const oldItem = oldMap.get(itemId);
          if (oldItem) {
            resultArray.push(oldItem);
          }
        } else {
          resultArray.push(item);
        }
      }
    } else {
      for (const item of oldArray) {
        const itemId = getItemIdentifier(item, identificationField);
        if (changedIds.has(itemId)) {
          resultArray.push(item);
        } else {
          const newItem = newMap.get(itemId);
          if (newItem) {
            resultArray.push(newItem);
          }
        }
      }
    }
  }
  const newStateWithUpdatedArray = setValueAtPathForDiff(
    diffState.newState,
    jsonPath,
    resultArray
  );
  let finalOldState = diffState.oldState;
  const finalNewState = newStateWithUpdatedArray;
  let finalComputedState;
  if (targetId !== void 0) {
    const currentComputedArray = getValueAtPath(
      diffState.computedState,
      jsonPath
    );
    const finalComputedArray = currentComputedArray.map((item) => {
      const itemId = getItemIdentifier(item, identificationField);
      if (itemId === targetId) {
        const processedItem = resultArray.find(
          (i) => getItemIdentifier(i, identificationField) === targetId
        );
        return processedItem || item;
      }
      return item;
    }).filter((item) => {
      if (action === "reject") {
        const itemId = getItemIdentifier(item, identificationField);
        if (itemId === targetId) {
          const oldItem = oldMap.get(itemId);
          if (!oldItem) {
            return false;
          }
        }
      }
      return true;
    });
    finalComputedState = setValueAtPathForDiff(
      diffState.computedState,
      jsonPath,
      finalComputedArray
    );
    if (action === "accept") {
      const updatedOldArray = [...oldArray];
      const targetIndex = updatedOldArray.findIndex(
        (item) => getItemIdentifier(item, identificationField) === targetId
      );
      const acceptedItem = resultArray.find(
        (item) => getItemIdentifier(item, identificationField) === targetId
      );
      if (acceptedItem) {
        if (targetIndex >= 0) {
          updatedOldArray[targetIndex] = acceptedItem;
        } else {
          updatedOldArray.push(acceptedItem);
        }
        finalOldState = setValueAtPathForDiff(
          diffState.oldState,
          jsonPath,
          updatedOldArray
        );
      }
    }
  } else {
    finalComputedState = newStateWithUpdatedArray;
    if (action === "accept") {
      finalOldState = newStateWithUpdatedArray;
    }
  }
  const stillInDiffMode = targetId !== void 0 ? (
    // For single-item, check if computed state has any remaining diff markers
    (() => {
      const computedArray = getValueAtPath(
        finalComputedState,
        jsonPath
      );
      const pathsToCheck = diffMarkerPaths || [
        "/data/diff",
        "/diff",
        "/meta/diff"
      ];
      return computedArray?.some((item) => {
        for (const path of pathsToCheck) {
          const diffValue = getValueAtPath(item, path);
          if (diffValue === "added" || diffValue === "changed" || diffValue === "removed") {
            return true;
          }
        }
        return false;
      }) || false;
    })()
  ) : false;
  const statesAreEquivalent = areStatesEquivalent(finalOldState, finalNewState);
  const finalIsDiffMode = statesAreEquivalent ? false : stillInDiffMode;
  const updatedDiffState = {
    oldState: finalOldState,
    newState: finalNewState,
    computedState: finalComputedState,
    isDiffMode: finalIsDiffMode,
    patches: []
  };
  const updatedHistory = [...history, diffState];
  const updatedDiffHistoryState = {
    diffState: updatedDiffState,
    history: updatedHistory,
    redoStack: [],
    // Clear redo stack on changes
    diffMode,
    computeState
  };
  get().setDiffState(key, updatedDiffHistoryState);
  return true;
}
var createDiffHistorySlice = (set, get) => ({
  diffHistoryStates: {},
  getDiffHistoryState: (key) => {
    return get().diffHistoryStates[key];
  },
  getDiffState: (key) => {
    const diffHistoryState = get().diffHistoryStates[key];
    return diffHistoryState?.diffState;
  },
  registerDiffState: (config) => {
    const {
      key,
      value,
      setValue,
      description,
      schema,
      stateSetters,
      diffMode = "defaultAccept",
      computeState
    } = config;
    const existingDiffState = get().getDiffHistoryState(key);
    if (!existingDiffState) {
      get().registerState({
        key,
        value,
        setValue,
        description,
        schema,
        stateSetters
      });
      const initialDiffHistoryState = {
        diffState: {
          oldState: value,
          newState: value,
          computedState: value,
          // Initial state is the same for all
          isDiffMode: false,
          patches: []
        },
        history: [],
        redoStack: [],
        diffMode,
        computeState
      };
      get().setDiffState(key, initialDiffHistoryState);
    } else {
      const currentNewState = existingDiffState.diffState.newState;
      const currentComputedState = existingDiffState.diffState.computedState;
      if (!isEqual(currentNewState, value) && !isEqual(currentComputedState, value)) {
        get().newDiffState(key, value);
      }
    }
  },
  setDiffState: (key, diffHistoryState) => {
    const oldState = diffHistoryState.diffState?.oldState;
    const diffNewState = diffHistoryState.diffState?.newState;
    const statesAreEquivalent = oldState && diffNewState ? areStatesEquivalent(oldState, diffNewState) : false;
    const correctedDiffHistoryState = statesAreEquivalent && diffHistoryState.diffState?.isDiffMode ? {
      ...diffHistoryState,
      diffState: {
        ...diffHistoryState.diffState,
        isDiffMode: false
      }
    } : diffHistoryState;
    set((state) => ({
      diffHistoryStates: {
        ...state.diffHistoryStates,
        [key]: correctedDiffHistoryState
      }
    }));
    const newState = correctedDiffHistoryState.diffState?.computedState ? correctedDiffHistoryState.diffState?.computedState : correctedDiffHistoryState.computeState ? correctedDiffHistoryState.computeState(
      correctedDiffHistoryState.diffState?.oldState,
      correctedDiffHistoryState.diffState?.newState,
      correctedDiffHistoryState.diffState?.patches || []
    ) : correctedDiffHistoryState.diffState?.newState;
    if (newState !== void 0) {
      const registeredState = get().registeredStates?.[key];
      if (!registeredState) {
        get().registerState({
          key,
          value: newState,
          // Change
          description: `Diff-tracked state: ${key}`
        });
      } else {
        const currentValue = registeredState.value;
        if (!isEqual(currentValue, newState)) {
          set(
            (state) => ({
              registeredStates: {
                ...state.registeredStates,
                [key]: {
                  ...state.registeredStates[key],
                  value: newState
                }
              }
            })
          );
          registeredState.setValue?.(newState);
        }
      }
    }
  },
  newDiffState: (key, newState, isDiffChange) => {
    const currentDiffHistoryState = get().getDiffHistoryState(key);
    if (!currentDiffHistoryState) {
      console.warn(`No diff history state found for key: ${key}`);
      return;
    }
    const {
      diffState: originalDiffState,
      history,
      diffMode,
      computeState
    } = currentDiffHistoryState;
    const effectiveIsDiffChange = isDiffChange ?? originalDiffState.isDiffMode;
    const updatedHistory = [...history, originalDiffState];
    let oldStateForDiff;
    if (!effectiveIsDiffChange) {
      oldStateForDiff = newState;
    } else {
      oldStateForDiff = originalDiffState.isDiffMode ? originalDiffState.oldState : originalDiffState.newState;
    }
    const patches = compare(oldStateForDiff, newState);
    const computedStateValue = computeState ? computeState(oldStateForDiff, newState, patches) : diffMode === "defaultAccept" ? newState : oldStateForDiff;
    const statesAreEquivalent = areStatesEquivalent(oldStateForDiff, newState);
    const finalIsDiffMode = statesAreEquivalent ? false : effectiveIsDiffChange;
    const newDiffState = {
      oldState: oldStateForDiff,
      newState,
      computedState: computedStateValue,
      isDiffMode: finalIsDiffMode,
      patches
    };
    const updatedDiffHistoryState = {
      diffState: newDiffState,
      history: updatedHistory,
      redoStack: [],
      // Clear redo stack on new changes
      diffMode,
      // Keep the same diff mode
      computeState
      // Preserve the computeState function
    };
    set((state) => ({
      diffHistoryStates: {
        ...state.diffHistoryStates,
        [key]: updatedDiffHistoryState
      }
    }));
    const registeredState = get().registeredStates?.[key];
    if (registeredState) {
      const currentValue = registeredState.value;
      if (!isEqual(currentValue, computedStateValue)) {
        set(
          (state) => ({
            registeredStates: {
              ...state.registeredStates,
              [key]: {
                ...state.registeredStates[key],
                value: computedStateValue
              }
            }
          })
        );
        registeredState.setValue?.(newState);
      }
    }
  },
  getCleanState: (key) => {
    const diffHistoryState = get().getDiffHistoryState(key);
    if (!diffHistoryState || !diffHistoryState.diffState) return void 0;
    const { diffState, diffMode } = diffHistoryState;
    if (diffMode === "defaultAccept") {
      return diffState.newState;
    } else {
      return diffState.oldState;
    }
  },
  getComputedState: (key) => {
    const diffHistoryState = get().getDiffHistoryState(key);
    if (!diffHistoryState) return void 0;
    return diffHistoryState.diffState.computedState;
  },
  setComputeStateFunction: (key, computeState) => {
    const currentDiffHistoryState = get().getDiffHistoryState(key);
    if (!currentDiffHistoryState) {
      console.warn(`No diff history state found for key: ${key}`);
      return;
    }
    const updatedDiffHistoryState = {
      ...currentDiffHistoryState,
      computeState
    };
    get().setDiffState(key, updatedDiffHistoryState);
  },
  executeDiffSetter: (key, setterKey, options = {}, args) => {
    const isDiff = options.isDiff ?? false;
    const currentDiffHistoryState = get().getDiffHistoryState(key);
    if (!currentDiffHistoryState) {
      console.warn(`No diff history state found for key: ${key}`);
      return;
    }
    const currentNewState = currentDiffHistoryState.diffState.newState;
    const registeredState = get().registeredStates?.[key];
    if (!registeredState) {
      console.warn(`No registered state found for key: ${key}`);
      return;
    }
    const stateSetters = registeredState.stateSetters || registeredState.customSetters;
    if (!stateSetters || !stateSetters[setterKey]) {
      console.warn(`State setter "${setterKey}" not found for state "${key}"`);
      return;
    }
    let resultState = currentNewState;
    const setValueFunc = (newValue) => {
      resultState = newValue;
    };
    try {
      const setter = stateSetters[setterKey];
      setter.execute(currentNewState, setValueFunc, args);
      get().newDiffState(key, resultState, isDiff);
    } catch (error) {
      console.error(`Error executing diff setter for "${key}":`, error);
    }
  },
  applyPatchesToDiffState: (key, patches, isDiffChange) => {
    const currentDiffHistoryState = get().getDiffHistoryState(key);
    if (!currentDiffHistoryState) {
      console.warn(`No diff history state found for key: ${key}`);
      return;
    }
    const {
      diffState: originalDiffState,
      history,
      diffMode,
      computeState
    } = currentDiffHistoryState;
    const updatedHistory = [...history, originalDiffState];
    const currentNewState = cloneDeep(originalDiffState.newState);
    const patchResult = applyPatch(
      currentNewState,
      patches,
      false,
      // Don't validate (for performance)
      false
      // Don't mutate the original
    ).newDocument;
    let oldStateForDiff;
    if (!isDiffChange) {
      oldStateForDiff = currentNewState;
    } else {
      oldStateForDiff = originalDiffState.isDiffMode ? originalDiffState.oldState : originalDiffState.newState;
    }
    const diffPatches = compare(
      oldStateForDiff,
      patchResult
    );
    const computedStateValue = computeState ? computeState(oldStateForDiff, patchResult, diffPatches) : diffMode === "defaultAccept" ? patchResult : oldStateForDiff;
    const statesAreEquivalent = areStatesEquivalent(
      oldStateForDiff,
      patchResult
    );
    const finalIsDiffMode = statesAreEquivalent ? false : isDiffChange;
    const newDiffState = {
      oldState: oldStateForDiff,
      newState: patchResult,
      computedState: computedStateValue,
      isDiffMode: finalIsDiffMode,
      patches: diffPatches
    };
    const updatedDiffHistoryState = {
      diffState: newDiffState,
      history: updatedHistory,
      redoStack: [],
      // Clear redo stack on new changes
      diffMode,
      // Keep the same diff mode
      computeState
      // Preserve the computeState function
    };
    get().setDiffState(key, updatedDiffHistoryState);
  },
  acceptAllDiffs: (key) => {
    const currentDiffHistoryState = get().getDiffHistoryState(key);
    if (!currentDiffHistoryState || !currentDiffHistoryState.diffState.isDiffMode) {
      return false;
    }
    const { diffState, history, diffMode, computeState } = currentDiffHistoryState;
    const acceptedComputedState = computeState ? computeState(diffState.newState, diffState.newState, []) : diffState.newState;
    const acceptedDiffState = {
      oldState: diffState.newState,
      // Copy newState to oldState
      newState: diffState.newState,
      // Keep newState as is
      computedState: acceptedComputedState,
      // Call computeState if available
      isDiffMode: false,
      // No longer in diff mode
      patches: []
      // Empty patches as states are synced
    };
    const updatedHistory = [...history, diffState];
    const updatedDiffHistoryState = {
      diffState: acceptedDiffState,
      history: updatedHistory,
      redoStack: currentDiffHistoryState.redoStack || [],
      // Preserve redo stack
      diffMode,
      computeState
      // Preserve the computeState function
    };
    get().setDiffState(key, updatedDiffHistoryState);
    return true;
  },
  rejectAllDiffs: (key) => {
    const currentDiffHistoryState = get().getDiffHistoryState(key);
    if (!currentDiffHistoryState || !currentDiffHistoryState.diffState.isDiffMode) {
      return false;
    }
    const { diffState, history, diffMode, computeState } = currentDiffHistoryState;
    const rejectedComputedState = computeState ? computeState(diffState.oldState, diffState.oldState, []) : diffState.oldState;
    const rejectedDiffState = {
      oldState: diffState.oldState,
      // Keep oldState as is
      newState: diffState.oldState,
      // Copy oldState to newState
      computedState: rejectedComputedState,
      // Call computeState if available
      isDiffMode: false,
      // No longer in diff mode
      patches: []
      // Empty patches as states are synced
    };
    const updatedHistory = [...history, diffState];
    const updatedDiffHistoryState = {
      diffState: rejectedDiffState,
      history: updatedHistory,
      redoStack: currentDiffHistoryState.redoStack || [],
      // Preserve redo stack
      diffMode,
      computeState
      // Preserve the computeState function
    };
    get().setDiffState(key, updatedDiffHistoryState);
    return true;
  },
  undo: (key) => {
    const currentDiffHistoryState = get().getDiffHistoryState(key);
    if (!currentDiffHistoryState || currentDiffHistoryState.history.length === 0) {
      return false;
    }
    const {
      diffState: currentDiffState,
      history,
      redoStack = [],
      diffMode,
      computeState
    } = currentDiffHistoryState;
    const newHistory = [...history];
    const previousState = newHistory.pop();
    if (!previousState) {
      return false;
    }
    const newRedoStack = [...redoStack, currentDiffState];
    const updatedDiffHistoryState = {
      diffState: previousState,
      history: newHistory,
      redoStack: newRedoStack,
      diffMode,
      computeState
      // Preserve the computeState function
    };
    get().setDiffState(key, updatedDiffHistoryState);
    return true;
  },
  redo: (key) => {
    const currentDiffHistoryState = get().getDiffHistoryState(key);
    if (!currentDiffHistoryState || !currentDiffHistoryState.redoStack || currentDiffHistoryState.redoStack.length === 0) {
      return false;
    }
    const {
      diffState: currentDiffState,
      history,
      redoStack,
      diffMode,
      computeState
    } = currentDiffHistoryState;
    const newRedoStack = [...redoStack];
    const redoState = newRedoStack.pop();
    if (!redoState) {
      return false;
    }
    const newHistory = [...history, currentDiffState];
    const updatedDiffHistoryState = {
      diffState: redoState,
      history: newHistory,
      redoStack: newRedoStack,
      diffMode,
      computeState
      // Preserve the computeState function
    };
    get().setDiffState(key, updatedDiffHistoryState);
    return true;
  },
  acceptDiff: (key, jsonPath, identificationField, targetId, diffMarkerPaths) => {
    return handleSingleDiff(
      get,
      key,
      jsonPath,
      identificationField,
      "accept",
      targetId,
      diffMarkerPaths
    );
  },
  rejectDiff: (key, jsonPath, identificationField, targetId, diffMarkerPaths) => {
    return handleSingleDiff(
      get,
      key,
      jsonPath,
      identificationField,
      "reject",
      targetId,
      diffMarkerPaths
    );
  }
});
export {
  createDiffHistorySlice
};
//# sourceMappingURL=diffHistorySlice.mjs.map