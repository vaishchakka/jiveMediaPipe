// src/store/agentConnection/agentUtils.ts
var processContentChunk = (rawChunk) => {
  return rawChunk.replace(/(\\n|\n)/g, "\n");
};
async function handleEventStream(response, handler) {
  if (!response.ok || !response.body) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }
  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  let buffer = "";
  const completedItems = [];
  let currentTextMessage = "";
  const parseSSEEvent = (raw) => {
    let eventType = "message";
    let data = "";
    for (const line of raw.split("\n")) {
      if (line.startsWith("event:")) {
        eventType = line.slice(6).trim();
      } else if (line.startsWith("data:")) {
        data += line.slice(5);
      }
    }
    return { eventType, data };
  };
  const processDataContent = (data) => {
    if (data.trim() === "[DONE]" || data.trim() === "done") {
      return;
    }
    try {
      const parsed = JSON.parse(data);
      if (parsed === null || typeof parsed !== "object") {
        const processedContent = processContentChunk(String(parsed));
        currentTextMessage += processedContent;
        handler({ type: "chunk", content: processedContent });
        return;
      }
      if (parsed.choices && parsed.choices[0] && parsed.choices[0].delta) {
        const delta = parsed.choices[0].delta;
        if (delta.content) {
          const processedContent = processContentChunk(delta.content);
          currentTextMessage += processedContent;
          handler({ type: "chunk", content: processedContent });
        }
        if (delta.tool_calls || delta.function_call) {
          if (currentTextMessage.trim()) {
            completedItems.push(currentTextMessage.trim());
            currentTextMessage = "";
          }
          handler({ type: "object", object: delta });
          completedItems.push(delta);
        }
        if (Object.keys(delta).length === 0) {
          return;
        }
      }
      if (typeof parsed.content === "string" && parsed.content.length > 0) {
        const processedContent = processContentChunk(parsed.content);
        currentTextMessage += processedContent;
        handler({ type: "chunk", content: processedContent });
      }
      if (parsed.type || parsed.object && parsed.object.type) {
        const structuredObject = parsed.type ? parsed : parsed.object;
        if (currentTextMessage.trim()) {
          completedItems.push(currentTextMessage.trim());
          currentTextMessage = "";
        }
        handler({ type: "object", object: structuredObject });
        completedItems.push(structuredObject);
      }
      if (!parsed.choices && !parsed.type && !(parsed.object && parsed.object.type) && !parsed.content) {
        if (currentTextMessage.trim()) {
          completedItems.push(currentTextMessage.trim());
          currentTextMessage = "";
        }
        handler({ type: "object", object: parsed });
        completedItems.push(parsed);
      }
    } catch {
      if (data && data !== "[DONE]" && data !== "done") {
        const processedContent = processContentChunk(data);
        currentTextMessage += processedContent;
        handler({ type: "chunk", content: processedContent });
      }
    }
  };
  try {
    while (true) {
      const { value, done } = await reader.read();
      if (done) break;
      buffer += decoder.decode(value, { stream: true });
      let eventBoundary;
      while ((eventBoundary = buffer.indexOf("\n\n")) !== -1) {
        const rawEvent = buffer.slice(0, eventBoundary);
        buffer = buffer.slice(eventBoundary + 2);
        if (!rawEvent.trim()) continue;
        const { eventType, data } = parseSSEEvent(rawEvent);
        if (eventType.trim() === "done" || data.trim() === "[DONE]") {
          break;
        } else {
          processDataContent(data);
        }
      }
    }
    if (currentTextMessage.trim()) {
      completedItems.push(currentTextMessage.trim());
    }
    handler({ type: "done", completedItems });
  } catch (error) {
    handler({ type: "error", error });
    throw error;
  }
}
export {
  handleEventStream
};
//# sourceMappingURL=agentUtils.mjs.map