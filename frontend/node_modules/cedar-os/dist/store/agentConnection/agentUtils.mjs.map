{"version":3,"sources":["../../../src/store/agentConnection/agentUtils.ts"],"sourcesContent":["/**\n * Enhanced Server-Sent Events (SSE) stream parser\n *\n * This function handles parsing of streaming responses from various LLM providers:\n * - OpenAI: Uses delta format with choices array\n * - Mastra: Uses custom object types\n * - AI SDK: Uses direct text streaming (handled internally by AI SDK)\n * - Raw text: Plain text chunks\n *\n * Key responsibilities:\n * 1. Parse SSE format (data: content\\n\\n)\n * 2. Handle mixed text/JSON content streams\n * 3. Accumulate text messages and track completed items\n * 4. Call handler immediately for real-time processing\n * 5. Provide completion summary with all items\n */\n\nimport type { StreamHandler } from '@/store/agentConnection/AgentConnectionTypes';\n\n/**\n * Process raw content chunks to handle encoding and newlines\n * Converts escaped newlines (\\n) and actual newlines to proper line breaks\n */\nconst processContentChunk = (rawChunk: string): string => {\n\treturn rawChunk.replace(/(\\\\n|\\n)/g, '\\n');\n};\n\n/**\n * Main SSE stream handler - processes Server-Sent Events from LLM providers\n *\n * @param response - HTTP Response object with streaming body\n * @param handler - StreamHandler to call for each parsed event (chunk, object, done, error)\n */\nexport async function handleEventStream(\n\tresponse: Response,\n\thandler: StreamHandler\n): Promise<void> {\n\tif (!response.ok || !response.body) {\n\t\tthrow new Error(`HTTP error! status: ${response.status}`);\n\t}\n\n\t// Set up streaming infrastructure\n\tconst reader = response.body.getReader();\n\tconst decoder = new TextDecoder();\n\tlet buffer = '';\n\tconst completedItems: (string | object)[] = []; // Track all processed items for completion logging\n\tlet currentTextMessage = ''; // Accumulate text chunks into messages\n\n\t/**\n\t * Parse Server-Sent Event format\n\t * Standard SSE format: \"event: type\\ndata: content\\n\\n\"\n\t * Most providers only use the data field\n\t */\n\tconst parseSSEEvent = (raw: string) => {\n\t\tlet eventType = 'message';\n\t\tlet data = '';\n\n\t\tfor (const line of raw.split('\\n')) {\n\t\t\tif (line.startsWith('event:')) {\n\t\t\t\teventType = line.slice(6).trim();\n\t\t\t} else if (line.startsWith('data:')) {\n\t\t\t\tdata += line.slice(5); // Note: preserves leading space after 'data:'\n\t\t\t}\n\t\t}\n\n\t\treturn { eventType, data };\n\t};\n\n\t/**\n\t * Process the data content from SSE events\n\t * Handles multiple content formats:\n\t * 1. OpenAI delta format: {\"choices\": [{\"delta\": {\"content\": \"text\"}}]}\n\t * 2. Custom object format: {\"type\": \"setState\", \"data\": {...}}\n\t * 3. Direct content: {\"content\": \"text\"}\n\t * 4. Plain text: raw string content\n\t */\n\tconst processDataContent = (data: string) => {\n\t\t// Skip completion markers that signal end of stream\n\t\tif (data.trim() === '[DONE]' || data.trim() === 'done') {\n\t\t\treturn;\n\t\t}\n\n\t\t// Attempt JSON parsing first (most common case)\n\t\ttry {\n\t\t\tconst parsed = JSON.parse(data);\n\n\t\t\t// If the parsed value is a primitive (number, string, boolean, null),\n\t\t\t// treat it as plain text content rather than a structured object.\n\t\t\t// This handles cases where providers stream individual tokens like \"292\" or \"â€¢\"\n\t\t\tif (parsed === null || typeof parsed !== 'object') {\n\t\t\t\tconst processedContent = processContentChunk(String(parsed));\n\t\t\t\tcurrentTextMessage += processedContent;\n\t\t\t\thandler({ type: 'chunk', content: processedContent });\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// OpenAI format: {\"choices\": [{\"delta\": {...}}]}\n\t\t\tif (parsed.choices && parsed.choices[0] && parsed.choices[0].delta) {\n\t\t\t\tconst delta = parsed.choices[0].delta;\n\n\t\t\t\t// Process text content from delta\n\t\t\t\tif (delta.content) {\n\t\t\t\t\tconst processedContent = processContentChunk(delta.content);\n\t\t\t\t\tcurrentTextMessage += processedContent;\n\t\t\t\t\thandler({ type: 'chunk', content: processedContent });\n\t\t\t\t}\n\n\t\t\t\t// Process structured data (tool calls, function calls)\n\t\t\t\t// Skip role-only deltas which don't contain actual content\n\t\t\t\tif (delta.tool_calls || delta.function_call) {\n\t\t\t\t\t// Save any accumulated text before processing object\n\t\t\t\t\tif (currentTextMessage.trim()) {\n\t\t\t\t\t\tcompletedItems.push(currentTextMessage.trim());\n\t\t\t\t\t\tcurrentTextMessage = '';\n\t\t\t\t\t}\n\t\t\t\t\thandler({ type: 'object', object: delta });\n\t\t\t\t\tcompletedItems.push(delta);\n\t\t\t\t}\n\n\t\t\t\t// Empty delta indicates completion for some providers\n\t\t\t\tif (Object.keys(delta).length === 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 1. Direct content (may accompany a structured object)\n\t\t\tif (typeof parsed.content === 'string' && parsed.content.length > 0) {\n\t\t\t\tconst processedContent = processContentChunk(parsed.content);\n\t\t\t\tcurrentTextMessage += processedContent;\n\t\t\t\thandler({ type: 'chunk', content: processedContent });\n\t\t\t}\n\n\t\t\t// 2. Mastra/custom structured object handling\n\t\t\t//    a) Inline object        -> {\"type\": \"setState\", ... }\n\t\t\t//    b) Nested under object  -> {\"object\": {\"type\": \"setState\", ...}}\n\t\t\tif (\n\t\t\t\tparsed.type ||\n\t\t\t\t(parsed.object && (parsed.object as { type?: string }).type)\n\t\t\t) {\n\t\t\t\tconst structuredObject = parsed.type\n\t\t\t\t\t? parsed\n\t\t\t\t\t: (parsed.object as object);\n\n\t\t\t\t// Flush any accumulated text before sending the object event\n\t\t\t\tif (currentTextMessage.trim()) {\n\t\t\t\t\tcompletedItems.push(currentTextMessage.trim());\n\t\t\t\t\tcurrentTextMessage = '';\n\t\t\t\t}\n\n\t\t\t\thandler({ type: 'object', object: structuredObject });\n\t\t\t\tcompletedItems.push(structuredObject);\n\t\t\t}\n\n\t\t\t// 3. Fallback for generic JSON without recognised fields but still valuable\n\t\t\tif (\n\t\t\t\t!parsed.choices &&\n\t\t\t\t!parsed.type &&\n\t\t\t\t!(parsed.object && (parsed.object as { type?: string }).type) &&\n\t\t\t\t!parsed.content\n\t\t\t) {\n\t\t\t\t// Flush accumulated text first\n\t\t\t\tif (currentTextMessage.trim()) {\n\t\t\t\t\tcompletedItems.push(currentTextMessage.trim());\n\t\t\t\t\tcurrentTextMessage = '';\n\t\t\t\t}\n\n\t\t\t\thandler({ type: 'object', object: parsed });\n\t\t\t\tcompletedItems.push(parsed);\n\t\t\t}\n\t\t} catch {\n\t\t\t// Not valid JSON, treat as plain text content\n\t\t\t// Note: Don't use data.trim() here as it would filter out space-only chunks\n\t\t\tif (data && data !== '[DONE]' && data !== 'done') {\n\t\t\t\tconst processedContent = processContentChunk(data);\n\t\t\t\tcurrentTextMessage += processedContent;\n\t\t\t\thandler({ type: 'chunk', content: processedContent });\n\t\t\t}\n\t\t}\n\t};\n\n\ttry {\n\t\t// Main streaming loop - read and process SSE events\n\t\twhile (true) {\n\t\t\tconst { value, done } = await reader.read();\n\t\t\tif (done) break;\n\n\t\t\t// Decode bytes to string and add to buffer\n\t\t\tbuffer += decoder.decode(value, { stream: true });\n\n\t\t\t// Process complete SSE events (delimited by \\n\\n)\n\t\t\tlet eventBoundary: number;\n\t\t\twhile ((eventBoundary = buffer.indexOf('\\n\\n')) !== -1) {\n\t\t\t\tconst rawEvent = buffer.slice(0, eventBoundary);\n\t\t\t\tbuffer = buffer.slice(eventBoundary + 2);\n\n\t\t\t\tif (!rawEvent.trim()) continue; // Skip empty events\n\n\t\t\t\tconst { eventType, data } = parseSSEEvent(rawEvent);\n\n\t\t\t\t// Check for stream completion signals\n\t\t\t\tif (eventType.trim() === 'done' || data.trim() === '[DONE]') {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tprocessDataContent(data);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Finalize any remaining accumulated text\n\t\tif (currentTextMessage.trim()) {\n\t\t\tcompletedItems.push(currentTextMessage.trim());\n\t\t}\n\n\t\t// Signal completion with summary of all processed items\n\t\thandler({ type: 'done', completedItems });\n\t} catch (error) {\n\t\thandler({ type: 'error', error: error as Error });\n\t\tthrow error;\n\t}\n}\n"],"mappings":"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","names":[]}