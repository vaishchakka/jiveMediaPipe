{"version":3,"sources":["../../../../src/store/agentConnection/responseProcessors/humanInTheLoopResponseProcessor.ts"],"sourcesContent":["import {\n\tInferProviderConfig,\n\tResponseProcessor,\n} from '@/store/agentConnection/AgentConnectionTypes';\nimport {\n\tHumanInTheLoopResponse,\n\tHumanInTheLoopState,\n} from './humanInTheLoopTypes';\n\n/**\n * Response processor for human-in-the-loop workflows\n * Handles suspend responses from Mastra backend and creates interactive UI\n */\nexport const humanInTheLoopResponseProcessor: ResponseProcessor<HumanInTheLoopResponse> =\n\t{\n\t\ttype: 'humanInTheLoop',\n\t\tnamespace: 'default',\n\t\texecute: async (obj, store) => {\n\t\t\tconst { runId, stepPath, suspendPayload, message, timeoutMs } = obj;\n\n\t\t\t// Use single state key for all human-in-the-loop data\n\t\t\tconst stateKey = 'humanInTheLoop';\n\n\t\t\t// Get current state or initialize\n\t\t\tconst currentState =\n\t\t\t\t(store.getCedarState(stateKey) as HumanInTheLoopState) || {};\n\n\t\t\t// Store suspend data for this runId\n\t\t\tconst suspendInfo = {\n\t\t\t\trunId,\n\t\t\t\tstepPath,\n\t\t\t\tsuspendPayload,\n\t\t\t\tsuspendedAt: new Date().toISOString(),\n\t\t\t\tstate: 'suspended' as const,\n\t\t\t\tthreadId: store.mainThreadId,\n\t\t\t\tmessageId: '', // Will be set after message creation\n\t\t\t};\n\n\t\t\t// Update the state with new suspend info\n\t\t\tconst newState = {\n\t\t\t\t...currentState,\n\t\t\t\t[runId]: suspendInfo,\n\t\t\t};\n\n\t\t\t// Register state if not exists, or update existing\n\t\t\tconst existingState = store.getCedarState(stateKey);\n\t\t\tif (!existingState) {\n\t\t\t\tstore.registerState({\n\t\t\t\t\tkey: stateKey,\n\t\t\t\t\tvalue: newState as HumanInTheLoopState,\n\t\t\t\t\tdescription: 'Human-in-the-loop workflow suspend/resume data',\n\t\t\t\t\tstateSetters: {\n\t\t\t\t\t\tresume: {\n\t\t\t\t\t\t\tname: 'resume',\n\t\t\t\t\t\t\tdescription: 'Resume a suspended workflow',\n\t\t\t\t\t\t\texecute: async (\n\t\t\t\t\t\t\t\tcurrent: HumanInTheLoopState,\n\t\t\t\t\t\t\t\t...args: unknown[]\n\t\t\t\t\t\t\t) => {\n\t\t\t\t\t\t\t\tconst [runId, resumeData] = args as [\n\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\tRecord<string, unknown>\n\t\t\t\t\t\t\t\t];\n\t\t\t\t\t\t\t\tconst workflow = current[runId];\n\t\t\t\t\t\t\t\tif (!workflow) return current;\n\n\t\t\t\t\t\t\t\t// Update state\n\t\t\t\t\t\t\t\tconst updatedState = {\n\t\t\t\t\t\t\t\t\t...current,\n\t\t\t\t\t\t\t\t\t[runId]: {\n\t\t\t\t\t\t\t\t\t\t...workflow,\n\t\t\t\t\t\t\t\t\t\tstate: 'resumed' as const,\n\t\t\t\t\t\t\t\t\t\tresumeData,\n\t\t\t\t\t\t\t\t\t\tresumedAt: new Date().toISOString(),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t// Add a new message to show resumed state instead of updating existing\n\t\t\t\t\t\t\t\tif (workflow.messageId) {\n\t\t\t\t\t\t\t\t\tconst originalMessage = store.getMessageById(\n\t\t\t\t\t\t\t\t\t\tworkflow.messageId\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tif (originalMessage) {\n\t\t\t\t\t\t\t\t\t\tconst resumedMessage = {\n\t\t\t\t\t\t\t\t\t\t\t...originalMessage,\n\t\t\t\t\t\t\t\t\t\t\tid: undefined, // Let addMessage generate new ID\n\t\t\t\t\t\t\t\t\t\t\tstate: 'resumed' as const,\n\t\t\t\t\t\t\t\t\t\t\tresumeData,\n\t\t\t\t\t\t\t\t\t\t\tresumedAt: new Date().toISOString(),\n\t\t\t\t\t\t\t\t\t\t\tcontent: `Successfully resumed workflow.`,\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\tstore.addMessage(resumedMessage);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Get resumePath from provider config\n\t\t\t\t\t\t\t\tconst config = store.providerConfig;\n\t\t\t\t\t\t\t\tconst resumePath =\n\t\t\t\t\t\t\t\t\tconfig?.provider === 'mastra'\n\t\t\t\t\t\t\t\t\t\t? (config as InferProviderConfig<'mastra'>).resumePath ||\n\t\t\t\t\t\t\t\t\t\t  '/chat/resume'\n\t\t\t\t\t\t\t\t\t\t: '/chat/resume';\n\n\t\t\t\t\t\t\t\t// Send resume request\n\t\t\t\t\t\t\t\tawait store.sendMessage<\n\t\t\t\t\t\t\t\t\tRecord<string, never>,\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\trunId: string;\n\t\t\t\t\t\t\t\t\t\tstepPath: [string[], ...string[][]];\n\t\t\t\t\t\t\t\t\t\tresumeData: Record<string, unknown>;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t>({\n\t\t\t\t\t\t\t\t\tstream: true,\n\t\t\t\t\t\t\t\t\troute: resumePath,\n\t\t\t\t\t\t\t\t\trunId,\n\t\t\t\t\t\t\t\t\tstepPath: workflow.stepPath,\n\t\t\t\t\t\t\t\t\tresumeData,\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\treturn updatedState;\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcancel: {\n\t\t\t\t\t\t\tname: 'cancel',\n\t\t\t\t\t\t\tdescription: 'Cancel a suspended workflow',\n\t\t\t\t\t\t\texecute: async (\n\t\t\t\t\t\t\t\tcurrent: HumanInTheLoopState,\n\t\t\t\t\t\t\t\t...args: unknown[]\n\t\t\t\t\t\t\t) => {\n\t\t\t\t\t\t\t\tconst [runId] = args as [string];\n\t\t\t\t\t\t\t\tconst workflow = current[runId];\n\t\t\t\t\t\t\t\tif (!workflow) return current;\n\n\t\t\t\t\t\t\t\tconst updatedState = {\n\t\t\t\t\t\t\t\t\t...current,\n\t\t\t\t\t\t\t\t\t[runId]: {\n\t\t\t\t\t\t\t\t\t\t...workflow,\n\t\t\t\t\t\t\t\t\t\tstate: 'cancelled' as const,\n\t\t\t\t\t\t\t\t\t\tcancelledAt: new Date().toISOString(),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t// Add a new message to show cancelled state instead of updating existing\n\t\t\t\t\t\t\t\tif (workflow.messageId) {\n\t\t\t\t\t\t\t\t\tconst originalMessage = store.getMessageById(\n\t\t\t\t\t\t\t\t\t\tworkflow.messageId\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tif (originalMessage) {\n\t\t\t\t\t\t\t\t\t\tconst cancelledMessage = {\n\t\t\t\t\t\t\t\t\t\t\t...originalMessage,\n\t\t\t\t\t\t\t\t\t\t\tid: undefined, // Let addMessage generate new ID\n\t\t\t\t\t\t\t\t\t\t\tstate: 'cancelled' as const,\n\t\t\t\t\t\t\t\t\t\t\tcancelledAt: new Date().toISOString(),\n\t\t\t\t\t\t\t\t\t\t\tcontent: `Workflow ${runId} has been cancelled.`,\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\tstore.addMessage(cancelledMessage);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn updatedState;\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tstore.setCedarState(stateKey, newState);\n\t\t\t}\n\n\t\t\t// Create typed resume callback\n\t\t\tconst resumeCallback = async (resumeData: Record<string, unknown>) => {\n\t\t\t\tawait store.executeCustomSetter({\n\t\t\t\t\tkey: stateKey,\n\t\t\t\t\tsetterKey: 'resume',\n\t\t\t\t\targs: [runId, resumeData],\n\t\t\t\t});\n\t\t\t};\n\n\t\t\t// Create typed cancel callback\n\t\t\tconst cancelCallback = async () => {\n\t\t\t\tawait store.executeCustomSetter({\n\t\t\t\t\tkey: stateKey,\n\t\t\t\t\tsetterKey: 'cancel',\n\t\t\t\t\targs: [runId],\n\t\t\t\t});\n\t\t\t};\n\n\t\t\t// Add message to chat with callbacks\n\t\t\tconst chatMessage = {\n\t\t\t\ttype: 'humanInTheLoop',\n\t\t\t\trole: 'assistant',\n\t\t\t\tcontent: message || `Workflow ${runId} is waiting for your input...`,\n\t\t\t\tstate: 'suspended',\n\t\t\t\trunId,\n\t\t\t\tstepPath,\n\t\t\t\tsuspendPayload,\n\t\t\t\tresumeCallback,\n\t\t\t\tcancelCallback,\n\t\t\t\tmetadata: obj.metadata,\n\t\t\t};\n\n\t\t\tconst addedMessage = store.addMessage(chatMessage);\n\n\t\t\t// Update state with messageId\n\t\t\tconst finalState = {\n\t\t\t\t...newState,\n\t\t\t\t[runId]: {\n\t\t\t\t\t...suspendInfo,\n\t\t\t\t\tmessageId: addedMessage.id,\n\t\t\t\t},\n\t\t\t};\n\t\t\tstore.setCedarState(stateKey, finalState);\n\n\t\t\t// Set up timeout if specified\n\t\t\tif (timeoutMs && timeoutMs > 0) {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tconst currentWorkflowState = store.getCedarState(\n\t\t\t\t\t\tstateKey\n\t\t\t\t\t) as HumanInTheLoopState;\n\t\t\t\t\tconst workflow = currentWorkflowState?.[runId];\n\t\t\t\t\tif (workflow?.state === 'suspended') {\n\t\t\t\t\t\t// Add a new timeout message instead of updating existing\n\t\t\t\t\t\tconst originalMessage = store.getMessageById(addedMessage.id);\n\t\t\t\t\t\tif (originalMessage) {\n\t\t\t\t\t\t\tconst timeoutMessage = {\n\t\t\t\t\t\t\t\t...originalMessage,\n\t\t\t\t\t\t\t\tid: undefined, // Let addMessage generate new ID\n\t\t\t\t\t\t\t\tstate: 'timeout' as const,\n\t\t\t\t\t\t\t\tcontent: `Workflow has timed out and been cancelled.`,\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tstore.addMessage(timeoutMessage);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcancelCallback();\n\t\t\t\t\t}\n\t\t\t\t}, timeoutMs);\n\t\t\t}\n\t\t},\n\t\tvalidate: (obj): obj is HumanInTheLoopResponse =>\n\t\t\tobj.type === 'humanInTheLoop' &&\n\t\t\t'runId' in obj &&\n\t\t\t'stepPath' in obj &&\n\t\t\t'status' in obj &&\n\t\t\tobj.status === 'suspended',\n\t};\n"],"mappings":"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","names":["runId"]}