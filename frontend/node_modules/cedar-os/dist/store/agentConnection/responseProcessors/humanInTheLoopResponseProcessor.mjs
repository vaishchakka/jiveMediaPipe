// src/store/agentConnection/responseProcessors/humanInTheLoopResponseProcessor.ts
var humanInTheLoopResponseProcessor = {
  type: "humanInTheLoop",
  namespace: "default",
  execute: async (obj, store) => {
    const { runId, stepPath, suspendPayload, message, timeoutMs } = obj;
    const stateKey = "humanInTheLoop";
    const currentState = store.getCedarState(stateKey) || {};
    const suspendInfo = {
      runId,
      stepPath,
      suspendPayload,
      suspendedAt: (/* @__PURE__ */ new Date()).toISOString(),
      state: "suspended",
      threadId: store.mainThreadId,
      messageId: ""
      // Will be set after message creation
    };
    const newState = {
      ...currentState,
      [runId]: suspendInfo
    };
    const existingState = store.getCedarState(stateKey);
    if (!existingState) {
      store.registerState({
        key: stateKey,
        value: newState,
        description: "Human-in-the-loop workflow suspend/resume data",
        stateSetters: {
          resume: {
            name: "resume",
            description: "Resume a suspended workflow",
            execute: async (current, ...args) => {
              const [runId2, resumeData] = args;
              const workflow = current[runId2];
              if (!workflow) return current;
              const updatedState = {
                ...current,
                [runId2]: {
                  ...workflow,
                  state: "resumed",
                  resumeData,
                  resumedAt: (/* @__PURE__ */ new Date()).toISOString()
                }
              };
              if (workflow.messageId) {
                const originalMessage = store.getMessageById(
                  workflow.messageId
                );
                if (originalMessage) {
                  const resumedMessage = {
                    ...originalMessage,
                    id: void 0,
                    // Let addMessage generate new ID
                    state: "resumed",
                    resumeData,
                    resumedAt: (/* @__PURE__ */ new Date()).toISOString(),
                    content: `Successfully resumed workflow.`
                  };
                  store.addMessage(resumedMessage);
                }
              }
              const config = store.providerConfig;
              const resumePath = config?.provider === "mastra" ? config.resumePath || "/chat/resume" : "/chat/resume";
              await store.sendMessage({
                stream: true,
                route: resumePath,
                runId: runId2,
                stepPath: workflow.stepPath,
                resumeData
              });
              return updatedState;
            }
          },
          cancel: {
            name: "cancel",
            description: "Cancel a suspended workflow",
            execute: async (current, ...args) => {
              const [runId2] = args;
              const workflow = current[runId2];
              if (!workflow) return current;
              const updatedState = {
                ...current,
                [runId2]: {
                  ...workflow,
                  state: "cancelled",
                  cancelledAt: (/* @__PURE__ */ new Date()).toISOString()
                }
              };
              if (workflow.messageId) {
                const originalMessage = store.getMessageById(
                  workflow.messageId
                );
                if (originalMessage) {
                  const cancelledMessage = {
                    ...originalMessage,
                    id: void 0,
                    // Let addMessage generate new ID
                    state: "cancelled",
                    cancelledAt: (/* @__PURE__ */ new Date()).toISOString(),
                    content: `Workflow ${runId2} has been cancelled.`
                  };
                  store.addMessage(cancelledMessage);
                }
              }
              return updatedState;
            }
          }
        }
      });
    } else {
      store.setCedarState(stateKey, newState);
    }
    const resumeCallback = async (resumeData) => {
      await store.executeCustomSetter({
        key: stateKey,
        setterKey: "resume",
        args: [runId, resumeData]
      });
    };
    const cancelCallback = async () => {
      await store.executeCustomSetter({
        key: stateKey,
        setterKey: "cancel",
        args: [runId]
      });
    };
    const chatMessage = {
      type: "humanInTheLoop",
      role: "assistant",
      content: message || `Workflow ${runId} is waiting for your input...`,
      state: "suspended",
      runId,
      stepPath,
      suspendPayload,
      resumeCallback,
      cancelCallback,
      metadata: obj.metadata
    };
    const addedMessage = store.addMessage(chatMessage);
    const finalState = {
      ...newState,
      [runId]: {
        ...suspendInfo,
        messageId: addedMessage.id
      }
    };
    store.setCedarState(stateKey, finalState);
    if (timeoutMs && timeoutMs > 0) {
      setTimeout(() => {
        const currentWorkflowState = store.getCedarState(
          stateKey
        );
        const workflow = currentWorkflowState?.[runId];
        if (workflow?.state === "suspended") {
          const originalMessage = store.getMessageById(addedMessage.id);
          if (originalMessage) {
            const timeoutMessage = {
              ...originalMessage,
              id: void 0,
              // Let addMessage generate new ID
              state: "timeout",
              content: `Workflow has timed out and been cancelled.`
            };
            store.addMessage(timeoutMessage);
          }
          cancelCallback();
        }
      }, timeoutMs);
    }
  },
  validate: (obj) => obj.type === "humanInTheLoop" && "runId" in obj && "stepPath" in obj && "status" in obj && obj.status === "suspended"
};
export {
  humanInTheLoopResponseProcessor
};
//# sourceMappingURL=humanInTheLoopResponseProcessor.mjs.map