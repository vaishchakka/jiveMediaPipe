"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/store/agentConnection/providers/mastra.ts
var mastra_exports = {};
__export(mastra_exports, {
  mastraProvider: () => mastraProvider
});
module.exports = __toCommonJS(mastra_exports);

// src/store/agentConnection/agentUtils.ts
var processContentChunk = (rawChunk) => {
  return rawChunk.replace(/(\\n|\n)/g, "\n");
};
async function handleEventStream(response, handler) {
  if (!response.ok || !response.body) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }
  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  let buffer = "";
  const completedItems = [];
  let currentTextMessage = "";
  const parseSSEEvent = (raw) => {
    let eventType = "message";
    let data = "";
    for (const line of raw.split("\n")) {
      if (line.startsWith("event:")) {
        eventType = line.slice(6).trim();
      } else if (line.startsWith("data:")) {
        data += line.slice(5);
      }
    }
    return { eventType, data };
  };
  const processDataContent = (data) => {
    if (data.trim() === "[DONE]" || data.trim() === "done") {
      return;
    }
    try {
      const parsed = JSON.parse(data);
      if (parsed === null || typeof parsed !== "object") {
        const processedContent = processContentChunk(String(parsed));
        currentTextMessage += processedContent;
        handler({ type: "chunk", content: processedContent });
        return;
      }
      if (parsed.choices && parsed.choices[0] && parsed.choices[0].delta) {
        const delta = parsed.choices[0].delta;
        if (delta.content) {
          const processedContent = processContentChunk(delta.content);
          currentTextMessage += processedContent;
          handler({ type: "chunk", content: processedContent });
        }
        if (delta.tool_calls || delta.function_call) {
          if (currentTextMessage.trim()) {
            completedItems.push(currentTextMessage.trim());
            currentTextMessage = "";
          }
          handler({ type: "object", object: delta });
          completedItems.push(delta);
        }
        if (Object.keys(delta).length === 0) {
          return;
        }
      }
      if (typeof parsed.content === "string" && parsed.content.length > 0) {
        const processedContent = processContentChunk(parsed.content);
        currentTextMessage += processedContent;
        handler({ type: "chunk", content: processedContent });
      }
      if (parsed.type || parsed.object && parsed.object.type) {
        const structuredObject = parsed.type ? parsed : parsed.object;
        if (currentTextMessage.trim()) {
          completedItems.push(currentTextMessage.trim());
          currentTextMessage = "";
        }
        handler({ type: "object", object: structuredObject });
        completedItems.push(structuredObject);
      }
      if (!parsed.choices && !parsed.type && !(parsed.object && parsed.object.type) && !parsed.content) {
        if (currentTextMessage.trim()) {
          completedItems.push(currentTextMessage.trim());
          currentTextMessage = "";
        }
        handler({ type: "object", object: parsed });
        completedItems.push(parsed);
      }
    } catch {
      if (data && data !== "[DONE]" && data !== "done") {
        const processedContent = processContentChunk(data);
        currentTextMessage += processedContent;
        handler({ type: "chunk", content: processedContent });
      }
    }
  };
  try {
    while (true) {
      const { value, done } = await reader.read();
      if (done) break;
      buffer += decoder.decode(value, { stream: true });
      let eventBoundary;
      while ((eventBoundary = buffer.indexOf("\n\n")) !== -1) {
        const rawEvent = buffer.slice(0, eventBoundary);
        buffer = buffer.slice(eventBoundary + 2);
        if (!rawEvent.trim()) continue;
        const { eventType, data } = parseSSEEvent(rawEvent);
        if (eventType.trim() === "done" || data.trim() === "[DONE]") {
          break;
        } else {
          processDataContent(data);
        }
      }
    }
    if (currentTextMessage.trim()) {
      completedItems.push(currentTextMessage.trim());
    }
    handler({ type: "done", completedItems });
  } catch (error) {
    handler({ type: "error", error });
    throw error;
  }
}

// src/store/agentConnection/providers/mastra.ts
async function handleVoiceEventStream(response, handler) {
  const reader = response.body?.getReader();
  if (!reader) {
    throw new Error("Response body is not readable");
  }
  const decoder = new TextDecoder();
  let buffer = "";
  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      const chunk = decoder.decode(value, { stream: true });
      buffer += chunk;
      const lines = buffer.split("\n");
      buffer = lines.pop() || "";
      for (const line of lines) {
        const trimmedLine = line.trim();
        if (!trimmedLine || !trimmedLine.startsWith("data: ")) continue;
        const data = trimmedLine.slice(6);
        try {
          const parsed = JSON.parse(data);
          if (parsed.type === "transcription" && parsed.transcription) {
            handler({
              type: "transcription",
              transcription: parsed.transcription
            });
          } else if (parsed.type === "audio" && parsed.audioData) {
            handler({
              type: "audio",
              audioData: parsed.audioData,
              audioFormat: parsed.audioFormat,
              content: parsed.content
            });
          } else if (parsed.type === "chunk" && parsed.content) {
            handler({
              type: "chunk",
              content: parsed.content
            });
          } else if (parsed.type === "object" && parsed.object) {
            handler({
              type: "object",
              object: parsed.object
            });
          } else if (parsed.type === "error") {
            handler({
              type: "error",
              error: new Error(parsed.error || "Stream error")
            });
          } else if (parsed.type === "done") {
            handler({
              type: "done",
              completedItems: parsed.completedItems || []
            });
          }
        } catch (parseError) {
          console.warn("Failed to parse voice stream event:", parseError);
          console.warn("Problematic data length:", data.length);
        }
      }
    }
    if (buffer.trim()) {
      const trimmedLine = buffer.trim();
      if (trimmedLine.startsWith("data: ")) {
        const data = trimmedLine.slice(6);
        try {
          const parsed = JSON.parse(data);
          if (parsed.type === "transcription" && parsed.transcription) {
            handler({
              type: "transcription",
              transcription: parsed.transcription
            });
          } else if (parsed.type === "audio" && parsed.audioData) {
            handler({
              type: "audio",
              audioData: parsed.audioData,
              audioFormat: parsed.audioFormat,
              content: parsed.content
            });
          } else if (parsed.type === "chunk" && parsed.content) {
            handler({
              type: "chunk",
              content: parsed.content
            });
          } else if (parsed.type === "object" && parsed.object) {
            handler({
              type: "object",
              object: parsed.object
            });
          } else if (parsed.type === "error") {
            handler({
              type: "error",
              error: new Error(parsed.error || "Stream error")
            });
          } else if (parsed.type === "done") {
            handler({
              type: "done",
              completedItems: parsed.completedItems || []
            });
          }
        } catch (parseError) {
          console.warn("Failed to parse final voice stream event:", parseError);
        }
      }
    }
  } finally {
    reader.releaseLock();
  }
}
var mastraProvider = {
  callLLM: async (params, config) => {
    const { route, prompt, systemPrompt, temperature, maxTokens, ...rest } = params;
    const headers = {
      "Content-Type": "application/json"
    };
    if (config.apiKey) {
      headers.Authorization = `Bearer ${config.apiKey}`;
    }
    const response = await fetch(`${config.baseURL}${route}`, {
      method: "POST",
      headers,
      body: JSON.stringify({
        prompt,
        systemPrompt,
        temperature,
        maxTokens,
        ...rest
      })
    });
    return mastraProvider.handleResponse(response);
  },
  callLLMStructured: async (params, config) => {
    const {
      route,
      prompt,
      systemPrompt,
      temperature,
      maxTokens,
      schema,
      schemaName,
      schemaDescription,
      ...rest
    } = params;
    const headers = {
      "Content-Type": "application/json"
    };
    if (config.apiKey) {
      headers.Authorization = `Bearer ${config.apiKey}`;
    }
    const body = {
      prompt,
      systemPrompt,
      temperature,
      maxTokens,
      ...rest
    };
    if (schema) {
      body.schema = schema;
      body.schemaName = schemaName;
      body.schemaDescription = schemaDescription;
    }
    const response = await fetch(`${config.baseURL}${route}`, {
      method: "POST",
      headers,
      body: JSON.stringify(body)
    });
    return mastraProvider.handleResponse(response);
  },
  streamLLM: (params, config, handler) => {
    const abortController = new AbortController();
    const completion = (async () => {
      try {
        const { route, prompt, systemPrompt, temperature, maxTokens, ...rest } = params;
        const headers = {
          "Content-Type": "application/json"
        };
        if (config.apiKey) {
          headers.Authorization = `Bearer ${config.apiKey}`;
        }
        const response = await fetch(`${config.baseURL}${route}/stream`, {
          method: "POST",
          headers,
          body: JSON.stringify({
            prompt,
            systemPrompt,
            temperature,
            maxTokens,
            ...rest
          }),
          signal: abortController.signal
        });
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        await handleEventStream(response, handler);
      } catch (error) {
        if (error instanceof Error && error.name !== "AbortError") {
          handler({ type: "error", error });
        }
      }
    })();
    return {
      abort: () => abortController.abort(),
      completion
    };
  },
  voiceLLM: async (params, config) => {
    const { audioData, voiceSettings, context, ...rest } = params;
    const headers = {};
    if (config.apiKey) {
      headers.Authorization = `Bearer ${config.apiKey}`;
    }
    const voiceEndpoint = voiceSettings.endpoint || config.voiceRoute || "/voice";
    const fullUrl = voiceEndpoint.startsWith("http") ? voiceEndpoint : `${config.baseURL}${voiceEndpoint}`;
    const formData = new FormData();
    formData.append("audio", audioData, "recording.webm");
    formData.append("settings", JSON.stringify(voiceSettings));
    if (context) {
      formData.append("context", JSON.stringify(context));
    }
    for (const [key, value] of Object.entries(rest)) {
      if (value === void 0 || value === null) continue;
      if (typeof value === "object") {
        formData.append(key, JSON.stringify(value));
      } else {
        formData.append(key, String(value));
      }
    }
    const response = await fetch(fullUrl, {
      method: "POST",
      headers,
      body: formData
    });
    if (!response.ok) {
      throw new Error(`Voice endpoint returned ${response.status}`);
    }
    const contentType = response.headers.get("content-type");
    if (contentType?.includes("audio")) {
      const audioBuffer = await response.arrayBuffer();
      const base64 = btoa(String.fromCharCode(...new Uint8Array(audioBuffer)));
      return {
        content: "",
        audioData: base64,
        audioFormat: contentType
      };
    } else if (contentType?.includes("application/json")) {
      const data = await response.json();
      return {
        content: data.text || data.content || "",
        transcription: data.transcription,
        audioData: data.audioData,
        audioUrl: data.audioUrl,
        audioFormat: data.audioFormat,
        usage: data.usage,
        metadata: data.metadata,
        object: data.object
      };
    } else {
      const text = await response.text();
      return {
        content: text
      };
    }
  },
  voiceStreamLLM: (params, config, handler) => {
    const abortController = new AbortController();
    const completion = (async () => {
      try {
        const { audioData, voiceSettings, context, ...rest } = params;
        const headers = {};
        if (config.apiKey) {
          headers.Authorization = `Bearer ${config.apiKey}`;
        }
        const voiceEndpoint = voiceSettings.endpoint || config.voiceRoute || "/voice";
        const fullUrl = voiceEndpoint.startsWith("http") ? voiceEndpoint : `${config.baseURL}${voiceEndpoint}`;
        const streamUrl = fullUrl.endsWith("/stream") ? fullUrl : `${fullUrl}/stream`;
        const formData = new FormData();
        formData.append("audio", audioData, "recording.webm");
        formData.append("settings", JSON.stringify(voiceSettings));
        if (context) {
          formData.append("context", JSON.stringify(context));
        }
        for (const [key, value] of Object.entries(rest)) {
          if (value === void 0 || value === null) continue;
          if (typeof value === "object") {
            formData.append(key, JSON.stringify(value));
          } else {
            formData.append(key, String(value));
          }
        }
        const response = await fetch(streamUrl, {
          method: "POST",
          headers,
          body: formData,
          signal: abortController.signal
        });
        if (!response.ok) {
          throw new Error(`Voice stream endpoint returned ${response.status}`);
        }
        await handleVoiceEventStream(response, handler);
      } catch (error) {
        if (error instanceof Error && error.name !== "AbortError") {
          handler({ type: "error", error });
        }
      }
    })();
    return {
      abort: () => abortController.abort(),
      completion
    };
  },
  handleResponse: async (response) => {
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = await response.json();
    return {
      content: data.text || data.content || "",
      usage: data.usage,
      metadata: {
        model: data.model,
        id: data.id
      },
      object: data.object
      // Include the structured output if present
    };
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  mastraProvider
});
//# sourceMappingURL=mastra.js.map