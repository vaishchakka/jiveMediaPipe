{"version":3,"sources":["../../../../src/store/agentConnection/providers/mastra.ts","../../../../src/store/agentConnection/agentUtils.ts"],"sourcesContent":["import type {\n\tInferProviderConfig,\n\tMastraParams,\n\tProviderImplementation,\n\tStructuredParams,\n\tVoiceStreamHandler,\n} from '@/store/agentConnection/AgentConnectionTypes';\nimport { handleEventStream } from '@/store/agentConnection/agentUtils';\n\ntype MastraConfig = InferProviderConfig<'mastra'>;\n\n/**\n * Handle voice streaming response from Mastra voice endpoint\n */\nasync function handleVoiceEventStream(\n\tresponse: Response,\n\thandler: VoiceStreamHandler\n): Promise<void> {\n\tconst reader = response.body?.getReader();\n\tif (!reader) {\n\t\tthrow new Error('Response body is not readable');\n\t}\n\n\tconst decoder = new TextDecoder();\n\tlet buffer = ''; // Buffer to accumulate incomplete chunks\n\n\ttry {\n\t\twhile (true) {\n\t\t\tconst { done, value } = await reader.read();\n\t\t\tif (done) break;\n\n\t\t\tconst chunk = decoder.decode(value, { stream: true });\n\t\t\tbuffer += chunk;\n\n\t\t\t// Process complete lines\n\t\t\tconst lines = buffer.split('\\n');\n\t\t\t// Keep the last potentially incomplete line in the buffer\n\t\t\tbuffer = lines.pop() || '';\n\n\t\t\tfor (const line of lines) {\n\t\t\t\tconst trimmedLine = line.trim();\n\t\t\t\tif (!trimmedLine || !trimmedLine.startsWith('data: ')) continue;\n\n\t\t\t\tconst data = trimmedLine.slice(6); // Remove 'data: ' prefix\n\n\t\t\t\ttry {\n\t\t\t\t\tconst parsed = JSON.parse(data);\n\n\t\t\t\t\t// Handle different event types\n\t\t\t\t\tif (parsed.type === 'transcription' && parsed.transcription) {\n\t\t\t\t\t\thandler({\n\t\t\t\t\t\t\ttype: 'transcription',\n\t\t\t\t\t\t\ttranscription: parsed.transcription,\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (parsed.type === 'audio' && parsed.audioData) {\n\t\t\t\t\t\thandler({\n\t\t\t\t\t\t\ttype: 'audio',\n\t\t\t\t\t\t\taudioData: parsed.audioData,\n\t\t\t\t\t\t\taudioFormat: parsed.audioFormat,\n\t\t\t\t\t\t\tcontent: parsed.content,\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (parsed.type === 'chunk' && parsed.content) {\n\t\t\t\t\t\thandler({\n\t\t\t\t\t\t\ttype: 'chunk',\n\t\t\t\t\t\t\tcontent: parsed.content,\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (parsed.type === 'object' && parsed.object) {\n\t\t\t\t\t\thandler({\n\t\t\t\t\t\t\ttype: 'object',\n\t\t\t\t\t\t\tobject: parsed.object,\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (parsed.type === 'error') {\n\t\t\t\t\t\thandler({\n\t\t\t\t\t\t\ttype: 'error',\n\t\t\t\t\t\t\terror: new Error(parsed.error || 'Stream error'),\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (parsed.type === 'done') {\n\t\t\t\t\t\thandler({\n\t\t\t\t\t\t\ttype: 'done',\n\t\t\t\t\t\t\tcompletedItems: parsed.completedItems || [],\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} catch (parseError) {\n\t\t\t\t\tconsole.warn('Failed to parse voice stream event:', parseError);\n\t\t\t\t\tconsole.warn('Problematic data length:', data.length);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Process any remaining data in the buffer\n\t\tif (buffer.trim()) {\n\t\t\tconst trimmedLine = buffer.trim();\n\t\t\tif (trimmedLine.startsWith('data: ')) {\n\t\t\t\tconst data = trimmedLine.slice(6);\n\t\t\t\ttry {\n\t\t\t\t\tconst parsed = JSON.parse(data);\n\t\t\t\t\t// Handle the final event (same logic as above)\n\t\t\t\t\tif (parsed.type === 'transcription' && parsed.transcription) {\n\t\t\t\t\t\thandler({\n\t\t\t\t\t\t\ttype: 'transcription',\n\t\t\t\t\t\t\ttranscription: parsed.transcription,\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (parsed.type === 'audio' && parsed.audioData) {\n\t\t\t\t\t\thandler({\n\t\t\t\t\t\t\ttype: 'audio',\n\t\t\t\t\t\t\taudioData: parsed.audioData,\n\t\t\t\t\t\t\taudioFormat: parsed.audioFormat,\n\t\t\t\t\t\t\tcontent: parsed.content,\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (parsed.type === 'chunk' && parsed.content) {\n\t\t\t\t\t\thandler({\n\t\t\t\t\t\t\ttype: 'chunk',\n\t\t\t\t\t\t\tcontent: parsed.content,\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (parsed.type === 'object' && parsed.object) {\n\t\t\t\t\t\thandler({\n\t\t\t\t\t\t\ttype: 'object',\n\t\t\t\t\t\t\tobject: parsed.object,\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (parsed.type === 'error') {\n\t\t\t\t\t\thandler({\n\t\t\t\t\t\t\ttype: 'error',\n\t\t\t\t\t\t\terror: new Error(parsed.error || 'Stream error'),\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (parsed.type === 'done') {\n\t\t\t\t\t\thandler({\n\t\t\t\t\t\t\ttype: 'done',\n\t\t\t\t\t\t\tcompletedItems: parsed.completedItems || [],\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} catch (parseError) {\n\t\t\t\t\tconsole.warn('Failed to parse final voice stream event:', parseError);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} finally {\n\t\treader.releaseLock();\n\t}\n}\n\nexport const mastraProvider: ProviderImplementation<\n\tMastraParams,\n\tMastraConfig\n> = {\n\tcallLLM: async (params, config) => {\n\t\tconst { route, prompt, systemPrompt, temperature, maxTokens, ...rest } =\n\t\t\tparams;\n\n\t\tconst headers: Record<string, string> = {\n\t\t\t'Content-Type': 'application/json',\n\t\t};\n\n\t\t// Only add Authorization header if apiKey is provided\n\t\tif (config.apiKey) {\n\t\t\theaders.Authorization = `Bearer ${config.apiKey}`;\n\t\t}\n\n\t\tconst response = await fetch(`${config.baseURL}${route}`, {\n\t\t\tmethod: 'POST',\n\t\t\theaders,\n\t\t\tbody: JSON.stringify({\n\t\t\t\tprompt,\n\t\t\t\tsystemPrompt,\n\t\t\t\ttemperature,\n\t\t\t\tmaxTokens,\n\t\t\t\t...rest,\n\t\t\t}),\n\t\t});\n\n\t\treturn mastraProvider.handleResponse(response);\n\t},\n\n\tcallLLMStructured: async (params, config) => {\n\t\tconst {\n\t\t\troute,\n\t\t\tprompt,\n\t\t\tsystemPrompt,\n\t\t\ttemperature,\n\t\t\tmaxTokens,\n\t\t\tschema,\n\t\t\tschemaName,\n\t\t\tschemaDescription,\n\t\t\t...rest\n\t\t} = params as MastraParams & StructuredParams;\n\n\t\tconst headers: Record<string, string> = {\n\t\t\t'Content-Type': 'application/json',\n\t\t};\n\n\t\t// Only add Authorization header if apiKey is provided\n\t\tif (config.apiKey) {\n\t\t\theaders.Authorization = `Bearer ${config.apiKey}`;\n\t\t}\n\n\t\tconst body: Record<string, unknown> = {\n\t\t\tprompt,\n\t\t\tsystemPrompt,\n\t\t\ttemperature,\n\t\t\tmaxTokens,\n\t\t\t...rest,\n\t\t};\n\n\t\t// Add schema information for structured output\n\t\tif (schema) {\n\t\t\tbody.schema = schema;\n\t\t\tbody.schemaName = schemaName;\n\t\t\tbody.schemaDescription = schemaDescription;\n\t\t}\n\n\t\tconst response = await fetch(`${config.baseURL}${route}`, {\n\t\t\tmethod: 'POST',\n\t\t\theaders,\n\t\t\tbody: JSON.stringify(body),\n\t\t});\n\n\t\treturn mastraProvider.handleResponse(response);\n\t},\n\n\tstreamLLM: (params, config, handler) => {\n\t\tconst abortController = new AbortController();\n\n\t\tconst completion = (async () => {\n\t\t\ttry {\n\t\t\t\tconst { route, prompt, systemPrompt, temperature, maxTokens, ...rest } =\n\t\t\t\t\tparams;\n\n\t\t\t\tconst headers: Record<string, string> = {\n\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t};\n\n\t\t\t\t// Only add Authorization header if apiKey is provided\n\t\t\t\tif (config.apiKey) {\n\t\t\t\t\theaders.Authorization = `Bearer ${config.apiKey}`;\n\t\t\t\t}\n\n\t\t\t\tconst response = await fetch(`${config.baseURL}${route}/stream`, {\n\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\theaders,\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tprompt,\n\t\t\t\t\t\tsystemPrompt,\n\t\t\t\t\t\ttemperature,\n\t\t\t\t\t\tmaxTokens,\n\t\t\t\t\t\t...rest,\n\t\t\t\t\t}),\n\t\t\t\t\tsignal: abortController.signal,\n\t\t\t\t});\n\n\t\t\t\tif (!response.ok) {\n\t\t\t\t\tthrow new Error(`HTTP error! status: ${response.status}`);\n\t\t\t\t}\n\n\t\t\t\tawait handleEventStream(response, handler);\n\t\t\t} catch (error) {\n\t\t\t\tif (error instanceof Error && error.name !== 'AbortError') {\n\t\t\t\t\thandler({ type: 'error', error });\n\t\t\t\t}\n\t\t\t}\n\t\t})();\n\n\t\treturn {\n\t\t\tabort: () => abortController.abort(),\n\t\t\tcompletion,\n\t\t};\n\t},\n\n\tvoiceLLM: async (params, config) => {\n\t\tconst { audioData, voiceSettings, context, ...rest } = params;\n\n\t\tconst headers: Record<string, string> = {};\n\n\t\t// Only add Authorization header if apiKey is provided\n\t\tif (config.apiKey) {\n\t\t\theaders.Authorization = `Bearer ${config.apiKey}`;\n\t\t}\n\n\t\t// Use the endpoint from voiceSettings if provided, otherwise use voiceRoute from config\n\t\tconst voiceEndpoint =\n\t\t\tvoiceSettings.endpoint || config.voiceRoute || '/voice';\n\t\tconst fullUrl = voiceEndpoint.startsWith('http')\n\t\t\t? voiceEndpoint\n\t\t\t: `${config.baseURL}${voiceEndpoint}`;\n\n\t\tconst formData = new FormData();\n\t\tformData.append('audio', audioData, 'recording.webm');\n\t\tformData.append('settings', JSON.stringify(voiceSettings));\n\t\tif (context) {\n\t\t\tformData.append('context', JSON.stringify(context));\n\t\t}\n\n\t\tfor (const [key, value] of Object.entries(rest)) {\n\t\t\tif (value === undefined || value === null) continue;\n\t\t\tif (typeof value === 'object') {\n\t\t\t\tformData.append(key, JSON.stringify(value));\n\t\t\t} else {\n\t\t\t\tformData.append(key, String(value));\n\t\t\t}\n\t\t}\n\n\t\tconst response = await fetch(fullUrl, {\n\t\t\tmethod: 'POST',\n\t\t\theaders,\n\t\t\tbody: formData,\n\t\t});\n\n\t\tif (!response.ok) {\n\t\t\tthrow new Error(`Voice endpoint returned ${response.status}`);\n\t\t}\n\n\t\t// Handle different response types\n\t\tconst contentType = response.headers.get('content-type');\n\n\t\tif (contentType?.includes('audio')) {\n\t\t\t// Audio response - return as base64\n\t\t\tconst audioBuffer = await response.arrayBuffer();\n\t\t\tconst base64 = btoa(String.fromCharCode(...new Uint8Array(audioBuffer)));\n\t\t\treturn {\n\t\t\t\tcontent: '',\n\t\t\t\taudioData: base64,\n\t\t\t\taudioFormat: contentType,\n\t\t\t};\n\t\t} else if (contentType?.includes('application/json')) {\n\t\t\t// JSON response\n\t\t\tconst data = await response.json();\n\t\t\treturn {\n\t\t\t\tcontent: data.text || data.content || '',\n\t\t\t\ttranscription: data.transcription,\n\t\t\t\taudioData: data.audioData,\n\t\t\t\taudioUrl: data.audioUrl,\n\t\t\t\taudioFormat: data.audioFormat,\n\t\t\t\tusage: data.usage,\n\t\t\t\tmetadata: data.metadata,\n\t\t\t\tobject: data.object,\n\t\t\t};\n\t\t} else {\n\t\t\t// Plain text response\n\t\t\tconst text = await response.text();\n\t\t\treturn {\n\t\t\t\tcontent: text,\n\t\t\t};\n\t\t}\n\t},\n\n\tvoiceStreamLLM: (params, config, handler) => {\n\t\tconst abortController = new AbortController();\n\n\t\tconst completion = (async () => {\n\t\t\ttry {\n\t\t\t\tconst { audioData, voiceSettings, context, ...rest } = params;\n\n\t\t\t\tconst headers: Record<string, string> = {};\n\n\t\t\t\t// Only add Authorization header if apiKey is provided\n\t\t\t\tif (config.apiKey) {\n\t\t\t\t\theaders.Authorization = `Bearer ${config.apiKey}`;\n\t\t\t\t}\n\n\t\t\t\t// Use the endpoint from voiceSettings if provided, otherwise use voiceRoute from config\n\t\t\t\tconst voiceEndpoint =\n\t\t\t\t\tvoiceSettings.endpoint || config.voiceRoute || '/voice';\n\t\t\t\tconst fullUrl = voiceEndpoint.startsWith('http')\n\t\t\t\t\t? voiceEndpoint\n\t\t\t\t\t: `${config.baseURL}${voiceEndpoint}`;\n\n\t\t\t\t// Add /stream suffix for streaming endpoint\n\t\t\t\tconst streamUrl = fullUrl.endsWith('/stream')\n\t\t\t\t\t? fullUrl\n\t\t\t\t\t: `${fullUrl}/stream`;\n\n\t\t\t\tconst formData = new FormData();\n\t\t\t\tformData.append('audio', audioData, 'recording.webm');\n\t\t\t\tformData.append('settings', JSON.stringify(voiceSettings));\n\t\t\t\tif (context) {\n\t\t\t\t\tformData.append('context', JSON.stringify(context));\n\t\t\t\t}\n\n\t\t\t\tfor (const [key, value] of Object.entries(rest)) {\n\t\t\t\t\tif (value === undefined || value === null) continue;\n\t\t\t\t\tif (typeof value === 'object') {\n\t\t\t\t\t\tformData.append(key, JSON.stringify(value));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tformData.append(key, String(value));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst response = await fetch(streamUrl, {\n\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\theaders,\n\t\t\t\t\tbody: formData,\n\t\t\t\t\tsignal: abortController.signal,\n\t\t\t\t});\n\n\t\t\t\tif (!response.ok) {\n\t\t\t\t\tthrow new Error(`Voice stream endpoint returned ${response.status}`);\n\t\t\t\t}\n\n\t\t\t\t// Handle streaming response\n\t\t\t\tawait handleVoiceEventStream(response, handler);\n\t\t\t} catch (error) {\n\t\t\t\tif (error instanceof Error && error.name !== 'AbortError') {\n\t\t\t\t\thandler({ type: 'error', error });\n\t\t\t\t}\n\t\t\t}\n\t\t})();\n\n\t\treturn {\n\t\t\tabort: () => abortController.abort(),\n\t\t\tcompletion,\n\t\t};\n\t},\n\n\thandleResponse: async (response) => {\n\t\tif (!response.ok) {\n\t\t\tthrow new Error(`HTTP error! status: ${response.status}`);\n\t\t}\n\n\t\tconst data = await response.json();\n\n\t\t// Mastra returns structured output in the 'object' field when using JSON Schema\n\t\treturn {\n\t\t\tcontent: data.text || data.content || '',\n\t\t\tusage: data.usage,\n\t\t\tmetadata: {\n\t\t\t\tmodel: data.model,\n\t\t\t\tid: data.id,\n\t\t\t},\n\t\t\tobject: data.object, // Include the structured output if present\n\t\t};\n\t},\n};\n\n/**\n * All event types emitted by a Mastra agent stream.\n */\nexport type MastraStreamedResponseType =\n\t| 'start'\n\t| 'step-start'\n\t| 'tool-call'\n\t| 'tool-result'\n\t| 'step-finish'\n\t| 'tool-output'\n\t| 'step-result'\n\t| 'step-output'\n\t| 'finish';\n\n/**\n * Strongly-typed wrapper around a Mastra structured response message.\n * Extends Cedar's `CustomMessage` so it is compatible with the message system.\n */\nexport type MastraStreamedResponse<\n\tT extends MastraStreamedResponseType = MastraStreamedResponseType\n> = {\n\ttype: T;\n\trunId: string;\n\tfrom: string;\n\t// TODO: update once Mastra releases new types\n\tpayload: Record<string, unknown>;\n};\n","/**\n * Enhanced Server-Sent Events (SSE) stream parser\n *\n * This function handles parsing of streaming responses from various LLM providers:\n * - OpenAI: Uses delta format with choices array\n * - Mastra: Uses custom object types\n * - AI SDK: Uses direct text streaming (handled internally by AI SDK)\n * - Raw text: Plain text chunks\n *\n * Key responsibilities:\n * 1. Parse SSE format (data: content\\n\\n)\n * 2. Handle mixed text/JSON content streams\n * 3. Accumulate text messages and track completed items\n * 4. Call handler immediately for real-time processing\n * 5. Provide completion summary with all items\n */\n\nimport type { StreamHandler } from '@/store/agentConnection/AgentConnectionTypes';\n\n/**\n * Process raw content chunks to handle encoding and newlines\n * Converts escaped newlines (\\n) and actual newlines to proper line breaks\n */\nconst processContentChunk = (rawChunk: string): string => {\n\treturn rawChunk.replace(/(\\\\n|\\n)/g, '\\n');\n};\n\n/**\n * Main SSE stream handler - processes Server-Sent Events from LLM providers\n *\n * @param response - HTTP Response object with streaming body\n * @param handler - StreamHandler to call for each parsed event (chunk, object, done, error)\n */\nexport async function handleEventStream(\n\tresponse: Response,\n\thandler: StreamHandler\n): Promise<void> {\n\tif (!response.ok || !response.body) {\n\t\tthrow new Error(`HTTP error! status: ${response.status}`);\n\t}\n\n\t// Set up streaming infrastructure\n\tconst reader = response.body.getReader();\n\tconst decoder = new TextDecoder();\n\tlet buffer = '';\n\tconst completedItems: (string | object)[] = []; // Track all processed items for completion logging\n\tlet currentTextMessage = ''; // Accumulate text chunks into messages\n\n\t/**\n\t * Parse Server-Sent Event format\n\t * Standard SSE format: \"event: type\\ndata: content\\n\\n\"\n\t * Most providers only use the data field\n\t */\n\tconst parseSSEEvent = (raw: string) => {\n\t\tlet eventType = 'message';\n\t\tlet data = '';\n\n\t\tfor (const line of raw.split('\\n')) {\n\t\t\tif (line.startsWith('event:')) {\n\t\t\t\teventType = line.slice(6).trim();\n\t\t\t} else if (line.startsWith('data:')) {\n\t\t\t\tdata += line.slice(5); // Note: preserves leading space after 'data:'\n\t\t\t}\n\t\t}\n\n\t\treturn { eventType, data };\n\t};\n\n\t/**\n\t * Process the data content from SSE events\n\t * Handles multiple content formats:\n\t * 1. OpenAI delta format: {\"choices\": [{\"delta\": {\"content\": \"text\"}}]}\n\t * 2. Custom object format: {\"type\": \"setState\", \"data\": {...}}\n\t * 3. Direct content: {\"content\": \"text\"}\n\t * 4. Plain text: raw string content\n\t */\n\tconst processDataContent = (data: string) => {\n\t\t// Skip completion markers that signal end of stream\n\t\tif (data.trim() === '[DONE]' || data.trim() === 'done') {\n\t\t\treturn;\n\t\t}\n\n\t\t// Attempt JSON parsing first (most common case)\n\t\ttry {\n\t\t\tconst parsed = JSON.parse(data);\n\n\t\t\t// If the parsed value is a primitive (number, string, boolean, null),\n\t\t\t// treat it as plain text content rather than a structured object.\n\t\t\t// This handles cases where providers stream individual tokens like \"292\" or \"â€¢\"\n\t\t\tif (parsed === null || typeof parsed !== 'object') {\n\t\t\t\tconst processedContent = processContentChunk(String(parsed));\n\t\t\t\tcurrentTextMessage += processedContent;\n\t\t\t\thandler({ type: 'chunk', content: processedContent });\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// OpenAI format: {\"choices\": [{\"delta\": {...}}]}\n\t\t\tif (parsed.choices && parsed.choices[0] && parsed.choices[0].delta) {\n\t\t\t\tconst delta = parsed.choices[0].delta;\n\n\t\t\t\t// Process text content from delta\n\t\t\t\tif (delta.content) {\n\t\t\t\t\tconst processedContent = processContentChunk(delta.content);\n\t\t\t\t\tcurrentTextMessage += processedContent;\n\t\t\t\t\thandler({ type: 'chunk', content: processedContent });\n\t\t\t\t}\n\n\t\t\t\t// Process structured data (tool calls, function calls)\n\t\t\t\t// Skip role-only deltas which don't contain actual content\n\t\t\t\tif (delta.tool_calls || delta.function_call) {\n\t\t\t\t\t// Save any accumulated text before processing object\n\t\t\t\t\tif (currentTextMessage.trim()) {\n\t\t\t\t\t\tcompletedItems.push(currentTextMessage.trim());\n\t\t\t\t\t\tcurrentTextMessage = '';\n\t\t\t\t\t}\n\t\t\t\t\thandler({ type: 'object', object: delta });\n\t\t\t\t\tcompletedItems.push(delta);\n\t\t\t\t}\n\n\t\t\t\t// Empty delta indicates completion for some providers\n\t\t\t\tif (Object.keys(delta).length === 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 1. Direct content (may accompany a structured object)\n\t\t\tif (typeof parsed.content === 'string' && parsed.content.length > 0) {\n\t\t\t\tconst processedContent = processContentChunk(parsed.content);\n\t\t\t\tcurrentTextMessage += processedContent;\n\t\t\t\thandler({ type: 'chunk', content: processedContent });\n\t\t\t}\n\n\t\t\t// 2. Mastra/custom structured object handling\n\t\t\t//    a) Inline object        -> {\"type\": \"setState\", ... }\n\t\t\t//    b) Nested under object  -> {\"object\": {\"type\": \"setState\", ...}}\n\t\t\tif (\n\t\t\t\tparsed.type ||\n\t\t\t\t(parsed.object && (parsed.object as { type?: string }).type)\n\t\t\t) {\n\t\t\t\tconst structuredObject = parsed.type\n\t\t\t\t\t? parsed\n\t\t\t\t\t: (parsed.object as object);\n\n\t\t\t\t// Flush any accumulated text before sending the object event\n\t\t\t\tif (currentTextMessage.trim()) {\n\t\t\t\t\tcompletedItems.push(currentTextMessage.trim());\n\t\t\t\t\tcurrentTextMessage = '';\n\t\t\t\t}\n\n\t\t\t\thandler({ type: 'object', object: structuredObject });\n\t\t\t\tcompletedItems.push(structuredObject);\n\t\t\t}\n\n\t\t\t// 3. Fallback for generic JSON without recognised fields but still valuable\n\t\t\tif (\n\t\t\t\t!parsed.choices &&\n\t\t\t\t!parsed.type &&\n\t\t\t\t!(parsed.object && (parsed.object as { type?: string }).type) &&\n\t\t\t\t!parsed.content\n\t\t\t) {\n\t\t\t\t// Flush accumulated text first\n\t\t\t\tif (currentTextMessage.trim()) {\n\t\t\t\t\tcompletedItems.push(currentTextMessage.trim());\n\t\t\t\t\tcurrentTextMessage = '';\n\t\t\t\t}\n\n\t\t\t\thandler({ type: 'object', object: parsed });\n\t\t\t\tcompletedItems.push(parsed);\n\t\t\t}\n\t\t} catch {\n\t\t\t// Not valid JSON, treat as plain text content\n\t\t\t// Note: Don't use data.trim() here as it would filter out space-only chunks\n\t\t\tif (data && data !== '[DONE]' && data !== 'done') {\n\t\t\t\tconst processedContent = processContentChunk(data);\n\t\t\t\tcurrentTextMessage += processedContent;\n\t\t\t\thandler({ type: 'chunk', content: processedContent });\n\t\t\t}\n\t\t}\n\t};\n\n\ttry {\n\t\t// Main streaming loop - read and process SSE events\n\t\twhile (true) {\n\t\t\tconst { value, done } = await reader.read();\n\t\t\tif (done) break;\n\n\t\t\t// Decode bytes to string and add to buffer\n\t\t\tbuffer += decoder.decode(value, { stream: true });\n\n\t\t\t// Process complete SSE events (delimited by \\n\\n)\n\t\t\tlet eventBoundary: number;\n\t\t\twhile ((eventBoundary = buffer.indexOf('\\n\\n')) !== -1) {\n\t\t\t\tconst rawEvent = buffer.slice(0, eventBoundary);\n\t\t\t\tbuffer = buffer.slice(eventBoundary + 2);\n\n\t\t\t\tif (!rawEvent.trim()) continue; // Skip empty events\n\n\t\t\t\tconst { eventType, data } = parseSSEEvent(rawEvent);\n\n\t\t\t\t// Check for stream completion signals\n\t\t\t\tif (eventType.trim() === 'done' || data.trim() === '[DONE]') {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tprocessDataContent(data);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Finalize any remaining accumulated text\n\t\tif (currentTextMessage.trim()) {\n\t\t\tcompletedItems.push(currentTextMessage.trim());\n\t\t}\n\n\t\t// Signal completion with summary of all processed items\n\t\thandler({ type: 'done', completedItems });\n\t} catch (error) {\n\t\thandler({ type: 'error', error: error as Error });\n\t\tthrow error;\n\t}\n}\n"],"mappings":"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","names":[]}