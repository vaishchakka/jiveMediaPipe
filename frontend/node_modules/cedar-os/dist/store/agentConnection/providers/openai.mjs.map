{"version":3,"sources":["../../../../src/store/agentConnection/agentUtils.ts","../../../../src/store/agentConnection/providers/openai.ts"],"sourcesContent":["/**\n * Enhanced Server-Sent Events (SSE) stream parser\n *\n * This function handles parsing of streaming responses from various LLM providers:\n * - OpenAI: Uses delta format with choices array\n * - Mastra: Uses custom object types\n * - AI SDK: Uses direct text streaming (handled internally by AI SDK)\n * - Raw text: Plain text chunks\n *\n * Key responsibilities:\n * 1. Parse SSE format (data: content\\n\\n)\n * 2. Handle mixed text/JSON content streams\n * 3. Accumulate text messages and track completed items\n * 4. Call handler immediately for real-time processing\n * 5. Provide completion summary with all items\n */\n\nimport type { StreamHandler } from '@/store/agentConnection/AgentConnectionTypes';\n\n/**\n * Process raw content chunks to handle encoding and newlines\n * Converts escaped newlines (\\n) and actual newlines to proper line breaks\n */\nconst processContentChunk = (rawChunk: string): string => {\n\treturn rawChunk.replace(/(\\\\n|\\n)/g, '\\n');\n};\n\n/**\n * Main SSE stream handler - processes Server-Sent Events from LLM providers\n *\n * @param response - HTTP Response object with streaming body\n * @param handler - StreamHandler to call for each parsed event (chunk, object, done, error)\n */\nexport async function handleEventStream(\n\tresponse: Response,\n\thandler: StreamHandler\n): Promise<void> {\n\tif (!response.ok || !response.body) {\n\t\tthrow new Error(`HTTP error! status: ${response.status}`);\n\t}\n\n\t// Set up streaming infrastructure\n\tconst reader = response.body.getReader();\n\tconst decoder = new TextDecoder();\n\tlet buffer = '';\n\tconst completedItems: (string | object)[] = []; // Track all processed items for completion logging\n\tlet currentTextMessage = ''; // Accumulate text chunks into messages\n\n\t/**\n\t * Parse Server-Sent Event format\n\t * Standard SSE format: \"event: type\\ndata: content\\n\\n\"\n\t * Most providers only use the data field\n\t */\n\tconst parseSSEEvent = (raw: string) => {\n\t\tlet eventType = 'message';\n\t\tlet data = '';\n\n\t\tfor (const line of raw.split('\\n')) {\n\t\t\tif (line.startsWith('event:')) {\n\t\t\t\teventType = line.slice(6).trim();\n\t\t\t} else if (line.startsWith('data:')) {\n\t\t\t\tdata += line.slice(5); // Note: preserves leading space after 'data:'\n\t\t\t}\n\t\t}\n\n\t\treturn { eventType, data };\n\t};\n\n\t/**\n\t * Process the data content from SSE events\n\t * Handles multiple content formats:\n\t * 1. OpenAI delta format: {\"choices\": [{\"delta\": {\"content\": \"text\"}}]}\n\t * 2. Custom object format: {\"type\": \"setState\", \"data\": {...}}\n\t * 3. Direct content: {\"content\": \"text\"}\n\t * 4. Plain text: raw string content\n\t */\n\tconst processDataContent = (data: string) => {\n\t\t// Skip completion markers that signal end of stream\n\t\tif (data.trim() === '[DONE]' || data.trim() === 'done') {\n\t\t\treturn;\n\t\t}\n\n\t\t// Attempt JSON parsing first (most common case)\n\t\ttry {\n\t\t\tconst parsed = JSON.parse(data);\n\n\t\t\t// If the parsed value is a primitive (number, string, boolean, null),\n\t\t\t// treat it as plain text content rather than a structured object.\n\t\t\t// This handles cases where providers stream individual tokens like \"292\" or \"â€¢\"\n\t\t\tif (parsed === null || typeof parsed !== 'object') {\n\t\t\t\tconst processedContent = processContentChunk(String(parsed));\n\t\t\t\tcurrentTextMessage += processedContent;\n\t\t\t\thandler({ type: 'chunk', content: processedContent });\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// OpenAI format: {\"choices\": [{\"delta\": {...}}]}\n\t\t\tif (parsed.choices && parsed.choices[0] && parsed.choices[0].delta) {\n\t\t\t\tconst delta = parsed.choices[0].delta;\n\n\t\t\t\t// Process text content from delta\n\t\t\t\tif (delta.content) {\n\t\t\t\t\tconst processedContent = processContentChunk(delta.content);\n\t\t\t\t\tcurrentTextMessage += processedContent;\n\t\t\t\t\thandler({ type: 'chunk', content: processedContent });\n\t\t\t\t}\n\n\t\t\t\t// Process structured data (tool calls, function calls)\n\t\t\t\t// Skip role-only deltas which don't contain actual content\n\t\t\t\tif (delta.tool_calls || delta.function_call) {\n\t\t\t\t\t// Save any accumulated text before processing object\n\t\t\t\t\tif (currentTextMessage.trim()) {\n\t\t\t\t\t\tcompletedItems.push(currentTextMessage.trim());\n\t\t\t\t\t\tcurrentTextMessage = '';\n\t\t\t\t\t}\n\t\t\t\t\thandler({ type: 'object', object: delta });\n\t\t\t\t\tcompletedItems.push(delta);\n\t\t\t\t}\n\n\t\t\t\t// Empty delta indicates completion for some providers\n\t\t\t\tif (Object.keys(delta).length === 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 1. Direct content (may accompany a structured object)\n\t\t\tif (typeof parsed.content === 'string' && parsed.content.length > 0) {\n\t\t\t\tconst processedContent = processContentChunk(parsed.content);\n\t\t\t\tcurrentTextMessage += processedContent;\n\t\t\t\thandler({ type: 'chunk', content: processedContent });\n\t\t\t}\n\n\t\t\t// 2. Mastra/custom structured object handling\n\t\t\t//    a) Inline object        -> {\"type\": \"setState\", ... }\n\t\t\t//    b) Nested under object  -> {\"object\": {\"type\": \"setState\", ...}}\n\t\t\tif (\n\t\t\t\tparsed.type ||\n\t\t\t\t(parsed.object && (parsed.object as { type?: string }).type)\n\t\t\t) {\n\t\t\t\tconst structuredObject = parsed.type\n\t\t\t\t\t? parsed\n\t\t\t\t\t: (parsed.object as object);\n\n\t\t\t\t// Flush any accumulated text before sending the object event\n\t\t\t\tif (currentTextMessage.trim()) {\n\t\t\t\t\tcompletedItems.push(currentTextMessage.trim());\n\t\t\t\t\tcurrentTextMessage = '';\n\t\t\t\t}\n\n\t\t\t\thandler({ type: 'object', object: structuredObject });\n\t\t\t\tcompletedItems.push(structuredObject);\n\t\t\t}\n\n\t\t\t// 3. Fallback for generic JSON without recognised fields but still valuable\n\t\t\tif (\n\t\t\t\t!parsed.choices &&\n\t\t\t\t!parsed.type &&\n\t\t\t\t!(parsed.object && (parsed.object as { type?: string }).type) &&\n\t\t\t\t!parsed.content\n\t\t\t) {\n\t\t\t\t// Flush accumulated text first\n\t\t\t\tif (currentTextMessage.trim()) {\n\t\t\t\t\tcompletedItems.push(currentTextMessage.trim());\n\t\t\t\t\tcurrentTextMessage = '';\n\t\t\t\t}\n\n\t\t\t\thandler({ type: 'object', object: parsed });\n\t\t\t\tcompletedItems.push(parsed);\n\t\t\t}\n\t\t} catch {\n\t\t\t// Not valid JSON, treat as plain text content\n\t\t\t// Note: Don't use data.trim() here as it would filter out space-only chunks\n\t\t\tif (data && data !== '[DONE]' && data !== 'done') {\n\t\t\t\tconst processedContent = processContentChunk(data);\n\t\t\t\tcurrentTextMessage += processedContent;\n\t\t\t\thandler({ type: 'chunk', content: processedContent });\n\t\t\t}\n\t\t}\n\t};\n\n\ttry {\n\t\t// Main streaming loop - read and process SSE events\n\t\twhile (true) {\n\t\t\tconst { value, done } = await reader.read();\n\t\t\tif (done) break;\n\n\t\t\t// Decode bytes to string and add to buffer\n\t\t\tbuffer += decoder.decode(value, { stream: true });\n\n\t\t\t// Process complete SSE events (delimited by \\n\\n)\n\t\t\tlet eventBoundary: number;\n\t\t\twhile ((eventBoundary = buffer.indexOf('\\n\\n')) !== -1) {\n\t\t\t\tconst rawEvent = buffer.slice(0, eventBoundary);\n\t\t\t\tbuffer = buffer.slice(eventBoundary + 2);\n\n\t\t\t\tif (!rawEvent.trim()) continue; // Skip empty events\n\n\t\t\t\tconst { eventType, data } = parseSSEEvent(rawEvent);\n\n\t\t\t\t// Check for stream completion signals\n\t\t\t\tif (eventType.trim() === 'done' || data.trim() === '[DONE]') {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tprocessDataContent(data);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Finalize any remaining accumulated text\n\t\tif (currentTextMessage.trim()) {\n\t\t\tcompletedItems.push(currentTextMessage.trim());\n\t\t}\n\n\t\t// Signal completion with summary of all processed items\n\t\thandler({ type: 'done', completedItems });\n\t} catch (error) {\n\t\thandler({ type: 'error', error: error as Error });\n\t\tthrow error;\n\t}\n}\n","import type {\n\tOpenAIParams,\n\tProviderImplementation,\n\tInferProviderConfig,\n\tStructuredParams,\n} from '@/store/agentConnection/AgentConnectionTypes';\nimport { handleEventStream } from '@/store/agentConnection/agentUtils';\n\ntype OpenAIConfig = InferProviderConfig<'openai'>;\n\nexport const openAIProvider: ProviderImplementation<\n\tOpenAIParams,\n\tOpenAIConfig\n> = {\n\tcallLLM: async (params, config) => {\n\t\tconst {\n\t\t\tprompt,\n\t\t\tmodel,\n\t\t\tsystemPrompt,\n\t\t\ttemperature,\n\t\t\tmaxTokens,\n\t\t\tmessages: providedMessages,\n\t\t\t...rest\n\t\t} = params;\n\n\t\t// Use provided messages array or construct from prompt\n\t\tconst messages = providedMessages || [\n\t\t\t...(systemPrompt ? [{ role: 'system', content: systemPrompt }] : []),\n\t\t\t{ role: 'user', content: prompt || '' },\n\t\t];\n\n\t\tconst response = await fetch('https://api.openai.com/v1/chat/completions', {\n\t\t\tmethod: 'POST',\n\t\t\theaders: {\n\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\tAuthorization: `Bearer ${config.apiKey}`,\n\t\t\t},\n\t\t\tbody: JSON.stringify({\n\t\t\t\tmodel,\n\t\t\t\tmessages,\n\t\t\t\ttemperature,\n\t\t\t\tmax_tokens: maxTokens,\n\t\t\t\t...rest,\n\t\t\t}),\n\t\t});\n\n\t\treturn openAIProvider.handleResponse(response);\n\t},\n\n\tstreamLLM: (params, config, handler) => {\n\t\tconst abortController = new AbortController();\n\n\t\tconst completion = (async () => {\n\t\t\ttry {\n\t\t\t\tconst {\n\t\t\t\t\tprompt,\n\t\t\t\t\tmodel,\n\t\t\t\t\tsystemPrompt,\n\t\t\t\t\ttemperature,\n\t\t\t\t\tmaxTokens,\n\t\t\t\t\tmessages: providedMessages,\n\t\t\t\t\t...rest\n\t\t\t\t} = params;\n\n\t\t\t\t// Use provided messages array or construct from prompt\n\t\t\t\tconst messages = providedMessages || [\n\t\t\t\t\t...(systemPrompt ? [{ role: 'system', content: systemPrompt }] : []),\n\t\t\t\t\t{ role: 'user', content: prompt || '' },\n\t\t\t\t];\n\n\t\t\t\tconst response = await fetch(\n\t\t\t\t\t'https://api.openai.com/v1/chat/completions',\n\t\t\t\t\t{\n\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t\t\tAuthorization: `Bearer ${config.apiKey}`,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\t\tmodel,\n\t\t\t\t\t\t\tmessages,\n\t\t\t\t\t\t\ttemperature,\n\t\t\t\t\t\t\tmax_tokens: maxTokens,\n\t\t\t\t\t\t\tstream: true,\n\t\t\t\t\t\t\t...rest,\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tsignal: abortController.signal,\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tif (!response.ok) {\n\t\t\t\t\tthrow new Error(`HTTP error! status: ${response.status}`);\n\t\t\t\t}\n\n\t\t\t\t// OpenAI uses SSE format, our unified parser handles it automatically\n\t\t\t\tawait handleEventStream(response, handler);\n\t\t\t} catch (error) {\n\t\t\t\tif (error instanceof Error && error.name !== 'AbortError') {\n\t\t\t\t\thandler({ type: 'error', error });\n\t\t\t\t}\n\t\t\t}\n\t\t})();\n\n\t\treturn {\n\t\t\tabort: () => abortController.abort(),\n\t\t\tcompletion,\n\t\t};\n\t},\n\n\thandleResponse: async (response) => {\n\t\tif (!response.ok) {\n\t\t\tthrow new Error(`HTTP error! status: ${response.status}`);\n\t\t}\n\n\t\tconst data = await response.json();\n\t\treturn {\n\t\t\tcontent: data.choices?.[0]?.message?.content || '',\n\t\t\tusage: data.usage\n\t\t\t\t? {\n\t\t\t\t\t\tpromptTokens: data.usage.prompt_tokens,\n\t\t\t\t\t\tcompletionTokens: data.usage.completion_tokens,\n\t\t\t\t\t\ttotalTokens: data.usage.total_tokens,\n\t\t\t\t  }\n\t\t\t\t: undefined,\n\t\t\tmetadata: {\n\t\t\t\tmodel: data.model,\n\t\t\t\tid: data.id,\n\t\t\t},\n\t\t};\n\t},\n\n\tcallLLMStructured: async (params, config) => {\n\t\tconst {\n\t\t\tprompt,\n\t\t\tmodel,\n\t\t\tsystemPrompt,\n\t\t\ttemperature,\n\t\t\tmaxTokens,\n\t\t\tschema,\n\t\t\tschemaName,\n\t\t\tschemaDescription,\n\t\t\t...rest\n\t\t} = params as OpenAIParams & StructuredParams;\n\n\t\tconst messages = [\n\t\t\t...(systemPrompt ? [{ role: 'system', content: systemPrompt }] : []),\n\t\t\t{ role: 'user', content: prompt },\n\t\t];\n\n\t\tconst body: Record<string, unknown> = {\n\t\t\tmodel,\n\t\t\tmessages,\n\t\t\ttemperature,\n\t\t\tmax_tokens: maxTokens,\n\t\t\t...rest,\n\t\t};\n\n\t\t// Add response_format for structured output if schema is provided\n\t\tif (schema) {\n\t\t\tbody.response_format = {\n\t\t\t\ttype: 'json_schema',\n\t\t\t\tjson_schema: {\n\t\t\t\t\tname: schemaName || 'response',\n\t\t\t\t\tdescription: schemaDescription,\n\t\t\t\t\tschema: schema,\n\t\t\t\t\tstrict: true,\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\tconst response = await fetch('https://api.openai.com/v1/chat/completions', {\n\t\t\tmethod: 'POST',\n\t\t\theaders: {\n\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\tAuthorization: `Bearer ${config.apiKey}`,\n\t\t\t},\n\t\t\tbody: JSON.stringify(body),\n\t\t});\n\n\t\tconst result = await openAIProvider.handleResponse(response);\n\n\t\t// If we have structured output, parse it and add to object field\n\t\tif (schema && result.content) {\n\t\t\ttry {\n\t\t\t\tresult.object = JSON.parse(result.content);\n\t\t\t} catch {\n\t\t\t\t// If parsing fails, leave object undefined\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t},\n\n\tvoiceLLM: async (params, config) => {\n\t\t// For custom backends using OpenAI format, use the same approach as Mastra\n\t\t// This allows custom backends to implement their own voice endpoints\n\t\tconst { audioData, voiceSettings, context } = params;\n\n\t\t// Use the endpoint from voiceSettings if provided, otherwise default\n\t\tconst voiceEndpoint = voiceSettings.endpoint || '/voice';\n\t\tconst fullUrl = voiceEndpoint.startsWith('http')\n\t\t\t? voiceEndpoint\n\t\t\t: voiceEndpoint; // Relative URLs will be relative to current origin\n\n\t\tconst formData = new FormData();\n\t\tformData.append('audio', audioData, 'recording.webm');\n\t\tformData.append('settings', JSON.stringify(voiceSettings));\n\t\tif (context) {\n\t\t\tformData.append('context', JSON.stringify(context));\n\t\t}\n\n\t\tconst response = await fetch(fullUrl, {\n\t\t\tmethod: 'POST',\n\t\t\theaders: {\n\t\t\t\tAuthorization: `Bearer ${config.apiKey}`,\n\t\t\t},\n\t\t\tbody: formData,\n\t\t});\n\n\t\tif (!response.ok) {\n\t\t\tthrow new Error(`Voice endpoint returned ${response.status}`);\n\t\t}\n\n\t\t// Handle different response types\n\t\tconst contentType = response.headers.get('content-type');\n\n\t\tif (contentType?.includes('audio')) {\n\t\t\t// Audio response - return as base64\n\t\t\tconst audioBuffer = await response.arrayBuffer();\n\t\t\tconst base64 = btoa(String.fromCharCode(...new Uint8Array(audioBuffer)));\n\t\t\treturn {\n\t\t\t\tcontent: '',\n\t\t\t\taudioData: base64,\n\t\t\t\taudioFormat: contentType,\n\t\t\t};\n\t\t} else if (contentType?.includes('application/json')) {\n\t\t\t// JSON response\n\t\t\tconst data = await response.json();\n\t\t\treturn {\n\t\t\t\tcontent: data.text || data.content || '',\n\t\t\t\ttranscription: data.transcription,\n\t\t\t\taudioData: data.audioData,\n\t\t\t\taudioUrl: data.audioUrl,\n\t\t\t\taudioFormat: data.audioFormat,\n\t\t\t\tusage: data.usage,\n\t\t\t\tmetadata: data.metadata,\n\t\t\t\tobject: data.object,\n\t\t\t};\n\t\t} else {\n\t\t\t// Plain text response\n\t\t\tconst text = await response.text();\n\t\t\treturn {\n\t\t\t\tcontent: text,\n\t\t\t};\n\t\t}\n\t},\n};\n"],"mappings":";AAuBA,IAAM,sBAAsB,CAAC,aAA6B;AACzD,SAAO,SAAS,QAAQ,aAAa,IAAI;AAC1C;AAQA,eAAsB,kBACrB,UACA,SACgB;AAChB,MAAI,CAAC,SAAS,MAAM,CAAC,SAAS,MAAM;AACnC,UAAM,IAAI,MAAM,uBAAuB,SAAS,MAAM,EAAE;AAAA,EACzD;AAGA,QAAM,SAAS,SAAS,KAAK,UAAU;AACvC,QAAM,UAAU,IAAI,YAAY;AAChC,MAAI,SAAS;AACb,QAAM,iBAAsC,CAAC;AAC7C,MAAI,qBAAqB;AAOzB,QAAM,gBAAgB,CAAC,QAAgB;AACtC,QAAI,YAAY;AAChB,QAAI,OAAO;AAEX,eAAW,QAAQ,IAAI,MAAM,IAAI,GAAG;AACnC,UAAI,KAAK,WAAW,QAAQ,GAAG;AAC9B,oBAAY,KAAK,MAAM,CAAC,EAAE,KAAK;AAAA,MAChC,WAAW,KAAK,WAAW,OAAO,GAAG;AACpC,gBAAQ,KAAK,MAAM,CAAC;AAAA,MACrB;AAAA,IACD;AAEA,WAAO,EAAE,WAAW,KAAK;AAAA,EAC1B;AAUA,QAAM,qBAAqB,CAAC,SAAiB;AAE5C,QAAI,KAAK,KAAK,MAAM,YAAY,KAAK,KAAK,MAAM,QAAQ;AACvD;AAAA,IACD;AAGA,QAAI;AACH,YAAM,SAAS,KAAK,MAAM,IAAI;AAK9B,UAAI,WAAW,QAAQ,OAAO,WAAW,UAAU;AAClD,cAAM,mBAAmB,oBAAoB,OAAO,MAAM,CAAC;AAC3D,8BAAsB;AACtB,gBAAQ,EAAE,MAAM,SAAS,SAAS,iBAAiB,CAAC;AACpD;AAAA,MACD;AAGA,UAAI,OAAO,WAAW,OAAO,QAAQ,CAAC,KAAK,OAAO,QAAQ,CAAC,EAAE,OAAO;AACnE,cAAM,QAAQ,OAAO,QAAQ,CAAC,EAAE;AAGhC,YAAI,MAAM,SAAS;AAClB,gBAAM,mBAAmB,oBAAoB,MAAM,OAAO;AAC1D,gCAAsB;AACtB,kBAAQ,EAAE,MAAM,SAAS,SAAS,iBAAiB,CAAC;AAAA,QACrD;AAIA,YAAI,MAAM,cAAc,MAAM,eAAe;AAE5C,cAAI,mBAAmB,KAAK,GAAG;AAC9B,2BAAe,KAAK,mBAAmB,KAAK,CAAC;AAC7C,iCAAqB;AAAA,UACtB;AACA,kBAAQ,EAAE,MAAM,UAAU,QAAQ,MAAM,CAAC;AACzC,yBAAe,KAAK,KAAK;AAAA,QAC1B;AAGA,YAAI,OAAO,KAAK,KAAK,EAAE,WAAW,GAAG;AACpC;AAAA,QACD;AAAA,MACD;AAEA,UAAI,OAAO,OAAO,YAAY,YAAY,OAAO,QAAQ,SAAS,GAAG;AACpE,cAAM,mBAAmB,oBAAoB,OAAO,OAAO;AAC3D,8BAAsB;AACtB,gBAAQ,EAAE,MAAM,SAAS,SAAS,iBAAiB,CAAC;AAAA,MACrD;AAKA,UACC,OAAO,QACN,OAAO,UAAW,OAAO,OAA6B,MACtD;AACD,cAAM,mBAAmB,OAAO,OAC7B,SACC,OAAO;AAGX,YAAI,mBAAmB,KAAK,GAAG;AAC9B,yBAAe,KAAK,mBAAmB,KAAK,CAAC;AAC7C,+BAAqB;AAAA,QACtB;AAEA,gBAAQ,EAAE,MAAM,UAAU,QAAQ,iBAAiB,CAAC;AACpD,uBAAe,KAAK,gBAAgB;AAAA,MACrC;AAGA,UACC,CAAC,OAAO,WACR,CAAC,OAAO,QACR,EAAE,OAAO,UAAW,OAAO,OAA6B,SACxD,CAAC,OAAO,SACP;AAED,YAAI,mBAAmB,KAAK,GAAG;AAC9B,yBAAe,KAAK,mBAAmB,KAAK,CAAC;AAC7C,+BAAqB;AAAA,QACtB;AAEA,gBAAQ,EAAE,MAAM,UAAU,QAAQ,OAAO,CAAC;AAC1C,uBAAe,KAAK,MAAM;AAAA,MAC3B;AAAA,IACD,QAAQ;AAGP,UAAI,QAAQ,SAAS,YAAY,SAAS,QAAQ;AACjD,cAAM,mBAAmB,oBAAoB,IAAI;AACjD,8BAAsB;AACtB,gBAAQ,EAAE,MAAM,SAAS,SAAS,iBAAiB,CAAC;AAAA,MACrD;AAAA,IACD;AAAA,EACD;AAEA,MAAI;AAEH,WAAO,MAAM;AACZ,YAAM,EAAE,OAAO,KAAK,IAAI,MAAM,OAAO,KAAK;AAC1C,UAAI,KAAM;AAGV,gBAAU,QAAQ,OAAO,OAAO,EAAE,QAAQ,KAAK,CAAC;AAGhD,UAAI;AACJ,cAAQ,gBAAgB,OAAO,QAAQ,MAAM,OAAO,IAAI;AACvD,cAAM,WAAW,OAAO,MAAM,GAAG,aAAa;AAC9C,iBAAS,OAAO,MAAM,gBAAgB,CAAC;AAEvC,YAAI,CAAC,SAAS,KAAK,EAAG;AAEtB,cAAM,EAAE,WAAW,KAAK,IAAI,cAAc,QAAQ;AAGlD,YAAI,UAAU,KAAK,MAAM,UAAU,KAAK,KAAK,MAAM,UAAU;AAC5D;AAAA,QACD,OAAO;AACN,6BAAmB,IAAI;AAAA,QACxB;AAAA,MACD;AAAA,IACD;AAGA,QAAI,mBAAmB,KAAK,GAAG;AAC9B,qBAAe,KAAK,mBAAmB,KAAK,CAAC;AAAA,IAC9C;AAGA,YAAQ,EAAE,MAAM,QAAQ,eAAe,CAAC;AAAA,EACzC,SAAS,OAAO;AACf,YAAQ,EAAE,MAAM,SAAS,MAAsB,CAAC;AAChD,UAAM;AAAA,EACP;AACD;;;AChNO,IAAM,iBAGT;AAAA,EACH,SAAS,OAAO,QAAQ,WAAW;AAClC,UAAM;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,UAAU;AAAA,MACV,GAAG;AAAA,IACJ,IAAI;AAGJ,UAAM,WAAW,oBAAoB;AAAA,MACpC,GAAI,eAAe,CAAC,EAAE,MAAM,UAAU,SAAS,aAAa,CAAC,IAAI,CAAC;AAAA,MAClE,EAAE,MAAM,QAAQ,SAAS,UAAU,GAAG;AAAA,IACvC;AAEA,UAAM,WAAW,MAAM,MAAM,8CAA8C;AAAA,MAC1E,QAAQ;AAAA,MACR,SAAS;AAAA,QACR,gBAAgB;AAAA,QAChB,eAAe,UAAU,OAAO,MAAM;AAAA,MACvC;AAAA,MACA,MAAM,KAAK,UAAU;AAAA,QACpB;AAAA,QACA;AAAA,QACA;AAAA,QACA,YAAY;AAAA,QACZ,GAAG;AAAA,MACJ,CAAC;AAAA,IACF,CAAC;AAED,WAAO,eAAe,eAAe,QAAQ;AAAA,EAC9C;AAAA,EAEA,WAAW,CAAC,QAAQ,QAAQ,YAAY;AACvC,UAAM,kBAAkB,IAAI,gBAAgB;AAE5C,UAAM,cAAc,YAAY;AAC/B,UAAI;AACH,cAAM;AAAA,UACL;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA,UAAU;AAAA,UACV,GAAG;AAAA,QACJ,IAAI;AAGJ,cAAM,WAAW,oBAAoB;AAAA,UACpC,GAAI,eAAe,CAAC,EAAE,MAAM,UAAU,SAAS,aAAa,CAAC,IAAI,CAAC;AAAA,UAClE,EAAE,MAAM,QAAQ,SAAS,UAAU,GAAG;AAAA,QACvC;AAEA,cAAM,WAAW,MAAM;AAAA,UACtB;AAAA,UACA;AAAA,YACC,QAAQ;AAAA,YACR,SAAS;AAAA,cACR,gBAAgB;AAAA,cAChB,eAAe,UAAU,OAAO,MAAM;AAAA,YACvC;AAAA,YACA,MAAM,KAAK,UAAU;AAAA,cACpB;AAAA,cACA;AAAA,cACA;AAAA,cACA,YAAY;AAAA,cACZ,QAAQ;AAAA,cACR,GAAG;AAAA,YACJ,CAAC;AAAA,YACD,QAAQ,gBAAgB;AAAA,UACzB;AAAA,QACD;AAEA,YAAI,CAAC,SAAS,IAAI;AACjB,gBAAM,IAAI,MAAM,uBAAuB,SAAS,MAAM,EAAE;AAAA,QACzD;AAGA,cAAM,kBAAkB,UAAU,OAAO;AAAA,MAC1C,SAAS,OAAO;AACf,YAAI,iBAAiB,SAAS,MAAM,SAAS,cAAc;AAC1D,kBAAQ,EAAE,MAAM,SAAS,MAAM,CAAC;AAAA,QACjC;AAAA,MACD;AAAA,IACD,GAAG;AAEH,WAAO;AAAA,MACN,OAAO,MAAM,gBAAgB,MAAM;AAAA,MACnC;AAAA,IACD;AAAA,EACD;AAAA,EAEA,gBAAgB,OAAO,aAAa;AACnC,QAAI,CAAC,SAAS,IAAI;AACjB,YAAM,IAAI,MAAM,uBAAuB,SAAS,MAAM,EAAE;AAAA,IACzD;AAEA,UAAM,OAAO,MAAM,SAAS,KAAK;AACjC,WAAO;AAAA,MACN,SAAS,KAAK,UAAU,CAAC,GAAG,SAAS,WAAW;AAAA,MAChD,OAAO,KAAK,QACT;AAAA,QACA,cAAc,KAAK,MAAM;AAAA,QACzB,kBAAkB,KAAK,MAAM;AAAA,QAC7B,aAAa,KAAK,MAAM;AAAA,MACxB,IACA;AAAA,MACH,UAAU;AAAA,QACT,OAAO,KAAK;AAAA,QACZ,IAAI,KAAK;AAAA,MACV;AAAA,IACD;AAAA,EACD;AAAA,EAEA,mBAAmB,OAAO,QAAQ,WAAW;AAC5C,UAAM;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,GAAG;AAAA,IACJ,IAAI;AAEJ,UAAM,WAAW;AAAA,MAChB,GAAI,eAAe,CAAC,EAAE,MAAM,UAAU,SAAS,aAAa,CAAC,IAAI,CAAC;AAAA,MAClE,EAAE,MAAM,QAAQ,SAAS,OAAO;AAAA,IACjC;AAEA,UAAM,OAAgC;AAAA,MACrC;AAAA,MACA;AAAA,MACA;AAAA,MACA,YAAY;AAAA,MACZ,GAAG;AAAA,IACJ;AAGA,QAAI,QAAQ;AACX,WAAK,kBAAkB;AAAA,QACtB,MAAM;AAAA,QACN,aAAa;AAAA,UACZ,MAAM,cAAc;AAAA,UACpB,aAAa;AAAA,UACb;AAAA,UACA,QAAQ;AAAA,QACT;AAAA,MACD;AAAA,IACD;AAEA,UAAM,WAAW,MAAM,MAAM,8CAA8C;AAAA,MAC1E,QAAQ;AAAA,MACR,SAAS;AAAA,QACR,gBAAgB;AAAA,QAChB,eAAe,UAAU,OAAO,MAAM;AAAA,MACvC;AAAA,MACA,MAAM,KAAK,UAAU,IAAI;AAAA,IAC1B,CAAC;AAED,UAAM,SAAS,MAAM,eAAe,eAAe,QAAQ;AAG3D,QAAI,UAAU,OAAO,SAAS;AAC7B,UAAI;AACH,eAAO,SAAS,KAAK,MAAM,OAAO,OAAO;AAAA,MAC1C,QAAQ;AAAA,MAER;AAAA,IACD;AAEA,WAAO;AAAA,EACR;AAAA,EAEA,UAAU,OAAO,QAAQ,WAAW;AAGnC,UAAM,EAAE,WAAW,eAAe,QAAQ,IAAI;AAG9C,UAAM,gBAAgB,cAAc,YAAY;AAChD,UAAM,UAAU,cAAc,WAAW,MAAM,IAC5C,gBACA;AAEH,UAAM,WAAW,IAAI,SAAS;AAC9B,aAAS,OAAO,SAAS,WAAW,gBAAgB;AACpD,aAAS,OAAO,YAAY,KAAK,UAAU,aAAa,CAAC;AACzD,QAAI,SAAS;AACZ,eAAS,OAAO,WAAW,KAAK,UAAU,OAAO,CAAC;AAAA,IACnD;AAEA,UAAM,WAAW,MAAM,MAAM,SAAS;AAAA,MACrC,QAAQ;AAAA,MACR,SAAS;AAAA,QACR,eAAe,UAAU,OAAO,MAAM;AAAA,MACvC;AAAA,MACA,MAAM;AAAA,IACP,CAAC;AAED,QAAI,CAAC,SAAS,IAAI;AACjB,YAAM,IAAI,MAAM,2BAA2B,SAAS,MAAM,EAAE;AAAA,IAC7D;AAGA,UAAM,cAAc,SAAS,QAAQ,IAAI,cAAc;AAEvD,QAAI,aAAa,SAAS,OAAO,GAAG;AAEnC,YAAM,cAAc,MAAM,SAAS,YAAY;AAC/C,YAAM,SAAS,KAAK,OAAO,aAAa,GAAG,IAAI,WAAW,WAAW,CAAC,CAAC;AACvE,aAAO;AAAA,QACN,SAAS;AAAA,QACT,WAAW;AAAA,QACX,aAAa;AAAA,MACd;AAAA,IACD,WAAW,aAAa,SAAS,kBAAkB,GAAG;AAErD,YAAM,OAAO,MAAM,SAAS,KAAK;AACjC,aAAO;AAAA,QACN,SAAS,KAAK,QAAQ,KAAK,WAAW;AAAA,QACtC,eAAe,KAAK;AAAA,QACpB,WAAW,KAAK;AAAA,QAChB,UAAU,KAAK;AAAA,QACf,aAAa,KAAK;AAAA,QAClB,OAAO,KAAK;AAAA,QACZ,UAAU,KAAK;AAAA,QACf,QAAQ,KAAK;AAAA,MACd;AAAA,IACD,OAAO;AAEN,YAAM,OAAO,MAAM,SAAS,KAAK;AACjC,aAAO;AAAA,QACN,SAAS;AAAA,MACV;AAAA,IACD;AAAA,EACD;AACD;","names":[]}