"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/store/debugger/debuggerSlice.ts
var debuggerSlice_exports = {};
__export(debuggerSlice_exports, {
  createDebuggerSlice: () => createDebuggerSlice
});
module.exports = __toCommonJS(debuggerSlice_exports);
var createDebuggerSlice = (set, get) => ({
  // Default state
  agentConnectionLogs: [],
  maxLogs: 50,
  isDebugEnabled: true,
  activeStreams: /* @__PURE__ */ new Map(),
  activeRequests: /* @__PURE__ */ new Map(),
  collapsedSections: {},
  // Actions
  logAgentRequest: (params, provider) => {
    const state = get();
    if (!state.isDebugEnabled) return "";
    const requestId = `req_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`;
    let apiRoute;
    if (provider === "mastra" && "route" in params) {
      apiRoute = params.route;
    }
    const requestTracker = {
      requestId,
      startTime: /* @__PURE__ */ new Date(),
      handlers: []
    };
    const newActiveRequests = new Map(state.activeRequests);
    newActiveRequests.set(requestId, requestTracker);
    const entry = {
      id: requestId,
      timestamp: /* @__PURE__ */ new Date(),
      type: "request",
      provider,
      apiRoute,
      data: { params }
    };
    set((state2) => ({
      agentConnectionLogs: [
        ...state2.agentConnectionLogs.slice(0, state2.maxLogs - 1),
        entry
      ],
      activeRequests: newActiveRequests
    }));
    return requestId;
  },
  logAgentResponse: (requestId, response) => {
    const state = get();
    if (!state.isDebugEnabled) return;
    const requestLog = state.agentConnectionLogs.find(
      (log) => log.id === requestId && log.type === "request"
    );
    const requestTracker = state.activeRequests.get(requestId);
    const handlers = requestTracker?.handlers || [];
    const entry = {
      id: `res_${requestId}`,
      timestamp: /* @__PURE__ */ new Date(),
      type: "response",
      provider: requestLog?.provider,
      apiRoute: requestLog?.apiRoute,
      data: {
        response,
        handlers: handlers.length > 0 ? handlers : void 0
      },
      duration: requestLog ? (/* @__PURE__ */ new Date()).getTime() - requestLog.timestamp.getTime() : void 0
    };
    const newActiveRequests = new Map(state.activeRequests);
    newActiveRequests.delete(requestId);
    set((state2) => ({
      agentConnectionLogs: [
        ...state2.agentConnectionLogs.slice(0, state2.maxLogs - 1),
        entry
      ],
      activeRequests: newActiveRequests
    }));
  },
  logAgentError: (requestId, error) => {
    const state = get();
    if (!state.isDebugEnabled) return;
    const isStreamError = state.activeStreams.has(requestId);
    if (isStreamError) {
      const tracker = state.activeStreams.get(requestId);
      let apiRoute;
      if (tracker.provider === "mastra" && tracker.params && "route" in tracker.params) {
        apiRoute = tracker.params.route;
      }
      const entry = {
        id: requestId,
        timestamp: tracker.startTime,
        type: "stream-error",
        provider: tracker.provider,
        apiRoute,
        data: {
          params: tracker.params,
          error,
          streamContent: tracker.chunks.join(""),
          streamObjects: tracker.objects
        },
        duration: (/* @__PURE__ */ new Date()).getTime() - tracker.startTime.getTime()
      };
      const newActiveStreams = new Map(state.activeStreams);
      newActiveStreams.delete(requestId);
      set((state2) => ({
        agentConnectionLogs: [
          ...state2.agentConnectionLogs.slice(0, state2.maxLogs - 1),
          entry
        ],
        activeStreams: newActiveStreams
      }));
    } else {
      const requestLog = state.agentConnectionLogs.find(
        (log) => log.id === requestId && log.type === "request"
      );
      const entry = {
        id: `err_${requestId}`,
        timestamp: /* @__PURE__ */ new Date(),
        type: "error",
        provider: requestLog?.provider,
        apiRoute: requestLog?.apiRoute,
        data: { error },
        duration: requestLog ? (/* @__PURE__ */ new Date()).getTime() - requestLog.timestamp.getTime() : void 0
      };
      set((state2) => ({
        agentConnectionLogs: [
          ...state2.agentConnectionLogs.slice(0, state2.maxLogs - 1),
          entry
        ]
      }));
    }
  },
  logStreamStart: (params, provider) => {
    const state = get();
    if (!state.isDebugEnabled) return "";
    const streamId = `stream_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`;
    const tracker = {
      streamId,
      startTime: /* @__PURE__ */ new Date(),
      provider,
      params,
      chunks: [],
      objects: [],
      handlers: []
    };
    const newActiveStreams = new Map(state.activeStreams);
    newActiveStreams.set(streamId, tracker);
    set({ activeStreams: newActiveStreams });
    return streamId;
  },
  logStreamChunk: (streamId, chunk) => {
    const state = get();
    if (!state.isDebugEnabled) return;
    const tracker = state.activeStreams.get(streamId);
    if (!tracker) return;
    tracker.chunks.push(chunk);
  },
  logStreamObject: (streamId, object) => {
    const state = get();
    if (!state.isDebugEnabled) return;
    const tracker = state.activeStreams.get(streamId);
    if (!tracker) return;
    tracker.objects.push(object);
  },
  logStreamEnd: (streamId, completedItems) => {
    const state = get();
    if (!state.isDebugEnabled) return;
    const tracker = state.activeStreams.get(streamId);
    if (!tracker) return;
    let apiRoute;
    if (tracker.provider === "mastra" && tracker.params && "route" in tracker.params) {
      apiRoute = tracker.params.route;
    }
    const entry = {
      id: streamId,
      timestamp: tracker.startTime,
      type: "stream-complete",
      provider: tracker.provider,
      apiRoute,
      data: {
        params: tracker.params,
        streamContent: tracker.chunks.join(""),
        streamObjects: tracker.objects,
        completedItems: completedItems || [
          ...tracker.chunks.length > 0 ? [tracker.chunks.join("")] : [],
          ...tracker.objects
        ],
        handlers: tracker.handlers.length > 0 ? tracker.handlers : void 0
      },
      duration: (/* @__PURE__ */ new Date()).getTime() - tracker.startTime.getTime()
    };
    const newActiveStreams = new Map(state.activeStreams);
    newActiveStreams.delete(streamId);
    set((state2) => ({
      agentConnectionLogs: [
        ...state2.agentConnectionLogs.slice(0, state2.maxLogs - 1),
        entry
      ],
      activeStreams: newActiveStreams
    }));
  },
  logResponseProcessorExecution: (obj, processor, requestOrStreamId) => {
    const state = get();
    if (!state.isDebugEnabled) return;
    const processorName = processor.namespace ? `${processor.namespace}:${processor.type}` : processor.type;
    const handlerInfo = { processorName, handledObject: obj };
    const streamTracker = requestOrStreamId ? state.activeStreams.get(requestOrStreamId) : null;
    if (streamTracker) {
      if (processorName === "builtin:text") {
        const lastHandler = streamTracker.handlers[streamTracker.handlers.length - 1];
        if (lastHandler && lastHandler.processorName === "builtin:text") {
          const existingContent = "content" in lastHandler.handledObject ? String(lastHandler.handledObject.content) : "";
          const newContent = "content" in obj ? String(obj.content) : "";
          lastHandler.handledObject = {
            type: "text",
            content: existingContent + newContent
          };
          return;
        }
      }
      streamTracker.handlers.push(handlerInfo);
      return;
    }
    const requestTracker = requestOrStreamId ? state.activeRequests.get(requestOrStreamId) : null;
    if (requestTracker) {
      if (processorName === "builtin:text") {
        const lastHandler = requestTracker.handlers[requestTracker.handlers.length - 1];
        if (lastHandler && lastHandler.processorName === "builtin:text") {
          const existingContent = "content" in lastHandler.handledObject ? String(lastHandler.handledObject.content) : "";
          const newContent = "content" in obj ? String(obj.content) : "";
          lastHandler.handledObject = {
            type: "text",
            content: existingContent + newContent
          };
          return;
        }
      }
      requestTracker.handlers.push(handlerInfo);
      return;
    }
    if (requestOrStreamId) {
      const newTracker = {
        requestId: requestOrStreamId,
        startTime: /* @__PURE__ */ new Date(),
        handlers: [handlerInfo]
      };
      const newActiveRequests = new Map(state.activeRequests);
      newActiveRequests.set(requestOrStreamId, newTracker);
      set({ activeRequests: newActiveRequests });
    }
  },
  clearDebugLogs: () => set({ agentConnectionLogs: [] }),
  setDebugEnabled: (enabled) => set({ isDebugEnabled: enabled }),
  setMaxLogs: (max) => set({ maxLogs: max }),
  toggleSectionCollapse: (stateKey, section) => {
    const state = get();
    const currentCollapsed = state.collapsedSections[stateKey]?.[section] || false;
    set((state2) => ({
      collapsedSections: {
        ...state2.collapsedSections,
        [stateKey]: {
          ...state2.collapsedSections[stateKey],
          [section]: !currentCollapsed
        }
      }
    }));
  },
  setSectionCollapse: (stateKey, section, collapsed) => {
    set((state) => ({
      collapsedSections: {
        ...state.collapsedSections,
        [stateKey]: {
          ...state.collapsedSections[stateKey],
          [section]: collapsed
        }
      }
    }));
  },
  initializeSectionCollapse: (stateKey, hasDiffStates) => {
    const state = get();
    if (!state.collapsedSections[stateKey]) {
      set((state2) => ({
        collapsedSections: {
          ...state2.collapsedSections,
          [stateKey]: {
            // Collapse registered state by default if diff states are present
            registeredState: hasDiffStates,
            // Keep diff state expanded by default when present
            diffState: false
          }
        }
      }));
    }
  }
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createDebuggerSlice
});
//# sourceMappingURL=debuggerSlice.js.map