{"version":3,"sources":["../../src/utils/sanitizeJson.ts"],"sourcesContent":["// Helper function to sanitize context data for JSON serialization\nexport const sanitizeJson = (\n\tobj: unknown,\n\tvisited = new Map<unknown, string>(),\n\tpath = '$'\n): unknown => {\n\tif (obj === null || obj === undefined) {\n\t\treturn obj;\n\t}\n\n\t// Handle functions early\n\tif (typeof obj === 'function') {\n\t\treturn '[Function]';\n\t}\n\n\t// Handle arrays\n\tif (Array.isArray(obj)) {\n\t\t// Check for circular reference in arrays\n\t\tif (visited.has(obj)) {\n\t\t\tconst originalPath = visited.get(obj);\n\t\t\treturn `[Circular: ${originalPath}]`;\n\t\t}\n\t\tvisited.set(obj, path);\n\n\t\tconst result = obj.map((item, index) =>\n\t\t\tsanitizeJson(item, visited, `${path}[${index}]`)\n\t\t);\n\t\treturn result;\n\t}\n\n\t// Handle objects\n\tif (typeof obj === 'object') {\n\t\t// Check for circular reference\n\t\tif (visited.has(obj)) {\n\t\t\tconst originalPath = visited.get(obj);\n\t\t\treturn `[Circular: ${originalPath}]`;\n\t\t}\n\n\t\t// Add to visited map with current path\n\t\tvisited.set(obj, path);\n\n\t\t// Check if it's a React element (has $$typeof property)\n\t\tif ('$$typeof' in obj) {\n\t\t\treturn '[React Component]';\n\t\t}\n\n\t\t// Check if it's a DOM element\n\t\tif (obj instanceof Element) {\n\t\t\treturn '[DOM Element]';\n\t\t}\n\n\t\t// Check for other non-plain objects\n\t\tif (obj instanceof Date) {\n\t\t\treturn obj.toISOString();\n\t\t}\n\t\tif (obj instanceof RegExp) {\n\t\t\treturn obj.toString();\n\t\t}\n\t\tif (obj instanceof Error) {\n\t\t\treturn {\n\t\t\t\tname: obj.name,\n\t\t\t\tmessage: obj.message,\n\t\t\t\tstack: obj.stack,\n\t\t\t};\n\t\t}\n\t\tif (obj instanceof Map || obj instanceof Set) {\n\t\t\treturn `[${obj.constructor.name}]`;\n\t\t}\n\n\t\t// Recursively sanitize object properties\n\t\tconst sanitized: Record<string, unknown> = {};\n\t\tfor (const [key, value] of Object.entries(obj)) {\n\t\t\t// Skip functions\n\t\t\tif (typeof value === 'function') {\n\t\t\t\tsanitized[key] = '[Function]';\n\t\t\t} else {\n\t\t\t\t// Build the JSON path for the property\n\t\t\t\tconst propertyPath = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key)\n\t\t\t\t\t? `${path}.${key}`\n\t\t\t\t\t: `${path}[\"${key.replace(/\"/g, '\\\\\"')}\"]`;\n\t\t\t\tsanitized[key] = sanitizeJson(value, visited, propertyPath);\n\t\t\t}\n\t\t}\n\n\t\treturn sanitized;\n\t}\n\n\t// Return primitives as-is\n\treturn obj;\n};\n\n// Helper function to desanitize JSON data back to its original form with circular references\nexport const desanitizeJson = (obj: unknown): unknown => {\n\t// First pass: create the structure without resolving circular references\n\tconst structure = createStructure(obj);\n\n\t// Second pass: resolve all circular references\n\tresolveCircularReferences(structure, structure);\n\n\treturn structure;\n};\n\n// First pass: create the basic structure\nfunction createStructure(obj: unknown): unknown {\n\tif (obj === null || obj === undefined) {\n\t\treturn obj;\n\t}\n\n\t// Primitives and strings (including circular reference markers)\n\tif (typeof obj !== 'object') {\n\t\treturn obj;\n\t}\n\n\t// Arrays\n\tif (Array.isArray(obj)) {\n\t\treturn obj.map((item) => createStructure(item));\n\t}\n\n\t// Objects\n\tconst result: Record<string, unknown> = {};\n\tfor (const [key, value] of Object.entries(obj)) {\n\t\tresult[key] = createStructure(value);\n\t}\n\treturn result;\n}\n\n// Second pass: resolve circular references\nfunction resolveCircularReferences(obj: unknown, root: unknown): void {\n\tif (obj === null || obj === undefined || typeof obj !== 'object') {\n\t\treturn;\n\t}\n\n\tif (Array.isArray(obj)) {\n\t\tfor (let i = 0; i < obj.length; i++) {\n\t\t\tif (typeof obj[i] === 'string') {\n\t\t\t\tconst circularMatch = (obj[i] as string).match(/^\\[Circular: (.+)\\]$/);\n\t\t\t\tif (circularMatch) {\n\t\t\t\t\tobj[i] = resolvePath(root, circularMatch[1]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresolveCircularReferences(obj[i], root);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// It's an object\n\t\tfor (const [key, value] of Object.entries(obj)) {\n\t\t\tif (typeof value === 'string') {\n\t\t\t\tconst circularMatch = value.match(/^\\[Circular: (.+)\\]$/);\n\t\t\t\tif (circularMatch) {\n\t\t\t\t\t(obj as Record<string, unknown>)[key] = resolvePath(\n\t\t\t\t\t\troot,\n\t\t\t\t\t\tcircularMatch[1]\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresolveCircularReferences(value, root);\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Helper function to resolve a JSON path to the actual object reference\nfunction resolvePath(root: unknown, path: string): unknown {\n\t// Handle root reference\n\tif (path === '$') {\n\t\treturn root;\n\t}\n\n\t// Parse the path and navigate to the target\n\tlet current: unknown = root;\n\n\t// Remove the leading $ and process the path\n\tconst pathWithoutRoot = path.substring(1);\n\n\t// Split the path into segments, handling both dot notation and bracket notation\n\tconst segments: string[] = [];\n\tlet currentSegment = '';\n\tlet inBracket = false;\n\tlet inQuotes = false;\n\tlet escapeNext = false;\n\n\tfor (let i = 0; i < pathWithoutRoot.length; i++) {\n\t\tconst char = pathWithoutRoot[i];\n\n\t\tif (escapeNext) {\n\t\t\tcurrentSegment += char;\n\t\t\tescapeNext = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (char === '\\\\') {\n\t\t\tescapeNext = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (char === '\"' && inBracket) {\n\t\t\tinQuotes = !inQuotes;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (char === '[' && !inQuotes) {\n\t\t\tif (currentSegment) {\n\t\t\t\tsegments.push(currentSegment);\n\t\t\t\tcurrentSegment = '';\n\t\t\t}\n\t\t\tinBracket = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (char === ']' && !inQuotes && inBracket) {\n\t\t\tif (currentSegment) {\n\t\t\t\tsegments.push(currentSegment);\n\t\t\t\tcurrentSegment = '';\n\t\t\t}\n\t\t\tinBracket = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (char === '.' && !inBracket && !inQuotes) {\n\t\t\tif (currentSegment) {\n\t\t\t\tsegments.push(currentSegment);\n\t\t\t\tcurrentSegment = '';\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tcurrentSegment += char;\n\t}\n\n\tif (currentSegment) {\n\t\tsegments.push(currentSegment);\n\t}\n\n\t// Navigate through the object using the segments\n\tfor (const segment of segments) {\n\t\tif (current === null || current === undefined) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Check if segment is a number (array index)\n\t\tconst indexMatch = segment.match(/^(\\d+)$/);\n\t\tif (indexMatch) {\n\t\t\tcurrent = (current as Record<number, unknown>)[parseInt(segment, 10)];\n\t\t} else {\n\t\t\t// It's a property name\n\t\t\tcurrent = (current as Record<string, unknown>)[segment];\n\t\t}\n\t}\n\n\treturn current;\n}\n"],"mappings":";AACO,IAAM,eAAe,CAC3B,KACA,UAAU,oBAAI,IAAqB,GACnC,OAAO,QACM;AACb,MAAI,QAAQ,QAAQ,QAAQ,QAAW;AACtC,WAAO;AAAA,EACR;AAGA,MAAI,OAAO,QAAQ,YAAY;AAC9B,WAAO;AAAA,EACR;AAGA,MAAI,MAAM,QAAQ,GAAG,GAAG;AAEvB,QAAI,QAAQ,IAAI,GAAG,GAAG;AACrB,YAAM,eAAe,QAAQ,IAAI,GAAG;AACpC,aAAO,cAAc,YAAY;AAAA,IAClC;AACA,YAAQ,IAAI,KAAK,IAAI;AAErB,UAAM,SAAS,IAAI;AAAA,MAAI,CAAC,MAAM,UAC7B,aAAa,MAAM,SAAS,GAAG,IAAI,IAAI,KAAK,GAAG;AAAA,IAChD;AACA,WAAO;AAAA,EACR;AAGA,MAAI,OAAO,QAAQ,UAAU;AAE5B,QAAI,QAAQ,IAAI,GAAG,GAAG;AACrB,YAAM,eAAe,QAAQ,IAAI,GAAG;AACpC,aAAO,cAAc,YAAY;AAAA,IAClC;AAGA,YAAQ,IAAI,KAAK,IAAI;AAGrB,QAAI,cAAc,KAAK;AACtB,aAAO;AAAA,IACR;AAGA,QAAI,eAAe,SAAS;AAC3B,aAAO;AAAA,IACR;AAGA,QAAI,eAAe,MAAM;AACxB,aAAO,IAAI,YAAY;AAAA,IACxB;AACA,QAAI,eAAe,QAAQ;AAC1B,aAAO,IAAI,SAAS;AAAA,IACrB;AACA,QAAI,eAAe,OAAO;AACzB,aAAO;AAAA,QACN,MAAM,IAAI;AAAA,QACV,SAAS,IAAI;AAAA,QACb,OAAO,IAAI;AAAA,MACZ;AAAA,IACD;AACA,QAAI,eAAe,OAAO,eAAe,KAAK;AAC7C,aAAO,IAAI,IAAI,YAAY,IAAI;AAAA,IAChC;AAGA,UAAM,YAAqC,CAAC;AAC5C,eAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,GAAG,GAAG;AAE/C,UAAI,OAAO,UAAU,YAAY;AAChC,kBAAU,GAAG,IAAI;AAAA,MAClB,OAAO;AAEN,cAAM,eAAe,6BAA6B,KAAK,GAAG,IACvD,GAAG,IAAI,IAAI,GAAG,KACd,GAAG,IAAI,KAAK,IAAI,QAAQ,MAAM,KAAK,CAAC;AACvC,kBAAU,GAAG,IAAI,aAAa,OAAO,SAAS,YAAY;AAAA,MAC3D;AAAA,IACD;AAEA,WAAO;AAAA,EACR;AAGA,SAAO;AACR;AAGO,IAAM,iBAAiB,CAAC,QAA0B;AAExD,QAAM,YAAY,gBAAgB,GAAG;AAGrC,4BAA0B,WAAW,SAAS;AAE9C,SAAO;AACR;AAGA,SAAS,gBAAgB,KAAuB;AAC/C,MAAI,QAAQ,QAAQ,QAAQ,QAAW;AACtC,WAAO;AAAA,EACR;AAGA,MAAI,OAAO,QAAQ,UAAU;AAC5B,WAAO;AAAA,EACR;AAGA,MAAI,MAAM,QAAQ,GAAG,GAAG;AACvB,WAAO,IAAI,IAAI,CAAC,SAAS,gBAAgB,IAAI,CAAC;AAAA,EAC/C;AAGA,QAAM,SAAkC,CAAC;AACzC,aAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,GAAG,GAAG;AAC/C,WAAO,GAAG,IAAI,gBAAgB,KAAK;AAAA,EACpC;AACA,SAAO;AACR;AAGA,SAAS,0BAA0B,KAAc,MAAqB;AACrE,MAAI,QAAQ,QAAQ,QAAQ,UAAa,OAAO,QAAQ,UAAU;AACjE;AAAA,EACD;AAEA,MAAI,MAAM,QAAQ,GAAG,GAAG;AACvB,aAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AACpC,UAAI,OAAO,IAAI,CAAC,MAAM,UAAU;AAC/B,cAAM,gBAAiB,IAAI,CAAC,EAAa,MAAM,sBAAsB;AACrE,YAAI,eAAe;AAClB,cAAI,CAAC,IAAI,YAAY,MAAM,cAAc,CAAC,CAAC;AAAA,QAC5C;AAAA,MACD,OAAO;AACN,kCAA0B,IAAI,CAAC,GAAG,IAAI;AAAA,MACvC;AAAA,IACD;AAAA,EACD,OAAO;AAEN,eAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,GAAG,GAAG;AAC/C,UAAI,OAAO,UAAU,UAAU;AAC9B,cAAM,gBAAgB,MAAM,MAAM,sBAAsB;AACxD,YAAI,eAAe;AAClB,UAAC,IAAgC,GAAG,IAAI;AAAA,YACvC;AAAA,YACA,cAAc,CAAC;AAAA,UAChB;AAAA,QACD;AAAA,MACD,OAAO;AACN,kCAA0B,OAAO,IAAI;AAAA,MACtC;AAAA,IACD;AAAA,EACD;AACD;AAGA,SAAS,YAAY,MAAe,MAAuB;AAE1D,MAAI,SAAS,KAAK;AACjB,WAAO;AAAA,EACR;AAGA,MAAI,UAAmB;AAGvB,QAAM,kBAAkB,KAAK,UAAU,CAAC;AAGxC,QAAM,WAAqB,CAAC;AAC5B,MAAI,iBAAiB;AACrB,MAAI,YAAY;AAChB,MAAI,WAAW;AACf,MAAI,aAAa;AAEjB,WAAS,IAAI,GAAG,IAAI,gBAAgB,QAAQ,KAAK;AAChD,UAAM,OAAO,gBAAgB,CAAC;AAE9B,QAAI,YAAY;AACf,wBAAkB;AAClB,mBAAa;AACb;AAAA,IACD;AAEA,QAAI,SAAS,MAAM;AAClB,mBAAa;AACb;AAAA,IACD;AAEA,QAAI,SAAS,OAAO,WAAW;AAC9B,iBAAW,CAAC;AACZ;AAAA,IACD;AAEA,QAAI,SAAS,OAAO,CAAC,UAAU;AAC9B,UAAI,gBAAgB;AACnB,iBAAS,KAAK,cAAc;AAC5B,yBAAiB;AAAA,MAClB;AACA,kBAAY;AACZ;AAAA,IACD;AAEA,QAAI,SAAS,OAAO,CAAC,YAAY,WAAW;AAC3C,UAAI,gBAAgB;AACnB,iBAAS,KAAK,cAAc;AAC5B,yBAAiB;AAAA,MAClB;AACA,kBAAY;AACZ;AAAA,IACD;AAEA,QAAI,SAAS,OAAO,CAAC,aAAa,CAAC,UAAU;AAC5C,UAAI,gBAAgB;AACnB,iBAAS,KAAK,cAAc;AAC5B,yBAAiB;AAAA,MAClB;AACA;AAAA,IACD;AAEA,sBAAkB;AAAA,EACnB;AAEA,MAAI,gBAAgB;AACnB,aAAS,KAAK,cAAc;AAAA,EAC7B;AAGA,aAAW,WAAW,UAAU;AAC/B,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC9C,aAAO;AAAA,IACR;AAGA,UAAM,aAAa,QAAQ,MAAM,SAAS;AAC1C,QAAI,YAAY;AACf,gBAAW,QAAoC,SAAS,SAAS,EAAE,CAAC;AAAA,IACrE,OAAO;AAEN,gBAAW,QAAoC,OAAO;AAAA,IACvD;AAAA,EACD;AAEA,SAAO;AACR;","names":[]}