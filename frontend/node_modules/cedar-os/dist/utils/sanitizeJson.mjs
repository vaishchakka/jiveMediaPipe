// src/utils/sanitizeJson.ts
var sanitizeJson = (obj, visited = /* @__PURE__ */ new Map(), path = "$") => {
  if (obj === null || obj === void 0) {
    return obj;
  }
  if (typeof obj === "function") {
    return "[Function]";
  }
  if (Array.isArray(obj)) {
    if (visited.has(obj)) {
      const originalPath = visited.get(obj);
      return `[Circular: ${originalPath}]`;
    }
    visited.set(obj, path);
    const result = obj.map(
      (item, index) => sanitizeJson(item, visited, `${path}[${index}]`)
    );
    return result;
  }
  if (typeof obj === "object") {
    if (visited.has(obj)) {
      const originalPath = visited.get(obj);
      return `[Circular: ${originalPath}]`;
    }
    visited.set(obj, path);
    if ("$$typeof" in obj) {
      return "[React Component]";
    }
    if (obj instanceof Element) {
      return "[DOM Element]";
    }
    if (obj instanceof Date) {
      return obj.toISOString();
    }
    if (obj instanceof RegExp) {
      return obj.toString();
    }
    if (obj instanceof Error) {
      return {
        name: obj.name,
        message: obj.message,
        stack: obj.stack
      };
    }
    if (obj instanceof Map || obj instanceof Set) {
      return `[${obj.constructor.name}]`;
    }
    const sanitized = {};
    for (const [key, value] of Object.entries(obj)) {
      if (typeof value === "function") {
        sanitized[key] = "[Function]";
      } else {
        const propertyPath = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key) ? `${path}.${key}` : `${path}["${key.replace(/"/g, '\\"')}"]`;
        sanitized[key] = sanitizeJson(value, visited, propertyPath);
      }
    }
    return sanitized;
  }
  return obj;
};
var desanitizeJson = (obj) => {
  const structure = createStructure(obj);
  resolveCircularReferences(structure, structure);
  return structure;
};
function createStructure(obj) {
  if (obj === null || obj === void 0) {
    return obj;
  }
  if (typeof obj !== "object") {
    return obj;
  }
  if (Array.isArray(obj)) {
    return obj.map((item) => createStructure(item));
  }
  const result = {};
  for (const [key, value] of Object.entries(obj)) {
    result[key] = createStructure(value);
  }
  return result;
}
function resolveCircularReferences(obj, root) {
  if (obj === null || obj === void 0 || typeof obj !== "object") {
    return;
  }
  if (Array.isArray(obj)) {
    for (let i = 0; i < obj.length; i++) {
      if (typeof obj[i] === "string") {
        const circularMatch = obj[i].match(/^\[Circular: (.+)\]$/);
        if (circularMatch) {
          obj[i] = resolvePath(root, circularMatch[1]);
        }
      } else {
        resolveCircularReferences(obj[i], root);
      }
    }
  } else {
    for (const [key, value] of Object.entries(obj)) {
      if (typeof value === "string") {
        const circularMatch = value.match(/^\[Circular: (.+)\]$/);
        if (circularMatch) {
          obj[key] = resolvePath(
            root,
            circularMatch[1]
          );
        }
      } else {
        resolveCircularReferences(value, root);
      }
    }
  }
}
function resolvePath(root, path) {
  if (path === "$") {
    return root;
  }
  let current = root;
  const pathWithoutRoot = path.substring(1);
  const segments = [];
  let currentSegment = "";
  let inBracket = false;
  let inQuotes = false;
  let escapeNext = false;
  for (let i = 0; i < pathWithoutRoot.length; i++) {
    const char = pathWithoutRoot[i];
    if (escapeNext) {
      currentSegment += char;
      escapeNext = false;
      continue;
    }
    if (char === "\\") {
      escapeNext = true;
      continue;
    }
    if (char === '"' && inBracket) {
      inQuotes = !inQuotes;
      continue;
    }
    if (char === "[" && !inQuotes) {
      if (currentSegment) {
        segments.push(currentSegment);
        currentSegment = "";
      }
      inBracket = true;
      continue;
    }
    if (char === "]" && !inQuotes && inBracket) {
      if (currentSegment) {
        segments.push(currentSegment);
        currentSegment = "";
      }
      inBracket = false;
      continue;
    }
    if (char === "." && !inBracket && !inQuotes) {
      if (currentSegment) {
        segments.push(currentSegment);
        currentSegment = "";
      }
      continue;
    }
    currentSegment += char;
  }
  if (currentSegment) {
    segments.push(currentSegment);
  }
  for (const segment of segments) {
    if (current === null || current === void 0) {
      return void 0;
    }
    const indexMatch = segment.match(/^(\d+)$/);
    if (indexMatch) {
      current = current[parseInt(segment, 10)];
    } else {
      current = current[segment];
    }
  }
  return current;
}
export {
  desanitizeJson,
  sanitizeJson
};
//# sourceMappingURL=sanitizeJson.mjs.map