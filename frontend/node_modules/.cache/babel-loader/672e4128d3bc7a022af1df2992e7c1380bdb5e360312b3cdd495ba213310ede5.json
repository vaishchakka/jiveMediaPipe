{"ast":null,"code":"'use strict';\n\nconst hasBuffer = typeof Buffer !== 'undefined';\nconst suspectProtoRx = /\"(?:_|\\\\u005[Ff])(?:_|\\\\u005[Ff])(?:p|\\\\u0070)(?:r|\\\\u0072)(?:o|\\\\u006[Ff])(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:_|\\\\u005[Ff])(?:_|\\\\u005[Ff])\"\\s*:/;\nconst suspectConstructorRx = /\"(?:c|\\\\u0063)(?:o|\\\\u006[Ff])(?:n|\\\\u006[Ee])(?:s|\\\\u0073)(?:t|\\\\u0074)(?:r|\\\\u0072)(?:u|\\\\u0075)(?:c|\\\\u0063)(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:r|\\\\u0072)\"\\s*:/;\nfunction _parse(text, reviver, options) {\n  // Normalize arguments\n  if (options == null) {\n    if (reviver !== null && typeof reviver === 'object') {\n      options = reviver;\n      reviver = undefined;\n    }\n  }\n  if (hasBuffer && Buffer.isBuffer(text)) {\n    text = text.toString();\n  }\n\n  // BOM checker\n  if (text && text.charCodeAt(0) === 0xFEFF) {\n    text = text.slice(1);\n  }\n\n  // Parse normally, allowing exceptions\n  const obj = JSON.parse(text, reviver);\n\n  // Ignore null and non-objects\n  if (obj === null || typeof obj !== 'object') {\n    return obj;\n  }\n  const protoAction = options && options.protoAction || 'error';\n  const constructorAction = options && options.constructorAction || 'error';\n\n  // options: 'error' (default) / 'remove' / 'ignore'\n  if (protoAction === 'ignore' && constructorAction === 'ignore') {\n    return obj;\n  }\n  if (protoAction !== 'ignore' && constructorAction !== 'ignore') {\n    if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {\n      return obj;\n    }\n  } else if (protoAction !== 'ignore' && constructorAction === 'ignore') {\n    if (suspectProtoRx.test(text) === false) {\n      return obj;\n    }\n  } else {\n    if (suspectConstructorRx.test(text) === false) {\n      return obj;\n    }\n  }\n\n  // Scan result for proto keys\n  return filter(obj, {\n    protoAction,\n    constructorAction,\n    safe: options && options.safe\n  });\n}\nfunction filter(obj, {\n  protoAction = 'error',\n  constructorAction = 'error',\n  safe\n} = {}) {\n  let next = [obj];\n  while (next.length) {\n    const nodes = next;\n    next = [];\n    for (const node of nodes) {\n      if (protoAction !== 'ignore' && Object.prototype.hasOwnProperty.call(node, '__proto__')) {\n        // Avoid calling node.hasOwnProperty directly\n        if (safe === true) {\n          return null;\n        } else if (protoAction === 'error') {\n          throw new SyntaxError('Object contains forbidden prototype property');\n        }\n        delete node.__proto__; // eslint-disable-line no-proto\n      }\n      if (constructorAction !== 'ignore' && Object.prototype.hasOwnProperty.call(node, 'constructor') && Object.prototype.hasOwnProperty.call(node.constructor, 'prototype')) {\n        // Avoid calling node.hasOwnProperty directly\n        if (safe === true) {\n          return null;\n        } else if (constructorAction === 'error') {\n          throw new SyntaxError('Object contains forbidden prototype property');\n        }\n        delete node.constructor;\n      }\n      for (const key in node) {\n        const value = node[key];\n        if (value && typeof value === 'object') {\n          next.push(value);\n        }\n      }\n    }\n  }\n  return obj;\n}\nfunction parse(text, reviver, options) {\n  const stackTraceLimit = Error.stackTraceLimit;\n  Error.stackTraceLimit = 0;\n  try {\n    return _parse(text, reviver, options);\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit;\n  }\n}\nfunction safeParse(text, reviver) {\n  const stackTraceLimit = Error.stackTraceLimit;\n  Error.stackTraceLimit = 0;\n  try {\n    return _parse(text, reviver, {\n      safe: true\n    });\n  } catch (_e) {\n    return null;\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit;\n  }\n}\nmodule.exports = parse;\nmodule.exports.default = parse;\nmodule.exports.parse = parse;\nmodule.exports.safeParse = safeParse;\nmodule.exports.scan = filter;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}