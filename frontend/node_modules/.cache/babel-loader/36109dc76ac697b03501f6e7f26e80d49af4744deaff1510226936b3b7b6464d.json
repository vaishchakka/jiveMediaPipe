{"ast":null,"code":"import { removeItem } from 'motion-utils';\nimport { microtask } from '../frameloop/microtask.mjs';\nimport { startViewAnimation } from './start.mjs';\nlet builders = [];\nlet current = null;\nfunction next() {\n  current = null;\n  const [nextBuilder] = builders;\n  if (nextBuilder) start(nextBuilder);\n}\nfunction start(builder) {\n  removeItem(builders, builder);\n  current = builder;\n  startViewAnimation(builder).then(animation => {\n    builder.notifyReady(animation);\n    animation.finished.finally(next);\n  });\n}\nfunction processQueue() {\n  /**\n   * Iterate backwards over the builders array. We can ignore the\n   * \"wait\" animations. If we have an interrupting animation in the\n   * queue then we need to batch all preceeding animations into it.\n   * Currently this only batches the update functions but will also\n   * need to batch the targets.\n   */\n  for (let i = builders.length - 1; i >= 0; i--) {\n    const builder = builders[i];\n    const {\n      interrupt\n    } = builder.options;\n    if (interrupt === \"immediate\") {\n      const batchedUpdates = builders.slice(0, i + 1).map(b => b.update);\n      const remaining = builders.slice(i + 1);\n      builder.update = () => {\n        batchedUpdates.forEach(update => update());\n      };\n      // Put the current builder at the front, followed by any \"wait\" builders\n      builders = [builder, ...remaining];\n      break;\n    }\n  }\n  if (!current || builders[0]?.options.interrupt === \"immediate\") {\n    next();\n  }\n}\nfunction addToQueue(builder) {\n  builders.push(builder);\n  microtask.render(processQueue);\n}\nexport { addToQueue };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}