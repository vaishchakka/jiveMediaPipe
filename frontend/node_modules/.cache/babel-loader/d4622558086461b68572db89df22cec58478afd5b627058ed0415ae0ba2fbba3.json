{"ast":null,"code":"import { BubbleMenuPlugin } from '@tiptap/extension-bubble-menu';\nimport React, { forwardRef, useState, useDebugValue, useLayoutEffect, useEffect, useRef, createContext, useContext, version, createRef, memo, createElement } from 'react';\nimport ReactDOM, { flushSync } from 'react-dom';\nimport { Editor, NodeView, getRenderedAttributes } from '@tiptap/core';\nexport * from '@tiptap/core';\nimport { FloatingMenuPlugin } from '@tiptap/extension-floating-menu';\nfunction getDefaultExportFromCjs(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\nvar shim = {\n  exports: {}\n};\nvar useSyncExternalStoreShim_production_min = {};\n\n/**\n * @license React\n * use-sync-external-store-shim.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar hasRequiredUseSyncExternalStoreShim_production_min;\nfunction requireUseSyncExternalStoreShim_production_min() {\n  if (hasRequiredUseSyncExternalStoreShim_production_min) return useSyncExternalStoreShim_production_min;\n  hasRequiredUseSyncExternalStoreShim_production_min = 1;\n  var e = React;\n  function h(a, b) {\n    return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;\n  }\n  var k = \"function\" === typeof Object.is ? Object.is : h,\n    l = e.useState,\n    m = e.useEffect,\n    n = e.useLayoutEffect,\n    p = e.useDebugValue;\n  function q(a, b) {\n    var d = b(),\n      f = l({\n        inst: {\n          value: d,\n          getSnapshot: b\n        }\n      }),\n      c = f[0].inst,\n      g = f[1];\n    n(function () {\n      c.value = d;\n      c.getSnapshot = b;\n      r(c) && g({\n        inst: c\n      });\n    }, [a, d, b]);\n    m(function () {\n      r(c) && g({\n        inst: c\n      });\n      return a(function () {\n        r(c) && g({\n          inst: c\n        });\n      });\n    }, [a]);\n    p(d);\n    return d;\n  }\n  function r(a) {\n    var b = a.getSnapshot;\n    a = a.value;\n    try {\n      var d = b();\n      return !k(a, d);\n    } catch (f) {\n      return !0;\n    }\n  }\n  function t(a, b) {\n    return b();\n  }\n  var u = \"undefined\" === typeof window || \"undefined\" === typeof window.document || \"undefined\" === typeof window.document.createElement ? t : q;\n  useSyncExternalStoreShim_production_min.useSyncExternalStore = void 0 !== e.useSyncExternalStore ? e.useSyncExternalStore : u;\n  return useSyncExternalStoreShim_production_min;\n}\nvar useSyncExternalStoreShim_development = {};\n\n/**\n * @license React\n * use-sync-external-store-shim.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar hasRequiredUseSyncExternalStoreShim_development;\nfunction requireUseSyncExternalStoreShim_development() {\n  if (hasRequiredUseSyncExternalStoreShim_development) return useSyncExternalStoreShim_development;\n  hasRequiredUseSyncExternalStoreShim_development = 1;\n  if (process.env.NODE_ENV !== \"production\") {\n    (function () {\n      /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === 'function') {\n        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n      }\n      var React$1 = React;\n      var ReactSharedInternals = React$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n      function error(format) {\n        {\n          {\n            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n              args[_key2 - 1] = arguments[_key2];\n            }\n            printWarning('error', format, args);\n          }\n        }\n      }\n      function printWarning(level, format, args) {\n        // When changing this logic, you might want to also\n        // update consoleWithStackDev.www.js as well.\n        {\n          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n          var stack = ReactDebugCurrentFrame.getStackAddendum();\n          if (stack !== '') {\n            format += '%s';\n            args = args.concat([stack]);\n          } // eslint-disable-next-line react-internal/safe-string-coercion\n\n          var argsWithFormat = args.map(function (item) {\n            return String(item);\n          }); // Careful: RN currently depends on this prefix\n\n          argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n          // breaks IE9: https://github.com/facebook/react/issues/13610\n          // eslint-disable-next-line react-internal/no-production-logging\n\n          Function.prototype.apply.call(console[level], console, argsWithFormat);\n        }\n      }\n\n      /**\n       * inlined Object.is polyfill to avoid requiring consumers ship their own\n       * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n       */\n      function is(x, y) {\n        return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n        ;\n      }\n      var objectIs = typeof Object.is === 'function' ? Object.is : is;\n\n      // dispatch for CommonJS interop named imports.\n\n      var useState = React$1.useState,\n        useEffect = React$1.useEffect,\n        useLayoutEffect = React$1.useLayoutEffect,\n        useDebugValue = React$1.useDebugValue;\n      var didWarnOld18Alpha = false;\n      var didWarnUncachedGetSnapshot = false; // Disclaimer: This shim breaks many of the rules of React, and only works\n      // because of a very particular set of implementation details and assumptions\n      // -- change any one of them and it will break. The most important assumption\n      // is that updates are always synchronous, because concurrent rendering is\n      // only available in versions of React that also have a built-in\n      // useSyncExternalStore API. And we only use this shim when the built-in API\n      // does not exist.\n      //\n      // Do not assume that the clever hacks used by this hook also work in general.\n      // The point of this shim is to replace the need for hacks by other libraries.\n\n      function useSyncExternalStore(subscribe, getSnapshot,\n      // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n      // React do not expose a way to check if we're hydrating. So users of the shim\n      // will need to track that themselves and return the correct value\n      // from `getSnapshot`.\n      getServerSnapshot) {\n        {\n          if (!didWarnOld18Alpha) {\n            if (React$1.startTransition !== undefined) {\n              didWarnOld18Alpha = true;\n              error('You are using an outdated, pre-release alpha of React 18 that ' + 'does not support useSyncExternalStore. The ' + 'use-sync-external-store shim will not work correctly. Upgrade ' + 'to a newer pre-release.');\n            }\n          }\n        } // Read the current snapshot from the store on every render. Again, this\n        // breaks the rules of React, and only works here because of specific\n        // implementation details, most importantly that updates are\n        // always synchronous.\n\n        var value = getSnapshot();\n        {\n          if (!didWarnUncachedGetSnapshot) {\n            var cachedValue = getSnapshot();\n            if (!objectIs(value, cachedValue)) {\n              error('The result of getSnapshot should be cached to avoid an infinite loop');\n              didWarnUncachedGetSnapshot = true;\n            }\n          }\n        } // Because updates are synchronous, we don't queue them. Instead we force a\n        // re-render whenever the subscribed state changes by updating an some\n        // arbitrary useState hook. Then, during render, we call getSnapshot to read\n        // the current value.\n        //\n        // Because we don't actually use the state returned by the useState hook, we\n        // can save a bit of memory by storing other stuff in that slot.\n        //\n        // To implement the early bailout, we need to track some things on a mutable\n        // object. Usually, we would put that in a useRef hook, but we can stash it in\n        // our useState hook instead.\n        //\n        // To force a re-render, we call forceUpdate({inst}). That works because the\n        // new object always fails an equality check.\n\n        var _useState = useState({\n            inst: {\n              value: value,\n              getSnapshot: getSnapshot\n            }\n          }),\n          inst = _useState[0].inst,\n          forceUpdate = _useState[1]; // Track the latest getSnapshot function with a ref. This needs to be updated\n        // in the layout phase so we can access it during the tearing check that\n        // happens on subscribe.\n\n        useLayoutEffect(function () {\n          inst.value = value;\n          inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the\n          // commit phase if there was an interleaved mutation. In concurrent mode\n          // this can happen all the time, but even in synchronous mode, an earlier\n          // effect may have mutated the store.\n\n          if (checkIfSnapshotChanged(inst)) {\n            // Force a re-render.\n            forceUpdate({\n              inst: inst\n            });\n          }\n        }, [subscribe, value, getSnapshot]);\n        useEffect(function () {\n          // Check for changes right before subscribing. Subsequent changes will be\n          // detected in the subscription handler.\n          if (checkIfSnapshotChanged(inst)) {\n            // Force a re-render.\n            forceUpdate({\n              inst: inst\n            });\n          }\n          var handleStoreChange = function () {\n            // TODO: Because there is no cross-renderer API for batching updates, it's\n            // up to the consumer of this library to wrap their subscription event\n            // with unstable_batchedUpdates. Should we try to detect when this isn't\n            // the case and print a warning in development?\n            // The store changed. Check if the snapshot changed since the last time we\n            // read from the store.\n            if (checkIfSnapshotChanged(inst)) {\n              // Force a re-render.\n              forceUpdate({\n                inst: inst\n              });\n            }\n          }; // Subscribe to the store and return a clean-up function.\n\n          return subscribe(handleStoreChange);\n        }, [subscribe]);\n        useDebugValue(value);\n        return value;\n      }\n      function checkIfSnapshotChanged(inst) {\n        var latestGetSnapshot = inst.getSnapshot;\n        var prevValue = inst.value;\n        try {\n          var nextValue = latestGetSnapshot();\n          return !objectIs(prevValue, nextValue);\n        } catch (error) {\n          return true;\n        }\n      }\n      function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {\n        // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n        // React do not expose a way to check if we're hydrating. So users of the shim\n        // will need to track that themselves and return the correct value\n        // from `getSnapshot`.\n        return getSnapshot();\n      }\n      var canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');\n      var isServerEnvironment = !canUseDOM;\n      var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;\n      var useSyncExternalStore$2 = React$1.useSyncExternalStore !== undefined ? React$1.useSyncExternalStore : shim;\n      useSyncExternalStoreShim_development.useSyncExternalStore = useSyncExternalStore$2;\n      /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === 'function') {\n        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n      }\n    })();\n  }\n  return useSyncExternalStoreShim_development;\n}\nif (process.env.NODE_ENV === 'production') {\n  shim.exports = requireUseSyncExternalStoreShim_production_min();\n} else {\n  shim.exports = requireUseSyncExternalStoreShim_development();\n}\nvar shimExports = shim.exports;\nconst mergeRefs = (...refs) => {\n  return node => {\n    refs.forEach(ref => {\n      if (typeof ref === 'function') {\n        ref(node);\n      } else if (ref) {\n        ref.current = node;\n      }\n    });\n  };\n};\n/**\n * This component renders all of the editor's node views.\n */\nconst Portals = ({\n  contentComponent\n}) => {\n  // For performance reasons, we render the node view portals on state changes only\n  const renderers = shimExports.useSyncExternalStore(contentComponent.subscribe, contentComponent.getSnapshot, contentComponent.getServerSnapshot);\n  // This allows us to directly render the portals without any additional wrapper\n  return React.createElement(React.Fragment, null, Object.values(renderers));\n};\nfunction getInstance() {\n  const subscribers = new Set();\n  let renderers = {};\n  return {\n    /**\n     * Subscribe to the editor instance's changes.\n     */\n    subscribe(callback) {\n      subscribers.add(callback);\n      return () => {\n        subscribers.delete(callback);\n      };\n    },\n    getSnapshot() {\n      return renderers;\n    },\n    getServerSnapshot() {\n      return renderers;\n    },\n    /**\n     * Adds a new NodeView Renderer to the editor.\n     */\n    setRenderer(id, renderer) {\n      renderers = {\n        ...renderers,\n        [id]: ReactDOM.createPortal(renderer.reactElement, renderer.element, id)\n      };\n      subscribers.forEach(subscriber => subscriber());\n    },\n    /**\n     * Removes a NodeView Renderer from the editor.\n     */\n    removeRenderer(id) {\n      const nextRenderers = {\n        ...renderers\n      };\n      delete nextRenderers[id];\n      renderers = nextRenderers;\n      subscribers.forEach(subscriber => subscriber());\n    }\n  };\n}\nclass PureEditorContent extends React.Component {\n  constructor(props) {\n    var _a;\n    super(props);\n    this.editorContentRef = React.createRef();\n    this.initialized = false;\n    this.state = {\n      hasContentComponentInitialized: Boolean((_a = props.editor) === null || _a === void 0 ? void 0 : _a.contentComponent)\n    };\n  }\n  componentDidMount() {\n    this.init();\n  }\n  componentDidUpdate() {\n    this.init();\n  }\n  init() {\n    const editor = this.props.editor;\n    if (editor && !editor.isDestroyed && editor.options.element) {\n      if (editor.contentComponent) {\n        return;\n      }\n      const element = this.editorContentRef.current;\n      element.append(...editor.options.element.childNodes);\n      editor.setOptions({\n        element\n      });\n      editor.contentComponent = getInstance();\n      // Has the content component been initialized?\n      if (!this.state.hasContentComponentInitialized) {\n        // Subscribe to the content component\n        this.unsubscribeToContentComponent = editor.contentComponent.subscribe(() => {\n          this.setState(prevState => {\n            if (!prevState.hasContentComponentInitialized) {\n              return {\n                hasContentComponentInitialized: true\n              };\n            }\n            return prevState;\n          });\n          // Unsubscribe to previous content component\n          if (this.unsubscribeToContentComponent) {\n            this.unsubscribeToContentComponent();\n          }\n        });\n      }\n      editor.createNodeViews();\n      this.initialized = true;\n    }\n  }\n  componentWillUnmount() {\n    const editor = this.props.editor;\n    if (!editor) {\n      return;\n    }\n    this.initialized = false;\n    if (!editor.isDestroyed) {\n      editor.view.setProps({\n        nodeViews: {}\n      });\n    }\n    if (this.unsubscribeToContentComponent) {\n      this.unsubscribeToContentComponent();\n    }\n    editor.contentComponent = null;\n    if (!editor.options.element.firstChild) {\n      return;\n    }\n    const newElement = document.createElement('div');\n    newElement.append(...editor.options.element.childNodes);\n    editor.setOptions({\n      element: newElement\n    });\n  }\n  render() {\n    const {\n      editor,\n      innerRef,\n      ...rest\n    } = this.props;\n    return React.createElement(React.Fragment, null, React.createElement(\"div\", {\n      ref: mergeRefs(innerRef, this.editorContentRef),\n      ...rest\n    }), (editor === null || editor === void 0 ? void 0 : editor.contentComponent) && React.createElement(Portals, {\n      contentComponent: editor.contentComponent\n    }));\n  }\n}\n// EditorContent should be re-created whenever the Editor instance changes\nconst EditorContentWithKey = forwardRef((props, ref) => {\n  const key = React.useMemo(() => {\n    return Math.floor(Math.random() * 0xffffffff).toString();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [props.editor]);\n  // Can't use JSX here because it conflicts with the type definition of Vue's JSX, so use createElement\n  return React.createElement(PureEditorContent, {\n    key,\n    innerRef: ref,\n    ...props\n  });\n});\nconst EditorContent = React.memo(EditorContentWithKey);\nvar react = function equal(a, b) {\n  if (a === b) return true;\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;) if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n    if (a instanceof Map && b instanceof Map) {\n      if (a.size !== b.size) return false;\n      for (i of a.entries()) if (!b.has(i[0])) return false;\n      for (i of a.entries()) if (!equal(i[1], b.get(i[0]))) return false;\n      return true;\n    }\n    if (a instanceof Set && b instanceof Set) {\n      if (a.size !== b.size) return false;\n      for (i of a.entries()) if (!b.has(i[0])) return false;\n      return true;\n    }\n    if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;) if (a[i] !== b[i]) return false;\n      return true;\n    }\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n    for (i = length; i-- !== 0;) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n      if (key === '_owner' && a.$$typeof) {\n        // React-specific: avoid traversing React elements' _owner.\n        //  _owner contains circular references\n        // and is not needed when comparing the actual elements (and not their owners)\n        continue;\n      }\n      if (!equal(a[key], b[key])) return false;\n    }\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a !== a && b !== b;\n};\nvar deepEqual = /*@__PURE__*/getDefaultExportFromCjs(react);\nvar withSelector = {\n  exports: {}\n};\nvar withSelector_production_min = {};\n\n/**\n * @license React\n * use-sync-external-store-shim/with-selector.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar hasRequiredWithSelector_production_min;\nfunction requireWithSelector_production_min() {\n  if (hasRequiredWithSelector_production_min) return withSelector_production_min;\n  hasRequiredWithSelector_production_min = 1;\n  var h = React,\n    n = shimExports;\n  function p(a, b) {\n    return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;\n  }\n  var q = \"function\" === typeof Object.is ? Object.is : p,\n    r = n.useSyncExternalStore,\n    t = h.useRef,\n    u = h.useEffect,\n    v = h.useMemo,\n    w = h.useDebugValue;\n  withSelector_production_min.useSyncExternalStoreWithSelector = function (a, b, e, l, g) {\n    var c = t(null);\n    if (null === c.current) {\n      var f = {\n        hasValue: !1,\n        value: null\n      };\n      c.current = f;\n    } else f = c.current;\n    c = v(function () {\n      function a(a) {\n        if (!c) {\n          c = !0;\n          d = a;\n          a = l(a);\n          if (void 0 !== g && f.hasValue) {\n            var b = f.value;\n            if (g(b, a)) return k = b;\n          }\n          return k = a;\n        }\n        b = k;\n        if (q(d, a)) return b;\n        var e = l(a);\n        if (void 0 !== g && g(b, e)) return b;\n        d = a;\n        return k = e;\n      }\n      var c = !1,\n        d,\n        k,\n        m = void 0 === e ? null : e;\n      return [function () {\n        return a(b());\n      }, null === m ? void 0 : function () {\n        return a(m());\n      }];\n    }, [b, e, l, g]);\n    var d = r(a, c[0], c[1]);\n    u(function () {\n      f.hasValue = !0;\n      f.value = d;\n    }, [d]);\n    w(d);\n    return d;\n  };\n  return withSelector_production_min;\n}\nvar withSelector_development = {};\n\n/**\n * @license React\n * use-sync-external-store-shim/with-selector.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar hasRequiredWithSelector_development;\nfunction requireWithSelector_development() {\n  if (hasRequiredWithSelector_development) return withSelector_development;\n  hasRequiredWithSelector_development = 1;\n  if (process.env.NODE_ENV !== \"production\") {\n    (function () {\n      /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === 'function') {\n        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n      }\n      var React$1 = React;\n      var shim = shimExports;\n\n      /**\n       * inlined Object.is polyfill to avoid requiring consumers ship their own\n       * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n       */\n      function is(x, y) {\n        return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n        ;\n      }\n      var objectIs = typeof Object.is === 'function' ? Object.is : is;\n      var useSyncExternalStore = shim.useSyncExternalStore;\n\n      // for CommonJS interop.\n\n      var useRef = React$1.useRef,\n        useEffect = React$1.useEffect,\n        useMemo = React$1.useMemo,\n        useDebugValue = React$1.useDebugValue; // Same as useSyncExternalStore, but supports selector and isEqual arguments.\n\n      function useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {\n        // Use this to track the rendered snapshot.\n        var instRef = useRef(null);\n        var inst;\n        if (instRef.current === null) {\n          inst = {\n            hasValue: false,\n            value: null\n          };\n          instRef.current = inst;\n        } else {\n          inst = instRef.current;\n        }\n        var _useMemo = useMemo(function () {\n            // Track the memoized state using closure variables that are local to this\n            // memoized instance of a getSnapshot function. Intentionally not using a\n            // useRef hook, because that state would be shared across all concurrent\n            // copies of the hook/component.\n            var hasMemo = false;\n            var memoizedSnapshot;\n            var memoizedSelection;\n            var memoizedSelector = function (nextSnapshot) {\n              if (!hasMemo) {\n                // The first time the hook is called, there is no memoized result.\n                hasMemo = true;\n                memoizedSnapshot = nextSnapshot;\n                var _nextSelection = selector(nextSnapshot);\n                if (isEqual !== undefined) {\n                  // Even if the selector has changed, the currently rendered selection\n                  // may be equal to the new selection. We should attempt to reuse the\n                  // current value if possible, to preserve downstream memoizations.\n                  if (inst.hasValue) {\n                    var currentSelection = inst.value;\n                    if (isEqual(currentSelection, _nextSelection)) {\n                      memoizedSelection = currentSelection;\n                      return currentSelection;\n                    }\n                  }\n                }\n                memoizedSelection = _nextSelection;\n                return _nextSelection;\n              } // We may be able to reuse the previous invocation's result.\n\n              // We may be able to reuse the previous invocation's result.\n              var prevSnapshot = memoizedSnapshot;\n              var prevSelection = memoizedSelection;\n              if (objectIs(prevSnapshot, nextSnapshot)) {\n                // The snapshot is the same as last time. Reuse the previous selection.\n                return prevSelection;\n              } // The snapshot has changed, so we need to compute a new selection.\n\n              // The snapshot has changed, so we need to compute a new selection.\n              var nextSelection = selector(nextSnapshot); // If a custom isEqual function is provided, use that to check if the data\n              // has changed. If it hasn't, return the previous selection. That signals\n              // to React that the selections are conceptually equal, and we can bail\n              // out of rendering.\n\n              // If a custom isEqual function is provided, use that to check if the data\n              // has changed. If it hasn't, return the previous selection. That signals\n              // to React that the selections are conceptually equal, and we can bail\n              // out of rendering.\n              if (isEqual !== undefined && isEqual(prevSelection, nextSelection)) {\n                return prevSelection;\n              }\n              memoizedSnapshot = nextSnapshot;\n              memoizedSelection = nextSelection;\n              return nextSelection;\n            }; // Assigning this to a constant so that Flow knows it can't change.\n\n            // Assigning this to a constant so that Flow knows it can't change.\n            var maybeGetServerSnapshot = getServerSnapshot === undefined ? null : getServerSnapshot;\n            var getSnapshotWithSelector = function () {\n              return memoizedSelector(getSnapshot());\n            };\n            var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? undefined : function () {\n              return memoizedSelector(maybeGetServerSnapshot());\n            };\n            return [getSnapshotWithSelector, getServerSnapshotWithSelector];\n          }, [getSnapshot, getServerSnapshot, selector, isEqual]),\n          getSelection = _useMemo[0],\n          getServerSelection = _useMemo[1];\n        var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);\n        useEffect(function () {\n          inst.hasValue = true;\n          inst.value = value;\n        }, [value]);\n        useDebugValue(value);\n        return value;\n      }\n      withSelector_development.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector;\n      /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === 'function') {\n        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n      }\n    })();\n  }\n  return withSelector_development;\n}\nif (process.env.NODE_ENV === 'production') {\n  withSelector.exports = requireWithSelector_production_min();\n} else {\n  withSelector.exports = requireWithSelector_development();\n}\nvar withSelectorExports = withSelector.exports;\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect;\n/**\n * To synchronize the editor instance with the component state,\n * we need to create a separate instance that is not affected by the component re-renders.\n */\nclass EditorStateManager {\n  constructor(initialEditor) {\n    this.transactionNumber = 0;\n    this.lastTransactionNumber = 0;\n    this.subscribers = new Set();\n    this.editor = initialEditor;\n    this.lastSnapshot = {\n      editor: initialEditor,\n      transactionNumber: 0\n    };\n    this.getSnapshot = this.getSnapshot.bind(this);\n    this.getServerSnapshot = this.getServerSnapshot.bind(this);\n    this.watch = this.watch.bind(this);\n    this.subscribe = this.subscribe.bind(this);\n  }\n  /**\n   * Get the current editor instance.\n   */\n  getSnapshot() {\n    if (this.transactionNumber === this.lastTransactionNumber) {\n      return this.lastSnapshot;\n    }\n    this.lastTransactionNumber = this.transactionNumber;\n    this.lastSnapshot = {\n      editor: this.editor,\n      transactionNumber: this.transactionNumber\n    };\n    return this.lastSnapshot;\n  }\n  /**\n   * Always disable the editor on the server-side.\n   */\n  getServerSnapshot() {\n    return {\n      editor: null,\n      transactionNumber: 0\n    };\n  }\n  /**\n   * Subscribe to the editor instance's changes.\n   */\n  subscribe(callback) {\n    this.subscribers.add(callback);\n    return () => {\n      this.subscribers.delete(callback);\n    };\n  }\n  /**\n   * Watch the editor instance for changes.\n   */\n  watch(nextEditor) {\n    this.editor = nextEditor;\n    if (this.editor) {\n      /**\n       * This will force a re-render when the editor state changes.\n       * This is to support things like `editor.can().toggleBold()` in components that `useEditor`.\n       * This could be more efficient, but it's a good trade-off for now.\n       */\n      const fn = () => {\n        this.transactionNumber += 1;\n        this.subscribers.forEach(callback => callback());\n      };\n      const currentEditor = this.editor;\n      currentEditor.on('transaction', fn);\n      return () => {\n        currentEditor.off('transaction', fn);\n      };\n    }\n    return undefined;\n  }\n}\n/**\n * This hook allows you to watch for changes on the editor instance.\n * It will allow you to select a part of the editor state and re-render the component when it changes.\n * @example\n * ```tsx\n * const editor = useEditor({...options})\n * const { currentSelection } = useEditorState({\n *  editor,\n *  selector: snapshot => ({ currentSelection: snapshot.editor.state.selection }),\n * })\n */\nfunction useEditorState(options) {\n  var _a;\n  const [editorStateManager] = useState(() => new EditorStateManager(options.editor));\n  // Using the `useSyncExternalStore` hook to sync the editor instance with the component state\n  const selectedState = withSelectorExports.useSyncExternalStoreWithSelector(editorStateManager.subscribe, editorStateManager.getSnapshot, editorStateManager.getServerSnapshot, options.selector, (_a = options.equalityFn) !== null && _a !== void 0 ? _a : deepEqual);\n  useIsomorphicLayoutEffect(() => {\n    return editorStateManager.watch(options.editor);\n  }, [options.editor, editorStateManager]);\n  useDebugValue(selectedState);\n  return selectedState;\n}\nconst isDev = process.env.NODE_ENV !== 'production';\nconst isSSR = typeof window === 'undefined';\nconst isNext = isSSR || Boolean(typeof window !== 'undefined' && window.next);\n/**\n * This class handles the creation, destruction, and re-creation of the editor instance.\n */\nclass EditorInstanceManager {\n  constructor(options) {\n    /**\n     * The current editor instance.\n     */\n    this.editor = null;\n    /**\n     * The subscriptions to notify when the editor instance\n     * has been created or destroyed.\n     */\n    this.subscriptions = new Set();\n    /**\n     * Whether the editor has been mounted.\n     */\n    this.isComponentMounted = false;\n    /**\n     * The most recent dependencies array.\n     */\n    this.previousDeps = null;\n    /**\n     * The unique instance ID. This is used to identify the editor instance. And will be re-generated for each new instance.\n     */\n    this.instanceId = '';\n    this.options = options;\n    this.subscriptions = new Set();\n    this.setEditor(this.getInitialEditor());\n    this.scheduleDestroy();\n    this.getEditor = this.getEditor.bind(this);\n    this.getServerSnapshot = this.getServerSnapshot.bind(this);\n    this.subscribe = this.subscribe.bind(this);\n    this.refreshEditorInstance = this.refreshEditorInstance.bind(this);\n    this.scheduleDestroy = this.scheduleDestroy.bind(this);\n    this.onRender = this.onRender.bind(this);\n    this.createEditor = this.createEditor.bind(this);\n  }\n  setEditor(editor) {\n    this.editor = editor;\n    this.instanceId = Math.random().toString(36).slice(2, 9);\n    // Notify all subscribers that the editor instance has been created\n    this.subscriptions.forEach(cb => cb());\n  }\n  getInitialEditor() {\n    if (this.options.current.immediatelyRender === undefined) {\n      if (isSSR || isNext) {\n        // TODO in the next major release, we should throw an error here\n        if (isDev) {\n          /**\n           * Throw an error in development, to make sure the developer is aware that tiptap cannot be SSR'd\n           * and that they need to set `immediatelyRender` to `false` to avoid hydration mismatches.\n           */\n          console.warn('Tiptap Error: SSR has been detected, please set `immediatelyRender` explicitly to `false` to avoid hydration mismatches.');\n        }\n        // Best faith effort in production, run the code in the legacy mode to avoid hydration mismatches and errors in production\n        return null;\n      }\n      // Default to immediately rendering when client-side rendering\n      return this.createEditor();\n    }\n    if (this.options.current.immediatelyRender && isSSR && isDev) {\n      // Warn in development, to make sure the developer is aware that tiptap cannot be SSR'd, set `immediatelyRender` to `false` to avoid hydration mismatches.\n      throw new Error('Tiptap Error: SSR has been detected, and `immediatelyRender` has been set to `true` this is an unsupported configuration that may result in errors, explicitly set `immediatelyRender` to `false` to avoid hydration mismatches.');\n    }\n    if (this.options.current.immediatelyRender) {\n      return this.createEditor();\n    }\n    return null;\n  }\n  /**\n   * Create a new editor instance. And attach event listeners.\n   */\n  createEditor() {\n    const optionsToApply = {\n      ...this.options.current,\n      // Always call the most recent version of the callback function by default\n      onBeforeCreate: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onBeforeCreate) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);\n      },\n      onBlur: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onBlur) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);\n      },\n      onCreate: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onCreate) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);\n      },\n      onDestroy: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onDestroy) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);\n      },\n      onFocus: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onFocus) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);\n      },\n      onSelectionUpdate: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onSelectionUpdate) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);\n      },\n      onTransaction: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onTransaction) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);\n      },\n      onUpdate: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onUpdate) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);\n      },\n      onContentError: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onContentError) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);\n      },\n      onDrop: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onDrop) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);\n      },\n      onPaste: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onPaste) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);\n      }\n    };\n    const editor = new Editor(optionsToApply);\n    // no need to keep track of the event listeners, they will be removed when the editor is destroyed\n    return editor;\n  }\n  /**\n   * Get the current editor instance.\n   */\n  getEditor() {\n    return this.editor;\n  }\n  /**\n   * Always disable the editor on the server-side.\n   */\n  getServerSnapshot() {\n    return null;\n  }\n  /**\n   * Subscribe to the editor instance's changes.\n   */\n  subscribe(onStoreChange) {\n    this.subscriptions.add(onStoreChange);\n    return () => {\n      this.subscriptions.delete(onStoreChange);\n    };\n  }\n  static compareOptions(a, b) {\n    return Object.keys(a).every(key => {\n      if (['onCreate', 'onBeforeCreate', 'onDestroy', 'onUpdate', 'onTransaction', 'onFocus', 'onBlur', 'onSelectionUpdate', 'onContentError', 'onDrop', 'onPaste'].includes(key)) {\n        // we don't want to compare callbacks, they are always different and only registered once\n        return true;\n      }\n      // We often encourage putting extensions inlined in the options object, so we will do a slightly deeper comparison here\n      if (key === 'extensions' && a.extensions && b.extensions) {\n        if (a.extensions.length !== b.extensions.length) {\n          return false;\n        }\n        return a.extensions.every((extension, index) => {\n          var _a;\n          if (extension !== ((_a = b.extensions) === null || _a === void 0 ? void 0 : _a[index])) {\n            return false;\n          }\n          return true;\n        });\n      }\n      if (a[key] !== b[key]) {\n        // if any of the options have changed, we should update the editor options\n        return false;\n      }\n      return true;\n    });\n  }\n  /**\n   * On each render, we will create, update, or destroy the editor instance.\n   * @param deps The dependencies to watch for changes\n   * @returns A cleanup function\n   */\n  onRender(deps) {\n    // The returned callback will run on each render\n    return () => {\n      this.isComponentMounted = true;\n      // Cleanup any scheduled destructions, since we are currently rendering\n      clearTimeout(this.scheduledDestructionTimeout);\n      if (this.editor && !this.editor.isDestroyed && deps.length === 0) {\n        // if the editor does exist & deps are empty, we don't need to re-initialize the editor generally\n        if (!EditorInstanceManager.compareOptions(this.options.current, this.editor.options)) {\n          // But, the options are different, so we need to update the editor options\n          // Still, this is faster than re-creating the editor\n          this.editor.setOptions({\n            ...this.options.current,\n            editable: this.editor.isEditable\n          });\n        }\n      } else {\n        // When the editor:\n        // - does not yet exist\n        // - is destroyed\n        // - the deps array changes\n        // We need to destroy the editor instance and re-initialize it\n        this.refreshEditorInstance(deps);\n      }\n      return () => {\n        this.isComponentMounted = false;\n        this.scheduleDestroy();\n      };\n    };\n  }\n  /**\n   * Recreate the editor instance if the dependencies have changed.\n   */\n  refreshEditorInstance(deps) {\n    if (this.editor && !this.editor.isDestroyed) {\n      // Editor instance already exists\n      if (this.previousDeps === null) {\n        // If lastDeps has not yet been initialized, reuse the current editor instance\n        this.previousDeps = deps;\n        return;\n      }\n      const depsAreEqual = this.previousDeps.length === deps.length && this.previousDeps.every((dep, index) => dep === deps[index]);\n      if (depsAreEqual) {\n        // deps exist and are equal, no need to recreate\n        return;\n      }\n    }\n    if (this.editor && !this.editor.isDestroyed) {\n      // Destroy the editor instance if it exists\n      this.editor.destroy();\n    }\n    this.setEditor(this.createEditor());\n    // Update the lastDeps to the current deps\n    this.previousDeps = deps;\n  }\n  /**\n   * Schedule the destruction of the editor instance.\n   * This will only destroy the editor if it was not mounted on the next tick.\n   * This is to avoid destroying the editor instance when it's actually still mounted.\n   */\n  scheduleDestroy() {\n    const currentInstanceId = this.instanceId;\n    const currentEditor = this.editor;\n    // Wait two ticks to see if the component is still mounted\n    this.scheduledDestructionTimeout = setTimeout(() => {\n      if (this.isComponentMounted && this.instanceId === currentInstanceId) {\n        // If still mounted on the following tick, with the same instanceId, do not destroy the editor\n        if (currentEditor) {\n          // just re-apply options as they might have changed\n          currentEditor.setOptions(this.options.current);\n        }\n        return;\n      }\n      if (currentEditor && !currentEditor.isDestroyed) {\n        currentEditor.destroy();\n        if (this.instanceId === currentInstanceId) {\n          this.setEditor(null);\n        }\n      }\n      // This allows the effect to run again between ticks\n      // which may save us from having to re-create the editor\n    }, 1);\n  }\n}\nfunction useEditor(options = {}, deps = []) {\n  const mostRecentOptions = useRef(options);\n  mostRecentOptions.current = options;\n  const [instanceManager] = useState(() => new EditorInstanceManager(mostRecentOptions));\n  const editor = shimExports.useSyncExternalStore(instanceManager.subscribe, instanceManager.getEditor, instanceManager.getServerSnapshot);\n  useDebugValue(editor);\n  // This effect will handle creating/updating the editor instance\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useEffect(instanceManager.onRender(deps));\n  // The default behavior is to re-render on each transaction\n  // This is legacy behavior that will be removed in future versions\n  useEditorState({\n    editor,\n    selector: ({\n      transactionNumber\n    }) => {\n      if (options.shouldRerenderOnTransaction === false) {\n        // This will prevent the editor from re-rendering on each transaction\n        return null;\n      }\n      // This will avoid re-rendering on the first transaction when `immediatelyRender` is set to `true`\n      if (options.immediatelyRender && transactionNumber === 0) {\n        return 0;\n      }\n      return transactionNumber + 1;\n    }\n  });\n  return editor;\n}\nconst EditorContext = createContext({\n  editor: null\n});\nconst EditorConsumer = EditorContext.Consumer;\n/**\n * A hook to get the current editor instance.\n */\nconst useCurrentEditor = () => useContext(EditorContext);\n/**\n * This is the provider component for the editor.\n * It allows the editor to be accessible across the entire component tree\n * with `useCurrentEditor`.\n */\nfunction EditorProvider({\n  children,\n  slotAfter,\n  slotBefore,\n  editorContainerProps = {},\n  ...editorOptions\n}) {\n  const editor = useEditor(editorOptions);\n  if (!editor) {\n    return null;\n  }\n  return React.createElement(EditorContext.Provider, {\n    value: {\n      editor\n    }\n  }, slotBefore, React.createElement(EditorConsumer, null, ({\n    editor: currentEditor\n  }) => React.createElement(EditorContent, {\n    editor: currentEditor,\n    ...editorContainerProps\n  })), children, slotAfter);\n}\nconst BubbleMenu = props => {\n  const [element, setElement] = useState(null);\n  const {\n    editor: currentEditor\n  } = useCurrentEditor();\n  useEffect(() => {\n    var _a;\n    if (!element) {\n      return;\n    }\n    if (((_a = props.editor) === null || _a === void 0 ? void 0 : _a.isDestroyed) || (currentEditor === null || currentEditor === void 0 ? void 0 : currentEditor.isDestroyed)) {\n      return;\n    }\n    const {\n      pluginKey = 'bubbleMenu',\n      editor,\n      tippyOptions = {},\n      updateDelay,\n      shouldShow = null\n    } = props;\n    const menuEditor = editor || currentEditor;\n    if (!menuEditor) {\n      console.warn('BubbleMenu component is not rendered inside of an editor component or does not have editor prop.');\n      return;\n    }\n    const plugin = BubbleMenuPlugin({\n      updateDelay,\n      editor: menuEditor,\n      element,\n      pluginKey,\n      shouldShow,\n      tippyOptions\n    });\n    menuEditor.registerPlugin(plugin);\n    return () => {\n      menuEditor.unregisterPlugin(pluginKey);\n    };\n  }, [props.editor, currentEditor, element]);\n  return React.createElement(\"div\", {\n    ref: setElement,\n    className: props.className,\n    style: {\n      visibility: 'hidden'\n    }\n  }, props.children);\n};\nconst FloatingMenu = props => {\n  const [element, setElement] = useState(null);\n  const {\n    editor: currentEditor\n  } = useCurrentEditor();\n  useEffect(() => {\n    var _a;\n    if (!element) {\n      return;\n    }\n    if (((_a = props.editor) === null || _a === void 0 ? void 0 : _a.isDestroyed) || (currentEditor === null || currentEditor === void 0 ? void 0 : currentEditor.isDestroyed)) {\n      return;\n    }\n    const {\n      pluginKey = 'floatingMenu',\n      editor,\n      tippyOptions = {},\n      shouldShow = null\n    } = props;\n    const menuEditor = editor || currentEditor;\n    if (!menuEditor) {\n      console.warn('FloatingMenu component is not rendered inside of an editor component or does not have editor prop.');\n      return;\n    }\n    const plugin = FloatingMenuPlugin({\n      pluginKey,\n      editor: menuEditor,\n      element,\n      tippyOptions,\n      shouldShow\n    });\n    menuEditor.registerPlugin(plugin);\n    return () => {\n      menuEditor.unregisterPlugin(pluginKey);\n    };\n  }, [props.editor, currentEditor, element]);\n  return React.createElement(\"div\", {\n    ref: setElement,\n    className: props.className,\n    style: {\n      visibility: 'hidden'\n    }\n  }, props.children);\n};\nconst ReactNodeViewContext = createContext({\n  onDragStart: undefined\n});\nconst useReactNodeView = () => useContext(ReactNodeViewContext);\nconst NodeViewContent = props => {\n  const Tag = props.as || 'div';\n  const {\n    nodeViewContentRef\n  } = useReactNodeView();\n  return (\n    // @ts-ignore\n    React.createElement(Tag, {\n      ...props,\n      ref: nodeViewContentRef,\n      \"data-node-view-content\": \"\",\n      style: {\n        whiteSpace: 'pre-wrap',\n        ...props.style\n      }\n    })\n  );\n};\nconst NodeViewWrapper = React.forwardRef((props, ref) => {\n  const {\n    onDragStart\n  } = useReactNodeView();\n  const Tag = props.as || 'div';\n  return (\n    // @ts-ignore\n    React.createElement(Tag, {\n      ...props,\n      ref: ref,\n      \"data-node-view-wrapper\": \"\",\n      onDragStart: onDragStart,\n      style: {\n        whiteSpace: 'normal',\n        ...props.style\n      }\n    })\n  );\n});\n\n/**\n * Check if a component is a class component.\n * @param Component\n * @returns {boolean}\n */\nfunction isClassComponent(Component) {\n  return !!(typeof Component === 'function' && Component.prototype && Component.prototype.isReactComponent);\n}\n/**\n * Check if a component is a forward ref component.\n * @param Component\n * @returns {boolean}\n */\nfunction isForwardRefComponent(Component) {\n  return !!(typeof Component === 'object' && Component.$$typeof && (Component.$$typeof.toString() === 'Symbol(react.forward_ref)' || Component.$$typeof.description === 'react.forward_ref'));\n}\n/**\n * Check if a component is a memoized component.\n * @param Component\n * @returns {boolean}\n */\nfunction isMemoComponent(Component) {\n  return !!(typeof Component === 'object' && Component.$$typeof && (Component.$$typeof.toString() === 'Symbol(react.memo)' || Component.$$typeof.description === 'react.memo'));\n}\n/**\n * Check if a component can safely receive a ref prop.\n * This includes class components, forwardRef components, and memoized components\n * that wrap forwardRef or class components.\n * @param Component\n * @returns {boolean}\n */\nfunction canReceiveRef(Component) {\n  // Check if it's a class component\n  if (isClassComponent(Component)) {\n    return true;\n  }\n  // Check if it's a forwardRef component\n  if (isForwardRefComponent(Component)) {\n    return true;\n  }\n  // Check if it's a memoized component\n  if (isMemoComponent(Component)) {\n    // For memoized components, check the wrapped component\n    const wrappedComponent = Component.type;\n    if (wrappedComponent) {\n      return isClassComponent(wrappedComponent) || isForwardRefComponent(wrappedComponent);\n    }\n  }\n  return false;\n}\n/**\n * Check if we're running React 19+ by detecting if function components support ref props\n * @returns {boolean}\n */\nfunction isReact19Plus() {\n  // React 19 is detected by checking React version if available\n  // In practice, we'll use a more conservative approach and assume React 18 behavior\n  // unless we can definitively detect React 19\n  try {\n    // @ts-ignore\n    if (version) {\n      const majorVersion = parseInt(version.split('.')[0], 10);\n      return majorVersion >= 19;\n    }\n  } catch {\n    // Fallback to React 18 behavior if we can't determine version\n  }\n  return false;\n}\n/**\n * The ReactRenderer class. It's responsible for rendering React components inside the editor.\n * @example\n * new ReactRenderer(MyComponent, {\n *   editor,\n *   props: {\n *     foo: 'bar',\n *   },\n *   as: 'span',\n * })\n*/\nclass ReactRenderer {\n  /**\n   * Immediately creates element and renders the provided React component.\n   */\n  constructor(component, {\n    editor,\n    props = {},\n    as = 'div',\n    className = ''\n  }) {\n    this.ref = null;\n    this.id = Math.floor(Math.random() * 0xFFFFFFFF).toString();\n    this.component = component;\n    this.editor = editor;\n    this.props = props;\n    this.element = document.createElement(as);\n    this.element.classList.add('react-renderer');\n    if (className) {\n      this.element.classList.add(...className.split(' '));\n    }\n    // If the editor is already initialized, we will need to\n    // synchronously render the component to ensure it renders\n    // together with Prosemirror's rendering.\n    if (this.editor.isInitialized) {\n      flushSync(() => {\n        this.render();\n      });\n    } else {\n      queueMicrotask(() => {\n        this.render();\n      });\n    }\n  }\n  /**\n   * Render the React component.\n   */\n  render() {\n    var _a;\n    const Component = this.component;\n    const props = this.props;\n    const editor = this.editor;\n    // Handle ref forwarding with React 18/19 compatibility\n    const isReact19 = isReact19Plus();\n    const componentCanReceiveRef = canReceiveRef(Component);\n    const elementProps = {\n      ...props\n    };\n    // Always remove ref if the component cannot receive it (unless React 19+)\n    if (elementProps.ref && !(isReact19 || componentCanReceiveRef)) {\n      delete elementProps.ref;\n    }\n    // Only assign our own ref if allowed\n    if (!elementProps.ref && (isReact19 || componentCanReceiveRef)) {\n      // @ts-ignore - Setting ref prop for compatible components\n      elementProps.ref = ref => {\n        this.ref = ref;\n      };\n    }\n    this.reactElement = React.createElement(Component, {\n      ...elementProps\n    });\n    (_a = editor === null || editor === void 0 ? void 0 : editor.contentComponent) === null || _a === void 0 ? void 0 : _a.setRenderer(this.id, this);\n  }\n  /**\n   * Re-renders the React component with new props.\n   */\n  updateProps(props = {}) {\n    this.props = {\n      ...this.props,\n      ...props\n    };\n    this.render();\n  }\n  /**\n   * Destroy the React component.\n   */\n  destroy() {\n    var _a;\n    const editor = this.editor;\n    (_a = editor === null || editor === void 0 ? void 0 : editor.contentComponent) === null || _a === void 0 ? void 0 : _a.removeRenderer(this.id);\n  }\n  /**\n   * Update the attributes of the element that holds the React component.\n   */\n  updateAttributes(attributes) {\n    Object.keys(attributes).forEach(key => {\n      this.element.setAttribute(key, attributes[key]);\n    });\n  }\n}\nclass ReactNodeView extends NodeView {\n  constructor(component, props, options) {\n    super(component, props, options);\n    if (!this.node.isLeaf) {\n      if (this.options.contentDOMElementTag) {\n        this.contentDOMElement = document.createElement(this.options.contentDOMElementTag);\n      } else {\n        this.contentDOMElement = document.createElement(this.node.isInline ? 'span' : 'div');\n      }\n      this.contentDOMElement.dataset.nodeViewContentReact = '';\n      this.contentDOMElement.dataset.nodeViewWrapper = '';\n      // For some reason the whiteSpace prop is not inherited properly in Chrome and Safari\n      // With this fix it seems to work fine\n      // See: https://github.com/ueberdosis/tiptap/issues/1197\n      this.contentDOMElement.style.whiteSpace = 'inherit';\n      const contentTarget = this.dom.querySelector('[data-node-view-content]');\n      if (!contentTarget) {\n        return;\n      }\n      contentTarget.appendChild(this.contentDOMElement);\n    }\n  }\n  /**\n   * Setup the React component.\n   * Called on initialization.\n   */\n  mount() {\n    const props = {\n      editor: this.editor,\n      node: this.node,\n      decorations: this.decorations,\n      innerDecorations: this.innerDecorations,\n      view: this.view,\n      selected: false,\n      extension: this.extension,\n      HTMLAttributes: this.HTMLAttributes,\n      getPos: () => this.getPos(),\n      updateAttributes: (attributes = {}) => this.updateAttributes(attributes),\n      deleteNode: () => this.deleteNode(),\n      ref: createRef()\n    };\n    if (!this.component.displayName) {\n      const capitalizeFirstChar = string => {\n        return string.charAt(0).toUpperCase() + string.substring(1);\n      };\n      this.component.displayName = capitalizeFirstChar(this.extension.name);\n    }\n    const onDragStart = this.onDragStart.bind(this);\n    const nodeViewContentRef = element => {\n      if (element && this.contentDOMElement && element.firstChild !== this.contentDOMElement) {\n        // remove the nodeViewWrapper attribute from the element\n        if (element.hasAttribute('data-node-view-wrapper')) {\n          element.removeAttribute('data-node-view-wrapper');\n        }\n        element.appendChild(this.contentDOMElement);\n      }\n    };\n    const context = {\n      onDragStart,\n      nodeViewContentRef\n    };\n    const Component = this.component;\n    // For performance reasons, we memoize the provider component\n    // And all of the things it requires are declared outside of the component, so it doesn't need to re-render\n    const ReactNodeViewProvider = memo(componentProps => {\n      return React.createElement(ReactNodeViewContext.Provider, {\n        value: context\n      }, createElement(Component, componentProps));\n    });\n    ReactNodeViewProvider.displayName = 'ReactNodeView';\n    let as = this.node.isInline ? 'span' : 'div';\n    if (this.options.as) {\n      as = this.options.as;\n    }\n    const {\n      className = ''\n    } = this.options;\n    this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this);\n    this.renderer = new ReactRenderer(ReactNodeViewProvider, {\n      editor: this.editor,\n      props,\n      as,\n      className: `node-${this.node.type.name} ${className}`.trim()\n    });\n    this.editor.on('selectionUpdate', this.handleSelectionUpdate);\n    this.updateElementAttributes();\n  }\n  /**\n   * Return the DOM element.\n   * This is the element that will be used to display the node view.\n   */\n  get dom() {\n    var _a;\n    if (this.renderer.element.firstElementChild && !((_a = this.renderer.element.firstElementChild) === null || _a === void 0 ? void 0 : _a.hasAttribute('data-node-view-wrapper'))) {\n      throw Error('Please use the NodeViewWrapper component for your node view.');\n    }\n    return this.renderer.element;\n  }\n  /**\n   * Return the content DOM element.\n   * This is the element that will be used to display the rich-text content of the node.\n   */\n  get contentDOM() {\n    if (this.node.isLeaf) {\n      return null;\n    }\n    return this.contentDOMElement;\n  }\n  /**\n   * On editor selection update, check if the node is selected.\n   * If it is, call `selectNode`, otherwise call `deselectNode`.\n   */\n  handleSelectionUpdate() {\n    const {\n      from,\n      to\n    } = this.editor.state.selection;\n    const pos = this.getPos();\n    if (typeof pos !== 'number') {\n      return;\n    }\n    if (from <= pos && to >= pos + this.node.nodeSize) {\n      if (this.renderer.props.selected) {\n        return;\n      }\n      this.selectNode();\n    } else {\n      if (!this.renderer.props.selected) {\n        return;\n      }\n      this.deselectNode();\n    }\n  }\n  /**\n   * On update, update the React component.\n   * To prevent unnecessary updates, the `update` option can be used.\n   */\n  update(node, decorations, innerDecorations) {\n    const rerenderComponent = props => {\n      this.renderer.updateProps(props);\n      if (typeof this.options.attrs === 'function') {\n        this.updateElementAttributes();\n      }\n    };\n    if (node.type !== this.node.type) {\n      return false;\n    }\n    if (typeof this.options.update === 'function') {\n      const oldNode = this.node;\n      const oldDecorations = this.decorations;\n      const oldInnerDecorations = this.innerDecorations;\n      this.node = node;\n      this.decorations = decorations;\n      this.innerDecorations = innerDecorations;\n      return this.options.update({\n        oldNode,\n        oldDecorations,\n        newNode: node,\n        newDecorations: decorations,\n        oldInnerDecorations,\n        innerDecorations,\n        updateProps: () => rerenderComponent({\n          node,\n          decorations,\n          innerDecorations\n        })\n      });\n    }\n    if (node === this.node && this.decorations === decorations && this.innerDecorations === innerDecorations) {\n      return true;\n    }\n    this.node = node;\n    this.decorations = decorations;\n    this.innerDecorations = innerDecorations;\n    rerenderComponent({\n      node,\n      decorations,\n      innerDecorations\n    });\n    return true;\n  }\n  /**\n   * Select the node.\n   * Add the `selected` prop and the `ProseMirror-selectednode` class.\n   */\n  selectNode() {\n    this.renderer.updateProps({\n      selected: true\n    });\n    this.renderer.element.classList.add('ProseMirror-selectednode');\n  }\n  /**\n   * Deselect the node.\n   * Remove the `selected` prop and the `ProseMirror-selectednode` class.\n   */\n  deselectNode() {\n    this.renderer.updateProps({\n      selected: false\n    });\n    this.renderer.element.classList.remove('ProseMirror-selectednode');\n  }\n  /**\n   * Destroy the React component instance.\n   */\n  destroy() {\n    this.renderer.destroy();\n    this.editor.off('selectionUpdate', this.handleSelectionUpdate);\n    this.contentDOMElement = null;\n  }\n  /**\n   * Update the attributes of the top-level element that holds the React component.\n   * Applying the attributes defined in the `attrs` option.\n   */\n  updateElementAttributes() {\n    if (this.options.attrs) {\n      let attrsObj = {};\n      if (typeof this.options.attrs === 'function') {\n        const extensionAttributes = this.editor.extensionManager.attributes;\n        const HTMLAttributes = getRenderedAttributes(this.node, extensionAttributes);\n        attrsObj = this.options.attrs({\n          node: this.node,\n          HTMLAttributes\n        });\n      } else {\n        attrsObj = this.options.attrs;\n      }\n      this.renderer.updateAttributes(attrsObj);\n    }\n  }\n}\n/**\n * Create a React node view renderer.\n */\nfunction ReactNodeViewRenderer(component, options) {\n  return props => {\n    // try to get the parent component\n    // this is important for vue devtools to show the component hierarchy correctly\n    // maybe its `undefined` because <editor-content> isnt rendered yet\n    if (!props.editor.contentComponent) {\n      return {};\n    }\n    return new ReactNodeView(component, props, options);\n  };\n}\nexport { BubbleMenu, EditorConsumer, EditorContent, EditorContext, EditorProvider, FloatingMenu, NodeViewContent, NodeViewWrapper, PureEditorContent, ReactNodeView, ReactNodeViewContext, ReactNodeViewRenderer, ReactRenderer, useCurrentEditor, useEditor, useEditorState, useReactNodeView };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}