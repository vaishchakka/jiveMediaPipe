{"ast":null,"code":"import { Node, mergeAttributes, canInsertNode, isNodeSelection, nodeInputRule } from '@tiptap/core';\nimport { TextSelection, NodeSelection } from '@tiptap/pm/state';\n\n/**\n * This extension allows you to insert horizontal rules.\n * @see https://www.tiptap.dev/api/nodes/horizontal-rule\n */\nconst HorizontalRule = Node.create({\n  name: 'horizontalRule',\n  addOptions() {\n    return {\n      HTMLAttributes: {}\n    };\n  },\n  group: 'block',\n  parseHTML() {\n    return [{\n      tag: 'hr'\n    }];\n  },\n  renderHTML({\n    HTMLAttributes\n  }) {\n    return ['hr', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];\n  },\n  addCommands() {\n    return {\n      setHorizontalRule: () => ({\n        chain,\n        state\n      }) => {\n        // Check if we can insert the node at the current selection\n        if (!canInsertNode(state, state.schema.nodes[this.name])) {\n          return false;\n        }\n        const {\n          selection\n        } = state;\n        const {\n          $from: $originFrom,\n          $to: $originTo\n        } = selection;\n        const currentChain = chain();\n        if ($originFrom.parentOffset === 0) {\n          currentChain.insertContentAt({\n            from: Math.max($originFrom.pos - 1, 0),\n            to: $originTo.pos\n          }, {\n            type: this.name\n          });\n        } else if (isNodeSelection(selection)) {\n          currentChain.insertContentAt($originTo.pos, {\n            type: this.name\n          });\n        } else {\n          currentChain.insertContent({\n            type: this.name\n          });\n        }\n        return currentChain\n        // set cursor after horizontal rule\n        .command(({\n          tr,\n          dispatch\n        }) => {\n          var _a;\n          if (dispatch) {\n            const {\n              $to\n            } = tr.selection;\n            const posAfter = $to.end();\n            if ($to.nodeAfter) {\n              if ($to.nodeAfter.isTextblock) {\n                tr.setSelection(TextSelection.create(tr.doc, $to.pos + 1));\n              } else if ($to.nodeAfter.isBlock) {\n                tr.setSelection(NodeSelection.create(tr.doc, $to.pos));\n              } else {\n                tr.setSelection(TextSelection.create(tr.doc, $to.pos));\n              }\n            } else {\n              // add node after horizontal rule if it’s the end of the document\n              const node = (_a = $to.parent.type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.create();\n              if (node) {\n                tr.insert(posAfter, node);\n                tr.setSelection(TextSelection.create(tr.doc, posAfter + 1));\n              }\n            }\n            tr.scrollIntoView();\n          }\n          return true;\n        }).run();\n      }\n    };\n  },\n  addInputRules() {\n    return [nodeInputRule({\n      find: /^(?:---|—-|___\\s|\\*\\*\\*\\s)$/,\n      type: this.type\n    })];\n  }\n});\nexport { HorizontalRule, HorizontalRule as default };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}