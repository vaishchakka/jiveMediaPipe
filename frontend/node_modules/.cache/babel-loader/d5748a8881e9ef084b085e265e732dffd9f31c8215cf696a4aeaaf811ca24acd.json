{"ast":null,"code":"export var util;\n(function (util) {\n  util.assertEqual = _ => {};\n  function assertIs(_arg) {}\n  util.assertIs = assertIs;\n  function assertNever(_x) {\n    throw new Error();\n  }\n  util.assertNever = assertNever;\n  util.arrayToEnum = items => {\n    const obj = {};\n    for (const item of items) {\n      obj[item] = item;\n    }\n    return obj;\n  };\n  util.getValidEnumValues = obj => {\n    const validKeys = util.objectKeys(obj).filter(k => typeof obj[obj[k]] !== \"number\");\n    const filtered = {};\n    for (const k of validKeys) {\n      filtered[k] = obj[k];\n    }\n    return util.objectValues(filtered);\n  };\n  util.objectValues = obj => {\n    return util.objectKeys(obj).map(function (e) {\n      return obj[e];\n    });\n  };\n  util.objectKeys = typeof Object.keys === \"function\" // eslint-disable-line ban/ban\n  ? obj => Object.keys(obj) // eslint-disable-line ban/ban\n  : object => {\n    const keys = [];\n    for (const key in object) {\n      if (Object.prototype.hasOwnProperty.call(object, key)) {\n        keys.push(key);\n      }\n    }\n    return keys;\n  };\n  util.find = (arr, checker) => {\n    for (const item of arr) {\n      if (checker(item)) return item;\n    }\n    return undefined;\n  };\n  util.isInteger = typeof Number.isInteger === \"function\" ? val => Number.isInteger(val) // eslint-disable-line ban/ban\n  : val => typeof val === \"number\" && Number.isFinite(val) && Math.floor(val) === val;\n  function joinValues(array, separator = \" | \") {\n    return array.map(val => typeof val === \"string\" ? `'${val}'` : val).join(separator);\n  }\n  util.joinValues = joinValues;\n  util.jsonStringifyReplacer = (_, value) => {\n    if (typeof value === \"bigint\") {\n      return value.toString();\n    }\n    return value;\n  };\n})(util || (util = {}));\nexport var objectUtil;\n(function (objectUtil) {\n  objectUtil.mergeShapes = (first, second) => {\n    return {\n      ...first,\n      ...second // second overwrites first\n    };\n  };\n})(objectUtil || (objectUtil = {}));\nexport const ZodParsedType = util.arrayToEnum([\"string\", \"nan\", \"number\", \"integer\", \"float\", \"boolean\", \"date\", \"bigint\", \"symbol\", \"function\", \"undefined\", \"null\", \"array\", \"object\", \"unknown\", \"promise\", \"void\", \"never\", \"map\", \"set\"]);\nexport const getParsedType = data => {\n  const t = typeof data;\n  switch (t) {\n    case \"undefined\":\n      return ZodParsedType.undefined;\n    case \"string\":\n      return ZodParsedType.string;\n    case \"number\":\n      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n    case \"boolean\":\n      return ZodParsedType.boolean;\n    case \"function\":\n      return ZodParsedType.function;\n    case \"bigint\":\n      return ZodParsedType.bigint;\n    case \"symbol\":\n      return ZodParsedType.symbol;\n    case \"object\":\n      if (Array.isArray(data)) {\n        return ZodParsedType.array;\n      }\n      if (data === null) {\n        return ZodParsedType.null;\n      }\n      if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n        return ZodParsedType.promise;\n      }\n      if (typeof Map !== \"undefined\" && data instanceof Map) {\n        return ZodParsedType.map;\n      }\n      if (typeof Set !== \"undefined\" && data instanceof Set) {\n        return ZodParsedType.set;\n      }\n      if (typeof Date !== \"undefined\" && data instanceof Date) {\n        return ZodParsedType.date;\n      }\n      return ZodParsedType.object;\n    default:\n      return ZodParsedType.unknown;\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}