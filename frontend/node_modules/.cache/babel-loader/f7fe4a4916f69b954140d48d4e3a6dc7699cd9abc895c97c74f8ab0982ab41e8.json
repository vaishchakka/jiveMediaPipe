{"ast":null,"code":"var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {\n    exports: {}\n  }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name19 in all) __defProp(target, name19, {\n    get: all[name19],\n    enumerable: true\n  });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n  return to;\n};\nvar __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\"));\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n// If the importer is in node compatibility mode or this is not an ESM\n// file that has been converted to a CommonJS file using a Babel-\n// compatible transform (i.e. \"__esModule\" has not been set), then set\n// \"default\" to the CommonJS \"module.exports\" for node compatibility.\nisNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n  value: mod,\n  enumerable: true\n}) : target, mod));\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n// ../../node_modules/secure-json-parse/index.js\nvar require_secure_json_parse = __commonJS({\n  \"../../node_modules/secure-json-parse/index.js\"(exports, module) {\n    \"use strict\";\n\n    var hasBuffer = typeof Buffer !== \"undefined\";\n    var suspectProtoRx4 = /\"(?:_|\\\\u005[Ff])(?:_|\\\\u005[Ff])(?:p|\\\\u0070)(?:r|\\\\u0072)(?:o|\\\\u006[Ff])(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:_|\\\\u005[Ff])(?:_|\\\\u005[Ff])\"\\s*:/;\n    var suspectConstructorRx4 = /\"(?:c|\\\\u0063)(?:o|\\\\u006[Ff])(?:n|\\\\u006[Ee])(?:s|\\\\u0073)(?:t|\\\\u0074)(?:r|\\\\u0072)(?:u|\\\\u0075)(?:c|\\\\u0063)(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:r|\\\\u0072)\"\\s*:/;\n    function _parse5(text2, reviver, options) {\n      if (options == null) {\n        if (reviver !== null && typeof reviver === \"object\") {\n          options = reviver;\n          reviver = void 0;\n        }\n      }\n      if (hasBuffer && Buffer.isBuffer(text2)) {\n        text2 = text2.toString();\n      }\n      if (text2 && text2.charCodeAt(0) === 65279) {\n        text2 = text2.slice(1);\n      }\n      const obj = JSON.parse(text2, reviver);\n      if (obj === null || typeof obj !== \"object\") {\n        return obj;\n      }\n      const protoAction = options && options.protoAction || \"error\";\n      const constructorAction = options && options.constructorAction || \"error\";\n      if (protoAction === \"ignore\" && constructorAction === \"ignore\") {\n        return obj;\n      }\n      if (protoAction !== \"ignore\" && constructorAction !== \"ignore\") {\n        if (suspectProtoRx4.test(text2) === false && suspectConstructorRx4.test(text2) === false) {\n          return obj;\n        }\n      } else if (protoAction !== \"ignore\" && constructorAction === \"ignore\") {\n        if (suspectProtoRx4.test(text2) === false) {\n          return obj;\n        }\n      } else {\n        if (suspectConstructorRx4.test(text2) === false) {\n          return obj;\n        }\n      }\n      return filter4(obj, {\n        protoAction,\n        constructorAction,\n        safe: options && options.safe\n      });\n    }\n    function filter4(obj, {\n      protoAction = \"error\",\n      constructorAction = \"error\",\n      safe\n    } = {}) {\n      let next = [obj];\n      while (next.length) {\n        const nodes = next;\n        next = [];\n        for (const node of nodes) {\n          if (protoAction !== \"ignore\" && Object.prototype.hasOwnProperty.call(node, \"__proto__\")) {\n            if (safe === true) {\n              return null;\n            } else if (protoAction === \"error\") {\n              throw new SyntaxError(\"Object contains forbidden prototype property\");\n            }\n            delete node.__proto__;\n          }\n          if (constructorAction !== \"ignore\" && Object.prototype.hasOwnProperty.call(node, \"constructor\") && Object.prototype.hasOwnProperty.call(node.constructor, \"prototype\")) {\n            if (safe === true) {\n              return null;\n            } else if (constructorAction === \"error\") {\n              throw new SyntaxError(\"Object contains forbidden prototype property\");\n            }\n            delete node.constructor;\n          }\n          for (const key in node) {\n            const value = node[key];\n            if (value && typeof value === \"object\") {\n              next.push(value);\n            }\n          }\n        }\n      }\n      return obj;\n    }\n    function parse3(text2, reviver, options) {\n      const stackTraceLimit = Error.stackTraceLimit;\n      Error.stackTraceLimit = 0;\n      try {\n        return _parse5(text2, reviver, options);\n      } finally {\n        Error.stackTraceLimit = stackTraceLimit;\n      }\n    }\n    function safeParse3(text2, reviver) {\n      const stackTraceLimit = Error.stackTraceLimit;\n      Error.stackTraceLimit = 0;\n      try {\n        return _parse5(text2, reviver, {\n          safe: true\n        });\n      } catch (_e) {\n        return null;\n      } finally {\n        Error.stackTraceLimit = stackTraceLimit;\n      }\n    }\n    module.exports = parse3;\n    module.exports.default = parse3;\n    module.exports.parse = parse3;\n    module.exports.safeParse = safeParse3;\n    module.exports.scan = filter4;\n  }\n});\n\n// src/components/CedarCopilot.client.tsx\nimport React3, { useEffect as useEffect9 } from \"react\";\n\n// src/store/CedarStore.ts\nimport { create } from \"zustand\";\n\n// src/utils/sanitizeJson.ts\nvar sanitizeJson = (obj, visited = /* @__PURE__ */new Map(), path = \"$\") => {\n  if (obj === null || obj === void 0) {\n    return obj;\n  }\n  if (typeof obj === \"function\") {\n    return \"[Function]\";\n  }\n  if (Array.isArray(obj)) {\n    if (visited.has(obj)) {\n      const originalPath = visited.get(obj);\n      return `[Circular: ${originalPath}]`;\n    }\n    visited.set(obj, path);\n    const result = obj.map((item, index) => sanitizeJson(item, visited, `${path}[${index}]`));\n    return result;\n  }\n  if (typeof obj === \"object\") {\n    if (visited.has(obj)) {\n      const originalPath = visited.get(obj);\n      return `[Circular: ${originalPath}]`;\n    }\n    visited.set(obj, path);\n    if (\"$$typeof\" in obj) {\n      return \"[React Component]\";\n    }\n    if (obj instanceof Element) {\n      return \"[DOM Element]\";\n    }\n    if (obj instanceof Date) {\n      return obj.toISOString();\n    }\n    if (obj instanceof RegExp) {\n      return obj.toString();\n    }\n    if (obj instanceof Error) {\n      return {\n        name: obj.name,\n        message: obj.message,\n        stack: obj.stack\n      };\n    }\n    if (obj instanceof Map || obj instanceof Set) {\n      return `[${obj.constructor.name}]`;\n    }\n    const sanitized = {};\n    for (const [key, value] of Object.entries(obj)) {\n      if (typeof value === \"function\") {\n        sanitized[key] = \"[Function]\";\n      } else {\n        const propertyPath = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key) ? `${path}.${key}` : `${path}[\"${key.replace(/\"/g, '\\\\\"')}\"]`;\n        sanitized[key] = sanitizeJson(value, visited, propertyPath);\n      }\n    }\n    return sanitized;\n  }\n  return obj;\n};\nvar desanitizeJson = obj => {\n  const structure = createStructure(obj);\n  resolveCircularReferences(structure, structure);\n  return structure;\n};\nfunction createStructure(obj) {\n  if (obj === null || obj === void 0) {\n    return obj;\n  }\n  if (typeof obj !== \"object\") {\n    return obj;\n  }\n  if (Array.isArray(obj)) {\n    return obj.map(item => createStructure(item));\n  }\n  const result = {};\n  for (const [key, value] of Object.entries(obj)) {\n    result[key] = createStructure(value);\n  }\n  return result;\n}\nfunction resolveCircularReferences(obj, root) {\n  if (obj === null || obj === void 0 || typeof obj !== \"object\") {\n    return;\n  }\n  if (Array.isArray(obj)) {\n    for (let i = 0; i < obj.length; i++) {\n      if (typeof obj[i] === \"string\") {\n        const circularMatch = obj[i].match(/^\\[Circular: (.+)\\]$/);\n        if (circularMatch) {\n          obj[i] = resolvePath(root, circularMatch[1]);\n        }\n      } else {\n        resolveCircularReferences(obj[i], root);\n      }\n    }\n  } else {\n    for (const [key, value] of Object.entries(obj)) {\n      if (typeof value === \"string\") {\n        const circularMatch = value.match(/^\\[Circular: (.+)\\]$/);\n        if (circularMatch) {\n          obj[key] = resolvePath(root, circularMatch[1]);\n        }\n      } else {\n        resolveCircularReferences(value, root);\n      }\n    }\n  }\n}\nfunction resolvePath(root, path) {\n  if (path === \"$\") {\n    return root;\n  }\n  let current = root;\n  const pathWithoutRoot = path.substring(1);\n  const segments = [];\n  let currentSegment = \"\";\n  let inBracket = false;\n  let inQuotes = false;\n  let escapeNext = false;\n  for (let i = 0; i < pathWithoutRoot.length; i++) {\n    const char = pathWithoutRoot[i];\n    if (escapeNext) {\n      currentSegment += char;\n      escapeNext = false;\n      continue;\n    }\n    if (char === \"\\\\\") {\n      escapeNext = true;\n      continue;\n    }\n    if (char === '\"' && inBracket) {\n      inQuotes = !inQuotes;\n      continue;\n    }\n    if (char === \"[\" && !inQuotes) {\n      if (currentSegment) {\n        segments.push(currentSegment);\n        currentSegment = \"\";\n      }\n      inBracket = true;\n      continue;\n    }\n    if (char === \"]\" && !inQuotes && inBracket) {\n      if (currentSegment) {\n        segments.push(currentSegment);\n        currentSegment = \"\";\n      }\n      inBracket = false;\n      continue;\n    }\n    if (char === \".\" && !inBracket && !inQuotes) {\n      if (currentSegment) {\n        segments.push(currentSegment);\n        currentSegment = \"\";\n      }\n      continue;\n    }\n    currentSegment += char;\n  }\n  if (currentSegment) {\n    segments.push(currentSegment);\n  }\n  for (const segment of segments) {\n    if (current === null || current === void 0) {\n      return void 0;\n    }\n    const indexMatch = segment.match(/^(\\d+)$/);\n    if (indexMatch) {\n      current = current[parseInt(segment, 10)];\n    } else {\n      current = current[segment];\n    }\n  }\n  return current;\n}\n\n// src/store/agentContext/agentContextSlice.ts\nimport { useEffect, useMemo } from \"react\";\n\n// ../../node_modules/zod-to-json-schema/dist/esm/Options.js\nvar ignoreOverride = Symbol(\"Let zodToJsonSchema decide on which parser to use\");\nvar defaultOptions = {\n  name: void 0,\n  $refStrategy: \"root\",\n  basePath: [\"#\"],\n  effectStrategy: \"input\",\n  pipeStrategy: \"all\",\n  dateStrategy: \"format:date-time\",\n  mapStrategy: \"entries\",\n  removeAdditionalStrategy: \"passthrough\",\n  allowedAdditionalProperties: true,\n  rejectedAdditionalProperties: false,\n  definitionPath: \"definitions\",\n  target: \"jsonSchema7\",\n  strictUnions: false,\n  definitions: {},\n  errorMessages: false,\n  markdownDescription: false,\n  patternStrategy: \"escape\",\n  applyRegexFlags: false,\n  emailStrategy: \"format:email\",\n  base64Strategy: \"contentEncoding:base64\",\n  nameStrategy: \"ref\",\n  openAiAnyTypeName: \"OpenAiAnyType\"\n};\nvar getDefaultOptions = options => typeof options === \"string\" ? {\n  ...defaultOptions,\n  name: options\n} : {\n  ...defaultOptions,\n  ...options\n};\n\n// ../../node_modules/zod-to-json-schema/dist/esm/Refs.js\nvar getRefs = options => {\n  const _options = getDefaultOptions(options);\n  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;\n  return {\n    ..._options,\n    flags: {\n      hasReferencedOpenAiAnyType: false\n    },\n    currentPath,\n    propertyPath: void 0,\n    seen: new Map(Object.entries(_options.definitions).map(([name19, def]) => [def._def, {\n      def: def._def,\n      path: [..._options.basePath, _options.definitionPath, name19],\n      // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.\n      jsonSchema: void 0\n    }]))\n  };\n};\n\n// ../../node_modules/zod-to-json-schema/dist/esm/errorMessages.js\nfunction addErrorMessage(res, key, errorMessage, refs) {\n  if (!refs?.errorMessages) return;\n  if (errorMessage) {\n    res.errorMessage = {\n      ...res.errorMessage,\n      [key]: errorMessage\n    };\n  }\n}\nfunction setResponseValueAndErrors(res, key, value, errorMessage, refs) {\n  res[key] = value;\n  addErrorMessage(res, key, errorMessage, refs);\n}\n\n// ../../node_modules/zod-to-json-schema/dist/esm/getRelativePath.js\nvar getRelativePath = (pathA, pathB) => {\n  let i = 0;\n  for (; i < pathA.length && i < pathB.length; i++) {\n    if (pathA[i] !== pathB[i]) break;\n  }\n  return [(pathA.length - i).toString(), ...pathB.slice(i)].join(\"/\");\n};\n\n// ../../node_modules/zod/v3/external.js\nvar external_exports = {};\n__export(external_exports, {\n  BRAND: () => BRAND,\n  DIRTY: () => DIRTY,\n  EMPTY_PATH: () => EMPTY_PATH,\n  INVALID: () => INVALID,\n  NEVER: () => NEVER,\n  OK: () => OK,\n  ParseStatus: () => ParseStatus,\n  Schema: () => ZodType,\n  ZodAny: () => ZodAny,\n  ZodArray: () => ZodArray,\n  ZodBigInt: () => ZodBigInt,\n  ZodBoolean: () => ZodBoolean,\n  ZodBranded: () => ZodBranded,\n  ZodCatch: () => ZodCatch,\n  ZodDate: () => ZodDate,\n  ZodDefault: () => ZodDefault,\n  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,\n  ZodEffects: () => ZodEffects,\n  ZodEnum: () => ZodEnum,\n  ZodError: () => ZodError,\n  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,\n  ZodFunction: () => ZodFunction,\n  ZodIntersection: () => ZodIntersection,\n  ZodIssueCode: () => ZodIssueCode,\n  ZodLazy: () => ZodLazy,\n  ZodLiteral: () => ZodLiteral,\n  ZodMap: () => ZodMap,\n  ZodNaN: () => ZodNaN,\n  ZodNativeEnum: () => ZodNativeEnum,\n  ZodNever: () => ZodNever,\n  ZodNull: () => ZodNull,\n  ZodNullable: () => ZodNullable,\n  ZodNumber: () => ZodNumber,\n  ZodObject: () => ZodObject,\n  ZodOptional: () => ZodOptional,\n  ZodParsedType: () => ZodParsedType,\n  ZodPipeline: () => ZodPipeline,\n  ZodPromise: () => ZodPromise,\n  ZodReadonly: () => ZodReadonly,\n  ZodRecord: () => ZodRecord,\n  ZodSchema: () => ZodType,\n  ZodSet: () => ZodSet,\n  ZodString: () => ZodString,\n  ZodSymbol: () => ZodSymbol,\n  ZodTransformer: () => ZodEffects,\n  ZodTuple: () => ZodTuple,\n  ZodType: () => ZodType,\n  ZodUndefined: () => ZodUndefined,\n  ZodUnion: () => ZodUnion,\n  ZodUnknown: () => ZodUnknown,\n  ZodVoid: () => ZodVoid,\n  addIssueToContext: () => addIssueToContext,\n  any: () => anyType,\n  array: () => arrayType,\n  bigint: () => bigIntType,\n  boolean: () => booleanType,\n  coerce: () => coerce,\n  custom: () => custom,\n  date: () => dateType,\n  datetimeRegex: () => datetimeRegex,\n  defaultErrorMap: () => en_default,\n  discriminatedUnion: () => discriminatedUnionType,\n  effect: () => effectsType,\n  enum: () => enumType,\n  function: () => functionType,\n  getErrorMap: () => getErrorMap,\n  getParsedType: () => getParsedType,\n  instanceof: () => instanceOfType,\n  intersection: () => intersectionType,\n  isAborted: () => isAborted,\n  isAsync: () => isAsync,\n  isDirty: () => isDirty,\n  isValid: () => isValid,\n  late: () => late,\n  lazy: () => lazyType,\n  literal: () => literalType,\n  makeIssue: () => makeIssue,\n  map: () => mapType,\n  nan: () => nanType,\n  nativeEnum: () => nativeEnumType,\n  never: () => neverType,\n  null: () => nullType,\n  nullable: () => nullableType,\n  number: () => numberType,\n  object: () => objectType,\n  objectUtil: () => objectUtil,\n  oboolean: () => oboolean,\n  onumber: () => onumber,\n  optional: () => optionalType,\n  ostring: () => ostring,\n  pipeline: () => pipelineType,\n  preprocess: () => preprocessType,\n  promise: () => promiseType,\n  quotelessJson: () => quotelessJson,\n  record: () => recordType,\n  set: () => setType,\n  setErrorMap: () => setErrorMap,\n  strictObject: () => strictObjectType,\n  string: () => stringType,\n  symbol: () => symbolType,\n  transformer: () => effectsType,\n  tuple: () => tupleType,\n  undefined: () => undefinedType,\n  union: () => unionType,\n  unknown: () => unknownType,\n  util: () => util,\n  void: () => voidType\n});\n\n// ../../node_modules/zod/v3/helpers/util.js\nvar util;\n(function (util2) {\n  util2.assertEqual = _ => {};\n  function assertIs2(_arg) {}\n  util2.assertIs = assertIs2;\n  function assertNever2(_x) {\n    throw new Error();\n  }\n  util2.assertNever = assertNever2;\n  util2.arrayToEnum = items => {\n    const obj = {};\n    for (const item of items) {\n      obj[item] = item;\n    }\n    return obj;\n  };\n  util2.getValidEnumValues = obj => {\n    const validKeys = util2.objectKeys(obj).filter(k => typeof obj[obj[k]] !== \"number\");\n    const filtered = {};\n    for (const k of validKeys) {\n      filtered[k] = obj[k];\n    }\n    return util2.objectValues(filtered);\n  };\n  util2.objectValues = obj => {\n    return util2.objectKeys(obj).map(function (e) {\n      return obj[e];\n    });\n  };\n  util2.objectKeys = typeof Object.keys === \"function\" ? obj => Object.keys(obj) : object3 => {\n    const keys2 = [];\n    for (const key in object3) {\n      if (Object.prototype.hasOwnProperty.call(object3, key)) {\n        keys2.push(key);\n      }\n    }\n    return keys2;\n  };\n  util2.find = (arr, checker) => {\n    for (const item of arr) {\n      if (checker(item)) return item;\n    }\n    return void 0;\n  };\n  util2.isInteger = typeof Number.isInteger === \"function\" ? val => Number.isInteger(val) : val => typeof val === \"number\" && Number.isFinite(val) && Math.floor(val) === val;\n  function joinValues2(array2, separator = \" | \") {\n    return array2.map(val => typeof val === \"string\" ? `'${val}'` : val).join(separator);\n  }\n  util2.joinValues = joinValues2;\n  util2.jsonStringifyReplacer = (_, value) => {\n    if (typeof value === \"bigint\") {\n      return value.toString();\n    }\n    return value;\n  };\n})(util || (util = {}));\nvar objectUtil;\n(function (objectUtil2) {\n  objectUtil2.mergeShapes = (first, second) => {\n    return {\n      ...first,\n      ...second\n      // second overwrites first\n    };\n  };\n})(objectUtil || (objectUtil = {}));\nvar ZodParsedType = util.arrayToEnum([\"string\", \"nan\", \"number\", \"integer\", \"float\", \"boolean\", \"date\", \"bigint\", \"symbol\", \"function\", \"undefined\", \"null\", \"array\", \"object\", \"unknown\", \"promise\", \"void\", \"never\", \"map\", \"set\"]);\nvar getParsedType = data => {\n  const t = typeof data;\n  switch (t) {\n    case \"undefined\":\n      return ZodParsedType.undefined;\n    case \"string\":\n      return ZodParsedType.string;\n    case \"number\":\n      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n    case \"boolean\":\n      return ZodParsedType.boolean;\n    case \"function\":\n      return ZodParsedType.function;\n    case \"bigint\":\n      return ZodParsedType.bigint;\n    case \"symbol\":\n      return ZodParsedType.symbol;\n    case \"object\":\n      if (Array.isArray(data)) {\n        return ZodParsedType.array;\n      }\n      if (data === null) {\n        return ZodParsedType.null;\n      }\n      if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n        return ZodParsedType.promise;\n      }\n      if (typeof Map !== \"undefined\" && data instanceof Map) {\n        return ZodParsedType.map;\n      }\n      if (typeof Set !== \"undefined\" && data instanceof Set) {\n        return ZodParsedType.set;\n      }\n      if (typeof Date !== \"undefined\" && data instanceof Date) {\n        return ZodParsedType.date;\n      }\n      return ZodParsedType.object;\n    default:\n      return ZodParsedType.unknown;\n  }\n};\n\n// ../../node_modules/zod/v3/ZodError.js\nvar ZodIssueCode = util.arrayToEnum([\"invalid_type\", \"invalid_literal\", \"custom\", \"invalid_union\", \"invalid_union_discriminator\", \"invalid_enum_value\", \"unrecognized_keys\", \"invalid_arguments\", \"invalid_return_type\", \"invalid_date\", \"invalid_string\", \"too_small\", \"too_big\", \"invalid_intersection_types\", \"not_multiple_of\", \"not_finite\"]);\nvar quotelessJson = obj => {\n  const json2 = JSON.stringify(obj, null, 2);\n  return json2.replace(/\"([^\"]+)\":/g, \"$1:\");\n};\nvar ZodError = class _ZodError extends Error {\n  get errors() {\n    return this.issues;\n  }\n  constructor(issues) {\n    super();\n    this.issues = [];\n    this.addIssue = sub => {\n      this.issues = [...this.issues, sub];\n    };\n    this.addIssues = (subs = []) => {\n      this.issues = [...this.issues, ...subs];\n    };\n    const actualProto = new.target.prototype;\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(this, actualProto);\n    } else {\n      this.__proto__ = actualProto;\n    }\n    this.name = \"ZodError\";\n    this.issues = issues;\n  }\n  format(_mapper) {\n    const mapper = _mapper || function (issue2) {\n      return issue2.message;\n    };\n    const fieldErrors = {\n      _errors: []\n    };\n    const processError = error40 => {\n      for (const issue2 of error40.issues) {\n        if (issue2.code === \"invalid_union\") {\n          issue2.unionErrors.map(processError);\n        } else if (issue2.code === \"invalid_return_type\") {\n          processError(issue2.returnTypeError);\n        } else if (issue2.code === \"invalid_arguments\") {\n          processError(issue2.argumentsError);\n        } else if (issue2.path.length === 0) {\n          fieldErrors._errors.push(mapper(issue2));\n        } else {\n          let curr = fieldErrors;\n          let i = 0;\n          while (i < issue2.path.length) {\n            const el = issue2.path[i];\n            const terminal = i === issue2.path.length - 1;\n            if (!terminal) {\n              curr[el] = curr[el] || {\n                _errors: []\n              };\n            } else {\n              curr[el] = curr[el] || {\n                _errors: []\n              };\n              curr[el]._errors.push(mapper(issue2));\n            }\n            curr = curr[el];\n            i++;\n          }\n        }\n      }\n    };\n    processError(this);\n    return fieldErrors;\n  }\n  static assert(value) {\n    if (!(value instanceof _ZodError)) {\n      throw new Error(`Not a ZodError: ${value}`);\n    }\n  }\n  toString() {\n    return this.message;\n  }\n  get message() {\n    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\n  }\n  get isEmpty() {\n    return this.issues.length === 0;\n  }\n  flatten(mapper = issue2 => issue2.message) {\n    const fieldErrors = {};\n    const formErrors = [];\n    for (const sub of this.issues) {\n      if (sub.path.length > 0) {\n        const firstEl = sub.path[0];\n        fieldErrors[firstEl] = fieldErrors[firstEl] || [];\n        fieldErrors[firstEl].push(mapper(sub));\n      } else {\n        formErrors.push(mapper(sub));\n      }\n    }\n    return {\n      formErrors,\n      fieldErrors\n    };\n  }\n  get formErrors() {\n    return this.flatten();\n  }\n};\nZodError.create = issues => {\n  const error40 = new ZodError(issues);\n  return error40;\n};\n\n// ../../node_modules/zod/v3/locales/en.js\nvar errorMap = (issue2, _ctx) => {\n  let message;\n  switch (issue2.code) {\n    case ZodIssueCode.invalid_type:\n      if (issue2.received === ZodParsedType.undefined) {\n        message = \"Required\";\n      } else {\n        message = `Expected ${issue2.expected}, received ${issue2.received}`;\n      }\n      break;\n    case ZodIssueCode.invalid_literal:\n      message = `Invalid literal value, expected ${JSON.stringify(issue2.expected, util.jsonStringifyReplacer)}`;\n      break;\n    case ZodIssueCode.unrecognized_keys:\n      message = `Unrecognized key(s) in object: ${util.joinValues(issue2.keys, \", \")}`;\n      break;\n    case ZodIssueCode.invalid_union:\n      message = `Invalid input`;\n      break;\n    case ZodIssueCode.invalid_union_discriminator:\n      message = `Invalid discriminator value. Expected ${util.joinValues(issue2.options)}`;\n      break;\n    case ZodIssueCode.invalid_enum_value:\n      message = `Invalid enum value. Expected ${util.joinValues(issue2.options)}, received '${issue2.received}'`;\n      break;\n    case ZodIssueCode.invalid_arguments:\n      message = `Invalid function arguments`;\n      break;\n    case ZodIssueCode.invalid_return_type:\n      message = `Invalid function return type`;\n      break;\n    case ZodIssueCode.invalid_date:\n      message = `Invalid date`;\n      break;\n    case ZodIssueCode.invalid_string:\n      if (typeof issue2.validation === \"object\") {\n        if (\"includes\" in issue2.validation) {\n          message = `Invalid input: must include \"${issue2.validation.includes}\"`;\n          if (typeof issue2.validation.position === \"number\") {\n            message = `${message} at one or more positions greater than or equal to ${issue2.validation.position}`;\n          }\n        } else if (\"startsWith\" in issue2.validation) {\n          message = `Invalid input: must start with \"${issue2.validation.startsWith}\"`;\n        } else if (\"endsWith\" in issue2.validation) {\n          message = `Invalid input: must end with \"${issue2.validation.endsWith}\"`;\n        } else {\n          util.assertNever(issue2.validation);\n        }\n      } else if (issue2.validation !== \"regex\") {\n        message = `Invalid ${issue2.validation}`;\n      } else {\n        message = \"Invalid\";\n      }\n      break;\n    case ZodIssueCode.too_small:\n      if (issue2.type === \"array\") message = `Array must contain ${issue2.exact ? \"exactly\" : issue2.inclusive ? `at least` : `more than`} ${issue2.minimum} element(s)`;else if (issue2.type === \"string\") message = `String must contain ${issue2.exact ? \"exactly\" : issue2.inclusive ? `at least` : `over`} ${issue2.minimum} character(s)`;else if (issue2.type === \"number\") message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;else if (issue2.type === \"bigint\") message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;else if (issue2.type === \"date\") message = `Date must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue2.minimum))}`;else message = \"Invalid input\";\n      break;\n    case ZodIssueCode.too_big:\n      if (issue2.type === \"array\") message = `Array must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `less than`} ${issue2.maximum} element(s)`;else if (issue2.type === \"string\") message = `String must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `under`} ${issue2.maximum} character(s)`;else if (issue2.type === \"number\") message = `Number must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;else if (issue2.type === \"bigint\") message = `BigInt must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;else if (issue2.type === \"date\") message = `Date must be ${issue2.exact ? `exactly` : issue2.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue2.maximum))}`;else message = \"Invalid input\";\n      break;\n    case ZodIssueCode.custom:\n      message = `Invalid input`;\n      break;\n    case ZodIssueCode.invalid_intersection_types:\n      message = `Intersection results could not be merged`;\n      break;\n    case ZodIssueCode.not_multiple_of:\n      message = `Number must be a multiple of ${issue2.multipleOf}`;\n      break;\n    case ZodIssueCode.not_finite:\n      message = \"Number must be finite\";\n      break;\n    default:\n      message = _ctx.defaultError;\n      util.assertNever(issue2);\n  }\n  return {\n    message\n  };\n};\nvar en_default = errorMap;\n\n// ../../node_modules/zod/v3/errors.js\nvar overrideErrorMap = en_default;\nfunction setErrorMap(map2) {\n  overrideErrorMap = map2;\n}\nfunction getErrorMap() {\n  return overrideErrorMap;\n}\n\n// ../../node_modules/zod/v3/helpers/parseUtil.js\nvar makeIssue = params => {\n  const {\n    data,\n    path,\n    errorMaps,\n    issueData\n  } = params;\n  const fullPath = [...path, ...(issueData.path || [])];\n  const fullIssue = {\n    ...issueData,\n    path: fullPath\n  };\n  if (issueData.message !== void 0) {\n    return {\n      ...issueData,\n      path: fullPath,\n      message: issueData.message\n    };\n  }\n  let errorMessage = \"\";\n  const maps = errorMaps.filter(m => !!m).slice().reverse();\n  for (const map2 of maps) {\n    errorMessage = map2(fullIssue, {\n      data,\n      defaultError: errorMessage\n    }).message;\n  }\n  return {\n    ...issueData,\n    path: fullPath,\n    message: errorMessage\n  };\n};\nvar EMPTY_PATH = [];\nfunction addIssueToContext(ctx, issueData) {\n  const overrideMap = getErrorMap();\n  const issue2 = makeIssue({\n    issueData,\n    data: ctx.data,\n    path: ctx.path,\n    errorMaps: [ctx.common.contextualErrorMap,\n    // contextual error map is first priority\n    ctx.schemaErrorMap,\n    // then schema-bound map if available\n    overrideMap,\n    // then global override map\n    overrideMap === en_default ? void 0 : en_default\n    // then global default map\n    ].filter(x => !!x)\n  });\n  ctx.common.issues.push(issue2);\n}\nvar ParseStatus = class _ParseStatus {\n  constructor() {\n    this.value = \"valid\";\n  }\n  dirty() {\n    if (this.value === \"valid\") this.value = \"dirty\";\n  }\n  abort() {\n    if (this.value !== \"aborted\") this.value = \"aborted\";\n  }\n  static mergeArray(status, results) {\n    const arrayValue = [];\n    for (const s of results) {\n      if (s.status === \"aborted\") return INVALID;\n      if (s.status === \"dirty\") status.dirty();\n      arrayValue.push(s.value);\n    }\n    return {\n      status: status.value,\n      value: arrayValue\n    };\n  }\n  static async mergeObjectAsync(status, pairs) {\n    const syncPairs = [];\n    for (const pair of pairs) {\n      const key = await pair.key;\n      const value = await pair.value;\n      syncPairs.push({\n        key,\n        value\n      });\n    }\n    return _ParseStatus.mergeObjectSync(status, syncPairs);\n  }\n  static mergeObjectSync(status, pairs) {\n    const finalObject = {};\n    for (const pair of pairs) {\n      const {\n        key,\n        value\n      } = pair;\n      if (key.status === \"aborted\") return INVALID;\n      if (value.status === \"aborted\") return INVALID;\n      if (key.status === \"dirty\") status.dirty();\n      if (value.status === \"dirty\") status.dirty();\n      if (key.value !== \"__proto__\" && (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\n        finalObject[key.value] = value.value;\n      }\n    }\n    return {\n      status: status.value,\n      value: finalObject\n    };\n  }\n};\nvar INVALID = Object.freeze({\n  status: \"aborted\"\n});\nvar DIRTY = value => ({\n  status: \"dirty\",\n  value\n});\nvar OK = value => ({\n  status: \"valid\",\n  value\n});\nvar isAborted = x => x.status === \"aborted\";\nvar isDirty = x => x.status === \"dirty\";\nvar isValid = x => x.status === \"valid\";\nvar isAsync = x => typeof Promise !== \"undefined\" && x instanceof Promise;\n\n// ../../node_modules/zod/v3/helpers/errorUtil.js\nvar errorUtil;\n(function (errorUtil2) {\n  errorUtil2.errToObj = message => typeof message === \"string\" ? {\n    message\n  } : message || {};\n  errorUtil2.toString = message => typeof message === \"string\" ? message : message?.message;\n})(errorUtil || (errorUtil = {}));\n\n// ../../node_modules/zod/v3/types.js\nvar ParseInputLazyPath = class {\n  constructor(parent, value, path, key) {\n    this._cachedPath = [];\n    this.parent = parent;\n    this.data = value;\n    this._path = path;\n    this._key = key;\n  }\n  get path() {\n    if (!this._cachedPath.length) {\n      if (Array.isArray(this._key)) {\n        this._cachedPath.push(...this._path, ...this._key);\n      } else {\n        this._cachedPath.push(...this._path, this._key);\n      }\n    }\n    return this._cachedPath;\n  }\n};\nvar handleResult = (ctx, result) => {\n  if (isValid(result)) {\n    return {\n      success: true,\n      data: result.value\n    };\n  } else {\n    if (!ctx.common.issues.length) {\n      throw new Error(\"Validation failed but no issues detected.\");\n    }\n    return {\n      success: false,\n      get error() {\n        if (this._error) return this._error;\n        const error40 = new ZodError(ctx.common.issues);\n        this._error = error40;\n        return this._error;\n      }\n    };\n  }\n};\nfunction processCreateParams(params) {\n  if (!params) return {};\n  const {\n    errorMap: errorMap2,\n    invalid_type_error,\n    required_error,\n    description\n  } = params;\n  if (errorMap2 && (invalid_type_error || required_error)) {\n    throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n  }\n  if (errorMap2) return {\n    errorMap: errorMap2,\n    description\n  };\n  const customMap = (iss, ctx) => {\n    const {\n      message\n    } = params;\n    if (iss.code === \"invalid_enum_value\") {\n      return {\n        message: message ?? ctx.defaultError\n      };\n    }\n    if (typeof ctx.data === \"undefined\") {\n      return {\n        message: message ?? required_error ?? ctx.defaultError\n      };\n    }\n    if (iss.code !== \"invalid_type\") return {\n      message: ctx.defaultError\n    };\n    return {\n      message: message ?? invalid_type_error ?? ctx.defaultError\n    };\n  };\n  return {\n    errorMap: customMap,\n    description\n  };\n}\nvar ZodType = class {\n  get description() {\n    return this._def.description;\n  }\n  _getType(input) {\n    return getParsedType(input.data);\n  }\n  _getOrReturnCtx(input, ctx) {\n    return ctx || {\n      common: input.parent.common,\n      data: input.data,\n      parsedType: getParsedType(input.data),\n      schemaErrorMap: this._def.errorMap,\n      path: input.path,\n      parent: input.parent\n    };\n  }\n  _processInputParams(input) {\n    return {\n      status: new ParseStatus(),\n      ctx: {\n        common: input.parent.common,\n        data: input.data,\n        parsedType: getParsedType(input.data),\n        schemaErrorMap: this._def.errorMap,\n        path: input.path,\n        parent: input.parent\n      }\n    };\n  }\n  _parseSync(input) {\n    const result = this._parse(input);\n    if (isAsync(result)) {\n      throw new Error(\"Synchronous parse encountered promise.\");\n    }\n    return result;\n  }\n  _parseAsync(input) {\n    const result = this._parse(input);\n    return Promise.resolve(result);\n  }\n  parse(data, params) {\n    const result = this.safeParse(data, params);\n    if (result.success) return result.data;\n    throw result.error;\n  }\n  safeParse(data, params) {\n    const ctx = {\n      common: {\n        issues: [],\n        async: params?.async ?? false,\n        contextualErrorMap: params?.errorMap\n      },\n      path: params?.path || [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data,\n      parsedType: getParsedType(data)\n    };\n    const result = this._parseSync({\n      data,\n      path: ctx.path,\n      parent: ctx\n    });\n    return handleResult(ctx, result);\n  }\n  \"~validate\"(data) {\n    const ctx = {\n      common: {\n        issues: [],\n        async: !!this[\"~standard\"].async\n      },\n      path: [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data,\n      parsedType: getParsedType(data)\n    };\n    if (!this[\"~standard\"].async) {\n      try {\n        const result = this._parseSync({\n          data,\n          path: [],\n          parent: ctx\n        });\n        return isValid(result) ? {\n          value: result.value\n        } : {\n          issues: ctx.common.issues\n        };\n      } catch (err) {\n        if (err?.message?.toLowerCase()?.includes(\"encountered\")) {\n          this[\"~standard\"].async = true;\n        }\n        ctx.common = {\n          issues: [],\n          async: true\n        };\n      }\n    }\n    return this._parseAsync({\n      data,\n      path: [],\n      parent: ctx\n    }).then(result => isValid(result) ? {\n      value: result.value\n    } : {\n      issues: ctx.common.issues\n    });\n  }\n  async parseAsync(data, params) {\n    const result = await this.safeParseAsync(data, params);\n    if (result.success) return result.data;\n    throw result.error;\n  }\n  async safeParseAsync(data, params) {\n    const ctx = {\n      common: {\n        issues: [],\n        contextualErrorMap: params?.errorMap,\n        async: true\n      },\n      path: params?.path || [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data,\n      parsedType: getParsedType(data)\n    };\n    const maybeAsyncResult = this._parse({\n      data,\n      path: ctx.path,\n      parent: ctx\n    });\n    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));\n    return handleResult(ctx, result);\n  }\n  refine(check2, message) {\n    const getIssueProperties = val => {\n      if (typeof message === \"string\" || typeof message === \"undefined\") {\n        return {\n          message\n        };\n      } else if (typeof message === \"function\") {\n        return message(val);\n      } else {\n        return message;\n      }\n    };\n    return this._refinement((val, ctx) => {\n      const result = check2(val);\n      const setError = () => ctx.addIssue({\n        code: ZodIssueCode.custom,\n        ...getIssueProperties(val)\n      });\n      if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n        return result.then(data => {\n          if (!data) {\n            setError();\n            return false;\n          } else {\n            return true;\n          }\n        });\n      }\n      if (!result) {\n        setError();\n        return false;\n      } else {\n        return true;\n      }\n    });\n  }\n  refinement(check2, refinementData) {\n    return this._refinement((val, ctx) => {\n      if (!check2(val)) {\n        ctx.addIssue(typeof refinementData === \"function\" ? refinementData(val, ctx) : refinementData);\n        return false;\n      } else {\n        return true;\n      }\n    });\n  }\n  _refinement(refinement) {\n    return new ZodEffects({\n      schema: this,\n      typeName: ZodFirstPartyTypeKind.ZodEffects,\n      effect: {\n        type: \"refinement\",\n        refinement\n      }\n    });\n  }\n  superRefine(refinement) {\n    return this._refinement(refinement);\n  }\n  constructor(def) {\n    this.spa = this.safeParseAsync;\n    this._def = def;\n    this.parse = this.parse.bind(this);\n    this.safeParse = this.safeParse.bind(this);\n    this.parseAsync = this.parseAsync.bind(this);\n    this.safeParseAsync = this.safeParseAsync.bind(this);\n    this.spa = this.spa.bind(this);\n    this.refine = this.refine.bind(this);\n    this.refinement = this.refinement.bind(this);\n    this.superRefine = this.superRefine.bind(this);\n    this.optional = this.optional.bind(this);\n    this.nullable = this.nullable.bind(this);\n    this.nullish = this.nullish.bind(this);\n    this.array = this.array.bind(this);\n    this.promise = this.promise.bind(this);\n    this.or = this.or.bind(this);\n    this.and = this.and.bind(this);\n    this.transform = this.transform.bind(this);\n    this.brand = this.brand.bind(this);\n    this.default = this.default.bind(this);\n    this.catch = this.catch.bind(this);\n    this.describe = this.describe.bind(this);\n    this.pipe = this.pipe.bind(this);\n    this.readonly = this.readonly.bind(this);\n    this.isNullable = this.isNullable.bind(this);\n    this.isOptional = this.isOptional.bind(this);\n    this[\"~standard\"] = {\n      version: 1,\n      vendor: \"zod\",\n      validate: data => this[\"~validate\"](data)\n    };\n  }\n  optional() {\n    return ZodOptional.create(this, this._def);\n  }\n  nullable() {\n    return ZodNullable.create(this, this._def);\n  }\n  nullish() {\n    return this.nullable().optional();\n  }\n  array() {\n    return ZodArray.create(this);\n  }\n  promise() {\n    return ZodPromise.create(this, this._def);\n  }\n  or(option) {\n    return ZodUnion.create([this, option], this._def);\n  }\n  and(incoming) {\n    return ZodIntersection.create(this, incoming, this._def);\n  }\n  transform(transform2) {\n    return new ZodEffects({\n      ...processCreateParams(this._def),\n      schema: this,\n      typeName: ZodFirstPartyTypeKind.ZodEffects,\n      effect: {\n        type: \"transform\",\n        transform: transform2\n      }\n    });\n  }\n  default(def) {\n    const defaultValueFunc = typeof def === \"function\" ? def : () => def;\n    return new ZodDefault({\n      ...processCreateParams(this._def),\n      innerType: this,\n      defaultValue: defaultValueFunc,\n      typeName: ZodFirstPartyTypeKind.ZodDefault\n    });\n  }\n  brand() {\n    return new ZodBranded({\n      typeName: ZodFirstPartyTypeKind.ZodBranded,\n      type: this,\n      ...processCreateParams(this._def)\n    });\n  }\n  catch(def) {\n    const catchValueFunc = typeof def === \"function\" ? def : () => def;\n    return new ZodCatch({\n      ...processCreateParams(this._def),\n      innerType: this,\n      catchValue: catchValueFunc,\n      typeName: ZodFirstPartyTypeKind.ZodCatch\n    });\n  }\n  describe(description) {\n    const This = this.constructor;\n    return new This({\n      ...this._def,\n      description\n    });\n  }\n  pipe(target) {\n    return ZodPipeline.create(this, target);\n  }\n  readonly() {\n    return ZodReadonly.create(this);\n  }\n  isOptional() {\n    return this.safeParse(void 0).success;\n  }\n  isNullable() {\n    return this.safeParse(null).success;\n  }\n};\nvar cuidRegex = /^c[^\\s-]{8,}$/i;\nvar cuid2Regex = /^[0-9a-z]+$/;\nvar ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;\nvar uuidRegex = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\nvar nanoidRegex = /^[a-z0-9_-]{21}$/i;\nvar jwtRegex = /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/;\nvar durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/;\nvar emailRegex = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_'+\\-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\nvar _emojiRegex = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\nvar emojiRegex;\nvar ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\nvar ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/;\nvar ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;\nvar ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;\nvar base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;\nvar base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;\nvar dateRegexSource = `((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))`;\nvar dateRegex = new RegExp(`^${dateRegexSource}$`);\nfunction timeRegexSource(args) {\n  let secondsRegexSource = `[0-5]\\\\d`;\n  if (args.precision) {\n    secondsRegexSource = `${secondsRegexSource}\\\\.\\\\d{${args.precision}}`;\n  } else if (args.precision == null) {\n    secondsRegexSource = `${secondsRegexSource}(\\\\.\\\\d+)?`;\n  }\n  const secondsQuantifier = args.precision ? \"+\" : \"?\";\n  return `([01]\\\\d|2[0-3]):[0-5]\\\\d(:${secondsRegexSource})${secondsQuantifier}`;\n}\nfunction timeRegex(args) {\n  return new RegExp(`^${timeRegexSource(args)}$`);\n}\nfunction datetimeRegex(args) {\n  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;\n  const opts = [];\n  opts.push(args.local ? `Z?` : `Z`);\n  if (args.offset) opts.push(`([+-]\\\\d{2}:?\\\\d{2})`);\n  regex = `${regex}(${opts.join(\"|\")})`;\n  return new RegExp(`^${regex}$`);\n}\nfunction isValidIP(ip, version2) {\n  if ((version2 === \"v4\" || !version2) && ipv4Regex.test(ip)) {\n    return true;\n  }\n  if ((version2 === \"v6\" || !version2) && ipv6Regex.test(ip)) {\n    return true;\n  }\n  return false;\n}\nfunction isValidJWT(jwt2, alg) {\n  if (!jwtRegex.test(jwt2)) return false;\n  try {\n    const [header] = jwt2.split(\".\");\n    if (!header) return false;\n    const base643 = header.replace(/-/g, \"+\").replace(/_/g, \"/\").padEnd(header.length + (4 - header.length % 4) % 4, \"=\");\n    const decoded = JSON.parse(atob(base643));\n    if (typeof decoded !== \"object\" || decoded === null) return false;\n    if (\"typ\" in decoded && decoded?.typ !== \"JWT\") return false;\n    if (!decoded.alg) return false;\n    if (alg && decoded.alg !== alg) return false;\n    return true;\n  } catch {\n    return false;\n  }\n}\nfunction isValidCidr(ip, version2) {\n  if ((version2 === \"v4\" || !version2) && ipv4CidrRegex.test(ip)) {\n    return true;\n  }\n  if ((version2 === \"v6\" || !version2) && ipv6CidrRegex.test(ip)) {\n    return true;\n  }\n  return false;\n}\nvar ZodString = class _ZodString2 extends ZodType {\n  _parse(input) {\n    if (this._def.coerce) {\n      input.data = String(input.data);\n    }\n    const parsedType4 = this._getType(input);\n    if (parsedType4 !== ZodParsedType.string) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.string,\n        received: ctx2.parsedType\n      });\n      return INVALID;\n    }\n    const status = new ParseStatus();\n    let ctx = void 0;\n    for (const check2 of this._def.checks) {\n      if (check2.kind === \"min\") {\n        if (input.data.length < check2.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            minimum: check2.value,\n            type: \"string\",\n            inclusive: true,\n            exact: false,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === \"max\") {\n        if (input.data.length > check2.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            maximum: check2.value,\n            type: \"string\",\n            inclusive: true,\n            exact: false,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === \"length\") {\n        const tooBig = input.data.length > check2.value;\n        const tooSmall = input.data.length < check2.value;\n        if (tooBig || tooSmall) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          if (tooBig) {\n            addIssueToContext(ctx, {\n              code: ZodIssueCode.too_big,\n              maximum: check2.value,\n              type: \"string\",\n              inclusive: true,\n              exact: true,\n              message: check2.message\n            });\n          } else if (tooSmall) {\n            addIssueToContext(ctx, {\n              code: ZodIssueCode.too_small,\n              minimum: check2.value,\n              type: \"string\",\n              inclusive: true,\n              exact: true,\n              message: check2.message\n            });\n          }\n          status.dirty();\n        }\n      } else if (check2.kind === \"email\") {\n        if (!emailRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"email\",\n            code: ZodIssueCode.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === \"emoji\") {\n        if (!emojiRegex) {\n          emojiRegex = new RegExp(_emojiRegex, \"u\");\n        }\n        if (!emojiRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"emoji\",\n            code: ZodIssueCode.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === \"uuid\") {\n        if (!uuidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"uuid\",\n            code: ZodIssueCode.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === \"nanoid\") {\n        if (!nanoidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"nanoid\",\n            code: ZodIssueCode.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === \"cuid\") {\n        if (!cuidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"cuid\",\n            code: ZodIssueCode.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === \"cuid2\") {\n        if (!cuid2Regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"cuid2\",\n            code: ZodIssueCode.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === \"ulid\") {\n        if (!ulidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"ulid\",\n            code: ZodIssueCode.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === \"url\") {\n        try {\n          new URL(input.data);\n        } catch {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"url\",\n            code: ZodIssueCode.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === \"regex\") {\n        check2.regex.lastIndex = 0;\n        const testResult = check2.regex.test(input.data);\n        if (!testResult) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"regex\",\n            code: ZodIssueCode.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === \"trim\") {\n        input.data = input.data.trim();\n      } else if (check2.kind === \"includes\") {\n        if (!input.data.includes(check2.value, check2.position)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: {\n              includes: check2.value,\n              position: check2.position\n            },\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === \"toLowerCase\") {\n        input.data = input.data.toLowerCase();\n      } else if (check2.kind === \"toUpperCase\") {\n        input.data = input.data.toUpperCase();\n      } else if (check2.kind === \"startsWith\") {\n        if (!input.data.startsWith(check2.value)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: {\n              startsWith: check2.value\n            },\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === \"endsWith\") {\n        if (!input.data.endsWith(check2.value)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: {\n              endsWith: check2.value\n            },\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === \"datetime\") {\n        const regex = datetimeRegex(check2);\n        if (!regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: \"datetime\",\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === \"date\") {\n        const regex = dateRegex;\n        if (!regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: \"date\",\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === \"time\") {\n        const regex = timeRegex(check2);\n        if (!regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: \"time\",\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === \"duration\") {\n        if (!durationRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"duration\",\n            code: ZodIssueCode.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === \"ip\") {\n        if (!isValidIP(input.data, check2.version)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"ip\",\n            code: ZodIssueCode.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === \"jwt\") {\n        if (!isValidJWT(input.data, check2.alg)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"jwt\",\n            code: ZodIssueCode.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === \"cidr\") {\n        if (!isValidCidr(input.data, check2.version)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"cidr\",\n            code: ZodIssueCode.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === \"base64\") {\n        if (!base64Regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"base64\",\n            code: ZodIssueCode.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === \"base64url\") {\n        if (!base64urlRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"base64url\",\n            code: ZodIssueCode.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check2);\n      }\n    }\n    return {\n      status: status.value,\n      value: input.data\n    };\n  }\n  _regex(regex, validation, message) {\n    return this.refinement(data => regex.test(data), {\n      validation,\n      code: ZodIssueCode.invalid_string,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  _addCheck(check2) {\n    return new _ZodString2({\n      ...this._def,\n      checks: [...this._def.checks, check2]\n    });\n  }\n  email(message) {\n    return this._addCheck({\n      kind: \"email\",\n      ...errorUtil.errToObj(message)\n    });\n  }\n  url(message) {\n    return this._addCheck({\n      kind: \"url\",\n      ...errorUtil.errToObj(message)\n    });\n  }\n  emoji(message) {\n    return this._addCheck({\n      kind: \"emoji\",\n      ...errorUtil.errToObj(message)\n    });\n  }\n  uuid(message) {\n    return this._addCheck({\n      kind: \"uuid\",\n      ...errorUtil.errToObj(message)\n    });\n  }\n  nanoid(message) {\n    return this._addCheck({\n      kind: \"nanoid\",\n      ...errorUtil.errToObj(message)\n    });\n  }\n  cuid(message) {\n    return this._addCheck({\n      kind: \"cuid\",\n      ...errorUtil.errToObj(message)\n    });\n  }\n  cuid2(message) {\n    return this._addCheck({\n      kind: \"cuid2\",\n      ...errorUtil.errToObj(message)\n    });\n  }\n  ulid(message) {\n    return this._addCheck({\n      kind: \"ulid\",\n      ...errorUtil.errToObj(message)\n    });\n  }\n  base64(message) {\n    return this._addCheck({\n      kind: \"base64\",\n      ...errorUtil.errToObj(message)\n    });\n  }\n  base64url(message) {\n    return this._addCheck({\n      kind: \"base64url\",\n      ...errorUtil.errToObj(message)\n    });\n  }\n  jwt(options) {\n    return this._addCheck({\n      kind: \"jwt\",\n      ...errorUtil.errToObj(options)\n    });\n  }\n  ip(options) {\n    return this._addCheck({\n      kind: \"ip\",\n      ...errorUtil.errToObj(options)\n    });\n  }\n  cidr(options) {\n    return this._addCheck({\n      kind: \"cidr\",\n      ...errorUtil.errToObj(options)\n    });\n  }\n  datetime(options) {\n    if (typeof options === \"string\") {\n      return this._addCheck({\n        kind: \"datetime\",\n        precision: null,\n        offset: false,\n        local: false,\n        message: options\n      });\n    }\n    return this._addCheck({\n      kind: \"datetime\",\n      precision: typeof options?.precision === \"undefined\" ? null : options?.precision,\n      offset: options?.offset ?? false,\n      local: options?.local ?? false,\n      ...errorUtil.errToObj(options?.message)\n    });\n  }\n  date(message) {\n    return this._addCheck({\n      kind: \"date\",\n      message\n    });\n  }\n  time(options) {\n    if (typeof options === \"string\") {\n      return this._addCheck({\n        kind: \"time\",\n        precision: null,\n        message: options\n      });\n    }\n    return this._addCheck({\n      kind: \"time\",\n      precision: typeof options?.precision === \"undefined\" ? null : options?.precision,\n      ...errorUtil.errToObj(options?.message)\n    });\n  }\n  duration(message) {\n    return this._addCheck({\n      kind: \"duration\",\n      ...errorUtil.errToObj(message)\n    });\n  }\n  regex(regex, message) {\n    return this._addCheck({\n      kind: \"regex\",\n      regex,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  includes(value, options) {\n    return this._addCheck({\n      kind: \"includes\",\n      value,\n      position: options?.position,\n      ...errorUtil.errToObj(options?.message)\n    });\n  }\n  startsWith(value, message) {\n    return this._addCheck({\n      kind: \"startsWith\",\n      value,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  endsWith(value, message) {\n    return this._addCheck({\n      kind: \"endsWith\",\n      value,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  min(minLength, message) {\n    return this._addCheck({\n      kind: \"min\",\n      value: minLength,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  max(maxLength, message) {\n    return this._addCheck({\n      kind: \"max\",\n      value: maxLength,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  length(len, message) {\n    return this._addCheck({\n      kind: \"length\",\n      value: len,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  /**\n   * Equivalent to `.min(1)`\n   */\n  nonempty(message) {\n    return this.min(1, errorUtil.errToObj(message));\n  }\n  trim() {\n    return new _ZodString2({\n      ...this._def,\n      checks: [...this._def.checks, {\n        kind: \"trim\"\n      }]\n    });\n  }\n  toLowerCase() {\n    return new _ZodString2({\n      ...this._def,\n      checks: [...this._def.checks, {\n        kind: \"toLowerCase\"\n      }]\n    });\n  }\n  toUpperCase() {\n    return new _ZodString2({\n      ...this._def,\n      checks: [...this._def.checks, {\n        kind: \"toUpperCase\"\n      }]\n    });\n  }\n  get isDatetime() {\n    return !!this._def.checks.find(ch => ch.kind === \"datetime\");\n  }\n  get isDate() {\n    return !!this._def.checks.find(ch => ch.kind === \"date\");\n  }\n  get isTime() {\n    return !!this._def.checks.find(ch => ch.kind === \"time\");\n  }\n  get isDuration() {\n    return !!this._def.checks.find(ch => ch.kind === \"duration\");\n  }\n  get isEmail() {\n    return !!this._def.checks.find(ch => ch.kind === \"email\");\n  }\n  get isURL() {\n    return !!this._def.checks.find(ch => ch.kind === \"url\");\n  }\n  get isEmoji() {\n    return !!this._def.checks.find(ch => ch.kind === \"emoji\");\n  }\n  get isUUID() {\n    return !!this._def.checks.find(ch => ch.kind === \"uuid\");\n  }\n  get isNANOID() {\n    return !!this._def.checks.find(ch => ch.kind === \"nanoid\");\n  }\n  get isCUID() {\n    return !!this._def.checks.find(ch => ch.kind === \"cuid\");\n  }\n  get isCUID2() {\n    return !!this._def.checks.find(ch => ch.kind === \"cuid2\");\n  }\n  get isULID() {\n    return !!this._def.checks.find(ch => ch.kind === \"ulid\");\n  }\n  get isIP() {\n    return !!this._def.checks.find(ch => ch.kind === \"ip\");\n  }\n  get isCIDR() {\n    return !!this._def.checks.find(ch => ch.kind === \"cidr\");\n  }\n  get isBase64() {\n    return !!this._def.checks.find(ch => ch.kind === \"base64\");\n  }\n  get isBase64url() {\n    return !!this._def.checks.find(ch => ch.kind === \"base64url\");\n  }\n  get minLength() {\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"min\") {\n        if (min === null || ch.value > min) min = ch.value;\n      }\n    }\n    return min;\n  }\n  get maxLength() {\n    let max = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"max\") {\n        if (max === null || ch.value < max) max = ch.value;\n      }\n    }\n    return max;\n  }\n};\nZodString.create = params => {\n  return new ZodString({\n    checks: [],\n    typeName: ZodFirstPartyTypeKind.ZodString,\n    coerce: params?.coerce ?? false,\n    ...processCreateParams(params)\n  });\n};\nfunction floatSafeRemainder(val, step) {\n  const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n  const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n  const valInt = Number.parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n  const stepInt = Number.parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n  return valInt % stepInt / 10 ** decCount;\n}\nvar ZodNumber = class _ZodNumber extends ZodType {\n  constructor() {\n    super(...arguments);\n    this.min = this.gte;\n    this.max = this.lte;\n    this.step = this.multipleOf;\n  }\n  _parse(input) {\n    if (this._def.coerce) {\n      input.data = Number(input.data);\n    }\n    const parsedType4 = this._getType(input);\n    if (parsedType4 !== ZodParsedType.number) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.number,\n        received: ctx2.parsedType\n      });\n      return INVALID;\n    }\n    let ctx = void 0;\n    const status = new ParseStatus();\n    for (const check2 of this._def.checks) {\n      if (check2.kind === \"int\") {\n        if (!util.isInteger(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: \"integer\",\n            received: \"float\",\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === \"min\") {\n        const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;\n        if (tooSmall) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            minimum: check2.value,\n            type: \"number\",\n            inclusive: check2.inclusive,\n            exact: false,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === \"max\") {\n        const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;\n        if (tooBig) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            maximum: check2.value,\n            type: \"number\",\n            inclusive: check2.inclusive,\n            exact: false,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === \"multipleOf\") {\n        if (floatSafeRemainder(input.data, check2.value) !== 0) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.not_multiple_of,\n            multipleOf: check2.value,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === \"finite\") {\n        if (!Number.isFinite(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.not_finite,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check2);\n      }\n    }\n    return {\n      status: status.value,\n      value: input.data\n    };\n  }\n  gte(value, message) {\n    return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n  }\n  gt(value, message) {\n    return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n  }\n  lte(value, message) {\n    return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n  }\n  lt(value, message) {\n    return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n  }\n  setLimit(kind, value, inclusive, message) {\n    return new _ZodNumber({\n      ...this._def,\n      checks: [...this._def.checks, {\n        kind,\n        value,\n        inclusive,\n        message: errorUtil.toString(message)\n      }]\n    });\n  }\n  _addCheck(check2) {\n    return new _ZodNumber({\n      ...this._def,\n      checks: [...this._def.checks, check2]\n    });\n  }\n  int(message) {\n    return this._addCheck({\n      kind: \"int\",\n      message: errorUtil.toString(message)\n    });\n  }\n  positive(message) {\n    return this._addCheck({\n      kind: \"min\",\n      value: 0,\n      inclusive: false,\n      message: errorUtil.toString(message)\n    });\n  }\n  negative(message) {\n    return this._addCheck({\n      kind: \"max\",\n      value: 0,\n      inclusive: false,\n      message: errorUtil.toString(message)\n    });\n  }\n  nonpositive(message) {\n    return this._addCheck({\n      kind: \"max\",\n      value: 0,\n      inclusive: true,\n      message: errorUtil.toString(message)\n    });\n  }\n  nonnegative(message) {\n    return this._addCheck({\n      kind: \"min\",\n      value: 0,\n      inclusive: true,\n      message: errorUtil.toString(message)\n    });\n  }\n  multipleOf(value, message) {\n    return this._addCheck({\n      kind: \"multipleOf\",\n      value,\n      message: errorUtil.toString(message)\n    });\n  }\n  finite(message) {\n    return this._addCheck({\n      kind: \"finite\",\n      message: errorUtil.toString(message)\n    });\n  }\n  safe(message) {\n    return this._addCheck({\n      kind: \"min\",\n      inclusive: true,\n      value: Number.MIN_SAFE_INTEGER,\n      message: errorUtil.toString(message)\n    })._addCheck({\n      kind: \"max\",\n      inclusive: true,\n      value: Number.MAX_SAFE_INTEGER,\n      message: errorUtil.toString(message)\n    });\n  }\n  get minValue() {\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"min\") {\n        if (min === null || ch.value > min) min = ch.value;\n      }\n    }\n    return min;\n  }\n  get maxValue() {\n    let max = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"max\") {\n        if (max === null || ch.value < max) max = ch.value;\n      }\n    }\n    return max;\n  }\n  get isInt() {\n    return !!this._def.checks.find(ch => ch.kind === \"int\" || ch.kind === \"multipleOf\" && util.isInteger(ch.value));\n  }\n  get isFinite() {\n    let max = null;\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"finite\" || ch.kind === \"int\" || ch.kind === \"multipleOf\") {\n        return true;\n      } else if (ch.kind === \"min\") {\n        if (min === null || ch.value > min) min = ch.value;\n      } else if (ch.kind === \"max\") {\n        if (max === null || ch.value < max) max = ch.value;\n      }\n    }\n    return Number.isFinite(min) && Number.isFinite(max);\n  }\n};\nZodNumber.create = params => {\n  return new ZodNumber({\n    checks: [],\n    typeName: ZodFirstPartyTypeKind.ZodNumber,\n    coerce: params?.coerce || false,\n    ...processCreateParams(params)\n  });\n};\nvar ZodBigInt = class _ZodBigInt extends ZodType {\n  constructor() {\n    super(...arguments);\n    this.min = this.gte;\n    this.max = this.lte;\n  }\n  _parse(input) {\n    if (this._def.coerce) {\n      try {\n        input.data = BigInt(input.data);\n      } catch {\n        return this._getInvalidInput(input);\n      }\n    }\n    const parsedType4 = this._getType(input);\n    if (parsedType4 !== ZodParsedType.bigint) {\n      return this._getInvalidInput(input);\n    }\n    let ctx = void 0;\n    const status = new ParseStatus();\n    for (const check2 of this._def.checks) {\n      if (check2.kind === \"min\") {\n        const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;\n        if (tooSmall) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            type: \"bigint\",\n            minimum: check2.value,\n            inclusive: check2.inclusive,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === \"max\") {\n        const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;\n        if (tooBig) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            type: \"bigint\",\n            maximum: check2.value,\n            inclusive: check2.inclusive,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === \"multipleOf\") {\n        if (input.data % check2.value !== BigInt(0)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.not_multiple_of,\n            multipleOf: check2.value,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check2);\n      }\n    }\n    return {\n      status: status.value,\n      value: input.data\n    };\n  }\n  _getInvalidInput(input) {\n    const ctx = this._getOrReturnCtx(input);\n    addIssueToContext(ctx, {\n      code: ZodIssueCode.invalid_type,\n      expected: ZodParsedType.bigint,\n      received: ctx.parsedType\n    });\n    return INVALID;\n  }\n  gte(value, message) {\n    return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n  }\n  gt(value, message) {\n    return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n  }\n  lte(value, message) {\n    return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n  }\n  lt(value, message) {\n    return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n  }\n  setLimit(kind, value, inclusive, message) {\n    return new _ZodBigInt({\n      ...this._def,\n      checks: [...this._def.checks, {\n        kind,\n        value,\n        inclusive,\n        message: errorUtil.toString(message)\n      }]\n    });\n  }\n  _addCheck(check2) {\n    return new _ZodBigInt({\n      ...this._def,\n      checks: [...this._def.checks, check2]\n    });\n  }\n  positive(message) {\n    return this._addCheck({\n      kind: \"min\",\n      value: BigInt(0),\n      inclusive: false,\n      message: errorUtil.toString(message)\n    });\n  }\n  negative(message) {\n    return this._addCheck({\n      kind: \"max\",\n      value: BigInt(0),\n      inclusive: false,\n      message: errorUtil.toString(message)\n    });\n  }\n  nonpositive(message) {\n    return this._addCheck({\n      kind: \"max\",\n      value: BigInt(0),\n      inclusive: true,\n      message: errorUtil.toString(message)\n    });\n  }\n  nonnegative(message) {\n    return this._addCheck({\n      kind: \"min\",\n      value: BigInt(0),\n      inclusive: true,\n      message: errorUtil.toString(message)\n    });\n  }\n  multipleOf(value, message) {\n    return this._addCheck({\n      kind: \"multipleOf\",\n      value,\n      message: errorUtil.toString(message)\n    });\n  }\n  get minValue() {\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"min\") {\n        if (min === null || ch.value > min) min = ch.value;\n      }\n    }\n    return min;\n  }\n  get maxValue() {\n    let max = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"max\") {\n        if (max === null || ch.value < max) max = ch.value;\n      }\n    }\n    return max;\n  }\n};\nZodBigInt.create = params => {\n  return new ZodBigInt({\n    checks: [],\n    typeName: ZodFirstPartyTypeKind.ZodBigInt,\n    coerce: params?.coerce ?? false,\n    ...processCreateParams(params)\n  });\n};\nvar ZodBoolean = class extends ZodType {\n  _parse(input) {\n    if (this._def.coerce) {\n      input.data = Boolean(input.data);\n    }\n    const parsedType4 = this._getType(input);\n    if (parsedType4 !== ZodParsedType.boolean) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.boolean,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n};\nZodBoolean.create = params => {\n  return new ZodBoolean({\n    typeName: ZodFirstPartyTypeKind.ZodBoolean,\n    coerce: params?.coerce || false,\n    ...processCreateParams(params)\n  });\n};\nvar ZodDate = class _ZodDate extends ZodType {\n  _parse(input) {\n    if (this._def.coerce) {\n      input.data = new Date(input.data);\n    }\n    const parsedType4 = this._getType(input);\n    if (parsedType4 !== ZodParsedType.date) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.date,\n        received: ctx2.parsedType\n      });\n      return INVALID;\n    }\n    if (Number.isNaN(input.data.getTime())) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_date\n      });\n      return INVALID;\n    }\n    const status = new ParseStatus();\n    let ctx = void 0;\n    for (const check2 of this._def.checks) {\n      if (check2.kind === \"min\") {\n        if (input.data.getTime() < check2.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            message: check2.message,\n            inclusive: true,\n            exact: false,\n            minimum: check2.value,\n            type: \"date\"\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === \"max\") {\n        if (input.data.getTime() > check2.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            message: check2.message,\n            inclusive: true,\n            exact: false,\n            maximum: check2.value,\n            type: \"date\"\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check2);\n      }\n    }\n    return {\n      status: status.value,\n      value: new Date(input.data.getTime())\n    };\n  }\n  _addCheck(check2) {\n    return new _ZodDate({\n      ...this._def,\n      checks: [...this._def.checks, check2]\n    });\n  }\n  min(minDate, message) {\n    return this._addCheck({\n      kind: \"min\",\n      value: minDate.getTime(),\n      message: errorUtil.toString(message)\n    });\n  }\n  max(maxDate, message) {\n    return this._addCheck({\n      kind: \"max\",\n      value: maxDate.getTime(),\n      message: errorUtil.toString(message)\n    });\n  }\n  get minDate() {\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"min\") {\n        if (min === null || ch.value > min) min = ch.value;\n      }\n    }\n    return min != null ? new Date(min) : null;\n  }\n  get maxDate() {\n    let max = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"max\") {\n        if (max === null || ch.value < max) max = ch.value;\n      }\n    }\n    return max != null ? new Date(max) : null;\n  }\n};\nZodDate.create = params => {\n  return new ZodDate({\n    checks: [],\n    coerce: params?.coerce || false,\n    typeName: ZodFirstPartyTypeKind.ZodDate,\n    ...processCreateParams(params)\n  });\n};\nvar ZodSymbol = class extends ZodType {\n  _parse(input) {\n    const parsedType4 = this._getType(input);\n    if (parsedType4 !== ZodParsedType.symbol) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.symbol,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n};\nZodSymbol.create = params => {\n  return new ZodSymbol({\n    typeName: ZodFirstPartyTypeKind.ZodSymbol,\n    ...processCreateParams(params)\n  });\n};\nvar ZodUndefined = class extends ZodType {\n  _parse(input) {\n    const parsedType4 = this._getType(input);\n    if (parsedType4 !== ZodParsedType.undefined) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.undefined,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n};\nZodUndefined.create = params => {\n  return new ZodUndefined({\n    typeName: ZodFirstPartyTypeKind.ZodUndefined,\n    ...processCreateParams(params)\n  });\n};\nvar ZodNull = class extends ZodType {\n  _parse(input) {\n    const parsedType4 = this._getType(input);\n    if (parsedType4 !== ZodParsedType.null) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.null,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n};\nZodNull.create = params => {\n  return new ZodNull({\n    typeName: ZodFirstPartyTypeKind.ZodNull,\n    ...processCreateParams(params)\n  });\n};\nvar ZodAny = class extends ZodType {\n  constructor() {\n    super(...arguments);\n    this._any = true;\n  }\n  _parse(input) {\n    return OK(input.data);\n  }\n};\nZodAny.create = params => {\n  return new ZodAny({\n    typeName: ZodFirstPartyTypeKind.ZodAny,\n    ...processCreateParams(params)\n  });\n};\nvar ZodUnknown = class extends ZodType {\n  constructor() {\n    super(...arguments);\n    this._unknown = true;\n  }\n  _parse(input) {\n    return OK(input.data);\n  }\n};\nZodUnknown.create = params => {\n  return new ZodUnknown({\n    typeName: ZodFirstPartyTypeKind.ZodUnknown,\n    ...processCreateParams(params)\n  });\n};\nvar ZodNever = class extends ZodType {\n  _parse(input) {\n    const ctx = this._getOrReturnCtx(input);\n    addIssueToContext(ctx, {\n      code: ZodIssueCode.invalid_type,\n      expected: ZodParsedType.never,\n      received: ctx.parsedType\n    });\n    return INVALID;\n  }\n};\nZodNever.create = params => {\n  return new ZodNever({\n    typeName: ZodFirstPartyTypeKind.ZodNever,\n    ...processCreateParams(params)\n  });\n};\nvar ZodVoid = class extends ZodType {\n  _parse(input) {\n    const parsedType4 = this._getType(input);\n    if (parsedType4 !== ZodParsedType.undefined) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.void,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n};\nZodVoid.create = params => {\n  return new ZodVoid({\n    typeName: ZodFirstPartyTypeKind.ZodVoid,\n    ...processCreateParams(params)\n  });\n};\nvar ZodArray = class _ZodArray extends ZodType {\n  _parse(input) {\n    const {\n      ctx,\n      status\n    } = this._processInputParams(input);\n    const def = this._def;\n    if (ctx.parsedType !== ZodParsedType.array) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.array,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    if (def.exactLength !== null) {\n      const tooBig = ctx.data.length > def.exactLength.value;\n      const tooSmall = ctx.data.length < def.exactLength.value;\n      if (tooBig || tooSmall) {\n        addIssueToContext(ctx, {\n          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,\n          minimum: tooSmall ? def.exactLength.value : void 0,\n          maximum: tooBig ? def.exactLength.value : void 0,\n          type: \"array\",\n          inclusive: true,\n          exact: true,\n          message: def.exactLength.message\n        });\n        status.dirty();\n      }\n    }\n    if (def.minLength !== null) {\n      if (ctx.data.length < def.minLength.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_small,\n          minimum: def.minLength.value,\n          type: \"array\",\n          inclusive: true,\n          exact: false,\n          message: def.minLength.message\n        });\n        status.dirty();\n      }\n    }\n    if (def.maxLength !== null) {\n      if (ctx.data.length > def.maxLength.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_big,\n          maximum: def.maxLength.value,\n          type: \"array\",\n          inclusive: true,\n          exact: false,\n          message: def.maxLength.message\n        });\n        status.dirty();\n      }\n    }\n    if (ctx.common.async) {\n      return Promise.all([...ctx.data].map((item, i) => {\n        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n      })).then(result2 => {\n        return ParseStatus.mergeArray(status, result2);\n      });\n    }\n    const result = [...ctx.data].map((item, i) => {\n      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n    });\n    return ParseStatus.mergeArray(status, result);\n  }\n  get element() {\n    return this._def.type;\n  }\n  min(minLength, message) {\n    return new _ZodArray({\n      ...this._def,\n      minLength: {\n        value: minLength,\n        message: errorUtil.toString(message)\n      }\n    });\n  }\n  max(maxLength, message) {\n    return new _ZodArray({\n      ...this._def,\n      maxLength: {\n        value: maxLength,\n        message: errorUtil.toString(message)\n      }\n    });\n  }\n  length(len, message) {\n    return new _ZodArray({\n      ...this._def,\n      exactLength: {\n        value: len,\n        message: errorUtil.toString(message)\n      }\n    });\n  }\n  nonempty(message) {\n    return this.min(1, message);\n  }\n};\nZodArray.create = (schema, params) => {\n  return new ZodArray({\n    type: schema,\n    minLength: null,\n    maxLength: null,\n    exactLength: null,\n    typeName: ZodFirstPartyTypeKind.ZodArray,\n    ...processCreateParams(params)\n  });\n};\nfunction deepPartialify(schema) {\n  if (schema instanceof ZodObject) {\n    const newShape = {};\n    for (const key in schema.shape) {\n      const fieldSchema = schema.shape[key];\n      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n    }\n    return new ZodObject({\n      ...schema._def,\n      shape: () => newShape\n    });\n  } else if (schema instanceof ZodArray) {\n    return new ZodArray({\n      ...schema._def,\n      type: deepPartialify(schema.element)\n    });\n  } else if (schema instanceof ZodOptional) {\n    return ZodOptional.create(deepPartialify(schema.unwrap()));\n  } else if (schema instanceof ZodNullable) {\n    return ZodNullable.create(deepPartialify(schema.unwrap()));\n  } else if (schema instanceof ZodTuple) {\n    return ZodTuple.create(schema.items.map(item => deepPartialify(item)));\n  } else {\n    return schema;\n  }\n}\nvar ZodObject = class _ZodObject extends ZodType {\n  constructor() {\n    super(...arguments);\n    this._cached = null;\n    this.nonstrict = this.passthrough;\n    this.augment = this.extend;\n  }\n  _getCached() {\n    if (this._cached !== null) return this._cached;\n    const shape = this._def.shape();\n    const keys2 = util.objectKeys(shape);\n    this._cached = {\n      shape,\n      keys: keys2\n    };\n    return this._cached;\n  }\n  _parse(input) {\n    const parsedType4 = this._getType(input);\n    if (parsedType4 !== ZodParsedType.object) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx2.parsedType\n      });\n      return INVALID;\n    }\n    const {\n      status,\n      ctx\n    } = this._processInputParams(input);\n    const {\n      shape,\n      keys: shapeKeys\n    } = this._getCached();\n    const extraKeys = [];\n    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === \"strip\")) {\n      for (const key in ctx.data) {\n        if (!shapeKeys.includes(key)) {\n          extraKeys.push(key);\n        }\n      }\n    }\n    const pairs = [];\n    for (const key of shapeKeys) {\n      const keyValidator = shape[key];\n      const value = ctx.data[key];\n      pairs.push({\n        key: {\n          status: \"valid\",\n          value: key\n        },\n        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n        alwaysSet: key in ctx.data\n      });\n    }\n    if (this._def.catchall instanceof ZodNever) {\n      const unknownKeys = this._def.unknownKeys;\n      if (unknownKeys === \"passthrough\") {\n        for (const key of extraKeys) {\n          pairs.push({\n            key: {\n              status: \"valid\",\n              value: key\n            },\n            value: {\n              status: \"valid\",\n              value: ctx.data[key]\n            }\n          });\n        }\n      } else if (unknownKeys === \"strict\") {\n        if (extraKeys.length > 0) {\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.unrecognized_keys,\n            keys: extraKeys\n          });\n          status.dirty();\n        }\n      } else if (unknownKeys === \"strip\") {} else {\n        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n      }\n    } else {\n      const catchall = this._def.catchall;\n      for (const key of extraKeys) {\n        const value = ctx.data[key];\n        pairs.push({\n          key: {\n            status: \"valid\",\n            value: key\n          },\n          value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)\n          //, ctx.child(key), value, getParsedType(value)\n          ),\n          alwaysSet: key in ctx.data\n        });\n      }\n    }\n    if (ctx.common.async) {\n      return Promise.resolve().then(async () => {\n        const syncPairs = [];\n        for (const pair of pairs) {\n          const key = await pair.key;\n          const value = await pair.value;\n          syncPairs.push({\n            key,\n            value,\n            alwaysSet: pair.alwaysSet\n          });\n        }\n        return syncPairs;\n      }).then(syncPairs => {\n        return ParseStatus.mergeObjectSync(status, syncPairs);\n      });\n    } else {\n      return ParseStatus.mergeObjectSync(status, pairs);\n    }\n  }\n  get shape() {\n    return this._def.shape();\n  }\n  strict(message) {\n    errorUtil.errToObj;\n    return new _ZodObject({\n      ...this._def,\n      unknownKeys: \"strict\",\n      ...(message !== void 0 ? {\n        errorMap: (issue2, ctx) => {\n          const defaultError = this._def.errorMap?.(issue2, ctx).message ?? ctx.defaultError;\n          if (issue2.code === \"unrecognized_keys\") return {\n            message: errorUtil.errToObj(message).message ?? defaultError\n          };\n          return {\n            message: defaultError\n          };\n        }\n      } : {})\n    });\n  }\n  strip() {\n    return new _ZodObject({\n      ...this._def,\n      unknownKeys: \"strip\"\n    });\n  }\n  passthrough() {\n    return new _ZodObject({\n      ...this._def,\n      unknownKeys: \"passthrough\"\n    });\n  }\n  // const AugmentFactory =\n  //   <Def extends ZodObjectDef>(def: Def) =>\n  //   <Augmentation extends ZodRawShape>(\n  //     augmentation: Augmentation\n  //   ): ZodObject<\n  //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\n  //     Def[\"unknownKeys\"],\n  //     Def[\"catchall\"]\n  //   > => {\n  //     return new ZodObject({\n  //       ...def,\n  //       shape: () => ({\n  //         ...def.shape(),\n  //         ...augmentation,\n  //       }),\n  //     }) as any;\n  //   };\n  extend(augmentation) {\n    return new _ZodObject({\n      ...this._def,\n      shape: () => ({\n        ...this._def.shape(),\n        ...augmentation\n      })\n    });\n  }\n  /**\n   * Prior to zod@1.0.12 there was a bug in the\n   * inferred type of merged objects. Please\n   * upgrade if you are experiencing issues.\n   */\n  merge(merging) {\n    const merged = new _ZodObject({\n      unknownKeys: merging._def.unknownKeys,\n      catchall: merging._def.catchall,\n      shape: () => ({\n        ...this._def.shape(),\n        ...merging._def.shape()\n      }),\n      typeName: ZodFirstPartyTypeKind.ZodObject\n    });\n    return merged;\n  }\n  // merge<\n  //   Incoming extends AnyZodObject,\n  //   Augmentation extends Incoming[\"shape\"],\n  //   NewOutput extends {\n  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n  //       ? Augmentation[k][\"_output\"]\n  //       : k extends keyof Output\n  //       ? Output[k]\n  //       : never;\n  //   },\n  //   NewInput extends {\n  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n  //       ? Augmentation[k][\"_input\"]\n  //       : k extends keyof Input\n  //       ? Input[k]\n  //       : never;\n  //   }\n  // >(\n  //   merging: Incoming\n  // ): ZodObject<\n  //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n  //   Incoming[\"_def\"][\"unknownKeys\"],\n  //   Incoming[\"_def\"][\"catchall\"],\n  //   NewOutput,\n  //   NewInput\n  // > {\n  //   const merged: any = new ZodObject({\n  //     unknownKeys: merging._def.unknownKeys,\n  //     catchall: merging._def.catchall,\n  //     shape: () =>\n  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n  //     typeName: ZodFirstPartyTypeKind.ZodObject,\n  //   }) as any;\n  //   return merged;\n  // }\n  setKey(key, schema) {\n    return this.augment({\n      [key]: schema\n    });\n  }\n  // merge<Incoming extends AnyZodObject>(\n  //   merging: Incoming\n  // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\n  // ZodObject<\n  //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n  //   Incoming[\"_def\"][\"unknownKeys\"],\n  //   Incoming[\"_def\"][\"catchall\"]\n  // > {\n  //   // const mergedShape = objectUtil.mergeShapes(\n  //   //   this._def.shape(),\n  //   //   merging._def.shape()\n  //   // );\n  //   const merged: any = new ZodObject({\n  //     unknownKeys: merging._def.unknownKeys,\n  //     catchall: merging._def.catchall,\n  //     shape: () =>\n  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n  //     typeName: ZodFirstPartyTypeKind.ZodObject,\n  //   }) as any;\n  //   return merged;\n  // }\n  catchall(index) {\n    return new _ZodObject({\n      ...this._def,\n      catchall: index\n    });\n  }\n  pick(mask) {\n    const shape = {};\n    for (const key of util.objectKeys(mask)) {\n      if (mask[key] && this.shape[key]) {\n        shape[key] = this.shape[key];\n      }\n    }\n    return new _ZodObject({\n      ...this._def,\n      shape: () => shape\n    });\n  }\n  omit(mask) {\n    const shape = {};\n    for (const key of util.objectKeys(this.shape)) {\n      if (!mask[key]) {\n        shape[key] = this.shape[key];\n      }\n    }\n    return new _ZodObject({\n      ...this._def,\n      shape: () => shape\n    });\n  }\n  /**\n   * @deprecated\n   */\n  deepPartial() {\n    return deepPartialify(this);\n  }\n  partial(mask) {\n    const newShape = {};\n    for (const key of util.objectKeys(this.shape)) {\n      const fieldSchema = this.shape[key];\n      if (mask && !mask[key]) {\n        newShape[key] = fieldSchema;\n      } else {\n        newShape[key] = fieldSchema.optional();\n      }\n    }\n    return new _ZodObject({\n      ...this._def,\n      shape: () => newShape\n    });\n  }\n  required(mask) {\n    const newShape = {};\n    for (const key of util.objectKeys(this.shape)) {\n      if (mask && !mask[key]) {\n        newShape[key] = this.shape[key];\n      } else {\n        const fieldSchema = this.shape[key];\n        let newField = fieldSchema;\n        while (newField instanceof ZodOptional) {\n          newField = newField._def.innerType;\n        }\n        newShape[key] = newField;\n      }\n    }\n    return new _ZodObject({\n      ...this._def,\n      shape: () => newShape\n    });\n  }\n  keyof() {\n    return createZodEnum(util.objectKeys(this.shape));\n  }\n};\nZodObject.create = (shape, params) => {\n  return new ZodObject({\n    shape: () => shape,\n    unknownKeys: \"strip\",\n    catchall: ZodNever.create(),\n    typeName: ZodFirstPartyTypeKind.ZodObject,\n    ...processCreateParams(params)\n  });\n};\nZodObject.strictCreate = (shape, params) => {\n  return new ZodObject({\n    shape: () => shape,\n    unknownKeys: \"strict\",\n    catchall: ZodNever.create(),\n    typeName: ZodFirstPartyTypeKind.ZodObject,\n    ...processCreateParams(params)\n  });\n};\nZodObject.lazycreate = (shape, params) => {\n  return new ZodObject({\n    shape,\n    unknownKeys: \"strip\",\n    catchall: ZodNever.create(),\n    typeName: ZodFirstPartyTypeKind.ZodObject,\n    ...processCreateParams(params)\n  });\n};\nvar ZodUnion = class extends ZodType {\n  _parse(input) {\n    const {\n      ctx\n    } = this._processInputParams(input);\n    const options = this._def.options;\n    function handleResults(results) {\n      for (const result of results) {\n        if (result.result.status === \"valid\") {\n          return result.result;\n        }\n      }\n      for (const result of results) {\n        if (result.result.status === \"dirty\") {\n          ctx.common.issues.push(...result.ctx.common.issues);\n          return result.result;\n        }\n      }\n      const unionErrors = results.map(result => new ZodError(result.ctx.common.issues));\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_union,\n        unionErrors\n      });\n      return INVALID;\n    }\n    if (ctx.common.async) {\n      return Promise.all(options.map(async option => {\n        const childCtx = {\n          ...ctx,\n          common: {\n            ...ctx.common,\n            issues: []\n          },\n          parent: null\n        };\n        return {\n          result: await option._parseAsync({\n            data: ctx.data,\n            path: ctx.path,\n            parent: childCtx\n          }),\n          ctx: childCtx\n        };\n      })).then(handleResults);\n    } else {\n      let dirty = void 0;\n      const issues = [];\n      for (const option of options) {\n        const childCtx = {\n          ...ctx,\n          common: {\n            ...ctx.common,\n            issues: []\n          },\n          parent: null\n        };\n        const result = option._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: childCtx\n        });\n        if (result.status === \"valid\") {\n          return result;\n        } else if (result.status === \"dirty\" && !dirty) {\n          dirty = {\n            result,\n            ctx: childCtx\n          };\n        }\n        if (childCtx.common.issues.length) {\n          issues.push(childCtx.common.issues);\n        }\n      }\n      if (dirty) {\n        ctx.common.issues.push(...dirty.ctx.common.issues);\n        return dirty.result;\n      }\n      const unionErrors = issues.map(issues2 => new ZodError(issues2));\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_union,\n        unionErrors\n      });\n      return INVALID;\n    }\n  }\n  get options() {\n    return this._def.options;\n  }\n};\nZodUnion.create = (types, params) => {\n  return new ZodUnion({\n    options: types,\n    typeName: ZodFirstPartyTypeKind.ZodUnion,\n    ...processCreateParams(params)\n  });\n};\nvar getDiscriminator = type => {\n  if (type instanceof ZodLazy) {\n    return getDiscriminator(type.schema);\n  } else if (type instanceof ZodEffects) {\n    return getDiscriminator(type.innerType());\n  } else if (type instanceof ZodLiteral) {\n    return [type.value];\n  } else if (type instanceof ZodEnum) {\n    return type.options;\n  } else if (type instanceof ZodNativeEnum) {\n    return util.objectValues(type.enum);\n  } else if (type instanceof ZodDefault) {\n    return getDiscriminator(type._def.innerType);\n  } else if (type instanceof ZodUndefined) {\n    return [void 0];\n  } else if (type instanceof ZodNull) {\n    return [null];\n  } else if (type instanceof ZodOptional) {\n    return [void 0, ...getDiscriminator(type.unwrap())];\n  } else if (type instanceof ZodNullable) {\n    return [null, ...getDiscriminator(type.unwrap())];\n  } else if (type instanceof ZodBranded) {\n    return getDiscriminator(type.unwrap());\n  } else if (type instanceof ZodReadonly) {\n    return getDiscriminator(type.unwrap());\n  } else if (type instanceof ZodCatch) {\n    return getDiscriminator(type._def.innerType);\n  } else {\n    return [];\n  }\n};\nvar ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {\n  _parse(input) {\n    const {\n      ctx\n    } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.object) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const discriminator = this.discriminator;\n    const discriminatorValue = ctx.data[discriminator];\n    const option = this.optionsMap.get(discriminatorValue);\n    if (!option) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_union_discriminator,\n        options: Array.from(this.optionsMap.keys()),\n        path: [discriminator]\n      });\n      return INVALID;\n    }\n    if (ctx.common.async) {\n      return option._parseAsync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      });\n    } else {\n      return option._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      });\n    }\n  }\n  get discriminator() {\n    return this._def.discriminator;\n  }\n  get options() {\n    return this._def.options;\n  }\n  get optionsMap() {\n    return this._def.optionsMap;\n  }\n  /**\n   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n   * have a different value for each object in the union.\n   * @param discriminator the name of the discriminator property\n   * @param types an array of object schemas\n   * @param params\n   */\n  static create(discriminator, options, params) {\n    const optionsMap = /* @__PURE__ */new Map();\n    for (const type of options) {\n      const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n      if (!discriminatorValues.length) {\n        throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\n      }\n      for (const value of discriminatorValues) {\n        if (optionsMap.has(value)) {\n          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n        }\n        optionsMap.set(value, type);\n      }\n    }\n    return new _ZodDiscriminatedUnion({\n      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n      discriminator,\n      options,\n      optionsMap,\n      ...processCreateParams(params)\n    });\n  }\n};\nfunction mergeValues(a, b) {\n  const aType = getParsedType(a);\n  const bType = getParsedType(b);\n  if (a === b) {\n    return {\n      valid: true,\n      data: a\n    };\n  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\n    const bKeys = util.objectKeys(b);\n    const sharedKeys = util.objectKeys(a).filter(key => bKeys.indexOf(key) !== -1);\n    const newObj = {\n      ...a,\n      ...b\n    };\n    for (const key of sharedKeys) {\n      const sharedValue = mergeValues(a[key], b[key]);\n      if (!sharedValue.valid) {\n        return {\n          valid: false\n        };\n      }\n      newObj[key] = sharedValue.data;\n    }\n    return {\n      valid: true,\n      data: newObj\n    };\n  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\n    if (a.length !== b.length) {\n      return {\n        valid: false\n      };\n    }\n    const newArray = [];\n    for (let index = 0; index < a.length; index++) {\n      const itemA = a[index];\n      const itemB = b[index];\n      const sharedValue = mergeValues(itemA, itemB);\n      if (!sharedValue.valid) {\n        return {\n          valid: false\n        };\n      }\n      newArray.push(sharedValue.data);\n    }\n    return {\n      valid: true,\n      data: newArray\n    };\n  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {\n    return {\n      valid: true,\n      data: a\n    };\n  } else {\n    return {\n      valid: false\n    };\n  }\n}\nvar ZodIntersection = class extends ZodType {\n  _parse(input) {\n    const {\n      status,\n      ctx\n    } = this._processInputParams(input);\n    const handleParsed = (parsedLeft, parsedRight) => {\n      if (isAborted(parsedLeft) || isAborted(parsedRight)) {\n        return INVALID;\n      }\n      const merged = mergeValues(parsedLeft.value, parsedRight.value);\n      if (!merged.valid) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.invalid_intersection_types\n        });\n        return INVALID;\n      }\n      if (isDirty(parsedLeft) || isDirty(parsedRight)) {\n        status.dirty();\n      }\n      return {\n        status: status.value,\n        value: merged.data\n      };\n    };\n    if (ctx.common.async) {\n      return Promise.all([this._def.left._parseAsync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      }), this._def.right._parseAsync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      })]).then(([left, right]) => handleParsed(left, right));\n    } else {\n      return handleParsed(this._def.left._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      }), this._def.right._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      }));\n    }\n  }\n};\nZodIntersection.create = (left, right, params) => {\n  return new ZodIntersection({\n    left,\n    right,\n    typeName: ZodFirstPartyTypeKind.ZodIntersection,\n    ...processCreateParams(params)\n  });\n};\nvar ZodTuple = class _ZodTuple extends ZodType {\n  _parse(input) {\n    const {\n      status,\n      ctx\n    } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.array) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.array,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    if (ctx.data.length < this._def.items.length) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.too_small,\n        minimum: this._def.items.length,\n        inclusive: true,\n        exact: false,\n        type: \"array\"\n      });\n      return INVALID;\n    }\n    const rest = this._def.rest;\n    if (!rest && ctx.data.length > this._def.items.length) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.too_big,\n        maximum: this._def.items.length,\n        inclusive: true,\n        exact: false,\n        type: \"array\"\n      });\n      status.dirty();\n    }\n    const items = [...ctx.data].map((item, itemIndex) => {\n      const schema = this._def.items[itemIndex] || this._def.rest;\n      if (!schema) return null;\n      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n    }).filter(x => !!x);\n    if (ctx.common.async) {\n      return Promise.all(items).then(results => {\n        return ParseStatus.mergeArray(status, results);\n      });\n    } else {\n      return ParseStatus.mergeArray(status, items);\n    }\n  }\n  get items() {\n    return this._def.items;\n  }\n  rest(rest) {\n    return new _ZodTuple({\n      ...this._def,\n      rest\n    });\n  }\n};\nZodTuple.create = (schemas, params) => {\n  if (!Array.isArray(schemas)) {\n    throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n  }\n  return new ZodTuple({\n    items: schemas,\n    typeName: ZodFirstPartyTypeKind.ZodTuple,\n    rest: null,\n    ...processCreateParams(params)\n  });\n};\nvar ZodRecord = class _ZodRecord extends ZodType {\n  get keySchema() {\n    return this._def.keyType;\n  }\n  get valueSchema() {\n    return this._def.valueType;\n  }\n  _parse(input) {\n    const {\n      status,\n      ctx\n    } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.object) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const pairs = [];\n    const keyType = this._def.keyType;\n    const valueType = this._def.valueType;\n    for (const key in ctx.data) {\n      pairs.push({\n        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n        alwaysSet: key in ctx.data\n      });\n    }\n    if (ctx.common.async) {\n      return ParseStatus.mergeObjectAsync(status, pairs);\n    } else {\n      return ParseStatus.mergeObjectSync(status, pairs);\n    }\n  }\n  get element() {\n    return this._def.valueType;\n  }\n  static create(first, second, third) {\n    if (second instanceof ZodType) {\n      return new _ZodRecord({\n        keyType: first,\n        valueType: second,\n        typeName: ZodFirstPartyTypeKind.ZodRecord,\n        ...processCreateParams(third)\n      });\n    }\n    return new _ZodRecord({\n      keyType: ZodString.create(),\n      valueType: first,\n      typeName: ZodFirstPartyTypeKind.ZodRecord,\n      ...processCreateParams(second)\n    });\n  }\n};\nvar ZodMap = class extends ZodType {\n  get keySchema() {\n    return this._def.keyType;\n  }\n  get valueSchema() {\n    return this._def.valueType;\n  }\n  _parse(input) {\n    const {\n      status,\n      ctx\n    } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.map) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.map,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const keyType = this._def.keyType;\n    const valueType = this._def.valueType;\n    const pairs = [...ctx.data.entries()].map(([key, value], index) => {\n      return {\n        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, \"key\"])),\n        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, \"value\"]))\n      };\n    });\n    if (ctx.common.async) {\n      const finalMap = /* @__PURE__ */new Map();\n      return Promise.resolve().then(async () => {\n        for (const pair of pairs) {\n          const key = await pair.key;\n          const value = await pair.value;\n          if (key.status === \"aborted\" || value.status === \"aborted\") {\n            return INVALID;\n          }\n          if (key.status === \"dirty\" || value.status === \"dirty\") {\n            status.dirty();\n          }\n          finalMap.set(key.value, value.value);\n        }\n        return {\n          status: status.value,\n          value: finalMap\n        };\n      });\n    } else {\n      const finalMap = /* @__PURE__ */new Map();\n      for (const pair of pairs) {\n        const key = pair.key;\n        const value = pair.value;\n        if (key.status === \"aborted\" || value.status === \"aborted\") {\n          return INVALID;\n        }\n        if (key.status === \"dirty\" || value.status === \"dirty\") {\n          status.dirty();\n        }\n        finalMap.set(key.value, value.value);\n      }\n      return {\n        status: status.value,\n        value: finalMap\n      };\n    }\n  }\n};\nZodMap.create = (keyType, valueType, params) => {\n  return new ZodMap({\n    valueType,\n    keyType,\n    typeName: ZodFirstPartyTypeKind.ZodMap,\n    ...processCreateParams(params)\n  });\n};\nvar ZodSet = class _ZodSet extends ZodType {\n  _parse(input) {\n    const {\n      status,\n      ctx\n    } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.set) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.set,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const def = this._def;\n    if (def.minSize !== null) {\n      if (ctx.data.size < def.minSize.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_small,\n          minimum: def.minSize.value,\n          type: \"set\",\n          inclusive: true,\n          exact: false,\n          message: def.minSize.message\n        });\n        status.dirty();\n      }\n    }\n    if (def.maxSize !== null) {\n      if (ctx.data.size > def.maxSize.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_big,\n          maximum: def.maxSize.value,\n          type: \"set\",\n          inclusive: true,\n          exact: false,\n          message: def.maxSize.message\n        });\n        status.dirty();\n      }\n    }\n    const valueType = this._def.valueType;\n    function finalizeSet(elements2) {\n      const parsedSet = /* @__PURE__ */new Set();\n      for (const element of elements2) {\n        if (element.status === \"aborted\") return INVALID;\n        if (element.status === \"dirty\") status.dirty();\n        parsedSet.add(element.value);\n      }\n      return {\n        status: status.value,\n        value: parsedSet\n      };\n    }\n    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n    if (ctx.common.async) {\n      return Promise.all(elements).then(elements2 => finalizeSet(elements2));\n    } else {\n      return finalizeSet(elements);\n    }\n  }\n  min(minSize, message) {\n    return new _ZodSet({\n      ...this._def,\n      minSize: {\n        value: minSize,\n        message: errorUtil.toString(message)\n      }\n    });\n  }\n  max(maxSize, message) {\n    return new _ZodSet({\n      ...this._def,\n      maxSize: {\n        value: maxSize,\n        message: errorUtil.toString(message)\n      }\n    });\n  }\n  size(size, message) {\n    return this.min(size, message).max(size, message);\n  }\n  nonempty(message) {\n    return this.min(1, message);\n  }\n};\nZodSet.create = (valueType, params) => {\n  return new ZodSet({\n    valueType,\n    minSize: null,\n    maxSize: null,\n    typeName: ZodFirstPartyTypeKind.ZodSet,\n    ...processCreateParams(params)\n  });\n};\nvar ZodFunction = class _ZodFunction extends ZodType {\n  constructor() {\n    super(...arguments);\n    this.validate = this.implement;\n  }\n  _parse(input) {\n    const {\n      ctx\n    } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.function) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.function,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    function makeArgsIssue(args, error40) {\n      return makeIssue({\n        data: args,\n        path: ctx.path,\n        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter(x => !!x),\n        issueData: {\n          code: ZodIssueCode.invalid_arguments,\n          argumentsError: error40\n        }\n      });\n    }\n    function makeReturnsIssue(returns, error40) {\n      return makeIssue({\n        data: returns,\n        path: ctx.path,\n        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter(x => !!x),\n        issueData: {\n          code: ZodIssueCode.invalid_return_type,\n          returnTypeError: error40\n        }\n      });\n    }\n    const params = {\n      errorMap: ctx.common.contextualErrorMap\n    };\n    const fn = ctx.data;\n    if (this._def.returns instanceof ZodPromise) {\n      const me = this;\n      return OK(async function (...args) {\n        const error40 = new ZodError([]);\n        const parsedArgs = await me._def.args.parseAsync(args, params).catch(e => {\n          error40.addIssue(makeArgsIssue(args, e));\n          throw error40;\n        });\n        const result = await Reflect.apply(fn, this, parsedArgs);\n        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch(e => {\n          error40.addIssue(makeReturnsIssue(result, e));\n          throw error40;\n        });\n        return parsedReturns;\n      });\n    } else {\n      const me = this;\n      return OK(function (...args) {\n        const parsedArgs = me._def.args.safeParse(args, params);\n        if (!parsedArgs.success) {\n          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);\n        }\n        const result = Reflect.apply(fn, this, parsedArgs.data);\n        const parsedReturns = me._def.returns.safeParse(result, params);\n        if (!parsedReturns.success) {\n          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);\n        }\n        return parsedReturns.data;\n      });\n    }\n  }\n  parameters() {\n    return this._def.args;\n  }\n  returnType() {\n    return this._def.returns;\n  }\n  args(...items) {\n    return new _ZodFunction({\n      ...this._def,\n      args: ZodTuple.create(items).rest(ZodUnknown.create())\n    });\n  }\n  returns(returnType) {\n    return new _ZodFunction({\n      ...this._def,\n      returns: returnType\n    });\n  }\n  implement(func) {\n    const validatedFunc = this.parse(func);\n    return validatedFunc;\n  }\n  strictImplement(func) {\n    const validatedFunc = this.parse(func);\n    return validatedFunc;\n  }\n  static create(args, returns, params) {\n    return new _ZodFunction({\n      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),\n      returns: returns || ZodUnknown.create(),\n      typeName: ZodFirstPartyTypeKind.ZodFunction,\n      ...processCreateParams(params)\n    });\n  }\n};\nvar ZodLazy = class extends ZodType {\n  get schema() {\n    return this._def.getter();\n  }\n  _parse(input) {\n    const {\n      ctx\n    } = this._processInputParams(input);\n    const lazySchema = this._def.getter();\n    return lazySchema._parse({\n      data: ctx.data,\n      path: ctx.path,\n      parent: ctx\n    });\n  }\n};\nZodLazy.create = (getter, params) => {\n  return new ZodLazy({\n    getter,\n    typeName: ZodFirstPartyTypeKind.ZodLazy,\n    ...processCreateParams(params)\n  });\n};\nvar ZodLiteral = class extends ZodType {\n  _parse(input) {\n    if (input.data !== this._def.value) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        received: ctx.data,\n        code: ZodIssueCode.invalid_literal,\n        expected: this._def.value\n      });\n      return INVALID;\n    }\n    return {\n      status: \"valid\",\n      value: input.data\n    };\n  }\n  get value() {\n    return this._def.value;\n  }\n};\nZodLiteral.create = (value, params) => {\n  return new ZodLiteral({\n    value,\n    typeName: ZodFirstPartyTypeKind.ZodLiteral,\n    ...processCreateParams(params)\n  });\n};\nfunction createZodEnum(values, params) {\n  return new ZodEnum({\n    values,\n    typeName: ZodFirstPartyTypeKind.ZodEnum,\n    ...processCreateParams(params)\n  });\n}\nvar ZodEnum = class _ZodEnum extends ZodType {\n  _parse(input) {\n    if (typeof input.data !== \"string\") {\n      const ctx = this._getOrReturnCtx(input);\n      const expectedValues = this._def.values;\n      addIssueToContext(ctx, {\n        expected: util.joinValues(expectedValues),\n        received: ctx.parsedType,\n        code: ZodIssueCode.invalid_type\n      });\n      return INVALID;\n    }\n    if (!this._cache) {\n      this._cache = new Set(this._def.values);\n    }\n    if (!this._cache.has(input.data)) {\n      const ctx = this._getOrReturnCtx(input);\n      const expectedValues = this._def.values;\n      addIssueToContext(ctx, {\n        received: ctx.data,\n        code: ZodIssueCode.invalid_enum_value,\n        options: expectedValues\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n  get options() {\n    return this._def.values;\n  }\n  get enum() {\n    const enumValues = {};\n    for (const val of this._def.values) {\n      enumValues[val] = val;\n    }\n    return enumValues;\n  }\n  get Values() {\n    const enumValues = {};\n    for (const val of this._def.values) {\n      enumValues[val] = val;\n    }\n    return enumValues;\n  }\n  get Enum() {\n    const enumValues = {};\n    for (const val of this._def.values) {\n      enumValues[val] = val;\n    }\n    return enumValues;\n  }\n  extract(values, newDef = this._def) {\n    return _ZodEnum.create(values, {\n      ...this._def,\n      ...newDef\n    });\n  }\n  exclude(values, newDef = this._def) {\n    return _ZodEnum.create(this.options.filter(opt => !values.includes(opt)), {\n      ...this._def,\n      ...newDef\n    });\n  }\n};\nZodEnum.create = createZodEnum;\nvar ZodNativeEnum = class extends ZodType {\n  _parse(input) {\n    const nativeEnumValues = util.getValidEnumValues(this._def.values);\n    const ctx = this._getOrReturnCtx(input);\n    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {\n      const expectedValues = util.objectValues(nativeEnumValues);\n      addIssueToContext(ctx, {\n        expected: util.joinValues(expectedValues),\n        received: ctx.parsedType,\n        code: ZodIssueCode.invalid_type\n      });\n      return INVALID;\n    }\n    if (!this._cache) {\n      this._cache = new Set(util.getValidEnumValues(this._def.values));\n    }\n    if (!this._cache.has(input.data)) {\n      const expectedValues = util.objectValues(nativeEnumValues);\n      addIssueToContext(ctx, {\n        received: ctx.data,\n        code: ZodIssueCode.invalid_enum_value,\n        options: expectedValues\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n  get enum() {\n    return this._def.values;\n  }\n};\nZodNativeEnum.create = (values, params) => {\n  return new ZodNativeEnum({\n    values,\n    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n    ...processCreateParams(params)\n  });\n};\nvar ZodPromise = class extends ZodType {\n  unwrap() {\n    return this._def.type;\n  }\n  _parse(input) {\n    const {\n      ctx\n    } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.promise,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);\n    return OK(promisified.then(data => {\n      return this._def.type.parseAsync(data, {\n        path: ctx.path,\n        errorMap: ctx.common.contextualErrorMap\n      });\n    }));\n  }\n};\nZodPromise.create = (schema, params) => {\n  return new ZodPromise({\n    type: schema,\n    typeName: ZodFirstPartyTypeKind.ZodPromise,\n    ...processCreateParams(params)\n  });\n};\nvar ZodEffects = class extends ZodType {\n  innerType() {\n    return this._def.schema;\n  }\n  sourceType() {\n    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;\n  }\n  _parse(input) {\n    const {\n      status,\n      ctx\n    } = this._processInputParams(input);\n    const effect = this._def.effect || null;\n    const checkCtx = {\n      addIssue: arg => {\n        addIssueToContext(ctx, arg);\n        if (arg.fatal) {\n          status.abort();\n        } else {\n          status.dirty();\n        }\n      },\n      get path() {\n        return ctx.path;\n      }\n    };\n    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n    if (effect.type === \"preprocess\") {\n      const processed = effect.transform(ctx.data, checkCtx);\n      if (ctx.common.async) {\n        return Promise.resolve(processed).then(async processed2 => {\n          if (status.value === \"aborted\") return INVALID;\n          const result = await this._def.schema._parseAsync({\n            data: processed2,\n            path: ctx.path,\n            parent: ctx\n          });\n          if (result.status === \"aborted\") return INVALID;\n          if (result.status === \"dirty\") return DIRTY(result.value);\n          if (status.value === \"dirty\") return DIRTY(result.value);\n          return result;\n        });\n      } else {\n        if (status.value === \"aborted\") return INVALID;\n        const result = this._def.schema._parseSync({\n          data: processed,\n          path: ctx.path,\n          parent: ctx\n        });\n        if (result.status === \"aborted\") return INVALID;\n        if (result.status === \"dirty\") return DIRTY(result.value);\n        if (status.value === \"dirty\") return DIRTY(result.value);\n        return result;\n      }\n    }\n    if (effect.type === \"refinement\") {\n      const executeRefinement = acc => {\n        const result = effect.refinement(acc, checkCtx);\n        if (ctx.common.async) {\n          return Promise.resolve(result);\n        }\n        if (result instanceof Promise) {\n          throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n        }\n        return acc;\n      };\n      if (ctx.common.async === false) {\n        const inner = this._def.schema._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        });\n        if (inner.status === \"aborted\") return INVALID;\n        if (inner.status === \"dirty\") status.dirty();\n        executeRefinement(inner.value);\n        return {\n          status: status.value,\n          value: inner.value\n        };\n      } else {\n        return this._def.schema._parseAsync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        }).then(inner => {\n          if (inner.status === \"aborted\") return INVALID;\n          if (inner.status === \"dirty\") status.dirty();\n          return executeRefinement(inner.value).then(() => {\n            return {\n              status: status.value,\n              value: inner.value\n            };\n          });\n        });\n      }\n    }\n    if (effect.type === \"transform\") {\n      if (ctx.common.async === false) {\n        const base = this._def.schema._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        });\n        if (!isValid(base)) return INVALID;\n        const result = effect.transform(base.value, checkCtx);\n        if (result instanceof Promise) {\n          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\n        }\n        return {\n          status: status.value,\n          value: result\n        };\n      } else {\n        return this._def.schema._parseAsync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        }).then(base => {\n          if (!isValid(base)) return INVALID;\n          return Promise.resolve(effect.transform(base.value, checkCtx)).then(result => ({\n            status: status.value,\n            value: result\n          }));\n        });\n      }\n    }\n    util.assertNever(effect);\n  }\n};\nZodEffects.create = (schema, effect, params) => {\n  return new ZodEffects({\n    schema,\n    typeName: ZodFirstPartyTypeKind.ZodEffects,\n    effect,\n    ...processCreateParams(params)\n  });\n};\nZodEffects.createWithPreprocess = (preprocess2, schema, params) => {\n  return new ZodEffects({\n    schema,\n    effect: {\n      type: \"preprocess\",\n      transform: preprocess2\n    },\n    typeName: ZodFirstPartyTypeKind.ZodEffects,\n    ...processCreateParams(params)\n  });\n};\nvar ZodOptional = class extends ZodType {\n  _parse(input) {\n    const parsedType4 = this._getType(input);\n    if (parsedType4 === ZodParsedType.undefined) {\n      return OK(void 0);\n    }\n    return this._def.innerType._parse(input);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n};\nZodOptional.create = (type, params) => {\n  return new ZodOptional({\n    innerType: type,\n    typeName: ZodFirstPartyTypeKind.ZodOptional,\n    ...processCreateParams(params)\n  });\n};\nvar ZodNullable = class extends ZodType {\n  _parse(input) {\n    const parsedType4 = this._getType(input);\n    if (parsedType4 === ZodParsedType.null) {\n      return OK(null);\n    }\n    return this._def.innerType._parse(input);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n};\nZodNullable.create = (type, params) => {\n  return new ZodNullable({\n    innerType: type,\n    typeName: ZodFirstPartyTypeKind.ZodNullable,\n    ...processCreateParams(params)\n  });\n};\nvar ZodDefault = class extends ZodType {\n  _parse(input) {\n    const {\n      ctx\n    } = this._processInputParams(input);\n    let data = ctx.data;\n    if (ctx.parsedType === ZodParsedType.undefined) {\n      data = this._def.defaultValue();\n    }\n    return this._def.innerType._parse({\n      data,\n      path: ctx.path,\n      parent: ctx\n    });\n  }\n  removeDefault() {\n    return this._def.innerType;\n  }\n};\nZodDefault.create = (type, params) => {\n  return new ZodDefault({\n    innerType: type,\n    typeName: ZodFirstPartyTypeKind.ZodDefault,\n    defaultValue: typeof params.default === \"function\" ? params.default : () => params.default,\n    ...processCreateParams(params)\n  });\n};\nvar ZodCatch = class extends ZodType {\n  _parse(input) {\n    const {\n      ctx\n    } = this._processInputParams(input);\n    const newCtx = {\n      ...ctx,\n      common: {\n        ...ctx.common,\n        issues: []\n      }\n    };\n    const result = this._def.innerType._parse({\n      data: newCtx.data,\n      path: newCtx.path,\n      parent: {\n        ...newCtx\n      }\n    });\n    if (isAsync(result)) {\n      return result.then(result2 => {\n        return {\n          status: \"valid\",\n          value: result2.status === \"valid\" ? result2.value : this._def.catchValue({\n            get error() {\n              return new ZodError(newCtx.common.issues);\n            },\n            input: newCtx.data\n          })\n        };\n      });\n    } else {\n      return {\n        status: \"valid\",\n        value: result.status === \"valid\" ? result.value : this._def.catchValue({\n          get error() {\n            return new ZodError(newCtx.common.issues);\n          },\n          input: newCtx.data\n        })\n      };\n    }\n  }\n  removeCatch() {\n    return this._def.innerType;\n  }\n};\nZodCatch.create = (type, params) => {\n  return new ZodCatch({\n    innerType: type,\n    typeName: ZodFirstPartyTypeKind.ZodCatch,\n    catchValue: typeof params.catch === \"function\" ? params.catch : () => params.catch,\n    ...processCreateParams(params)\n  });\n};\nvar ZodNaN = class extends ZodType {\n  _parse(input) {\n    const parsedType4 = this._getType(input);\n    if (parsedType4 !== ZodParsedType.nan) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.nan,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return {\n      status: \"valid\",\n      value: input.data\n    };\n  }\n};\nZodNaN.create = params => {\n  return new ZodNaN({\n    typeName: ZodFirstPartyTypeKind.ZodNaN,\n    ...processCreateParams(params)\n  });\n};\nvar BRAND = Symbol(\"zod_brand\");\nvar ZodBranded = class extends ZodType {\n  _parse(input) {\n    const {\n      ctx\n    } = this._processInputParams(input);\n    const data = ctx.data;\n    return this._def.type._parse({\n      data,\n      path: ctx.path,\n      parent: ctx\n    });\n  }\n  unwrap() {\n    return this._def.type;\n  }\n};\nvar ZodPipeline = class _ZodPipeline extends ZodType {\n  _parse(input) {\n    const {\n      status,\n      ctx\n    } = this._processInputParams(input);\n    if (ctx.common.async) {\n      const handleAsync = async () => {\n        const inResult = await this._def.in._parseAsync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        });\n        if (inResult.status === \"aborted\") return INVALID;\n        if (inResult.status === \"dirty\") {\n          status.dirty();\n          return DIRTY(inResult.value);\n        } else {\n          return this._def.out._parseAsync({\n            data: inResult.value,\n            path: ctx.path,\n            parent: ctx\n          });\n        }\n      };\n      return handleAsync();\n    } else {\n      const inResult = this._def.in._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      });\n      if (inResult.status === \"aborted\") return INVALID;\n      if (inResult.status === \"dirty\") {\n        status.dirty();\n        return {\n          status: \"dirty\",\n          value: inResult.value\n        };\n      } else {\n        return this._def.out._parseSync({\n          data: inResult.value,\n          path: ctx.path,\n          parent: ctx\n        });\n      }\n    }\n  }\n  static create(a, b) {\n    return new _ZodPipeline({\n      in: a,\n      out: b,\n      typeName: ZodFirstPartyTypeKind.ZodPipeline\n    });\n  }\n};\nvar ZodReadonly = class extends ZodType {\n  _parse(input) {\n    const result = this._def.innerType._parse(input);\n    const freeze = data => {\n      if (isValid(data)) {\n        data.value = Object.freeze(data.value);\n      }\n      return data;\n    };\n    return isAsync(result) ? result.then(data => freeze(data)) : freeze(result);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n};\nZodReadonly.create = (type, params) => {\n  return new ZodReadonly({\n    innerType: type,\n    typeName: ZodFirstPartyTypeKind.ZodReadonly,\n    ...processCreateParams(params)\n  });\n};\nfunction cleanParams(params, data) {\n  const p = typeof params === \"function\" ? params(data) : typeof params === \"string\" ? {\n    message: params\n  } : params;\n  const p2 = typeof p === \"string\" ? {\n    message: p\n  } : p;\n  return p2;\n}\nfunction custom(check2, _params = {}, fatal) {\n  if (check2) return ZodAny.create().superRefine((data, ctx) => {\n    const r2 = check2(data);\n    if (r2 instanceof Promise) {\n      return r2.then(r3 => {\n        if (!r3) {\n          const params = cleanParams(_params, data);\n          const _fatal = params.fatal ?? fatal ?? true;\n          ctx.addIssue({\n            code: \"custom\",\n            ...params,\n            fatal: _fatal\n          });\n        }\n      });\n    }\n    if (!r2) {\n      const params = cleanParams(_params, data);\n      const _fatal = params.fatal ?? fatal ?? true;\n      ctx.addIssue({\n        code: \"custom\",\n        ...params,\n        fatal: _fatal\n      });\n    }\n    return;\n  });\n  return ZodAny.create();\n}\nvar late = {\n  object: ZodObject.lazycreate\n};\nvar ZodFirstPartyTypeKind;\n(function (ZodFirstPartyTypeKind2) {\n  ZodFirstPartyTypeKind2[\"ZodString\"] = \"ZodString\";\n  ZodFirstPartyTypeKind2[\"ZodNumber\"] = \"ZodNumber\";\n  ZodFirstPartyTypeKind2[\"ZodNaN\"] = \"ZodNaN\";\n  ZodFirstPartyTypeKind2[\"ZodBigInt\"] = \"ZodBigInt\";\n  ZodFirstPartyTypeKind2[\"ZodBoolean\"] = \"ZodBoolean\";\n  ZodFirstPartyTypeKind2[\"ZodDate\"] = \"ZodDate\";\n  ZodFirstPartyTypeKind2[\"ZodSymbol\"] = \"ZodSymbol\";\n  ZodFirstPartyTypeKind2[\"ZodUndefined\"] = \"ZodUndefined\";\n  ZodFirstPartyTypeKind2[\"ZodNull\"] = \"ZodNull\";\n  ZodFirstPartyTypeKind2[\"ZodAny\"] = \"ZodAny\";\n  ZodFirstPartyTypeKind2[\"ZodUnknown\"] = \"ZodUnknown\";\n  ZodFirstPartyTypeKind2[\"ZodNever\"] = \"ZodNever\";\n  ZodFirstPartyTypeKind2[\"ZodVoid\"] = \"ZodVoid\";\n  ZodFirstPartyTypeKind2[\"ZodArray\"] = \"ZodArray\";\n  ZodFirstPartyTypeKind2[\"ZodObject\"] = \"ZodObject\";\n  ZodFirstPartyTypeKind2[\"ZodUnion\"] = \"ZodUnion\";\n  ZodFirstPartyTypeKind2[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\n  ZodFirstPartyTypeKind2[\"ZodIntersection\"] = \"ZodIntersection\";\n  ZodFirstPartyTypeKind2[\"ZodTuple\"] = \"ZodTuple\";\n  ZodFirstPartyTypeKind2[\"ZodRecord\"] = \"ZodRecord\";\n  ZodFirstPartyTypeKind2[\"ZodMap\"] = \"ZodMap\";\n  ZodFirstPartyTypeKind2[\"ZodSet\"] = \"ZodSet\";\n  ZodFirstPartyTypeKind2[\"ZodFunction\"] = \"ZodFunction\";\n  ZodFirstPartyTypeKind2[\"ZodLazy\"] = \"ZodLazy\";\n  ZodFirstPartyTypeKind2[\"ZodLiteral\"] = \"ZodLiteral\";\n  ZodFirstPartyTypeKind2[\"ZodEnum\"] = \"ZodEnum\";\n  ZodFirstPartyTypeKind2[\"ZodEffects\"] = \"ZodEffects\";\n  ZodFirstPartyTypeKind2[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\n  ZodFirstPartyTypeKind2[\"ZodOptional\"] = \"ZodOptional\";\n  ZodFirstPartyTypeKind2[\"ZodNullable\"] = \"ZodNullable\";\n  ZodFirstPartyTypeKind2[\"ZodDefault\"] = \"ZodDefault\";\n  ZodFirstPartyTypeKind2[\"ZodCatch\"] = \"ZodCatch\";\n  ZodFirstPartyTypeKind2[\"ZodPromise\"] = \"ZodPromise\";\n  ZodFirstPartyTypeKind2[\"ZodBranded\"] = \"ZodBranded\";\n  ZodFirstPartyTypeKind2[\"ZodPipeline\"] = \"ZodPipeline\";\n  ZodFirstPartyTypeKind2[\"ZodReadonly\"] = \"ZodReadonly\";\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\nvar instanceOfType = (cls, params = {\n  message: `Input not instance of ${cls.name}`\n}) => custom(data => data instanceof cls, params);\nvar stringType = ZodString.create;\nvar numberType = ZodNumber.create;\nvar nanType = ZodNaN.create;\nvar bigIntType = ZodBigInt.create;\nvar booleanType = ZodBoolean.create;\nvar dateType = ZodDate.create;\nvar symbolType = ZodSymbol.create;\nvar undefinedType = ZodUndefined.create;\nvar nullType = ZodNull.create;\nvar anyType = ZodAny.create;\nvar unknownType = ZodUnknown.create;\nvar neverType = ZodNever.create;\nvar voidType = ZodVoid.create;\nvar arrayType = ZodArray.create;\nvar objectType = ZodObject.create;\nvar strictObjectType = ZodObject.strictCreate;\nvar unionType = ZodUnion.create;\nvar discriminatedUnionType = ZodDiscriminatedUnion.create;\nvar intersectionType = ZodIntersection.create;\nvar tupleType = ZodTuple.create;\nvar recordType = ZodRecord.create;\nvar mapType = ZodMap.create;\nvar setType = ZodSet.create;\nvar functionType = ZodFunction.create;\nvar lazyType = ZodLazy.create;\nvar literalType = ZodLiteral.create;\nvar enumType = ZodEnum.create;\nvar nativeEnumType = ZodNativeEnum.create;\nvar promiseType = ZodPromise.create;\nvar effectsType = ZodEffects.create;\nvar optionalType = ZodOptional.create;\nvar nullableType = ZodNullable.create;\nvar preprocessType = ZodEffects.createWithPreprocess;\nvar pipelineType = ZodPipeline.create;\nvar ostring = () => stringType().optional();\nvar onumber = () => numberType().optional();\nvar oboolean = () => booleanType().optional();\nvar coerce = {\n  string: arg => ZodString.create({\n    ...arg,\n    coerce: true\n  }),\n  number: arg => ZodNumber.create({\n    ...arg,\n    coerce: true\n  }),\n  boolean: arg => ZodBoolean.create({\n    ...arg,\n    coerce: true\n  }),\n  bigint: arg => ZodBigInt.create({\n    ...arg,\n    coerce: true\n  }),\n  date: arg => ZodDate.create({\n    ...arg,\n    coerce: true\n  })\n};\nvar NEVER = INVALID;\n\n// ../../node_modules/zod/index.js\nvar zod_default = external_exports;\n\n// ../../node_modules/zod-to-json-schema/dist/esm/parsers/any.js\nfunction parseAnyDef(refs) {\n  if (refs.target !== \"openAi\") {\n    return {};\n  }\n  const anyDefinitionPath = [...refs.basePath, refs.definitionPath, refs.openAiAnyTypeName];\n  refs.flags.hasReferencedOpenAiAnyType = true;\n  return {\n    $ref: refs.$refStrategy === \"relative\" ? getRelativePath(anyDefinitionPath, refs.currentPath) : anyDefinitionPath.join(\"/\")\n  };\n}\n\n// ../../node_modules/zod-to-json-schema/dist/esm/parsers/array.js\nfunction parseArrayDef(def, refs) {\n  const res = {\n    type: \"array\"\n  };\n  if (def.type?._def && def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny) {\n    res.items = parseDef(def.type._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"items\"]\n    });\n  }\n  if (def.minLength) {\n    setResponseValueAndErrors(res, \"minItems\", def.minLength.value, def.minLength.message, refs);\n  }\n  if (def.maxLength) {\n    setResponseValueAndErrors(res, \"maxItems\", def.maxLength.value, def.maxLength.message, refs);\n  }\n  if (def.exactLength) {\n    setResponseValueAndErrors(res, \"minItems\", def.exactLength.value, def.exactLength.message, refs);\n    setResponseValueAndErrors(res, \"maxItems\", def.exactLength.value, def.exactLength.message, refs);\n  }\n  return res;\n}\n\n// ../../node_modules/zod-to-json-schema/dist/esm/parsers/bigint.js\nfunction parseBigintDef(def, refs) {\n  const res = {\n    type: \"integer\",\n    format: \"int64\"\n  };\n  if (!def.checks) return res;\n  for (const check2 of def.checks) {\n    switch (check2.kind) {\n      case \"min\":\n        if (refs.target === \"jsonSchema7\") {\n          if (check2.inclusive) {\n            setResponseValueAndErrors(res, \"minimum\", check2.value, check2.message, refs);\n          } else {\n            setResponseValueAndErrors(res, \"exclusiveMinimum\", check2.value, check2.message, refs);\n          }\n        } else {\n          if (!check2.inclusive) {\n            res.exclusiveMinimum = true;\n          }\n          setResponseValueAndErrors(res, \"minimum\", check2.value, check2.message, refs);\n        }\n        break;\n      case \"max\":\n        if (refs.target === \"jsonSchema7\") {\n          if (check2.inclusive) {\n            setResponseValueAndErrors(res, \"maximum\", check2.value, check2.message, refs);\n          } else {\n            setResponseValueAndErrors(res, \"exclusiveMaximum\", check2.value, check2.message, refs);\n          }\n        } else {\n          if (!check2.inclusive) {\n            res.exclusiveMaximum = true;\n          }\n          setResponseValueAndErrors(res, \"maximum\", check2.value, check2.message, refs);\n        }\n        break;\n      case \"multipleOf\":\n        setResponseValueAndErrors(res, \"multipleOf\", check2.value, check2.message, refs);\n        break;\n    }\n  }\n  return res;\n}\n\n// ../../node_modules/zod-to-json-schema/dist/esm/parsers/boolean.js\nfunction parseBooleanDef() {\n  return {\n    type: \"boolean\"\n  };\n}\n\n// ../../node_modules/zod-to-json-schema/dist/esm/parsers/branded.js\nfunction parseBrandedDef(_def, refs) {\n  return parseDef(_def.type._def, refs);\n}\n\n// ../../node_modules/zod-to-json-schema/dist/esm/parsers/catch.js\nvar parseCatchDef = (def, refs) => {\n  return parseDef(def.innerType._def, refs);\n};\n\n// ../../node_modules/zod-to-json-schema/dist/esm/parsers/date.js\nfunction parseDateDef(def, refs, overrideDateStrategy) {\n  const strategy = overrideDateStrategy ?? refs.dateStrategy;\n  if (Array.isArray(strategy)) {\n    return {\n      anyOf: strategy.map((item, i) => parseDateDef(def, refs, item))\n    };\n  }\n  switch (strategy) {\n    case \"string\":\n    case \"format:date-time\":\n      return {\n        type: \"string\",\n        format: \"date-time\"\n      };\n    case \"format:date\":\n      return {\n        type: \"string\",\n        format: \"date\"\n      };\n    case \"integer\":\n      return integerDateParser(def, refs);\n  }\n}\nvar integerDateParser = (def, refs) => {\n  const res = {\n    type: \"integer\",\n    format: \"unix-time\"\n  };\n  if (refs.target === \"openApi3\") {\n    return res;\n  }\n  for (const check2 of def.checks) {\n    switch (check2.kind) {\n      case \"min\":\n        setResponseValueAndErrors(res, \"minimum\", check2.value,\n        // This is in milliseconds\n        check2.message, refs);\n        break;\n      case \"max\":\n        setResponseValueAndErrors(res, \"maximum\", check2.value,\n        // This is in milliseconds\n        check2.message, refs);\n        break;\n    }\n  }\n  return res;\n};\n\n// ../../node_modules/zod-to-json-schema/dist/esm/parsers/default.js\nfunction parseDefaultDef(_def, refs) {\n  return {\n    ...parseDef(_def.innerType._def, refs),\n    default: _def.defaultValue()\n  };\n}\n\n// ../../node_modules/zod-to-json-schema/dist/esm/parsers/effects.js\nfunction parseEffectsDef(_def, refs) {\n  return refs.effectStrategy === \"input\" ? parseDef(_def.schema._def, refs) : parseAnyDef(refs);\n}\n\n// ../../node_modules/zod-to-json-schema/dist/esm/parsers/enum.js\nfunction parseEnumDef(def) {\n  return {\n    type: \"string\",\n    enum: Array.from(def.values)\n  };\n}\n\n// ../../node_modules/zod-to-json-schema/dist/esm/parsers/intersection.js\nvar isJsonSchema7AllOfType = type => {\n  if (\"type\" in type && type.type === \"string\") return false;\n  return \"allOf\" in type;\n};\nfunction parseIntersectionDef(def, refs) {\n  const allOf = [parseDef(def.left._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"allOf\", \"0\"]\n  }), parseDef(def.right._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"allOf\", \"1\"]\n  })].filter(x => !!x);\n  let unevaluatedProperties = refs.target === \"jsonSchema2019-09\" ? {\n    unevaluatedProperties: false\n  } : void 0;\n  const mergedAllOf = [];\n  allOf.forEach(schema => {\n    if (isJsonSchema7AllOfType(schema)) {\n      mergedAllOf.push(...schema.allOf);\n      if (schema.unevaluatedProperties === void 0) {\n        unevaluatedProperties = void 0;\n      }\n    } else {\n      let nestedSchema = schema;\n      if (\"additionalProperties\" in schema && schema.additionalProperties === false) {\n        const {\n          additionalProperties,\n          ...rest\n        } = schema;\n        nestedSchema = rest;\n      } else {\n        unevaluatedProperties = void 0;\n      }\n      mergedAllOf.push(nestedSchema);\n    }\n  });\n  return mergedAllOf.length ? {\n    allOf: mergedAllOf,\n    ...unevaluatedProperties\n  } : void 0;\n}\n\n// ../../node_modules/zod-to-json-schema/dist/esm/parsers/literal.js\nfunction parseLiteralDef(def, refs) {\n  const parsedType4 = typeof def.value;\n  if (parsedType4 !== \"bigint\" && parsedType4 !== \"number\" && parsedType4 !== \"boolean\" && parsedType4 !== \"string\") {\n    return {\n      type: Array.isArray(def.value) ? \"array\" : \"object\"\n    };\n  }\n  if (refs.target === \"openApi3\") {\n    return {\n      type: parsedType4 === \"bigint\" ? \"integer\" : parsedType4,\n      enum: [def.value]\n    };\n  }\n  return {\n    type: parsedType4 === \"bigint\" ? \"integer\" : parsedType4,\n    const: def.value\n  };\n}\n\n// ../../node_modules/zod-to-json-schema/dist/esm/parsers/string.js\nvar emojiRegex2 = void 0;\nvar zodPatterns = {\n  /**\n   * `c` was changed to `[cC]` to replicate /i flag\n   */\n  cuid: /^[cC][^\\s-]{8,}$/,\n  cuid2: /^[0-9a-z]+$/,\n  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,\n  /**\n   * `a-z` was added to replicate /i flag\n   */\n  email: /^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_'+\\-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$/,\n  /**\n   * Constructed a valid Unicode RegExp\n   *\n   * Lazily instantiate since this type of regex isn't supported\n   * in all envs (e.g. React Native).\n   *\n   * See:\n   * https://github.com/colinhacks/zod/issues/2433\n   * Fix in Zod:\n   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b\n   */\n  emoji: () => {\n    if (emojiRegex2 === void 0) {\n      emojiRegex2 = RegExp(\"^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$\", \"u\");\n    }\n    return emojiRegex2;\n  },\n  /**\n   * Unused\n   */\n  uuid: /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/,\n  /**\n   * Unused\n   */\n  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,\n  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/,\n  /**\n   * Unused\n   */\n  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,\n  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,\n  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,\n  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,\n  nanoid: /^[a-zA-Z0-9_-]{21}$/,\n  jwt: /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/\n};\nfunction parseStringDef(def, refs) {\n  const res = {\n    type: \"string\"\n  };\n  if (def.checks) {\n    for (const check2 of def.checks) {\n      switch (check2.kind) {\n        case \"min\":\n          setResponseValueAndErrors(res, \"minLength\", typeof res.minLength === \"number\" ? Math.max(res.minLength, check2.value) : check2.value, check2.message, refs);\n          break;\n        case \"max\":\n          setResponseValueAndErrors(res, \"maxLength\", typeof res.maxLength === \"number\" ? Math.min(res.maxLength, check2.value) : check2.value, check2.message, refs);\n          break;\n        case \"email\":\n          switch (refs.emailStrategy) {\n            case \"format:email\":\n              addFormat(res, \"email\", check2.message, refs);\n              break;\n            case \"format:idn-email\":\n              addFormat(res, \"idn-email\", check2.message, refs);\n              break;\n            case \"pattern:zod\":\n              addPattern(res, zodPatterns.email, check2.message, refs);\n              break;\n          }\n          break;\n        case \"url\":\n          addFormat(res, \"uri\", check2.message, refs);\n          break;\n        case \"uuid\":\n          addFormat(res, \"uuid\", check2.message, refs);\n          break;\n        case \"regex\":\n          addPattern(res, check2.regex, check2.message, refs);\n          break;\n        case \"cuid\":\n          addPattern(res, zodPatterns.cuid, check2.message, refs);\n          break;\n        case \"cuid2\":\n          addPattern(res, zodPatterns.cuid2, check2.message, refs);\n          break;\n        case \"startsWith\":\n          addPattern(res, RegExp(`^${escapeLiteralCheckValue(check2.value, refs)}`), check2.message, refs);\n          break;\n        case \"endsWith\":\n          addPattern(res, RegExp(`${escapeLiteralCheckValue(check2.value, refs)}$`), check2.message, refs);\n          break;\n        case \"datetime\":\n          addFormat(res, \"date-time\", check2.message, refs);\n          break;\n        case \"date\":\n          addFormat(res, \"date\", check2.message, refs);\n          break;\n        case \"time\":\n          addFormat(res, \"time\", check2.message, refs);\n          break;\n        case \"duration\":\n          addFormat(res, \"duration\", check2.message, refs);\n          break;\n        case \"length\":\n          setResponseValueAndErrors(res, \"minLength\", typeof res.minLength === \"number\" ? Math.max(res.minLength, check2.value) : check2.value, check2.message, refs);\n          setResponseValueAndErrors(res, \"maxLength\", typeof res.maxLength === \"number\" ? Math.min(res.maxLength, check2.value) : check2.value, check2.message, refs);\n          break;\n        case \"includes\":\n          {\n            addPattern(res, RegExp(escapeLiteralCheckValue(check2.value, refs)), check2.message, refs);\n            break;\n          }\n        case \"ip\":\n          {\n            if (check2.version !== \"v6\") {\n              addFormat(res, \"ipv4\", check2.message, refs);\n            }\n            if (check2.version !== \"v4\") {\n              addFormat(res, \"ipv6\", check2.message, refs);\n            }\n            break;\n          }\n        case \"base64url\":\n          addPattern(res, zodPatterns.base64url, check2.message, refs);\n          break;\n        case \"jwt\":\n          addPattern(res, zodPatterns.jwt, check2.message, refs);\n          break;\n        case \"cidr\":\n          {\n            if (check2.version !== \"v6\") {\n              addPattern(res, zodPatterns.ipv4Cidr, check2.message, refs);\n            }\n            if (check2.version !== \"v4\") {\n              addPattern(res, zodPatterns.ipv6Cidr, check2.message, refs);\n            }\n            break;\n          }\n        case \"emoji\":\n          addPattern(res, zodPatterns.emoji(), check2.message, refs);\n          break;\n        case \"ulid\":\n          {\n            addPattern(res, zodPatterns.ulid, check2.message, refs);\n            break;\n          }\n        case \"base64\":\n          {\n            switch (refs.base64Strategy) {\n              case \"format:binary\":\n                {\n                  addFormat(res, \"binary\", check2.message, refs);\n                  break;\n                }\n              case \"contentEncoding:base64\":\n                {\n                  setResponseValueAndErrors(res, \"contentEncoding\", \"base64\", check2.message, refs);\n                  break;\n                }\n              case \"pattern:zod\":\n                {\n                  addPattern(res, zodPatterns.base64, check2.message, refs);\n                  break;\n                }\n            }\n            break;\n          }\n        case \"nanoid\":\n          {\n            addPattern(res, zodPatterns.nanoid, check2.message, refs);\n          }\n        case \"toLowerCase\":\n        case \"toUpperCase\":\n        case \"trim\":\n          break;\n        default:\n          /* @__PURE__ */(_ => {})(check2);\n      }\n    }\n  }\n  return res;\n}\nfunction escapeLiteralCheckValue(literal2, refs) {\n  return refs.patternStrategy === \"escape\" ? escapeNonAlphaNumeric(literal2) : literal2;\n}\nvar ALPHA_NUMERIC = new Set(\"ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789\");\nfunction escapeNonAlphaNumeric(source) {\n  let result = \"\";\n  for (let i = 0; i < source.length; i++) {\n    if (!ALPHA_NUMERIC.has(source[i])) {\n      result += \"\\\\\";\n    }\n    result += source[i];\n  }\n  return result;\n}\nfunction addFormat(schema, value, message, refs) {\n  if (schema.format || schema.anyOf?.some(x => x.format)) {\n    if (!schema.anyOf) {\n      schema.anyOf = [];\n    }\n    if (schema.format) {\n      schema.anyOf.push({\n        format: schema.format,\n        ...(schema.errorMessage && refs.errorMessages && {\n          errorMessage: {\n            format: schema.errorMessage.format\n          }\n        })\n      });\n      delete schema.format;\n      if (schema.errorMessage) {\n        delete schema.errorMessage.format;\n        if (Object.keys(schema.errorMessage).length === 0) {\n          delete schema.errorMessage;\n        }\n      }\n    }\n    schema.anyOf.push({\n      format: value,\n      ...(message && refs.errorMessages && {\n        errorMessage: {\n          format: message\n        }\n      })\n    });\n  } else {\n    setResponseValueAndErrors(schema, \"format\", value, message, refs);\n  }\n}\nfunction addPattern(schema, regex, message, refs) {\n  if (schema.pattern || schema.allOf?.some(x => x.pattern)) {\n    if (!schema.allOf) {\n      schema.allOf = [];\n    }\n    if (schema.pattern) {\n      schema.allOf.push({\n        pattern: schema.pattern,\n        ...(schema.errorMessage && refs.errorMessages && {\n          errorMessage: {\n            pattern: schema.errorMessage.pattern\n          }\n        })\n      });\n      delete schema.pattern;\n      if (schema.errorMessage) {\n        delete schema.errorMessage.pattern;\n        if (Object.keys(schema.errorMessage).length === 0) {\n          delete schema.errorMessage;\n        }\n      }\n    }\n    schema.allOf.push({\n      pattern: stringifyRegExpWithFlags(regex, refs),\n      ...(message && refs.errorMessages && {\n        errorMessage: {\n          pattern: message\n        }\n      })\n    });\n  } else {\n    setResponseValueAndErrors(schema, \"pattern\", stringifyRegExpWithFlags(regex, refs), message, refs);\n  }\n}\nfunction stringifyRegExpWithFlags(regex, refs) {\n  if (!refs.applyRegexFlags || !regex.flags) {\n    return regex.source;\n  }\n  const flags = {\n    i: regex.flags.includes(\"i\"),\n    m: regex.flags.includes(\"m\"),\n    s: regex.flags.includes(\"s\")\n    // `.` matches newlines\n  };\n  const source = flags.i ? regex.source.toLowerCase() : regex.source;\n  let pattern = \"\";\n  let isEscaped = false;\n  let inCharGroup = false;\n  let inCharRange = false;\n  for (let i = 0; i < source.length; i++) {\n    if (isEscaped) {\n      pattern += source[i];\n      isEscaped = false;\n      continue;\n    }\n    if (flags.i) {\n      if (inCharGroup) {\n        if (source[i].match(/[a-z]/)) {\n          if (inCharRange) {\n            pattern += source[i];\n            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();\n            inCharRange = false;\n          } else if (source[i + 1] === \"-\" && source[i + 2]?.match(/[a-z]/)) {\n            pattern += source[i];\n            inCharRange = true;\n          } else {\n            pattern += `${source[i]}${source[i].toUpperCase()}`;\n          }\n          continue;\n        }\n      } else if (source[i].match(/[a-z]/)) {\n        pattern += `[${source[i]}${source[i].toUpperCase()}]`;\n        continue;\n      }\n    }\n    if (flags.m) {\n      if (source[i] === \"^\") {\n        pattern += `(^|(?<=[\\r\n]))`;\n        continue;\n      } else if (source[i] === \"$\") {\n        pattern += `($|(?=[\\r\n]))`;\n        continue;\n      }\n    }\n    if (flags.s && source[i] === \".\") {\n      pattern += inCharGroup ? `${source[i]}\\r\n` : `[${source[i]}\\r\n]`;\n      continue;\n    }\n    pattern += source[i];\n    if (source[i] === \"\\\\\") {\n      isEscaped = true;\n    } else if (inCharGroup && source[i] === \"]\") {\n      inCharGroup = false;\n    } else if (!inCharGroup && source[i] === \"[\") {\n      inCharGroup = true;\n    }\n  }\n  try {\n    new RegExp(pattern);\n  } catch {\n    console.warn(`Could not convert regex pattern at ${refs.currentPath.join(\"/\")} to a flag-independent form! Falling back to the flag-ignorant source`);\n    return regex.source;\n  }\n  return pattern;\n}\n\n// ../../node_modules/zod-to-json-schema/dist/esm/parsers/record.js\nfunction parseRecordDef(def, refs) {\n  if (refs.target === \"openAi\") {\n    console.warn(\"Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.\");\n  }\n  if (refs.target === \"openApi3\" && def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {\n    return {\n      type: \"object\",\n      required: def.keyType._def.values,\n      properties: def.keyType._def.values.reduce((acc, key) => ({\n        ...acc,\n        [key]: parseDef(def.valueType._def, {\n          ...refs,\n          currentPath: [...refs.currentPath, \"properties\", key]\n        }) ?? parseAnyDef(refs)\n      }), {}),\n      additionalProperties: refs.rejectedAdditionalProperties\n    };\n  }\n  const schema = {\n    type: \"object\",\n    additionalProperties: parseDef(def.valueType._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"additionalProperties\"]\n    }) ?? refs.allowedAdditionalProperties\n  };\n  if (refs.target === \"openApi3\") {\n    return schema;\n  }\n  if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.checks?.length) {\n    const {\n      type,\n      ...keyType\n    } = parseStringDef(def.keyType._def, refs);\n    return {\n      ...schema,\n      propertyNames: keyType\n    };\n  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {\n    return {\n      ...schema,\n      propertyNames: {\n        enum: def.keyType._def.values\n      }\n    };\n  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.type._def.checks?.length) {\n    const {\n      type,\n      ...keyType\n    } = parseBrandedDef(def.keyType._def, refs);\n    return {\n      ...schema,\n      propertyNames: keyType\n    };\n  }\n  return schema;\n}\n\n// ../../node_modules/zod-to-json-schema/dist/esm/parsers/map.js\nfunction parseMapDef(def, refs) {\n  if (refs.mapStrategy === \"record\") {\n    return parseRecordDef(def, refs);\n  }\n  const keys2 = parseDef(def.keyType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"items\", \"items\", \"0\"]\n  }) || parseAnyDef(refs);\n  const values = parseDef(def.valueType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"items\", \"items\", \"1\"]\n  }) || parseAnyDef(refs);\n  return {\n    type: \"array\",\n    maxItems: 125,\n    items: {\n      type: \"array\",\n      items: [keys2, values],\n      minItems: 2,\n      maxItems: 2\n    }\n  };\n}\n\n// ../../node_modules/zod-to-json-schema/dist/esm/parsers/nativeEnum.js\nfunction parseNativeEnumDef(def) {\n  const object3 = def.values;\n  const actualKeys = Object.keys(def.values).filter(key => {\n    return typeof object3[object3[key]] !== \"number\";\n  });\n  const actualValues = actualKeys.map(key => object3[key]);\n  const parsedTypes = Array.from(new Set(actualValues.map(values => typeof values)));\n  return {\n    type: parsedTypes.length === 1 ? parsedTypes[0] === \"string\" ? \"string\" : \"number\" : [\"string\", \"number\"],\n    enum: actualValues\n  };\n}\n\n// ../../node_modules/zod-to-json-schema/dist/esm/parsers/never.js\nfunction parseNeverDef(refs) {\n  return refs.target === \"openAi\" ? void 0 : {\n    not: parseAnyDef({\n      ...refs,\n      currentPath: [...refs.currentPath, \"not\"]\n    })\n  };\n}\n\n// ../../node_modules/zod-to-json-schema/dist/esm/parsers/null.js\nfunction parseNullDef(refs) {\n  return refs.target === \"openApi3\" ? {\n    enum: [\"null\"],\n    nullable: true\n  } : {\n    type: \"null\"\n  };\n}\n\n// ../../node_modules/zod-to-json-schema/dist/esm/parsers/union.js\nvar primitiveMappings = {\n  ZodString: \"string\",\n  ZodNumber: \"number\",\n  ZodBigInt: \"integer\",\n  ZodBoolean: \"boolean\",\n  ZodNull: \"null\"\n};\nfunction parseUnionDef(def, refs) {\n  if (refs.target === \"openApi3\") return asAnyOf(def, refs);\n  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;\n  if (options.every(x => x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length))) {\n    const types = options.reduce((types2, x) => {\n      const type = primitiveMappings[x._def.typeName];\n      return type && !types2.includes(type) ? [...types2, type] : types2;\n    }, []);\n    return {\n      type: types.length > 1 ? types : types[0]\n    };\n  } else if (options.every(x => x._def.typeName === \"ZodLiteral\" && !x.description)) {\n    const types = options.reduce((acc, x) => {\n      const type = typeof x._def.value;\n      switch (type) {\n        case \"string\":\n        case \"number\":\n        case \"boolean\":\n          return [...acc, type];\n        case \"bigint\":\n          return [...acc, \"integer\"];\n        case \"object\":\n          if (x._def.value === null) return [...acc, \"null\"];\n        case \"symbol\":\n        case \"undefined\":\n        case \"function\":\n        default:\n          return acc;\n      }\n    }, []);\n    if (types.length === options.length) {\n      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);\n      return {\n        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],\n        enum: options.reduce((acc, x) => {\n          return acc.includes(x._def.value) ? acc : [...acc, x._def.value];\n        }, [])\n      };\n    }\n  } else if (options.every(x => x._def.typeName === \"ZodEnum\")) {\n    return {\n      type: \"string\",\n      enum: options.reduce((acc, x) => [...acc, ...x._def.values.filter(x2 => !acc.includes(x2))], [])\n    };\n  }\n  return asAnyOf(def, refs);\n}\nvar asAnyOf = (def, refs) => {\n  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i) => parseDef(x._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"anyOf\", `${i}`]\n  })).filter(x => !!x && (!refs.strictUnions || typeof x === \"object\" && Object.keys(x).length > 0));\n  return anyOf.length ? {\n    anyOf\n  } : void 0;\n};\n\n// ../../node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js\nfunction parseNullableDef(def, refs) {\n  if ([\"ZodString\", \"ZodNumber\", \"ZodBigInt\", \"ZodBoolean\", \"ZodNull\"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {\n    if (refs.target === \"openApi3\") {\n      return {\n        type: primitiveMappings[def.innerType._def.typeName],\n        nullable: true\n      };\n    }\n    return {\n      type: [primitiveMappings[def.innerType._def.typeName], \"null\"]\n    };\n  }\n  if (refs.target === \"openApi3\") {\n    const base2 = parseDef(def.innerType._def, {\n      ...refs,\n      currentPath: [...refs.currentPath]\n    });\n    if (base2 && \"$ref\" in base2) return {\n      allOf: [base2],\n      nullable: true\n    };\n    return base2 && {\n      ...base2,\n      nullable: true\n    };\n  }\n  const base = parseDef(def.innerType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"anyOf\", \"0\"]\n  });\n  return base && {\n    anyOf: [base, {\n      type: \"null\"\n    }]\n  };\n}\n\n// ../../node_modules/zod-to-json-schema/dist/esm/parsers/number.js\nfunction parseNumberDef(def, refs) {\n  const res = {\n    type: \"number\"\n  };\n  if (!def.checks) return res;\n  for (const check2 of def.checks) {\n    switch (check2.kind) {\n      case \"int\":\n        res.type = \"integer\";\n        addErrorMessage(res, \"type\", check2.message, refs);\n        break;\n      case \"min\":\n        if (refs.target === \"jsonSchema7\") {\n          if (check2.inclusive) {\n            setResponseValueAndErrors(res, \"minimum\", check2.value, check2.message, refs);\n          } else {\n            setResponseValueAndErrors(res, \"exclusiveMinimum\", check2.value, check2.message, refs);\n          }\n        } else {\n          if (!check2.inclusive) {\n            res.exclusiveMinimum = true;\n          }\n          setResponseValueAndErrors(res, \"minimum\", check2.value, check2.message, refs);\n        }\n        break;\n      case \"max\":\n        if (refs.target === \"jsonSchema7\") {\n          if (check2.inclusive) {\n            setResponseValueAndErrors(res, \"maximum\", check2.value, check2.message, refs);\n          } else {\n            setResponseValueAndErrors(res, \"exclusiveMaximum\", check2.value, check2.message, refs);\n          }\n        } else {\n          if (!check2.inclusive) {\n            res.exclusiveMaximum = true;\n          }\n          setResponseValueAndErrors(res, \"maximum\", check2.value, check2.message, refs);\n        }\n        break;\n      case \"multipleOf\":\n        setResponseValueAndErrors(res, \"multipleOf\", check2.value, check2.message, refs);\n        break;\n    }\n  }\n  return res;\n}\n\n// ../../node_modules/zod-to-json-schema/dist/esm/parsers/object.js\nfunction parseObjectDef(def, refs) {\n  const forceOptionalIntoNullable = refs.target === \"openAi\";\n  const result = {\n    type: \"object\",\n    properties: {}\n  };\n  const required2 = [];\n  const shape = def.shape();\n  for (const propName in shape) {\n    let propDef = shape[propName];\n    if (propDef === void 0 || propDef._def === void 0) {\n      continue;\n    }\n    let propOptional = safeIsOptional(propDef);\n    if (propOptional && forceOptionalIntoNullable) {\n      if (propDef._def.typeName === \"ZodOptional\") {\n        propDef = propDef._def.innerType;\n      }\n      if (!propDef.isNullable()) {\n        propDef = propDef.nullable();\n      }\n      propOptional = false;\n    }\n    const parsedDef = parseDef(propDef._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"properties\", propName],\n      propertyPath: [...refs.currentPath, \"properties\", propName]\n    });\n    if (parsedDef === void 0) {\n      continue;\n    }\n    result.properties[propName] = parsedDef;\n    if (!propOptional) {\n      required2.push(propName);\n    }\n  }\n  if (required2.length) {\n    result.required = required2;\n  }\n  const additionalProperties = decideAdditionalProperties(def, refs);\n  if (additionalProperties !== void 0) {\n    result.additionalProperties = additionalProperties;\n  }\n  return result;\n}\nfunction decideAdditionalProperties(def, refs) {\n  if (def.catchall._def.typeName !== \"ZodNever\") {\n    return parseDef(def.catchall._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"additionalProperties\"]\n    });\n  }\n  switch (def.unknownKeys) {\n    case \"passthrough\":\n      return refs.allowedAdditionalProperties;\n    case \"strict\":\n      return refs.rejectedAdditionalProperties;\n    case \"strip\":\n      return refs.removeAdditionalStrategy === \"strict\" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;\n  }\n}\nfunction safeIsOptional(schema) {\n  try {\n    return schema.isOptional();\n  } catch {\n    return true;\n  }\n}\n\n// ../../node_modules/zod-to-json-schema/dist/esm/parsers/optional.js\nvar parseOptionalDef = (def, refs) => {\n  if (refs.currentPath.toString() === refs.propertyPath?.toString()) {\n    return parseDef(def.innerType._def, refs);\n  }\n  const innerSchema = parseDef(def.innerType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"anyOf\", \"1\"]\n  });\n  return innerSchema ? {\n    anyOf: [{\n      not: parseAnyDef(refs)\n    }, innerSchema]\n  } : parseAnyDef(refs);\n};\n\n// ../../node_modules/zod-to-json-schema/dist/esm/parsers/pipeline.js\nvar parsePipelineDef = (def, refs) => {\n  if (refs.pipeStrategy === \"input\") {\n    return parseDef(def.in._def, refs);\n  } else if (refs.pipeStrategy === \"output\") {\n    return parseDef(def.out._def, refs);\n  }\n  const a = parseDef(def.in._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"allOf\", \"0\"]\n  });\n  const b = parseDef(def.out._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"allOf\", a ? \"1\" : \"0\"]\n  });\n  return {\n    allOf: [a, b].filter(x => x !== void 0)\n  };\n};\n\n// ../../node_modules/zod-to-json-schema/dist/esm/parsers/promise.js\nfunction parsePromiseDef(def, refs) {\n  return parseDef(def.type._def, refs);\n}\n\n// ../../node_modules/zod-to-json-schema/dist/esm/parsers/set.js\nfunction parseSetDef(def, refs) {\n  const items = parseDef(def.valueType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"items\"]\n  });\n  const schema = {\n    type: \"array\",\n    uniqueItems: true,\n    items\n  };\n  if (def.minSize) {\n    setResponseValueAndErrors(schema, \"minItems\", def.minSize.value, def.minSize.message, refs);\n  }\n  if (def.maxSize) {\n    setResponseValueAndErrors(schema, \"maxItems\", def.maxSize.value, def.maxSize.message, refs);\n  }\n  return schema;\n}\n\n// ../../node_modules/zod-to-json-schema/dist/esm/parsers/tuple.js\nfunction parseTupleDef(def, refs) {\n  if (def.rest) {\n    return {\n      type: \"array\",\n      minItems: def.items.length,\n      items: def.items.map((x, i) => parseDef(x._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"items\", `${i}`]\n      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], []),\n      additionalItems: parseDef(def.rest._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"additionalItems\"]\n      })\n    };\n  } else {\n    return {\n      type: \"array\",\n      minItems: def.items.length,\n      maxItems: def.items.length,\n      items: def.items.map((x, i) => parseDef(x._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"items\", `${i}`]\n      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], [])\n    };\n  }\n}\n\n// ../../node_modules/zod-to-json-schema/dist/esm/parsers/undefined.js\nfunction parseUndefinedDef(refs) {\n  return {\n    not: parseAnyDef(refs)\n  };\n}\n\n// ../../node_modules/zod-to-json-schema/dist/esm/parsers/unknown.js\nfunction parseUnknownDef(refs) {\n  return parseAnyDef(refs);\n}\n\n// ../../node_modules/zod-to-json-schema/dist/esm/parsers/readonly.js\nvar parseReadonlyDef = (def, refs) => {\n  return parseDef(def.innerType._def, refs);\n};\n\n// ../../node_modules/zod-to-json-schema/dist/esm/selectParser.js\nvar selectParser = (def, typeName, refs) => {\n  switch (typeName) {\n    case ZodFirstPartyTypeKind.ZodString:\n      return parseStringDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodNumber:\n      return parseNumberDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodObject:\n      return parseObjectDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodBigInt:\n      return parseBigintDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodBoolean:\n      return parseBooleanDef();\n    case ZodFirstPartyTypeKind.ZodDate:\n      return parseDateDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodUndefined:\n      return parseUndefinedDef(refs);\n    case ZodFirstPartyTypeKind.ZodNull:\n      return parseNullDef(refs);\n    case ZodFirstPartyTypeKind.ZodArray:\n      return parseArrayDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodUnion:\n    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:\n      return parseUnionDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodIntersection:\n      return parseIntersectionDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodTuple:\n      return parseTupleDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodRecord:\n      return parseRecordDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodLiteral:\n      return parseLiteralDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodEnum:\n      return parseEnumDef(def);\n    case ZodFirstPartyTypeKind.ZodNativeEnum:\n      return parseNativeEnumDef(def);\n    case ZodFirstPartyTypeKind.ZodNullable:\n      return parseNullableDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodOptional:\n      return parseOptionalDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodMap:\n      return parseMapDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodSet:\n      return parseSetDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodLazy:\n      return () => def.getter()._def;\n    case ZodFirstPartyTypeKind.ZodPromise:\n      return parsePromiseDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodNaN:\n    case ZodFirstPartyTypeKind.ZodNever:\n      return parseNeverDef(refs);\n    case ZodFirstPartyTypeKind.ZodEffects:\n      return parseEffectsDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodAny:\n      return parseAnyDef(refs);\n    case ZodFirstPartyTypeKind.ZodUnknown:\n      return parseUnknownDef(refs);\n    case ZodFirstPartyTypeKind.ZodDefault:\n      return parseDefaultDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodBranded:\n      return parseBrandedDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodReadonly:\n      return parseReadonlyDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodCatch:\n      return parseCatchDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodPipeline:\n      return parsePipelineDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodFunction:\n    case ZodFirstPartyTypeKind.ZodVoid:\n    case ZodFirstPartyTypeKind.ZodSymbol:\n      return void 0;\n    default:\n      return /* @__PURE__ */(_ => void 0)(typeName);\n  }\n};\n\n// ../../node_modules/zod-to-json-schema/dist/esm/parseDef.js\nfunction parseDef(def, refs, forceResolution = false) {\n  const seenItem = refs.seen.get(def);\n  if (refs.override) {\n    const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);\n    if (overrideResult !== ignoreOverride) {\n      return overrideResult;\n    }\n  }\n  if (seenItem && !forceResolution) {\n    const seenSchema = get$ref(seenItem, refs);\n    if (seenSchema !== void 0) {\n      return seenSchema;\n    }\n  }\n  const newItem = {\n    def,\n    path: refs.currentPath,\n    jsonSchema: void 0\n  };\n  refs.seen.set(def, newItem);\n  const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);\n  const jsonSchema2 = typeof jsonSchemaOrGetter === \"function\" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;\n  if (jsonSchema2) {\n    addMeta(def, refs, jsonSchema2);\n  }\n  if (refs.postProcess) {\n    const postProcessResult = refs.postProcess(jsonSchema2, def, refs);\n    newItem.jsonSchema = jsonSchema2;\n    return postProcessResult;\n  }\n  newItem.jsonSchema = jsonSchema2;\n  return jsonSchema2;\n}\nvar get$ref = (item, refs) => {\n  switch (refs.$refStrategy) {\n    case \"root\":\n      return {\n        $ref: item.path.join(\"/\")\n      };\n    case \"relative\":\n      return {\n        $ref: getRelativePath(refs.currentPath, item.path)\n      };\n    case \"none\":\n    case \"seen\":\n      {\n        if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {\n          console.warn(`Recursive reference detected at ${refs.currentPath.join(\"/\")}! Defaulting to any`);\n          return parseAnyDef(refs);\n        }\n        return refs.$refStrategy === \"seen\" ? parseAnyDef(refs) : void 0;\n      }\n  }\n};\nvar addMeta = (def, refs, jsonSchema2) => {\n  if (def.description) {\n    jsonSchema2.description = def.description;\n    if (refs.markdownDescription) {\n      jsonSchema2.markdownDescription = def.description;\n    }\n  }\n  return jsonSchema2;\n};\n\n// ../../node_modules/zod-to-json-schema/dist/esm/zodToJsonSchema.js\nvar zodToJsonSchema = (schema, options) => {\n  const refs = getRefs(options);\n  let definitions = typeof options === \"object\" && options.definitions ? Object.entries(options.definitions).reduce((acc, [name20, schema2]) => ({\n    ...acc,\n    [name20]: parseDef(schema2._def, {\n      ...refs,\n      currentPath: [...refs.basePath, refs.definitionPath, name20]\n    }, true) ?? parseAnyDef(refs)\n  }), {}) : void 0;\n  const name19 = typeof options === \"string\" ? options : options?.nameStrategy === \"title\" ? void 0 : options?.name;\n  const main = parseDef(schema._def, name19 === void 0 ? refs : {\n    ...refs,\n    currentPath: [...refs.basePath, refs.definitionPath, name19]\n  }, false) ?? parseAnyDef(refs);\n  const title = typeof options === \"object\" && options.name !== void 0 && options.nameStrategy === \"title\" ? options.name : void 0;\n  if (title !== void 0) {\n    main.title = title;\n  }\n  if (refs.flags.hasReferencedOpenAiAnyType) {\n    if (!definitions) {\n      definitions = {};\n    }\n    if (!definitions[refs.openAiAnyTypeName]) {\n      definitions[refs.openAiAnyTypeName] = {\n        // Skipping \"object\" as no properties can be defined and additionalProperties must be \"false\"\n        type: [\"string\", \"number\", \"integer\", \"boolean\", \"array\", \"null\"],\n        items: {\n          $ref: refs.$refStrategy === \"relative\" ? \"1\" : [...refs.basePath, refs.definitionPath, refs.openAiAnyTypeName].join(\"/\")\n        }\n      };\n    }\n  }\n  const combined = name19 === void 0 ? definitions ? {\n    ...main,\n    [refs.definitionPath]: definitions\n  } : main : {\n    $ref: [...(refs.$refStrategy === \"relative\" ? [] : refs.basePath), refs.definitionPath, name19].join(\"/\"),\n    [refs.definitionPath]: {\n      ...definitions,\n      [name19]: main\n    }\n  };\n  if (refs.target === \"jsonSchema7\") {\n    combined.$schema = \"http://json-schema.org/draft-07/schema#\";\n  } else if (refs.target === \"jsonSchema2019-09\" || refs.target === \"openAi\") {\n    combined.$schema = \"https://json-schema.org/draft/2019-09/schema#\";\n  }\n  if (refs.target === \"openAi\" && (\"anyOf\" in combined || \"oneOf\" in combined || \"allOf\" in combined || \"type\" in combined && Array.isArray(combined.type))) {\n    console.warn(\"Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.\");\n  }\n  return combined;\n};\n\n// src/store/agentContext/agentContextSlice.ts\nfunction normalizeToArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\nfunction extractLabel(item, labelField) {\n  if (typeof labelField === \"function\") {\n    return labelField(item);\n  }\n  if (typeof labelField === \"string\" && typeof item === \"object\" && item !== null) {\n    const obj = item;\n    if (labelField in obj) {\n      return String(obj[labelField]);\n    }\n  }\n  if (typeof item === \"object\" && item !== null) {\n    const obj = item;\n    return String(obj.title || obj.label || obj.name || obj.id || \"Unknown\");\n  }\n  return String(item);\n}\nfunction formatContextEntries(key, value, options) {\n  if (value === null || value === void 0) {\n    return [];\n  }\n  const isInputArray = Array.isArray(value);\n  const items = isInputArray ? value : [value];\n  const entries = items.map((item, index) => {\n    const id = typeof item === \"object\" && item !== null && \"id\" in item ? String(item.id) : `${key}-${index}`;\n    const label = extractLabel(item, options?.labelField);\n    const resolvedIcon = options?.icon ? typeof options.icon === \"function\" ? options.icon(item) : options.icon : void 0;\n    const entry = {\n      id,\n      source: options?.source || \"subscription\",\n      data: item,\n      // The original data, unchanged\n      metadata: {\n        label,\n        ...(resolvedIcon && {\n          icon: resolvedIcon\n        }),\n        ...(options?.color && {\n          color: options.color\n        }),\n        ...(options?.order !== void 0 && {\n          order: options.order\n        }),\n        showInChat: true\n        // Default to true, will be resolved later if function\n      }\n    };\n    if (options?.showInChat !== void 0) {\n      entry.metadata.showInChat = typeof options.showInChat === \"function\" ? options.showInChat(entry) : options.showInChat;\n    }\n    return entry;\n  });\n  return isInputArray ? entries : entries[0];\n}\nvar createAgentContextSlice = (set2, get) => ({\n  chatInputContent: null,\n  overrideInputContent: {\n    input: null\n  },\n  additionalContext: {},\n  mentionProviders: /* @__PURE__ */new Map(),\n  collapsingConfigs: /* @__PURE__ */new Map(),\n  collapsingConfigRefs: /* @__PURE__ */new Map(),\n  setChatInputContent: content => {\n    set2({\n      chatInputContent: content\n    });\n  },\n  setOverrideInputContent: content => {\n    set2({\n      overrideInputContent: {\n        input: content\n      }\n    });\n  },\n  addContextEntry: (key, entry) => {\n    set2(state => {\n      const currentValue = state.additionalContext[key];\n      const currentEntries = currentValue ? normalizeToArray(currentValue) : [];\n      const exists = currentEntries.some(e => e.id === entry.id);\n      if (exists) {\n        return state;\n      }\n      const updatedEntries = [...currentEntries, entry];\n      return {\n        additionalContext: {\n          ...state.additionalContext,\n          [key]: updatedEntries\n        }\n      };\n    });\n  },\n  removeContextEntry: (key, entryId) => {\n    set2(state => {\n      const currentValue = state.additionalContext[key];\n      if (!currentValue) return state;\n      const currentEntries = normalizeToArray(currentValue);\n      const filtered = currentEntries.filter(e => e.id !== entryId);\n      const newValue = filtered.length === 0 ? [] : filtered.length === 1 ? filtered[0] : filtered;\n      return {\n        additionalContext: {\n          ...state.additionalContext,\n          [key]: newValue\n        }\n      };\n    });\n  },\n  clearContextBySource: source => {\n    set2(state => {\n      const newContext = {};\n      Object.entries(state.additionalContext).forEach(([key, value]) => {\n        const entries = normalizeToArray(value);\n        const filtered = entries.filter(e => e.source !== source);\n        if (filtered.length === 0) {\n          newContext[key] = [];\n        } else if (filtered.length === 1 && !Array.isArray(value)) {\n          newContext[key] = filtered[0];\n        } else {\n          newContext[key] = filtered;\n        }\n      });\n      return {\n        additionalContext: newContext\n      };\n    });\n  },\n  clearMentions: () => {\n    get().clearContextBySource(\"mention\");\n  },\n  // internal method to update the additional context\n  updateAdditionalContext: context => {\n    set2(state => {\n      const newContext = {\n        ...state.additionalContext\n      };\n      Object.entries(context).forEach(([key, value]) => {\n        if (Array.isArray(value)) {\n          if (value.length === 0) {\n            newContext[key] = [];\n          } else {\n            newContext[key] = value.map(item => ({\n              ...item,\n              source: item.source || \"subscription\"\n            }));\n          }\n        } else if (value && typeof value === \"object\") {\n          const entry = value;\n          newContext[key] = {\n            ...entry,\n            source: entry.source || \"subscription\"\n          };\n        }\n      });\n      return {\n        additionalContext: newContext\n      };\n    });\n  },\n  putAdditionalContext: (key, value, options) => {\n    set2(state => {\n      const newContext = {\n        ...state.additionalContext\n      };\n      const formattedEntries = formatContextEntries(key, value, {\n        ...options,\n        source: \"function\"\n      });\n      newContext[key] = formattedEntries;\n      return {\n        additionalContext: newContext\n      };\n    });\n  },\n  registerMentionProvider: provider => {\n    set2(state => {\n      const newProviders = new Map(state.mentionProviders);\n      newProviders.set(provider.id, provider);\n      return {\n        mentionProviders: newProviders\n      };\n    });\n  },\n  unregisterMentionProvider: providerId => {\n    set2(state => {\n      const newProviders = new Map(state.mentionProviders);\n      newProviders.delete(providerId);\n      return {\n        mentionProviders: newProviders\n      };\n    });\n  },\n  getMentionProvidersByTrigger: trigger => {\n    const providers = get().mentionProviders;\n    return Array.from(providers.values()).filter(provider => provider.trigger === trigger);\n  },\n  setCollapsingConfig: (key, config2, componentId) => {\n    set2(state => {\n      const newConfigs = new Map(state.collapsingConfigs);\n      let normalizedConfig;\n      if (typeof config2 === \"boolean\") {\n        normalizedConfig = {\n          threshold: 5\n        };\n      } else if (typeof config2 === \"number\") {\n        normalizedConfig = {\n          threshold: config2\n        };\n      } else {\n        normalizedConfig = config2;\n      }\n      newConfigs.set(key, normalizedConfig);\n      const newRefs = new Map(state.collapsingConfigRefs);\n      const refs = newRefs.get(key) || /* @__PURE__ */new Set();\n      refs.add(componentId);\n      newRefs.set(key, refs);\n      return {\n        collapsingConfigs: newConfigs,\n        collapsingConfigRefs: newRefs\n      };\n    });\n  },\n  removeCollapsingConfig: (key, componentId) => {\n    set2(state => {\n      const newRefs = new Map(state.collapsingConfigRefs);\n      const refs = newRefs.get(key);\n      if (refs) {\n        refs.delete(componentId);\n        if (refs.size === 0) {\n          newRefs.delete(key);\n          const newConfigs = new Map(state.collapsingConfigs);\n          newConfigs.delete(key);\n          return {\n            collapsingConfigs: newConfigs,\n            collapsingConfigRefs: newRefs\n          };\n        } else {\n          newRefs.set(key, refs);\n          return {\n            collapsingConfigs: state.collapsingConfigs,\n            collapsingConfigRefs: newRefs\n          };\n        }\n      }\n      return state;\n    });\n  },\n  stringifyEditor: () => {\n    const content = get().chatInputContent;\n    if (!content) return \"\";\n    const extractText = node => {\n      let text2 = \"\";\n      if (node.type === \"text\" && node.text) {\n        text2 += node.text;\n      }\n      if (node.type === \"mention\" && node.attrs) {\n        const label = node.attrs.label || node.attrs.id || \"mention\";\n        text2 += `@${label}`;\n      }\n      if (node.type === \"choice\" && node.attrs) {\n        const selectedOption = node.attrs.selectedOption || \"\";\n        const options = node.attrs.options || [];\n        const optionValue = selectedOption || (options.length > 0 ? options[0] : \"\");\n        text2 += optionValue;\n      }\n      if (node.content && Array.isArray(node.content)) {\n        node.content.forEach(child => {\n          text2 += extractText(child);\n        });\n      }\n      return text2;\n    };\n    return extractText(content).trim();\n  },\n  compileStateSetters: () => {\n    const registeredStates = get().registeredStates;\n    const stateSetters = {};\n    const setters = {};\n    const schemas = {};\n    Object.keys(registeredStates).forEach(stateKey => {\n      const state = registeredStates[stateKey];\n      if (state?.schema) {\n        schemas[stateKey] = {\n          stateKey,\n          description: state.description,\n          schema: zodToJsonSchema(state.schema, stateKey)\n        };\n      }\n      const settersToProcess = state?.stateSetters || state?.customSetters;\n      if (settersToProcess) {\n        Object.entries(settersToProcess).forEach(([setterKey, setter]) => {\n          const setterInfo = {\n            name: setter.name,\n            stateKey,\n            description: setter.description,\n            argsSchema: setter.argsSchema ? zodToJsonSchema(setter.argsSchema, setter.name) : void 0\n          };\n          stateSetters[setterKey] = setterInfo;\n        });\n      }\n    });\n    return {\n      stateSetters,\n      setters,\n      // Deprecated but maintained for compatibility\n      schemas\n    };\n  },\n  compileAdditionalContext: () => {\n    const context = get().additionalContext;\n    const simplifiedContext = {};\n    Object.entries(context).forEach(([key, value]) => {\n      const entries = normalizeToArray(value);\n      const wasArray = Array.isArray(value);\n      const simplified = entries.map(entry => ({\n        data: entry.data,\n        source: entry.source\n      }));\n      simplifiedContext[key] = wasArray ? simplified : simplified[0];\n    });\n    const compiledStateSetters = get().compileStateSetters();\n    const frontendTools = get().compileFrontendTools();\n    const mergedContext = {\n      ...simplifiedContext,\n      ...compiledStateSetters,\n      ...(Object.keys(frontendTools).length > 0 && {\n        frontendTools\n      })\n    };\n    const sanitizedContext = sanitizeJson(mergedContext);\n    return sanitizedContext;\n  },\n  stringifyInputContext: () => {\n    const state = get();\n    const editorContent = state.stringifyEditor();\n    const contextData = JSON.stringify(state.compileAdditionalContext());\n    let result = `User Text: ${editorContent}\n\n`;\n    result += `Additional Context: ${contextData}`;\n    return result;\n  },\n  compileFrontendTools: () => {\n    const tools = get().registeredTools;\n    const toolsObject = {};\n    tools.forEach((tool2, name19) => {\n      toolsObject[name19] = {\n        name: name19,\n        description: tool2.description,\n        // Convert Zod schema to JSON schema for agent compatibility\n        argsSchema: zodToJsonSchema(tool2.argsSchema, name19)\n      };\n    });\n    return toolsObject;\n  }\n});\nfunction useSubscribeStateToAgentContext(stateKey, mapFn, options) {\n  const updateAdditionalContext = useCedarStore(s => s.updateAdditionalContext);\n  const setCollapsingConfig = useCedarStore(s => s.setCollapsingConfig);\n  const removeCollapsingConfig = useCedarStore(s => s.removeCollapsingConfig);\n  const componentId = useMemo(() => `${stateKey}-${Math.random().toString(36).substr(2, 9)}`, [stateKey]);\n  const stateExists = useCedarStore(s => stateKey in s.registeredStates);\n  const stateValue = useCedarStore(s => s.registeredStates[stateKey]?.value);\n  const memoizedOptions = useMemo(() => options, [options?.icon, options?.color, options?.labelField, options?.order, options?.showInChat, options?.collapse]);\n  const mappedData = useMemo(() => {\n    if (!stateExists) {\n      console.warn(`State with key \"${stateKey}\" was not found in Cedar store. Did you forget to register it with useCedarState()?`);\n      return {};\n    }\n    return mapFn(stateValue);\n  }, [stateExists, stateValue, mapFn]);\n  const formattedContext = useMemo(() => {\n    const context = {};\n    for (const [key, value] of Object.entries(mappedData)) {\n      const entries = formatContextEntries(key, value, memoizedOptions);\n      context[key] = entries;\n    }\n    return context;\n  }, [mappedData, memoizedOptions]);\n  useEffect(() => {\n    if (Object.keys(formattedContext).length > 0) {\n      updateAdditionalContext(formattedContext);\n    }\n  }, [formattedContext, updateAdditionalContext]);\n  useEffect(() => {\n    if (options?.collapse && Object.keys(mappedData).length > 0) {\n      let threshold;\n      if (typeof options.collapse === \"boolean\") {\n        threshold = 5;\n      } else if (typeof options.collapse === \"number\") {\n        threshold = options.collapse;\n      } else {\n        threshold = options.collapse.threshold;\n      }\n      Object.entries(mappedData).forEach(([contextKey, value]) => {\n        const entries = Array.isArray(value) ? value : [value];\n        const entryCount = entries.length;\n        if (entryCount > threshold) {\n          setCollapsingConfig(contextKey, options.collapse, componentId);\n        } else {\n          removeCollapsingConfig(contextKey, componentId);\n        }\n      });\n    } else if (!options?.collapse) {\n      Object.keys(mappedData).forEach(contextKey => {\n        removeCollapsingConfig(contextKey, componentId);\n      });\n    }\n    return () => {\n      Object.keys(mappedData).forEach(contextKey => {\n        removeCollapsingConfig(contextKey, componentId);\n      });\n    };\n  }, [mappedData, options?.collapse, setCollapsingConfig, removeCollapsingConfig, componentId]);\n}\nfunction useRenderAdditionalContext(renderers) {\n  const additionalContext = useCedarStore(s => s.additionalContext);\n  return useMemo(() => {\n    const elements = [];\n    Object.entries(renderers).forEach(([key, renderer]) => {\n      const value = additionalContext[key];\n      if (value) {\n        const entries = normalizeToArray(value);\n        entries.forEach(entry => {\n          const element = renderer(entry);\n          elements.push(element);\n        });\n      }\n    });\n    return elements;\n  }, [additionalContext, renderers]);\n}\n\n// src/store/stylingSlice.ts\nvar DEFAULT_STYLING = {\n  darkMode: false,\n  color: \"#93C5FD\",\n  // blue-300\n  secondaryColor: \"#1D4ED8\",\n  // blue-700\n  accentColor: \"#FB923C\"\n  // orange-400\n};\nvar createStylingSlice = set2 => ({\n  // Initial state\n  styling: DEFAULT_STYLING,\n  // Actions\n  setStyling: newStyling => set2(state => ({\n    styling: {\n      ...state.styling,\n      ...newStyling\n    }\n  })),\n  toggleDarkMode: () => set2(state => ({\n    styling: {\n      ...state.styling,\n      darkMode: !state.styling.darkMode\n    }\n  }))\n});\n\n// src/store/stateSlice/stateSlice.ts\nimport { isEqual } from \"lodash\";\nvar createStateSlice = (set2, get) => {\n  return {\n    // Default state\n    registeredStates: {},\n    // Register a new state or replace an existing one\n    registerState: config2 => {\n      const mergedSetters = {\n        ...(config2.customSetters || {}),\n        ...(config2.stateSetters || {})\n        // stateSetters takes precedence\n      };\n      if (config2.customSetters && !config2.stateSetters) {\n        console.warn(`\\u26A0\\uFE0F 'customSetters' is deprecated for state \"${config2.key}\". Use 'stateSetters' instead.`);\n      }\n      const stateExists = Boolean(get().registeredStates[config2.key]);\n      if (stateExists) {\n        set2(state => {\n          const updatedState = {\n            key: config2.key,\n            value: config2.value,\n            // Update ALL fields to ensure fresh closures after remount\n            setValue: config2.setValue,\n            stateSetters: mergedSetters,\n            customSetters: config2.customSetters,\n            // Keep for backward compatibility\n            description: config2.description,\n            schema: config2.schema\n          };\n          return {\n            registeredStates: {\n              ...state.registeredStates,\n              [config2.key]: updatedState\n            }\n          };\n        });\n        return;\n      }\n      set2(state => {\n        const registeredState = {\n          key: config2.key,\n          value: config2.value,\n          description: config2.description,\n          schema: config2.schema,\n          setValue: config2.setValue,\n          stateSetters: mergedSetters,\n          customSetters: config2.customSetters\n          // Keep for backward compatibility\n        };\n        return {\n          registeredStates: {\n            ...state.registeredStates,\n            [config2.key]: registeredState\n          }\n        };\n      });\n    },\n    getState: key => {\n      return get().registeredStates[key];\n    },\n    /** Retrieves the stored value for a given state key */\n    getCedarState: key => {\n      const record2 = get().registeredStates[key];\n      return record2?.value;\n    },\n    /**\n     * Set a registered state value and call its external setter if provided.\n     * @param key The state key.\n     * @param value The new value to set.\n     */\n    setCedarState: (key, value, isDiffChange = false) => {\n      const diffHistoryState = get().getDiffHistoryState?.(key);\n      if (diffHistoryState) {\n        get().newDiffState(key, value, isDiffChange);\n        return;\n      }\n      const existingState = get().registeredStates[key];\n      if (!existingState) {\n        console.warn(`State with key \"${key}\" not found.`);\n        return;\n      }\n      if (isEqual(existingState.value, value)) {\n        return;\n      }\n      set2(state => ({\n        registeredStates: {\n          ...state.registeredStates,\n          [key]: {\n            ...state.registeredStates[key],\n            value\n          }\n        }\n      }));\n      if (existingState.setValue) {\n        try {\n          existingState.setValue(value);\n        } catch (error40) {\n          console.warn(`Error calling external setter for \"${key}\"`, error40);\n        }\n      }\n    },\n    // Add state setters to an existing state\n    addStateSetters: (key, setters) => {\n      const existingState = get().registeredStates[key];\n      if (!existingState) {\n        console.info(`Creating placeholder state for \"${key}\" with state setters`);\n        set2(state => ({\n          registeredStates: {\n            ...state.registeredStates,\n            [key]: {\n              key,\n              value: \"\",\n              // Default empty value\n              schema: external_exports.any(),\n              // Optional description placeholder\n              description: \"\",\n              stateSetters: {\n                ...setters\n              },\n              customSetters: {\n                ...setters\n              }\n              // Keep for backward compatibility\n            }\n          }\n        }));\n        return true;\n      }\n      set2(state => ({\n        registeredStates: {\n          ...state.registeredStates,\n          [key]: {\n            ...state.registeredStates[key],\n            // Merge existing stateSetters with new ones\n            stateSetters: {\n              ...(state.registeredStates[key].stateSetters || {}),\n              ...setters\n            },\n            // Also update customSetters for backward compatibility\n            customSetters: {\n              ...(state.registeredStates[key].customSetters || {}),\n              ...setters\n            }\n          }\n        }\n      }));\n      return true;\n    },\n    // Deprecated: Add custom setters to an existing state\n    addCustomSetters: (key, setters) => {\n      console.warn(`\\u26A0\\uFE0F 'addCustomSetters' is deprecated for state \"${key}\". Use 'addStateSetters' instead.`);\n      return get().addStateSetters(key, setters);\n    },\n    /**\n     * Execute a named state setter for a registered state.\n     */\n    executeStateSetter: params => {\n      const {\n        key,\n        setterKey,\n        options = {},\n        args\n      } = params;\n      const diffHistoryState = get().getDiffHistoryState?.(key);\n      if (diffHistoryState) {\n        const isDiff = options.isDiff ?? false;\n        get().executeDiffSetter(key, setterKey, {\n          isDiff\n        }, args);\n        return;\n      }\n      const existingState = get().registeredStates[key];\n      if (!existingState) {\n        console.warn(`State with key \"${key}\" not found.`);\n        return;\n      }\n      const setters = existingState.stateSetters || existingState.customSetters;\n      if (!setters || !setters[setterKey]) {\n        console.warn(`State setter \"${setterKey}\" not found for state \"${key}\".`);\n        return;\n      }\n      const setter = setters[setterKey];\n      const setValueFunc = newValue => {\n        get().setCedarState(key, newValue);\n      };\n      const schema = setter.argsSchema || setter.schema;\n      if (schema) {\n        try {\n          const validatedArgs = schema.parse(args);\n          setter.execute(existingState.value, setValueFunc, validatedArgs);\n        } catch (error40) {\n          let validationErrors = [];\n          if (error40 instanceof external_exports.ZodError) {\n            validationErrors = error40.issues.map(err => {\n              const errorInfo = {\n                path: err.path.join(\".\") || \"root\",\n                message: err.message,\n                code: err.code\n              };\n              if (\"received\" in err) {\n                errorInfo.received = err.received;\n              }\n              if (\"expected\" in err) {\n                errorInfo.expected = err.expected;\n              }\n              return errorInfo;\n            });\n          }\n          const errorMessage = [`\\u274C Args validation failed for setter \"${setterKey}\" on state \"${key}\"`, `\\u{1F4E5} Received args: ${JSON.stringify(args, null, 2)}`, `\\u{1F50D} Validation errors: ${JSON.stringify(validationErrors.length > 0 ? validationErrors : error40, null, 2)}`, `\\u{1F4A1} Tip: Check your backend response format or update the setter's argsSchema`].join(\"\\n\");\n          console.error(errorMessage);\n          return;\n        }\n      } else {\n        if (args !== void 0) {\n          setter.execute(existingState.value, setValueFunc, args);\n        } else {\n          setter.execute(existingState.value, setValueFunc);\n        }\n      }\n    },\n    /**\n     * @deprecated Use executeStateSetter instead\n     * Execute a named custom setter for a registered state.\n     */\n    executeCustomSetter: params => {\n      console.warn(`\\u26A0\\uFE0F 'executeCustomSetter' is deprecated. Use 'executeStateSetter' instead.`);\n      get().executeStateSetter({\n        key: params.key,\n        setterKey: params.setterKey,\n        options: params.options,\n        args: params.args\n      });\n    },\n    /**\n     * Unregister a state from the store.\n     * @param key The state key to unregister.\n     */\n    unregisterState: key => {\n      set2(state => {\n        const {\n          [key]: removed,\n          ...remainingStates\n        } = state.registeredStates;\n        return {\n          registeredStates: remainingStates\n        };\n      });\n    }\n  };\n};\n\n// src/store/messages/MessageTypes.ts\nvar DEFAULT_THREAD_ID = \"default-thread\";\n\n// src/store/messages/messageStorage.ts\nimport { v4 } from \"uuid\";\nvar createMessageStorageLocalAdapter = (opts = {}) => {\n  const prefix = opts.key ?? \"cedar\";\n  const threadsKey = userId => `${prefix}-threads-${userId}`;\n  const threadKey = (userId, threadId) => `${prefix}-thread-${userId}-${threadId}`;\n  const persistThreadMeta = (userId, list) => {\n    localStorage.setItem(threadsKey(userId), JSON.stringify(list));\n  };\n  return {\n    type: \"local\",\n    async listThreads(userId) {\n      const raw = localStorage.getItem(threadsKey(userId));\n      return raw ? JSON.parse(raw) : [];\n    },\n    async loadMessages(userId, threadId) {\n      try {\n        const raw = localStorage.getItem(threadKey(userId, threadId));\n        return raw ? JSON.parse(raw) : [];\n      } catch {\n        return [];\n      }\n    },\n    async persistMessage(userId, threadId, message) {\n      try {\n        const existingMessages = (await this.loadMessages?.(userId, threadId)) ?? [];\n        const updatedMessages = [...existingMessages, message];\n        localStorage.setItem(threadKey(userId, threadId), JSON.stringify(updatedMessages));\n      } catch {}\n      return message;\n    },\n    async createThread(userId, threadId, meta) {\n      try {\n        const metaList = await this.listThreads?.(userId);\n        if (metaList && !metaList.some(m => m.id === threadId)) {\n          metaList.push(meta);\n          persistThreadMeta(userId, metaList);\n        }\n      } catch {}\n      return meta;\n    },\n    async updateThread(userId, threadId, meta) {\n      try {\n        const metaList = await this.listThreads?.(userId);\n        if (metaList) {\n          const idx = metaList.findIndex(m => m.id === threadId);\n          if (idx === -1) metaList.push(meta);else metaList[idx] = {\n            ...metaList[idx],\n            ...meta\n          };\n          persistThreadMeta(userId, metaList);\n        }\n      } catch {}\n      return meta;\n    },\n    async deleteThread(userId, threadId) {\n      let removed;\n      try {\n        const metaList = await this.listThreads?.(userId);\n        if (metaList) {\n          const idx = metaList.findIndex(m => m.id === threadId);\n          if (idx !== -1) removed = metaList[idx];\n          const newList = metaList.filter(m => m.id !== threadId);\n          persistThreadMeta(userId, newList);\n          localStorage.removeItem(threadKey(userId, threadId));\n        }\n      } catch {}\n      return removed;\n    },\n    async updateMessage(userId, threadId, updatedMsg) {\n      try {\n        const msgs = (await this.loadMessages?.(userId, threadId)) ?? [];\n        const newMsgs = msgs.map(m => m.id === updatedMsg.id ? {\n          ...m,\n          ...updatedMsg\n        } : m);\n        localStorage.setItem(threadKey(userId, threadId), JSON.stringify(newMsgs));\n      } catch {}\n      return updatedMsg;\n    },\n    async deleteMessage(userId, threadId, messageId) {\n      let removed;\n      try {\n        const msgs = (await this.loadMessages?.(userId, threadId)) ?? [];\n        removed = msgs.find(m => m.id === messageId);\n        const newMsgs = msgs.filter(m => m.id !== messageId);\n        localStorage.setItem(threadKey(userId, threadId), JSON.stringify(newMsgs));\n      } catch {}\n      return removed;\n    }\n  };\n};\nvar createMessageStorageNoopAdapter = () => ({\n  type: \"none\",\n  async listThreads() {\n    return [];\n  },\n  async loadMessages() {\n    return [];\n  },\n  async persistMessage(_userId, _threadId, message) {\n    return message;\n  }\n});\nvar createMessageStorageAdapter = cfg => {\n  if (!cfg || cfg.type === \"none\") {\n    return createMessageStorageNoopAdapter();\n  }\n  if (cfg.type === \"local\") return createMessageStorageLocalAdapter(cfg?.options);\n  if (cfg.type === \"custom\") return {\n    type: \"custom\",\n    ...cfg.adapter\n  };\n  return createMessageStorageNoopAdapter();\n};\nfunction getMessageStorageState(set2, get) {\n  let adapter = void 0;\n  const syncThreadsFromStorage = async (userId, autoCreateThread = true) => {\n    if (!adapter || !adapter.listThreads || !userId) return null;\n    try {\n      let threads = await adapter.listThreads(userId);\n      const state = get();\n      if (threads.length === 0 && autoCreateThread && adapter.createThread) {\n        const newThreadId = `thread-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\n        const newMeta = {\n          id: newThreadId,\n          title: \"New Thread\",\n          updatedAt: (/* @__PURE__ */new Date()).toISOString()\n        };\n        try {\n          await adapter.createThread(userId, newThreadId, newMeta);\n          threads = await adapter.listThreads(userId);\n        } catch (error40) {\n          console.warn(\"Failed to auto-create thread:\", error40);\n        }\n      }\n      const currentThreadMap = state.threadMap;\n      const updatedThreadMap = {\n        ...currentThreadMap\n      };\n      threads.forEach(threadMeta => {\n        if (!updatedThreadMap[threadMeta.id]) {\n          updatedThreadMap[threadMeta.id] = {\n            id: threadMeta.id,\n            name: threadMeta.title,\n            lastLoaded: (/* @__PURE__ */new Date()).toISOString(),\n            messages: []\n            // Messages will be loaded separately\n          };\n        } else {\n          const existingThread = updatedThreadMap[threadMeta.id];\n          if (existingThread.name !== threadMeta.title) {\n            updatedThreadMap[threadMeta.id] = {\n              ...existingThread,\n              name: threadMeta.title\n            };\n          }\n        }\n      });\n      if (Object.keys(updatedThreadMap).length !== Object.keys(currentThreadMap).length || threads.some(meta => !currentThreadMap[meta.id] || currentThreadMap[meta.id].name !== meta.title)) {\n        set2({\n          threadMap: updatedThreadMap\n        });\n      }\n      const currentThreadId = get().mainThreadId;\n      if (!currentThreadId && threads.length > 0) {\n        const threadToSelect = threads[0].id;\n        get().setMainThreadId(threadToSelect);\n        return threadToSelect;\n      }\n    } catch (error40) {\n      console.warn(\"Failed to sync threads from storage:\", error40);\n    }\n    return null;\n  };\n  return {\n    messageStorageAdapter: adapter,\n    setMessageStorageAdapter: cfg => {\n      adapter = createMessageStorageAdapter(cfg);\n      set2({\n        messageStorageAdapter: adapter\n      });\n    },\n    persistMessageStorageMessage: async message => {\n      if (!adapter?.persistMessage) return;\n      const uid = getCedarState(\"userId\");\n      const tid = get().mainThreadId || v4();\n      if (!uid) return;\n      if (adapter.persistMessage) {\n        await adapter.persistMessage(uid, tid, message);\n      }\n      if (adapter.updateThread) {\n        const existingThread = get().threadMap[tid];\n        const meta = {\n          id: tid,\n          title: existingThread?.name || (message.content || \"Chat\").slice(0, 40),\n          updatedAt: (/* @__PURE__ */new Date()).toISOString()\n        };\n        await adapter.updateThread(uid, tid, meta);\n      }\n      await syncThreadsFromStorage(uid, false);\n    },\n    initializeChat: async params => {\n      const uid = params?.userId || getCedarState(\"userId\");\n      const tidFromParams = params?.threadId;\n      let tid = tidFromParams;\n      if (adapter?.createThread && uid) {\n        const threadId = await syncThreadsFromStorage(uid, true);\n        tid = tidFromParams || threadId;\n      } else {\n        const state = get();\n        if (!state.threadMap[DEFAULT_THREAD_ID]) {\n          set2(state2 => ({\n            threadMap: {\n              ...state2.threadMap,\n              [DEFAULT_THREAD_ID]: {\n                id: DEFAULT_THREAD_ID,\n                name: \"Main Chat\",\n                lastLoaded: (/* @__PURE__ */new Date()).toISOString(),\n                messages: []\n              }\n            }\n          }));\n        }\n        tid = tidFromParams || DEFAULT_THREAD_ID;\n      }\n      if (tid) {\n        get().setMainThreadId(tid);\n      }\n      useCedarStore.getState().setMessages([]);\n      if (!adapter || !adapter.loadMessages || !uid || !tid) return;\n      try {\n        const msgs = await adapter.loadMessages(uid, tid);\n        if (msgs.length) {\n          useCedarStore.getState().setMessages(msgs);\n        }\n      } catch (error40) {\n        console.warn(\"Failed to load messages during initialization:\", error40);\n      }\n    }\n  };\n}\n\n// ../../node_modules/motion/dist/es/react.mjs\nvar react_exports = {};\n__reExport(react_exports, framer_motion_star);\nimport * as framer_motion_star from \"framer-motion\";\n\n// src/store/messages/renderers/ShimmerText.tsx\nimport React from \"react\";\nimport { Hammer, Check, X, Brain, ChevronDown, ChevronRight } from \"lucide-react\";\nimport { jsx, jsxs } from \"react/jsx-runtime\";\nvar ShimmerText = ({\n  text: text2,\n  state,\n  payload\n}) => {\n  const [isExpanded, setIsExpanded] = React.useState(false);\n  const [isHovered, setIsHovered] = React.useState(false);\n  const isComplete = state === \"complete\";\n  const isError = state === \"error\";\n  const isThinking = state === \"thinking\";\n  const isEventWithPayload = state === \"eventWithPayload\";\n  const {\n    styling\n  } = useStyling();\n  const isDark = styling.darkMode ?? false;\n  const grey = isDark ? \"#475569\" : \"#6B7280\";\n  const highlight = isDark ? \"#FFFFFF\" : \"#000000\";\n  const errorColor = isDark ? \"#DC2626\" : \"#EF4444\";\n  const stagger = 0.03;\n  const duration3 = text2.length * 0.13;\n  const getIcon = () => {\n    if (isEventWithPayload && isHovered) {\n      return isExpanded ? ChevronDown : ChevronRight;\n    }\n    if (isError) return X;\n    if (isComplete) return Check;\n    if (isThinking || isEventWithPayload) return Brain;\n    return Hammer;\n  };\n  const IconComponent = getIcon();\n  const handleIconClick = () => {\n    if (isEventWithPayload && payload) {\n      setIsExpanded(!isExpanded);\n    }\n  };\n  return /* @__PURE__ */jsxs(\"div\", {\n    className: \"w-full\",\n    children: [/* @__PURE__ */jsxs(\"div\", {\n      className: \"flex mx-0.5 items-center cursor-pointer\",\n      onMouseEnter: () => setIsHovered(true),\n      onMouseLeave: () => setIsHovered(false),\n      onClick: handleIconClick,\n      \"aria-label\": text2,\n      tabIndex: 0,\n      role: \"text\",\n      children: [/* @__PURE__ */jsx(react_exports.motion.span, {\n        className: `mr-1 ${isEventWithPayload && payload ? \"cursor-pointer\" : \"\"}`,\n        initial: {\n          color: isError ? errorColor : grey\n        },\n        animate: isComplete ? {\n          color: grey\n        } : isError ? {\n          color: errorColor\n        } : {\n          color: [grey, grey, highlight, grey, grey]\n        },\n        transition: isComplete || isError ? void 0 : {\n          duration: duration3,\n          repeat: Infinity,\n          delay: 0,\n          ease: \"easeInOut\"\n        },\n        style: {\n          willChange: isComplete || isError ? void 0 : \"color\"\n        },\n        children: /* @__PURE__ */jsx(IconComponent, {\n          size: 14,\n          \"aria-label\": isComplete ? \"completed icon\" : isError ? \"error icon\" : isThinking ? \"thinking icon\" : isEventWithPayload ? isExpanded ? \"collapse payload\" : \"expand payload\" : \"tool icon\"\n        })\n      }, `icon-${state}`), text2.split(\"\").map((char, index) => /* @__PURE__ */jsx(react_exports.motion.span, {\n        className: \"whitespace-pre\",\n        initial: {\n          color: isError ? errorColor : grey\n        },\n        animate: isComplete ? {\n          color: grey\n        } : isError ? {\n          color: errorColor\n        } : {\n          color: [grey, grey, highlight, grey, grey]\n        },\n        transition: isComplete || isError ? void 0 : {\n          duration: duration3,\n          repeat: Infinity,\n          delay: (index + 1) * stagger,\n          ease: \"easeInOut\"\n        },\n        style: {\n          willChange: isComplete || isError ? void 0 : \"color\"\n        },\n        children: char\n      }, `${state}-${index}`))]\n    }), isEventWithPayload && payload && isExpanded && /* @__PURE__ */jsx(react_exports.motion.div, {\n      initial: {\n        opacity: 0,\n        height: 0\n      },\n      animate: {\n        opacity: 1,\n        height: \"auto\"\n      },\n      exit: {\n        opacity: 0,\n        height: 0\n      },\n      className: \"ml-5\",\n      children: /* @__PURE__ */jsx(\"pre\", {\n        className: \"text-xs rounded py-2 overflow-x-auto opacity-70\",\n        children: formatJson(payload)\n      })\n    })]\n  });\n};\nfunction formatJson(data) {\n  if (typeof data !== \"object\" || data === null || Array.isArray(data)) {\n    throw new Error(\"Input must be a non-null object\");\n  }\n  const lines = [];\n  for (const [key, value] of Object.entries(data)) {\n    if (value && typeof value === \"object\" && !Array.isArray(value)) {\n      for (const [subKey, subValue] of Object.entries(value)) {\n        lines.push(`${key}.${subKey}: ${subValue}`);\n      }\n    } else {\n      lines.push(`${key}: ${value}`);\n    }\n  }\n  return lines.join(\"\\n\");\n}\n\n// src/store/messages/renderers/ProgressUpdateRenderer.tsx\nimport { jsx as jsx2 } from \"react/jsx-runtime\";\nvar ProgressUpdateRenderer = ({\n  message\n}) => {\n  return /* @__PURE__ */jsx2(ShimmerText, {\n    text: message.text,\n    state: message.state\n  });\n};\nvar ProgressUpdateRenderer_default = ProgressUpdateRenderer;\n\n// src/store/messages/renderers/SetStateRenderer.tsx\nimport { jsx as jsx3 } from \"react/jsx-runtime\";\nvar SetStateRenderer = ({\n  message\n}) => {\n  const defaultText = `Executed setState ${message.setterKey ?? \"\"}`;\n  const text2 = message.content || defaultText;\n  return /* @__PURE__ */jsx3(ShimmerText, {\n    text: text2,\n    state: \"complete\"\n  });\n};\nvar SetStateRenderer_default = SetStateRenderer;\n\n// src/store/messages/renderers/LegacyActionRenderer.tsx\nimport { jsx as jsx4 } from \"react/jsx-runtime\";\nvar LegacyActionRenderer = ({\n  message\n}) => {\n  const defaultText = `Executed action ${message.setterKey ?? \"\"}`;\n  const text2 = message.content || defaultText;\n  return /* @__PURE__ */jsx4(ShimmerText, {\n    text: text2,\n    state: \"complete\"\n  });\n};\nvar LegacyActionRenderer_default = LegacyActionRenderer;\n\n// src/store/messages/renderers/MastraEventRenderer.tsx\nimport { jsx as jsx5 } from \"react/jsx-runtime\";\nvar MastraEventRenderer = ({\n  message\n}) => {\n  const {\n    type,\n    runId,\n    payload\n  } = message;\n  const formatEventType = eventType => {\n    return eventType.split(\"-\").map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(\" \");\n  };\n  const text2 = message.content || `Mastra ${formatEventType(type)}`;\n  const displayPayload = {\n    runId,\n    ...(payload || {})\n  };\n  return /* @__PURE__ */jsx5(ShimmerText, {\n    text: text2,\n    state: \"eventWithPayload\",\n    payload: displayPayload\n  });\n};\nvar MastraEventRenderer_default = MastraEventRenderer;\n\n// src/store/messages/renderers/HumanInTheLoopRenderer.tsx\nimport { useState } from \"react\";\nimport { jsx as jsx6, jsxs as jsxs2 } from \"react/jsx-runtime\";\nvar HumanInTheLoopRenderer = ({\n  message\n}) => {\n  const [isProcessing, setIsProcessing] = useState(false);\n  const handleResume = async data => {\n    if (!message.resumeCallback) return;\n    setIsProcessing(true);\n    try {\n      await message.resumeCallback(data);\n    } catch (error40) {\n      console.error(\"Failed to resume workflow:\", error40);\n    } finally {\n      setIsProcessing(false);\n    }\n  };\n  const handleCancel = async () => {\n    if (!message.cancelCallback) return;\n    setIsProcessing(true);\n    try {\n      await message.cancelCallback();\n    } catch (error40) {\n      console.error(\"Failed to cancel workflow:\", error40);\n    } finally {\n      setIsProcessing(false);\n    }\n  };\n  const messages = useCedarStore(state => state.messages);\n  const isLatestMessage = messages[messages.length - 1].id === message.id;\n  switch (message.state) {\n    case \"suspended\":\n      return /* @__PURE__ */jsxs2(\"div\", {\n        className: \"human-in-the-loop-suspended\",\n        children: [/* @__PURE__ */jsx6(ShimmerText, {\n          text: message.content,\n          state: \"eventWithPayload\",\n          payload: message.suspendPayload\n        }), isLatestMessage && /* @__PURE__ */jsxs2(\"div\", {\n          className: \"actions flex gap-2 mt-3 ml-5\",\n          children: [/* @__PURE__ */jsx6(\"button\", {\n            onClick: () => handleResume({\n              approved: true\n            }),\n            disabled: isProcessing,\n            className: \"py-1 px-2 bg-blue-600 text-white rounded disabled:opacity-50 disabled:cursor-not-allowed text-sm cursor-pointer hover:bg-blue-800\",\n            children: isProcessing ? \"Processing...\" : \"Continue\"\n          }), /* @__PURE__ */jsx6(\"button\", {\n            onClick: handleCancel,\n            disabled: isProcessing,\n            className: \"py-1 text-gray-500 rounded disabled:opacity-50 disabled:cursor-not-allowed text-sm cursor-pointer hover:text-gray-700\",\n            children: isProcessing ? \"Processing...\" : \"Cancel\"\n          })]\n        })]\n      });\n    case \"resumed\":\n      return /* @__PURE__ */jsx6(\"div\", {\n        className: \"human-in-the-loop-resumed\",\n        children: /* @__PURE__ */jsx6(ShimmerText, {\n          text: message.content,\n          state: \"complete\",\n          payload: message.resumeData\n        })\n      });\n    case \"cancelled\":\n      return /* @__PURE__ */jsx6(\"div\", {\n        className: \"human-in-the-loop-cancelled\",\n        children: /* @__PURE__ */jsx6(ShimmerText, {\n          text: message.content,\n          state: \"error\",\n          payload: {\n            cancelledAt: message.cancelledAt\n          }\n        })\n      });\n    case \"timeout\":\n      return /* @__PURE__ */jsx6(\"div\", {\n        className: \"human-in-the-loop-timeout\",\n        children: /* @__PURE__ */jsx6(ShimmerText, {\n          text: message.content,\n          state: \"error\",\n          payload: {\n            reason: \"Workflow timed out and was automatically cancelled\"\n          }\n        })\n      });\n    default:\n      return /* @__PURE__ */jsx6(\"div\", {\n        className: \"human-in-the-loop-unknown\",\n        children: /* @__PURE__ */jsx6(ShimmerText, {\n          text: `Unknown workflow state: ${message.state}`,\n          state: \"error\",\n          payload: {\n            state: message.state,\n            content: message.content,\n            runId: message.runId\n          }\n        })\n      });\n  }\n};\nvar humanInTheLoopMessageRenderer = {\n  type: \"humanInTheLoop\",\n  namespace: \"default\",\n  render: message => /* @__PURE__ */jsx6(HumanInTheLoopRenderer, {\n    message\n  }),\n  validateMessage: msg => msg.type === \"humanInTheLoop\"\n};\n\n// src/store/messages/renderers/FrontendToolRenderer.tsx\nimport { jsx as jsx7 } from \"react/jsx-runtime\";\nvar defaultFrontendToolMessageRenderer = {\n  type: \"frontendTool\",\n  render: message => /* @__PURE__ */jsx7(ShimmerText, {\n    text: message.content,\n    state: \"eventWithPayload\",\n    payload: {\n      toolName: message.toolName,\n      args: message.args\n    }\n  }),\n  namespace: \"default\",\n  validateMessage: message => {\n    return message.type === \"frontendTool\";\n  }\n};\n\n// src/store/messages/renderers/initializeMessageRendererRegistry.tsx\nimport { jsx as jsx8 } from \"react/jsx-runtime\";\nvar progressUpdateMessageRenderer = {\n  type: \"progress_update\",\n  namespace: \"default\",\n  render: message => /* @__PURE__ */jsx8(ProgressUpdateRenderer_default, {\n    message\n  }),\n  validateMessage: msg => msg.type === \"progress_update\"\n};\nvar setStateResponseMessageRenderer = {\n  type: \"setState\",\n  namespace: \"default\",\n  render: message => /* @__PURE__ */jsx8(SetStateRenderer_default, {\n    message\n  }),\n  validateMessage: msg => msg.type === \"setState\"\n};\nvar legacyActionMessageRenderer = {\n  type: \"action\",\n  namespace: \"default\",\n  render: message => /* @__PURE__ */jsx8(LegacyActionRenderer_default, {\n    message\n  }),\n  validateMessage: msg => msg.type === \"action\"\n};\nvar mastraEventTypes = [\"start\", \"step-start\", \"tool-call\", \"tool-result\", \"step-finish\", \"tool-output\", \"step-result\", \"step-output\", \"finish\"];\nvar mastraEventRenderers = mastraEventTypes.map(t => ({\n  type: t,\n  namespace: \"mastra\",\n  render: message => /* @__PURE__ */jsx8(MastraEventRenderer_default, {\n    message\n  }),\n  validateMessage: msg => msg.type === t\n}));\nvar defaultMessageRenderers = [progressUpdateMessageRenderer, setStateResponseMessageRenderer, legacyActionMessageRenderer,\n// Backwards compatibility for 'action' type\nhumanInTheLoopMessageRenderer,\n// Human-in-the-loop workflow support\ndefaultFrontendToolMessageRenderer,\n// Simple frontend tool renderer (like tool but for frontend)\n...mastraEventRenderers];\nvar initializeMessageRendererRegistry = renderers => {\n  const registry2 = {};\n  renderers.forEach(renderer => {\n    const existing = registry2[renderer.type];\n    if (!existing) {\n      registry2[renderer.type] = renderer;\n    }\n  });\n  return registry2;\n};\n\n// src/store/messages/messagesSlice.ts\nvar createMessagesSlice = (set2, get) => {\n  const ensureThread = (threadId, name19) => {\n    const state = get();\n    if (!state.threadMap[threadId]) {\n      set2(state2 => ({\n        threadMap: {\n          ...state2.threadMap,\n          [threadId]: {\n            id: threadId,\n            name: name19,\n            lastLoaded: (/* @__PURE__ */new Date()).toISOString(),\n            messages: []\n          }\n        }\n      }));\n    }\n  };\n  return {\n    ...getMessageStorageState(set2, get),\n    // === CORE STATE ===\n    // Start with empty threadMap - threads will be created during initialization\n    threadMap: {},\n    mainThreadId: \"\",\n    isProcessing: false,\n    showChat: false,\n    messageRenderers: initializeMessageRendererRegistry(defaultMessageRenderers),\n    // === COMPUTED GETTER ===\n    // This makes the slice backward compatible\n    messages: [],\n    // Initialize with empty array, will be synced with current thread\n    // === ACTIONS (thread-aware) ===\n    setMessages: (messages, threadId) => {\n      const tid = threadId || get().mainThreadId;\n      ensureThread(tid);\n      set2(state => ({\n        threadMap: {\n          ...state.threadMap,\n          [tid]: {\n            ...state.threadMap[tid],\n            messages,\n            lastLoaded: (/* @__PURE__ */new Date()).toISOString()\n          }\n        },\n        // Update main messages if it's the current thread\n        messages: tid === state.mainThreadId ? messages : state.messages\n      }));\n    },\n    addMessage: (messageData, isComplete = true, threadId) => {\n      const tid = threadId || get().mainThreadId;\n      ensureThread(tid);\n      const newMessage = {\n        ...messageData,\n        id: messageData.id || `message-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`,\n        createdAt: (/* @__PURE__ */new Date()).toISOString()\n      };\n      set2(state => {\n        const existingThread = state.threadMap[tid];\n        const thread = existingThread || {\n          id: tid,\n          lastLoaded: (/* @__PURE__ */new Date()).toISOString(),\n          messages: []\n        };\n        const updatedMessages = [...thread.messages, newMessage];\n        return {\n          ...state,\n          threadMap: {\n            ...state.threadMap,\n            [tid]: {\n              ...thread,\n              messages: updatedMessages,\n              lastLoaded: (/* @__PURE__ */new Date()).toISOString()\n            }\n          },\n          // Update main messages if it's the current thread\n          messages: tid === state.mainThreadId ? updatedMessages : state.messages\n        };\n      });\n      if (isComplete) {\n        try {\n          get().persistMessageStorageMessage(newMessage);\n        } catch (error40) {\n          console.error(\"Error persisting message:\", error40);\n        }\n      }\n      return newMessage;\n    },\n    appendToLatestMessage: (content, isComplete = true, threadId) => {\n      const state = get();\n      const tid = threadId || state.mainThreadId;\n      ensureThread(tid);\n      const thread = state.threadMap[tid] || get().threadMap[tid];\n      if (!thread) {\n        return get().addMessage({\n          role: \"assistant\",\n          type: \"text\",\n          content\n        }, isComplete, tid);\n      }\n      const messages = thread.messages;\n      const latestMessage = messages[messages.length - 1];\n      if (latestMessage && latestMessage.role !== \"user\" && latestMessage.type === \"text\") {\n        const updatedLatestMessage = {\n          ...latestMessage,\n          content: latestMessage.content + content\n        };\n        get().updateMessage(latestMessage.id, updatedLatestMessage, tid);\n        return updatedLatestMessage;\n      } else {\n        return get().addMessage({\n          role: \"assistant\",\n          type: \"text\",\n          content\n        }, isComplete, tid);\n      }\n    },\n    updateMessage: (id, updates, threadId) => {\n      const tid = threadId || get().mainThreadId;\n      set2(state => {\n        const thread = state.threadMap[tid];\n        if (!thread) return state;\n        const updatedMessages = thread.messages.map(msg => msg.id === id ? {\n          ...msg,\n          ...updates\n        } : msg);\n        return {\n          threadMap: {\n            ...state.threadMap,\n            [tid]: {\n              ...thread,\n              messages: updatedMessages\n            }\n          },\n          // Update main messages if it's the current thread\n          messages: tid === state.mainThreadId ? updatedMessages : state.messages\n        };\n      });\n    },\n    deleteMessage: (id, threadId) => {\n      const tid = threadId || get().mainThreadId;\n      set2(state => {\n        const thread = state.threadMap[tid];\n        if (!thread) return state;\n        const updatedMessages = thread.messages.filter(msg => msg.id !== id);\n        return {\n          threadMap: {\n            ...state.threadMap,\n            [tid]: {\n              ...thread,\n              messages: updatedMessages\n            }\n          },\n          // Update main messages if it's the current thread\n          messages: tid === state.mainThreadId ? updatedMessages : state.messages\n        };\n      });\n    },\n    clearMessages: threadId => {\n      const tid = threadId || get().mainThreadId;\n      set2(state => ({\n        threadMap: {\n          ...state.threadMap,\n          [tid]: {\n            ...state.threadMap[tid],\n            messages: [],\n            lastLoaded: (/* @__PURE__ */new Date()).toISOString()\n          }\n        },\n        // Update main messages if it's the current thread\n        messages: tid === state.mainThreadId ? [] : state.messages\n      }));\n    },\n    // === THREAD MANAGEMENT ===\n    setMainThreadId: threadId => {\n      ensureThread(threadId);\n      const threadMessages = get().threadMap[threadId]?.messages || [];\n      set2({\n        mainThreadId: threadId,\n        messages: threadMessages\n        // Update messages to match new thread\n      });\n    },\n    createThread: (threadId, name19) => {\n      const tid = threadId || `thread-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\n      set2(state => ({\n        ...state,\n        threadMap: {\n          ...state.threadMap,\n          [tid]: {\n            id: tid,\n            name: name19,\n            lastLoaded: (/* @__PURE__ */new Date()).toISOString(),\n            messages: []\n          }\n        }\n      }));\n      return tid;\n    },\n    deleteThread: threadId => {\n      if (threadId === DEFAULT_THREAD_ID || threadId === get().mainThreadId) {\n        console.warn(`Cannot delete ${threadId === DEFAULT_THREAD_ID ? \"default\" : \"current\"} thread`);\n        return;\n      }\n      set2(state => {\n        const {\n          [threadId]: deleted,\n          ...rest\n        } = state.threadMap;\n        void deleted;\n        return {\n          threadMap: rest\n        };\n      });\n    },\n    updateThreadName: (threadId, name19) => {\n      set2(state => {\n        const thread = state.threadMap[threadId];\n        if (!thread) return state;\n        return {\n          ...state,\n          threadMap: {\n            ...state.threadMap,\n            [threadId]: {\n              ...thread,\n              name: name19\n            }\n          }\n        };\n      });\n    },\n    switchThread: (threadId, name19) => {\n      set2(state => {\n        const threadExists = state.threadMap[threadId];\n        const threadToUse = threadExists || {\n          id: threadId,\n          name: name19,\n          lastLoaded: (/* @__PURE__ */new Date()).toISOString(),\n          messages: []\n        };\n        if (!threadExists || threadToUse.messages.length === 0) {\n          get().initializeChat({\n            threadId\n          });\n        }\n        return {\n          ...state,\n          threadMap: {\n            ...state.threadMap,\n            [threadId]: threadToUse\n          },\n          mainThreadId: threadId,\n          messages: threadToUse.messages\n        };\n      });\n    },\n    // === THREAD GETTERS ===\n    getThread: threadId => {\n      const tid = threadId || get().mainThreadId;\n      return get().threadMap[tid];\n    },\n    getThreadMessages: threadId => {\n      const tid = threadId || get().mainThreadId;\n      return get().threadMap[tid]?.messages || [];\n    },\n    getAllThreadIds: () => {\n      return Object.keys(get().threadMap);\n    },\n    getCurrentThreadId: () => {\n      return get().mainThreadId;\n    },\n    // === UTILITY METHODS ===\n    getMessageById: (id, threadId) => {\n      const tid = threadId || get().mainThreadId;\n      return get().threadMap[tid]?.messages.find(msg => msg.id === id);\n    },\n    getMessagesByRole: (role, threadId) => {\n      const tid = threadId || get().mainThreadId;\n      return get().threadMap[tid]?.messages.filter(msg => msg.role === role) || [];\n    },\n    // === EXISTING METHODS (unchanged) ===\n    setIsProcessing: isProcessing => set2({\n      isProcessing\n    }),\n    setShowChat: showChat => set2({\n      showChat\n    }),\n    registerMessageRenderer: config2 => {\n      set2(state => ({\n        messageRenderers: {\n          ...state.messageRenderers,\n          [config2.type]: config2\n        }\n      }));\n    },\n    unregisterMessageRenderer: (type, namespace) => {\n      set2(state => {\n        const existing = state.messageRenderers[type];\n        if (!existing) return {};\n        if (!namespace || existing.namespace === namespace) {\n          const {\n            [type]: removed,\n            ...rest\n          } = state.messageRenderers;\n          void removed;\n          return {\n            messageRenderers: rest\n          };\n        }\n        return {};\n      });\n    },\n    getMessageRenderers: type => {\n      return get().messageRenderers[type];\n    }\n  };\n};\n\n// src/store/agentConnection/agentUtils.ts\nvar processContentChunk = rawChunk => {\n  return rawChunk.replace(/(\\\\n|\\n)/g, \"\\n\");\n};\nasync function handleEventStream(response, handler) {\n  if (!response.ok || !response.body) {\n    throw new Error(`HTTP error! status: ${response.status}`);\n  }\n  const reader = response.body.getReader();\n  const decoder = new TextDecoder();\n  let buffer = \"\";\n  const completedItems = [];\n  let currentTextMessage = \"\";\n  const parseSSEEvent = raw => {\n    let eventType = \"message\";\n    let data = \"\";\n    for (const line of raw.split(\"\\n\")) {\n      if (line.startsWith(\"event:\")) {\n        eventType = line.slice(6).trim();\n      } else if (line.startsWith(\"data:\")) {\n        data += line.slice(5);\n      }\n    }\n    return {\n      eventType,\n      data\n    };\n  };\n  const processDataContent = data => {\n    if (data.trim() === \"[DONE]\" || data.trim() === \"done\") {\n      return;\n    }\n    try {\n      const parsed = JSON.parse(data);\n      if (parsed === null || typeof parsed !== \"object\") {\n        const processedContent = processContentChunk(String(parsed));\n        currentTextMessage += processedContent;\n        handler({\n          type: \"chunk\",\n          content: processedContent\n        });\n        return;\n      }\n      if (parsed.choices && parsed.choices[0] && parsed.choices[0].delta) {\n        const delta = parsed.choices[0].delta;\n        if (delta.content) {\n          const processedContent = processContentChunk(delta.content);\n          currentTextMessage += processedContent;\n          handler({\n            type: \"chunk\",\n            content: processedContent\n          });\n        }\n        if (delta.tool_calls || delta.function_call) {\n          if (currentTextMessage.trim()) {\n            completedItems.push(currentTextMessage.trim());\n            currentTextMessage = \"\";\n          }\n          handler({\n            type: \"object\",\n            object: delta\n          });\n          completedItems.push(delta);\n        }\n        if (Object.keys(delta).length === 0) {\n          return;\n        }\n      }\n      if (typeof parsed.content === \"string\" && parsed.content.length > 0) {\n        const processedContent = processContentChunk(parsed.content);\n        currentTextMessage += processedContent;\n        handler({\n          type: \"chunk\",\n          content: processedContent\n        });\n      }\n      if (parsed.type || parsed.object && parsed.object.type) {\n        const structuredObject = parsed.type ? parsed : parsed.object;\n        if (currentTextMessage.trim()) {\n          completedItems.push(currentTextMessage.trim());\n          currentTextMessage = \"\";\n        }\n        handler({\n          type: \"object\",\n          object: structuredObject\n        });\n        completedItems.push(structuredObject);\n      }\n      if (!parsed.choices && !parsed.type && !(parsed.object && parsed.object.type) && !parsed.content) {\n        if (currentTextMessage.trim()) {\n          completedItems.push(currentTextMessage.trim());\n          currentTextMessage = \"\";\n        }\n        handler({\n          type: \"object\",\n          object: parsed\n        });\n        completedItems.push(parsed);\n      }\n    } catch {\n      if (data && data !== \"[DONE]\" && data !== \"done\") {\n        const processedContent = processContentChunk(data);\n        currentTextMessage += processedContent;\n        handler({\n          type: \"chunk\",\n          content: processedContent\n        });\n      }\n    }\n  };\n  try {\n    while (true) {\n      const {\n        value,\n        done\n      } = await reader.read();\n      if (done) break;\n      buffer += decoder.decode(value, {\n        stream: true\n      });\n      let eventBoundary;\n      while ((eventBoundary = buffer.indexOf(\"\\n\\n\")) !== -1) {\n        const rawEvent = buffer.slice(0, eventBoundary);\n        buffer = buffer.slice(eventBoundary + 2);\n        if (!rawEvent.trim()) continue;\n        const {\n          eventType,\n          data\n        } = parseSSEEvent(rawEvent);\n        if (eventType.trim() === \"done\" || data.trim() === \"[DONE]\") {\n          break;\n        } else {\n          processDataContent(data);\n        }\n      }\n    }\n    if (currentTextMessage.trim()) {\n      completedItems.push(currentTextMessage.trim());\n    }\n    handler({\n      type: \"done\",\n      completedItems\n    });\n  } catch (error40) {\n    handler({\n      type: \"error\",\n      error: error40\n    });\n    throw error40;\n  }\n}\n\n// src/store/agentConnection/providers/openai.ts\nvar openAIProvider = {\n  callLLM: async (params, config2) => {\n    const {\n      prompt,\n      model,\n      systemPrompt,\n      temperature,\n      maxTokens,\n      messages: providedMessages,\n      ...rest\n    } = params;\n    const messages = providedMessages || [...(systemPrompt ? [{\n      role: \"system\",\n      content: systemPrompt\n    }] : []), {\n      role: \"user\",\n      content: prompt || \"\"\n    }];\n    const response = await fetch(\"https://api.openai.com/v1/chat/completions\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${config2.apiKey}`\n      },\n      body: JSON.stringify({\n        model,\n        messages,\n        temperature,\n        max_tokens: maxTokens,\n        ...rest\n      })\n    });\n    return openAIProvider.handleResponse(response);\n  },\n  streamLLM: (params, config2, handler) => {\n    const abortController = new AbortController();\n    const completion = (async () => {\n      try {\n        const {\n          prompt,\n          model,\n          systemPrompt,\n          temperature,\n          maxTokens,\n          messages: providedMessages,\n          ...rest\n        } = params;\n        const messages = providedMessages || [...(systemPrompt ? [{\n          role: \"system\",\n          content: systemPrompt\n        }] : []), {\n          role: \"user\",\n          content: prompt || \"\"\n        }];\n        const response = await fetch(\"https://api.openai.com/v1/chat/completions\", {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n            Authorization: `Bearer ${config2.apiKey}`\n          },\n          body: JSON.stringify({\n            model,\n            messages,\n            temperature,\n            max_tokens: maxTokens,\n            stream: true,\n            ...rest\n          }),\n          signal: abortController.signal\n        });\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        await handleEventStream(response, handler);\n      } catch (error40) {\n        if (error40 instanceof Error && error40.name !== \"AbortError\") {\n          handler({\n            type: \"error\",\n            error: error40\n          });\n        }\n      }\n    })();\n    return {\n      abort: () => abortController.abort(),\n      completion\n    };\n  },\n  handleResponse: async response => {\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.json();\n    return {\n      content: data.choices?.[0]?.message?.content || \"\",\n      usage: data.usage ? {\n        promptTokens: data.usage.prompt_tokens,\n        completionTokens: data.usage.completion_tokens,\n        totalTokens: data.usage.total_tokens\n      } : void 0,\n      metadata: {\n        model: data.model,\n        id: data.id\n      }\n    };\n  },\n  callLLMStructured: async (params, config2) => {\n    const {\n      prompt,\n      model,\n      systemPrompt,\n      temperature,\n      maxTokens,\n      schema,\n      schemaName,\n      schemaDescription,\n      ...rest\n    } = params;\n    const messages = [...(systemPrompt ? [{\n      role: \"system\",\n      content: systemPrompt\n    }] : []), {\n      role: \"user\",\n      content: prompt\n    }];\n    const body = {\n      model,\n      messages,\n      temperature,\n      max_tokens: maxTokens,\n      ...rest\n    };\n    if (schema) {\n      body.response_format = {\n        type: \"json_schema\",\n        json_schema: {\n          name: schemaName || \"response\",\n          description: schemaDescription,\n          schema,\n          strict: true\n        }\n      };\n    }\n    const response = await fetch(\"https://api.openai.com/v1/chat/completions\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${config2.apiKey}`\n      },\n      body: JSON.stringify(body)\n    });\n    const result = await openAIProvider.handleResponse(response);\n    if (schema && result.content) {\n      try {\n        result.object = JSON.parse(result.content);\n      } catch {}\n    }\n    return result;\n  },\n  voiceLLM: async (params, config2) => {\n    const {\n      audioData,\n      voiceSettings,\n      context\n    } = params;\n    const voiceEndpoint = voiceSettings.endpoint || \"/voice\";\n    const fullUrl = voiceEndpoint.startsWith(\"http\") ? voiceEndpoint : voiceEndpoint;\n    const formData = new FormData();\n    formData.append(\"audio\", audioData, \"recording.webm\");\n    formData.append(\"settings\", JSON.stringify(voiceSettings));\n    if (context) {\n      formData.append(\"context\", JSON.stringify(context));\n    }\n    const response = await fetch(fullUrl, {\n      method: \"POST\",\n      headers: {\n        Authorization: `Bearer ${config2.apiKey}`\n      },\n      body: formData\n    });\n    if (!response.ok) {\n      throw new Error(`Voice endpoint returned ${response.status}`);\n    }\n    const contentType = response.headers.get(\"content-type\");\n    if (contentType?.includes(\"audio\")) {\n      const audioBuffer = await response.arrayBuffer();\n      const base643 = btoa(String.fromCharCode(...new Uint8Array(audioBuffer)));\n      return {\n        content: \"\",\n        audioData: base643,\n        audioFormat: contentType\n      };\n    } else if (contentType?.includes(\"application/json\")) {\n      const data = await response.json();\n      return {\n        content: data.text || data.content || \"\",\n        transcription: data.transcription,\n        audioData: data.audioData,\n        audioUrl: data.audioUrl,\n        audioFormat: data.audioFormat,\n        usage: data.usage,\n        metadata: data.metadata,\n        object: data.object\n      };\n    } else {\n      const text2 = await response.text();\n      return {\n        content: text2\n      };\n    }\n  }\n};\n\n// src/store/agentConnection/providers/mastra.ts\nasync function handleVoiceEventStream(response, handler) {\n  const reader = response.body?.getReader();\n  if (!reader) {\n    throw new Error(\"Response body is not readable\");\n  }\n  const decoder = new TextDecoder();\n  let buffer = \"\";\n  try {\n    while (true) {\n      const {\n        done,\n        value\n      } = await reader.read();\n      if (done) break;\n      const chunk = decoder.decode(value, {\n        stream: true\n      });\n      buffer += chunk;\n      const lines = buffer.split(\"\\n\");\n      buffer = lines.pop() || \"\";\n      for (const line of lines) {\n        const trimmedLine = line.trim();\n        if (!trimmedLine || !trimmedLine.startsWith(\"data: \")) continue;\n        const data = trimmedLine.slice(6);\n        try {\n          const parsed = JSON.parse(data);\n          if (parsed.type === \"transcription\" && parsed.transcription) {\n            handler({\n              type: \"transcription\",\n              transcription: parsed.transcription\n            });\n          } else if (parsed.type === \"audio\" && parsed.audioData) {\n            handler({\n              type: \"audio\",\n              audioData: parsed.audioData,\n              audioFormat: parsed.audioFormat,\n              content: parsed.content\n            });\n          } else if (parsed.type === \"chunk\" && parsed.content) {\n            handler({\n              type: \"chunk\",\n              content: parsed.content\n            });\n          } else if (parsed.type === \"object\" && parsed.object) {\n            handler({\n              type: \"object\",\n              object: parsed.object\n            });\n          } else if (parsed.type === \"error\") {\n            handler({\n              type: \"error\",\n              error: new Error(parsed.error || \"Stream error\")\n            });\n          } else if (parsed.type === \"done\") {\n            handler({\n              type: \"done\",\n              completedItems: parsed.completedItems || []\n            });\n          }\n        } catch (parseError) {\n          console.warn(\"Failed to parse voice stream event:\", parseError);\n          console.warn(\"Problematic data length:\", data.length);\n        }\n      }\n    }\n    if (buffer.trim()) {\n      const trimmedLine = buffer.trim();\n      if (trimmedLine.startsWith(\"data: \")) {\n        const data = trimmedLine.slice(6);\n        try {\n          const parsed = JSON.parse(data);\n          if (parsed.type === \"transcription\" && parsed.transcription) {\n            handler({\n              type: \"transcription\",\n              transcription: parsed.transcription\n            });\n          } else if (parsed.type === \"audio\" && parsed.audioData) {\n            handler({\n              type: \"audio\",\n              audioData: parsed.audioData,\n              audioFormat: parsed.audioFormat,\n              content: parsed.content\n            });\n          } else if (parsed.type === \"chunk\" && parsed.content) {\n            handler({\n              type: \"chunk\",\n              content: parsed.content\n            });\n          } else if (parsed.type === \"object\" && parsed.object) {\n            handler({\n              type: \"object\",\n              object: parsed.object\n            });\n          } else if (parsed.type === \"error\") {\n            handler({\n              type: \"error\",\n              error: new Error(parsed.error || \"Stream error\")\n            });\n          } else if (parsed.type === \"done\") {\n            handler({\n              type: \"done\",\n              completedItems: parsed.completedItems || []\n            });\n          }\n        } catch (parseError) {\n          console.warn(\"Failed to parse final voice stream event:\", parseError);\n        }\n      }\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\nvar mastraProvider = {\n  callLLM: async (params, config2) => {\n    const {\n      route,\n      prompt,\n      systemPrompt,\n      temperature,\n      maxTokens,\n      ...rest\n    } = params;\n    const headers = {\n      \"Content-Type\": \"application/json\"\n    };\n    if (config2.apiKey) {\n      headers.Authorization = `Bearer ${config2.apiKey}`;\n    }\n    const response = await fetch(`${config2.baseURL}${route}`, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify({\n        prompt,\n        systemPrompt,\n        temperature,\n        maxTokens,\n        ...rest\n      })\n    });\n    return mastraProvider.handleResponse(response);\n  },\n  callLLMStructured: async (params, config2) => {\n    const {\n      route,\n      prompt,\n      systemPrompt,\n      temperature,\n      maxTokens,\n      schema,\n      schemaName,\n      schemaDescription,\n      ...rest\n    } = params;\n    const headers = {\n      \"Content-Type\": \"application/json\"\n    };\n    if (config2.apiKey) {\n      headers.Authorization = `Bearer ${config2.apiKey}`;\n    }\n    const body = {\n      prompt,\n      systemPrompt,\n      temperature,\n      maxTokens,\n      ...rest\n    };\n    if (schema) {\n      body.schema = schema;\n      body.schemaName = schemaName;\n      body.schemaDescription = schemaDescription;\n    }\n    const response = await fetch(`${config2.baseURL}${route}`, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify(body)\n    });\n    return mastraProvider.handleResponse(response);\n  },\n  streamLLM: (params, config2, handler) => {\n    const abortController = new AbortController();\n    const completion = (async () => {\n      try {\n        const {\n          route,\n          prompt,\n          systemPrompt,\n          temperature,\n          maxTokens,\n          ...rest\n        } = params;\n        const headers = {\n          \"Content-Type\": \"application/json\"\n        };\n        if (config2.apiKey) {\n          headers.Authorization = `Bearer ${config2.apiKey}`;\n        }\n        const response = await fetch(`${config2.baseURL}${route}/stream`, {\n          method: \"POST\",\n          headers,\n          body: JSON.stringify({\n            prompt,\n            systemPrompt,\n            temperature,\n            maxTokens,\n            ...rest\n          }),\n          signal: abortController.signal\n        });\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        await handleEventStream(response, handler);\n      } catch (error40) {\n        if (error40 instanceof Error && error40.name !== \"AbortError\") {\n          handler({\n            type: \"error\",\n            error: error40\n          });\n        }\n      }\n    })();\n    return {\n      abort: () => abortController.abort(),\n      completion\n    };\n  },\n  voiceLLM: async (params, config2) => {\n    const {\n      audioData,\n      voiceSettings,\n      context,\n      ...rest\n    } = params;\n    const headers = {};\n    if (config2.apiKey) {\n      headers.Authorization = `Bearer ${config2.apiKey}`;\n    }\n    const voiceEndpoint = voiceSettings.endpoint || config2.voiceRoute || \"/voice\";\n    const fullUrl = voiceEndpoint.startsWith(\"http\") ? voiceEndpoint : `${config2.baseURL}${voiceEndpoint}`;\n    const formData = new FormData();\n    formData.append(\"audio\", audioData, \"recording.webm\");\n    formData.append(\"settings\", JSON.stringify(voiceSettings));\n    if (context) {\n      formData.append(\"context\", JSON.stringify(context));\n    }\n    for (const [key, value] of Object.entries(rest)) {\n      if (value === void 0 || value === null) continue;\n      if (typeof value === \"object\") {\n        formData.append(key, JSON.stringify(value));\n      } else {\n        formData.append(key, String(value));\n      }\n    }\n    const response = await fetch(fullUrl, {\n      method: \"POST\",\n      headers,\n      body: formData\n    });\n    if (!response.ok) {\n      throw new Error(`Voice endpoint returned ${response.status}`);\n    }\n    const contentType = response.headers.get(\"content-type\");\n    if (contentType?.includes(\"audio\")) {\n      const audioBuffer = await response.arrayBuffer();\n      const base643 = btoa(String.fromCharCode(...new Uint8Array(audioBuffer)));\n      return {\n        content: \"\",\n        audioData: base643,\n        audioFormat: contentType\n      };\n    } else if (contentType?.includes(\"application/json\")) {\n      const data = await response.json();\n      return {\n        content: data.text || data.content || \"\",\n        transcription: data.transcription,\n        audioData: data.audioData,\n        audioUrl: data.audioUrl,\n        audioFormat: data.audioFormat,\n        usage: data.usage,\n        metadata: data.metadata,\n        object: data.object\n      };\n    } else {\n      const text2 = await response.text();\n      return {\n        content: text2\n      };\n    }\n  },\n  voiceStreamLLM: (params, config2, handler) => {\n    const abortController = new AbortController();\n    const completion = (async () => {\n      try {\n        const {\n          audioData,\n          voiceSettings,\n          context,\n          ...rest\n        } = params;\n        const headers = {};\n        if (config2.apiKey) {\n          headers.Authorization = `Bearer ${config2.apiKey}`;\n        }\n        const voiceEndpoint = voiceSettings.endpoint || config2.voiceRoute || \"/voice\";\n        const fullUrl = voiceEndpoint.startsWith(\"http\") ? voiceEndpoint : `${config2.baseURL}${voiceEndpoint}`;\n        const streamUrl = fullUrl.endsWith(\"/stream\") ? fullUrl : `${fullUrl}/stream`;\n        const formData = new FormData();\n        formData.append(\"audio\", audioData, \"recording.webm\");\n        formData.append(\"settings\", JSON.stringify(voiceSettings));\n        if (context) {\n          formData.append(\"context\", JSON.stringify(context));\n        }\n        for (const [key, value] of Object.entries(rest)) {\n          if (value === void 0 || value === null) continue;\n          if (typeof value === \"object\") {\n            formData.append(key, JSON.stringify(value));\n          } else {\n            formData.append(key, String(value));\n          }\n        }\n        const response = await fetch(streamUrl, {\n          method: \"POST\",\n          headers,\n          body: formData,\n          signal: abortController.signal\n        });\n        if (!response.ok) {\n          throw new Error(`Voice stream endpoint returned ${response.status}`);\n        }\n        await handleVoiceEventStream(response, handler);\n      } catch (error40) {\n        if (error40 instanceof Error && error40.name !== \"AbortError\") {\n          handler({\n            type: \"error\",\n            error: error40\n          });\n        }\n      }\n    })();\n    return {\n      abort: () => abortController.abort(),\n      completion\n    };\n  },\n  handleResponse: async response => {\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.json();\n    return {\n      content: data.text || data.content || \"\",\n      usage: data.usage,\n      metadata: {\n        model: data.model,\n        id: data.id\n      },\n      object: data.object\n      // Include the structured output if present\n    };\n  }\n};\n\n// ../../node_modules/@ai-sdk/gateway/node_modules/@ai-sdk/provider/dist/index.mjs\nvar marker = \"vercel.ai.error\";\nvar symbol = Symbol.for(marker);\nvar _a;\nvar _AISDKError = class _AISDKError2 extends Error {\n  /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */\n  constructor({\n    name: name143,\n    message,\n    cause\n  }) {\n    super(message);\n    this[_a] = true;\n    this.name = name143;\n    this.cause = cause;\n  }\n  /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */\n  static isInstance(error40) {\n    return _AISDKError2.hasMarker(error40, marker);\n  }\n  static hasMarker(error40, marker153) {\n    const markerSymbol = Symbol.for(marker153);\n    return error40 != null && typeof error40 === \"object\" && markerSymbol in error40 && typeof error40[markerSymbol] === \"boolean\" && error40[markerSymbol] === true;\n  }\n};\n_a = symbol;\nvar AISDKError = _AISDKError;\nvar name = \"AI_APICallError\";\nvar marker2 = `vercel.ai.error.${name}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar APICallError = class extends AISDKError {\n  constructor({\n    message,\n    url: url2,\n    requestBodyValues,\n    statusCode,\n    responseHeaders,\n    responseBody,\n    cause,\n    isRetryable = statusCode != null && (statusCode === 408 ||\n    // request timeout\n    statusCode === 409 ||\n    // conflict\n    statusCode === 429 ||\n    // too many requests\n    statusCode >= 500),\n    // server error\n    data\n  }) {\n    super({\n      name,\n      message,\n      cause\n    });\n    this[_a2] = true;\n    this.url = url2;\n    this.requestBodyValues = requestBodyValues;\n    this.statusCode = statusCode;\n    this.responseHeaders = responseHeaders;\n    this.responseBody = responseBody;\n    this.isRetryable = isRetryable;\n    this.data = data;\n  }\n  static isInstance(error40) {\n    return AISDKError.hasMarker(error40, marker2);\n  }\n};\n_a2 = symbol2;\nvar name2 = \"AI_EmptyResponseBodyError\";\nvar marker3 = `vercel.ai.error.${name2}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar EmptyResponseBodyError = class extends AISDKError {\n  // used in isInstance\n  constructor({\n    message = \"Empty response body\"\n  } = {}) {\n    super({\n      name: name2,\n      message\n    });\n    this[_a3] = true;\n  }\n  static isInstance(error40) {\n    return AISDKError.hasMarker(error40, marker3);\n  }\n};\n_a3 = symbol3;\nfunction getErrorMessage(error40) {\n  if (error40 == null) {\n    return \"unknown error\";\n  }\n  if (typeof error40 === \"string\") {\n    return error40;\n  }\n  if (error40 instanceof Error) {\n    return error40.message;\n  }\n  return JSON.stringify(error40);\n}\nvar name3 = \"AI_InvalidArgumentError\";\nvar marker4 = `vercel.ai.error.${name3}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar InvalidArgumentError = class extends AISDKError {\n  constructor({\n    message,\n    cause,\n    argument\n  }) {\n    super({\n      name: name3,\n      message,\n      cause\n    });\n    this[_a4] = true;\n    this.argument = argument;\n  }\n  static isInstance(error40) {\n    return AISDKError.hasMarker(error40, marker4);\n  }\n};\n_a4 = symbol4;\nvar name4 = \"AI_InvalidPromptError\";\nvar marker5 = `vercel.ai.error.${name4}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\n_a5 = symbol5;\nvar name5 = \"AI_InvalidResponseDataError\";\nvar marker6 = `vercel.ai.error.${name5}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\n_a6 = symbol6;\nvar name6 = \"AI_JSONParseError\";\nvar marker7 = `vercel.ai.error.${name6}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar JSONParseError = class extends AISDKError {\n  constructor({\n    text: text2,\n    cause\n  }) {\n    super({\n      name: name6,\n      message: `JSON parsing failed: Text: ${text2}.\nError message: ${getErrorMessage(cause)}`,\n      cause\n    });\n    this[_a7] = true;\n    this.text = text2;\n  }\n  static isInstance(error40) {\n    return AISDKError.hasMarker(error40, marker7);\n  }\n};\n_a7 = symbol7;\nvar name7 = \"AI_LoadAPIKeyError\";\nvar marker8 = `vercel.ai.error.${name7}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\n_a8 = symbol8;\nvar name8 = \"AI_LoadSettingError\";\nvar marker9 = `vercel.ai.error.${name8}`;\nvar symbol9 = Symbol.for(marker9);\nvar _a9;\n_a9 = symbol9;\nvar name9 = \"AI_NoContentGeneratedError\";\nvar marker10 = `vercel.ai.error.${name9}`;\nvar symbol10 = Symbol.for(marker10);\nvar _a10;\n_a10 = symbol10;\nvar name10 = \"AI_NoSuchModelError\";\nvar marker11 = `vercel.ai.error.${name10}`;\nvar symbol11 = Symbol.for(marker11);\nvar _a11;\nvar NoSuchModelError = class extends AISDKError {\n  constructor({\n    errorName = name10,\n    modelId,\n    modelType,\n    message = `No such ${modelType}: ${modelId}`\n  }) {\n    super({\n      name: errorName,\n      message\n    });\n    this[_a11] = true;\n    this.modelId = modelId;\n    this.modelType = modelType;\n  }\n  static isInstance(error40) {\n    return AISDKError.hasMarker(error40, marker11);\n  }\n};\n_a11 = symbol11;\nvar name11 = \"AI_TooManyEmbeddingValuesForCallError\";\nvar marker12 = `vercel.ai.error.${name11}`;\nvar symbol12 = Symbol.for(marker12);\nvar _a12;\n_a12 = symbol12;\nvar name12 = \"AI_TypeValidationError\";\nvar marker13 = `vercel.ai.error.${name12}`;\nvar symbol13 = Symbol.for(marker13);\nvar _a13;\nvar _TypeValidationError = class _TypeValidationError2 extends AISDKError {\n  constructor({\n    value,\n    cause\n  }) {\n    super({\n      name: name12,\n      message: `Type validation failed: Value: ${JSON.stringify(value)}.\nError message: ${getErrorMessage(cause)}`,\n      cause\n    });\n    this[_a13] = true;\n    this.value = value;\n  }\n  static isInstance(error40) {\n    return AISDKError.hasMarker(error40, marker13);\n  }\n  /**\n   * Wraps an error into a TypeValidationError.\n   * If the cause is already a TypeValidationError with the same value, it returns the cause.\n   * Otherwise, it creates a new TypeValidationError.\n   *\n   * @param {Object} params - The parameters for wrapping the error.\n   * @param {unknown} params.value - The value that failed validation.\n   * @param {unknown} params.cause - The original error or cause of the validation failure.\n   * @returns {TypeValidationError} A TypeValidationError instance.\n   */\n  static wrap({\n    value,\n    cause\n  }) {\n    return _TypeValidationError2.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError2({\n      value,\n      cause\n    });\n  }\n};\n_a13 = symbol13;\nvar TypeValidationError = _TypeValidationError;\nvar name13 = \"AI_UnsupportedFunctionalityError\";\nvar marker14 = `vercel.ai.error.${name13}`;\nvar symbol14 = Symbol.for(marker14);\nvar _a14;\n_a14 = symbol14;\n\n// ../../node_modules/eventsource-parser/dist/index.js\nvar ParseError = class extends Error {\n  constructor(message, options) {\n    super(message), this.name = \"ParseError\", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;\n  }\n};\nfunction noop(_arg) {}\nfunction createParser(callbacks) {\n  if (typeof callbacks == \"function\") throw new TypeError(\"`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?\");\n  const {\n    onEvent = noop,\n    onError = noop,\n    onRetry = noop,\n    onComment\n  } = callbacks;\n  let incompleteLine = \"\",\n    isFirstChunk = true,\n    id,\n    data = \"\",\n    eventType = \"\";\n  function feed(newChunk) {\n    const chunk = isFirstChunk ? newChunk.replace(/^\\xEF\\xBB\\xBF/, \"\") : newChunk,\n      [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);\n    for (const line of complete) parseLine(line);\n    incompleteLine = incomplete, isFirstChunk = false;\n  }\n  function parseLine(line) {\n    if (line === \"\") {\n      dispatchEvent();\n      return;\n    }\n    if (line.startsWith(\":\")) {\n      onComment && onComment(line.slice(line.startsWith(\": \") ? 2 : 1));\n      return;\n    }\n    const fieldSeparatorIndex = line.indexOf(\":\");\n    if (fieldSeparatorIndex !== -1) {\n      const field = line.slice(0, fieldSeparatorIndex),\n        offset2 = line[fieldSeparatorIndex + 1] === \" \" ? 2 : 1,\n        value = line.slice(fieldSeparatorIndex + offset2);\n      processField(field, value, line);\n      return;\n    }\n    processField(line, \"\", line);\n  }\n  function processField(field, value, line) {\n    switch (field) {\n      case \"event\":\n        eventType = value;\n        break;\n      case \"data\":\n        data = `${data}${value}\n`;\n        break;\n      case \"id\":\n        id = value.includes(\"\\0\") ? void 0 : value;\n        break;\n      case \"retry\":\n        /^\\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(new ParseError(`Invalid \\`retry\\` value: \"${value}\"`, {\n          type: \"invalid-retry\",\n          value,\n          line\n        }));\n        break;\n      default:\n        onError(new ParseError(`Unknown field \"${field.length > 20 ? `${field.slice(0, 20)}\\u2026` : field}\"`, {\n          type: \"unknown-field\",\n          field,\n          value,\n          line\n        }));\n        break;\n    }\n  }\n  function dispatchEvent() {\n    data.length > 0 && onEvent({\n      id,\n      event: eventType || void 0,\n      // If the data buffer's last character is a U+000A LINE FEED (LF) character,\n      // then remove the last character from the data buffer.\n      data: data.endsWith(`\n`) ? data.slice(0, -1) : data\n    }), id = void 0, data = \"\", eventType = \"\";\n  }\n  function reset(options = {}) {\n    incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = true, id = void 0, data = \"\", eventType = \"\", incompleteLine = \"\";\n  }\n  return {\n    feed,\n    reset\n  };\n}\nfunction splitLines(chunk) {\n  const lines = [];\n  let incompleteLine = \"\",\n    searchIndex = 0;\n  for (; searchIndex < chunk.length;) {\n    const crIndex = chunk.indexOf(\"\\r\", searchIndex),\n      lfIndex = chunk.indexOf(`\n`, searchIndex);\n    let lineEnd = -1;\n    if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? crIndex === chunk.length - 1 ? lineEnd = -1 : lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {\n      incompleteLine = chunk.slice(searchIndex);\n      break;\n    } else {\n      const line = chunk.slice(searchIndex, lineEnd);\n      lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === \"\\r\" && chunk[searchIndex] === `\n` && searchIndex++;\n    }\n  }\n  return [lines, incompleteLine];\n}\n\n// ../../node_modules/eventsource-parser/dist/stream.js\nvar EventSourceParserStream = class extends TransformStream {\n  constructor({\n    onError,\n    onRetry,\n    onComment\n  } = {}) {\n    let parser;\n    super({\n      start(controller) {\n        parser = createParser({\n          onEvent: event => {\n            controller.enqueue(event);\n          },\n          onError(error40) {\n            onError === \"terminate\" ? controller.error(error40) : typeof onError == \"function\" && onError(error40);\n          },\n          onRetry,\n          onComment\n        });\n      },\n      transform(chunk) {\n        parser.feed(chunk);\n      }\n    });\n  }\n};\n\n// ../../node_modules/zod/v4/classic/external.js\nvar external_exports2 = {};\n__export(external_exports2, {\n  $brand: () => $brand,\n  $input: () => $input,\n  $output: () => $output,\n  NEVER: () => NEVER2,\n  TimePrecision: () => TimePrecision,\n  ZodAny: () => ZodAny2,\n  ZodArray: () => ZodArray2,\n  ZodBase64: () => ZodBase64,\n  ZodBase64URL: () => ZodBase64URL,\n  ZodBigInt: () => ZodBigInt2,\n  ZodBigIntFormat: () => ZodBigIntFormat,\n  ZodBoolean: () => ZodBoolean2,\n  ZodCIDRv4: () => ZodCIDRv4,\n  ZodCIDRv6: () => ZodCIDRv6,\n  ZodCUID: () => ZodCUID,\n  ZodCUID2: () => ZodCUID2,\n  ZodCatch: () => ZodCatch2,\n  ZodCustom: () => ZodCustom,\n  ZodCustomStringFormat: () => ZodCustomStringFormat,\n  ZodDate: () => ZodDate2,\n  ZodDefault: () => ZodDefault2,\n  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion2,\n  ZodE164: () => ZodE164,\n  ZodEmail: () => ZodEmail,\n  ZodEmoji: () => ZodEmoji,\n  ZodEnum: () => ZodEnum2,\n  ZodError: () => ZodError2,\n  ZodFile: () => ZodFile,\n  ZodGUID: () => ZodGUID,\n  ZodIPv4: () => ZodIPv4,\n  ZodIPv6: () => ZodIPv6,\n  ZodISODate: () => ZodISODate,\n  ZodISODateTime: () => ZodISODateTime,\n  ZodISODuration: () => ZodISODuration,\n  ZodISOTime: () => ZodISOTime,\n  ZodIntersection: () => ZodIntersection2,\n  ZodIssueCode: () => ZodIssueCode2,\n  ZodJWT: () => ZodJWT,\n  ZodKSUID: () => ZodKSUID,\n  ZodLazy: () => ZodLazy2,\n  ZodLiteral: () => ZodLiteral2,\n  ZodMap: () => ZodMap2,\n  ZodNaN: () => ZodNaN2,\n  ZodNanoID: () => ZodNanoID,\n  ZodNever: () => ZodNever2,\n  ZodNonOptional: () => ZodNonOptional,\n  ZodNull: () => ZodNull2,\n  ZodNullable: () => ZodNullable2,\n  ZodNumber: () => ZodNumber2,\n  ZodNumberFormat: () => ZodNumberFormat,\n  ZodObject: () => ZodObject2,\n  ZodOptional: () => ZodOptional2,\n  ZodPipe: () => ZodPipe,\n  ZodPrefault: () => ZodPrefault,\n  ZodPromise: () => ZodPromise2,\n  ZodReadonly: () => ZodReadonly2,\n  ZodRealError: () => ZodRealError,\n  ZodRecord: () => ZodRecord2,\n  ZodSet: () => ZodSet2,\n  ZodString: () => ZodString2,\n  ZodStringFormat: () => ZodStringFormat,\n  ZodSuccess: () => ZodSuccess,\n  ZodSymbol: () => ZodSymbol2,\n  ZodTemplateLiteral: () => ZodTemplateLiteral,\n  ZodTransform: () => ZodTransform,\n  ZodTuple: () => ZodTuple2,\n  ZodType: () => ZodType2,\n  ZodULID: () => ZodULID,\n  ZodURL: () => ZodURL,\n  ZodUUID: () => ZodUUID,\n  ZodUndefined: () => ZodUndefined2,\n  ZodUnion: () => ZodUnion2,\n  ZodUnknown: () => ZodUnknown2,\n  ZodVoid: () => ZodVoid2,\n  ZodXID: () => ZodXID,\n  _ZodString: () => _ZodString,\n  _default: () => _default2,\n  any: () => any,\n  array: () => array,\n  base64: () => base642,\n  base64url: () => base64url2,\n  bigint: () => bigint2,\n  boolean: () => boolean2,\n  catch: () => _catch2,\n  check: () => check,\n  cidrv4: () => cidrv42,\n  cidrv6: () => cidrv62,\n  clone: () => clone,\n  coerce: () => coerce_exports,\n  config: () => config,\n  core: () => core_exports2,\n  cuid: () => cuid3,\n  cuid2: () => cuid22,\n  custom: () => custom2,\n  date: () => date3,\n  discriminatedUnion: () => discriminatedUnion,\n  e164: () => e1642,\n  email: () => email2,\n  emoji: () => emoji2,\n  endsWith: () => _endsWith,\n  enum: () => _enum2,\n  file: () => file,\n  flattenError: () => flattenError,\n  float32: () => float32,\n  float64: () => float64,\n  formatError: () => formatError,\n  function: () => _function,\n  getErrorMap: () => getErrorMap2,\n  globalRegistry: () => globalRegistry,\n  gt: () => _gt,\n  gte: () => _gte,\n  guid: () => guid2,\n  includes: () => _includes,\n  instanceof: () => _instanceof,\n  int: () => int,\n  int32: () => int32,\n  int64: () => int64,\n  intersection: () => intersection,\n  ipv4: () => ipv42,\n  ipv6: () => ipv62,\n  iso: () => iso_exports,\n  json: () => json,\n  jwt: () => jwt,\n  keyof: () => keyof,\n  ksuid: () => ksuid2,\n  lazy: () => lazy,\n  length: () => _length,\n  literal: () => literal,\n  locales: () => locales_exports,\n  looseObject: () => looseObject,\n  lowercase: () => _lowercase,\n  lt: () => _lt,\n  lte: () => _lte,\n  map: () => map,\n  maxLength: () => _maxLength,\n  maxSize: () => _maxSize,\n  mime: () => _mime,\n  minLength: () => _minLength,\n  minSize: () => _minSize,\n  multipleOf: () => _multipleOf,\n  nan: () => nan,\n  nanoid: () => nanoid2,\n  nativeEnum: () => nativeEnum,\n  negative: () => _negative,\n  never: () => never,\n  nonnegative: () => _nonnegative,\n  nonoptional: () => nonoptional,\n  nonpositive: () => _nonpositive,\n  normalize: () => _normalize,\n  null: () => _null3,\n  nullable: () => nullable,\n  nullish: () => nullish2,\n  number: () => number2,\n  object: () => object,\n  optional: () => optional,\n  overwrite: () => _overwrite,\n  parse: () => parse2,\n  parseAsync: () => parseAsync2,\n  partialRecord: () => partialRecord,\n  pipe: () => pipe,\n  positive: () => _positive,\n  prefault: () => prefault,\n  preprocess: () => preprocess,\n  prettifyError: () => prettifyError,\n  promise: () => promise,\n  property: () => _property,\n  readonly: () => readonly,\n  record: () => record,\n  refine: () => refine,\n  regex: () => _regex,\n  regexes: () => regexes_exports,\n  registry: () => registry,\n  safeParse: () => safeParse2,\n  safeParseAsync: () => safeParseAsync2,\n  set: () => set,\n  setErrorMap: () => setErrorMap2,\n  size: () => _size,\n  startsWith: () => _startsWith,\n  strictObject: () => strictObject,\n  string: () => string2,\n  stringFormat: () => stringFormat,\n  stringbool: () => stringbool,\n  success: () => success,\n  superRefine: () => superRefine,\n  symbol: () => symbol15,\n  templateLiteral: () => templateLiteral,\n  toJSONSchema: () => toJSONSchema,\n  toLowerCase: () => _toLowerCase,\n  toUpperCase: () => _toUpperCase,\n  transform: () => transform,\n  treeifyError: () => treeifyError,\n  trim: () => _trim,\n  tuple: () => tuple,\n  uint32: () => uint32,\n  uint64: () => uint64,\n  ulid: () => ulid2,\n  undefined: () => _undefined3,\n  union: () => union,\n  unknown: () => unknown,\n  uppercase: () => _uppercase,\n  url: () => url,\n  uuid: () => uuid2,\n  uuidv4: () => uuidv4,\n  uuidv6: () => uuidv6,\n  uuidv7: () => uuidv7,\n  void: () => _void2,\n  xid: () => xid2\n});\n\n// ../../node_modules/zod/v4/core/index.js\nvar core_exports2 = {};\n__export(core_exports2, {\n  $ZodAny: () => $ZodAny,\n  $ZodArray: () => $ZodArray,\n  $ZodAsyncError: () => $ZodAsyncError,\n  $ZodBase64: () => $ZodBase64,\n  $ZodBase64URL: () => $ZodBase64URL,\n  $ZodBigInt: () => $ZodBigInt,\n  $ZodBigIntFormat: () => $ZodBigIntFormat,\n  $ZodBoolean: () => $ZodBoolean,\n  $ZodCIDRv4: () => $ZodCIDRv4,\n  $ZodCIDRv6: () => $ZodCIDRv6,\n  $ZodCUID: () => $ZodCUID,\n  $ZodCUID2: () => $ZodCUID2,\n  $ZodCatch: () => $ZodCatch,\n  $ZodCheck: () => $ZodCheck,\n  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,\n  $ZodCheckEndsWith: () => $ZodCheckEndsWith,\n  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,\n  $ZodCheckIncludes: () => $ZodCheckIncludes,\n  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,\n  $ZodCheckLessThan: () => $ZodCheckLessThan,\n  $ZodCheckLowerCase: () => $ZodCheckLowerCase,\n  $ZodCheckMaxLength: () => $ZodCheckMaxLength,\n  $ZodCheckMaxSize: () => $ZodCheckMaxSize,\n  $ZodCheckMimeType: () => $ZodCheckMimeType,\n  $ZodCheckMinLength: () => $ZodCheckMinLength,\n  $ZodCheckMinSize: () => $ZodCheckMinSize,\n  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,\n  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,\n  $ZodCheckOverwrite: () => $ZodCheckOverwrite,\n  $ZodCheckProperty: () => $ZodCheckProperty,\n  $ZodCheckRegex: () => $ZodCheckRegex,\n  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,\n  $ZodCheckStartsWith: () => $ZodCheckStartsWith,\n  $ZodCheckStringFormat: () => $ZodCheckStringFormat,\n  $ZodCheckUpperCase: () => $ZodCheckUpperCase,\n  $ZodCustom: () => $ZodCustom,\n  $ZodCustomStringFormat: () => $ZodCustomStringFormat,\n  $ZodDate: () => $ZodDate,\n  $ZodDefault: () => $ZodDefault,\n  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,\n  $ZodE164: () => $ZodE164,\n  $ZodEmail: () => $ZodEmail,\n  $ZodEmoji: () => $ZodEmoji,\n  $ZodEnum: () => $ZodEnum,\n  $ZodError: () => $ZodError,\n  $ZodFile: () => $ZodFile,\n  $ZodFunction: () => $ZodFunction,\n  $ZodGUID: () => $ZodGUID,\n  $ZodIPv4: () => $ZodIPv4,\n  $ZodIPv6: () => $ZodIPv6,\n  $ZodISODate: () => $ZodISODate,\n  $ZodISODateTime: () => $ZodISODateTime,\n  $ZodISODuration: () => $ZodISODuration,\n  $ZodISOTime: () => $ZodISOTime,\n  $ZodIntersection: () => $ZodIntersection,\n  $ZodJWT: () => $ZodJWT,\n  $ZodKSUID: () => $ZodKSUID,\n  $ZodLazy: () => $ZodLazy,\n  $ZodLiteral: () => $ZodLiteral,\n  $ZodMap: () => $ZodMap,\n  $ZodNaN: () => $ZodNaN,\n  $ZodNanoID: () => $ZodNanoID,\n  $ZodNever: () => $ZodNever,\n  $ZodNonOptional: () => $ZodNonOptional,\n  $ZodNull: () => $ZodNull,\n  $ZodNullable: () => $ZodNullable,\n  $ZodNumber: () => $ZodNumber,\n  $ZodNumberFormat: () => $ZodNumberFormat,\n  $ZodObject: () => $ZodObject,\n  $ZodOptional: () => $ZodOptional,\n  $ZodPipe: () => $ZodPipe,\n  $ZodPrefault: () => $ZodPrefault,\n  $ZodPromise: () => $ZodPromise,\n  $ZodReadonly: () => $ZodReadonly,\n  $ZodRealError: () => $ZodRealError,\n  $ZodRecord: () => $ZodRecord,\n  $ZodRegistry: () => $ZodRegistry,\n  $ZodSet: () => $ZodSet,\n  $ZodString: () => $ZodString,\n  $ZodStringFormat: () => $ZodStringFormat,\n  $ZodSuccess: () => $ZodSuccess,\n  $ZodSymbol: () => $ZodSymbol,\n  $ZodTemplateLiteral: () => $ZodTemplateLiteral,\n  $ZodTransform: () => $ZodTransform,\n  $ZodTuple: () => $ZodTuple,\n  $ZodType: () => $ZodType,\n  $ZodULID: () => $ZodULID,\n  $ZodURL: () => $ZodURL,\n  $ZodUUID: () => $ZodUUID,\n  $ZodUndefined: () => $ZodUndefined,\n  $ZodUnion: () => $ZodUnion,\n  $ZodUnknown: () => $ZodUnknown,\n  $ZodVoid: () => $ZodVoid,\n  $ZodXID: () => $ZodXID,\n  $brand: () => $brand,\n  $constructor: () => $constructor,\n  $input: () => $input,\n  $output: () => $output,\n  Doc: () => Doc,\n  JSONSchema: () => json_schema_exports,\n  JSONSchemaGenerator: () => JSONSchemaGenerator,\n  NEVER: () => NEVER2,\n  TimePrecision: () => TimePrecision,\n  _any: () => _any,\n  _array: () => _array,\n  _base64: () => _base64,\n  _base64url: () => _base64url,\n  _bigint: () => _bigint,\n  _boolean: () => _boolean,\n  _catch: () => _catch,\n  _cidrv4: () => _cidrv4,\n  _cidrv6: () => _cidrv6,\n  _coercedBigint: () => _coercedBigint,\n  _coercedBoolean: () => _coercedBoolean,\n  _coercedDate: () => _coercedDate,\n  _coercedNumber: () => _coercedNumber,\n  _coercedString: () => _coercedString,\n  _cuid: () => _cuid,\n  _cuid2: () => _cuid2,\n  _custom: () => _custom,\n  _date: () => _date,\n  _default: () => _default,\n  _discriminatedUnion: () => _discriminatedUnion,\n  _e164: () => _e164,\n  _email: () => _email,\n  _emoji: () => _emoji2,\n  _endsWith: () => _endsWith,\n  _enum: () => _enum,\n  _file: () => _file,\n  _float32: () => _float32,\n  _float64: () => _float64,\n  _gt: () => _gt,\n  _gte: () => _gte,\n  _guid: () => _guid,\n  _includes: () => _includes,\n  _int: () => _int,\n  _int32: () => _int32,\n  _int64: () => _int64,\n  _intersection: () => _intersection,\n  _ipv4: () => _ipv4,\n  _ipv6: () => _ipv6,\n  _isoDate: () => _isoDate,\n  _isoDateTime: () => _isoDateTime,\n  _isoDuration: () => _isoDuration,\n  _isoTime: () => _isoTime,\n  _jwt: () => _jwt,\n  _ksuid: () => _ksuid,\n  _lazy: () => _lazy,\n  _length: () => _length,\n  _literal: () => _literal,\n  _lowercase: () => _lowercase,\n  _lt: () => _lt,\n  _lte: () => _lte,\n  _map: () => _map,\n  _max: () => _lte,\n  _maxLength: () => _maxLength,\n  _maxSize: () => _maxSize,\n  _mime: () => _mime,\n  _min: () => _gte,\n  _minLength: () => _minLength,\n  _minSize: () => _minSize,\n  _multipleOf: () => _multipleOf,\n  _nan: () => _nan,\n  _nanoid: () => _nanoid,\n  _nativeEnum: () => _nativeEnum,\n  _negative: () => _negative,\n  _never: () => _never,\n  _nonnegative: () => _nonnegative,\n  _nonoptional: () => _nonoptional,\n  _nonpositive: () => _nonpositive,\n  _normalize: () => _normalize,\n  _null: () => _null2,\n  _nullable: () => _nullable,\n  _number: () => _number,\n  _optional: () => _optional,\n  _overwrite: () => _overwrite,\n  _parse: () => _parse,\n  _parseAsync: () => _parseAsync,\n  _pipe: () => _pipe,\n  _positive: () => _positive,\n  _promise: () => _promise,\n  _property: () => _property,\n  _readonly: () => _readonly,\n  _record: () => _record,\n  _refine: () => _refine,\n  _regex: () => _regex,\n  _safeParse: () => _safeParse,\n  _safeParseAsync: () => _safeParseAsync,\n  _set: () => _set,\n  _size: () => _size,\n  _startsWith: () => _startsWith,\n  _string: () => _string,\n  _stringFormat: () => _stringFormat,\n  _stringbool: () => _stringbool,\n  _success: () => _success,\n  _symbol: () => _symbol,\n  _templateLiteral: () => _templateLiteral,\n  _toLowerCase: () => _toLowerCase,\n  _toUpperCase: () => _toUpperCase,\n  _transform: () => _transform,\n  _trim: () => _trim,\n  _tuple: () => _tuple,\n  _uint32: () => _uint32,\n  _uint64: () => _uint64,\n  _ulid: () => _ulid,\n  _undefined: () => _undefined2,\n  _union: () => _union,\n  _unknown: () => _unknown,\n  _uppercase: () => _uppercase,\n  _url: () => _url,\n  _uuid: () => _uuid,\n  _uuidv4: () => _uuidv4,\n  _uuidv6: () => _uuidv6,\n  _uuidv7: () => _uuidv7,\n  _void: () => _void,\n  _xid: () => _xid,\n  clone: () => clone,\n  config: () => config,\n  flattenError: () => flattenError,\n  formatError: () => formatError,\n  function: () => _function,\n  globalConfig: () => globalConfig,\n  globalRegistry: () => globalRegistry,\n  isValidBase64: () => isValidBase64,\n  isValidBase64URL: () => isValidBase64URL,\n  isValidJWT: () => isValidJWT2,\n  locales: () => locales_exports,\n  parse: () => parse,\n  parseAsync: () => parseAsync,\n  prettifyError: () => prettifyError,\n  regexes: () => regexes_exports,\n  registry: () => registry,\n  safeParse: () => safeParse,\n  safeParseAsync: () => safeParseAsync,\n  toDotPath: () => toDotPath,\n  toJSONSchema: () => toJSONSchema,\n  treeifyError: () => treeifyError,\n  util: () => util_exports,\n  version: () => version\n});\n\n// ../../node_modules/zod/v4/core/core.js\nvar NEVER2 = Object.freeze({\n  status: \"aborted\"\n});\n// @__NO_SIDE_EFFECTS__\nfunction $constructor(name19, initializer3, params) {\n  function init(inst, def) {\n    var _a20;\n    Object.defineProperty(inst, \"_zod\", {\n      value: inst._zod ?? {},\n      enumerable: false\n    });\n    (_a20 = inst._zod).traits ?? (_a20.traits = /* @__PURE__ */new Set());\n    inst._zod.traits.add(name19);\n    initializer3(inst, def);\n    for (const k in _.prototype) {\n      if (!(k in inst)) Object.defineProperty(inst, k, {\n        value: _.prototype[k].bind(inst)\n      });\n    }\n    inst._zod.constr = _;\n    inst._zod.def = def;\n  }\n  const Parent = params?.Parent ?? Object;\n  class Definition extends Parent {}\n  Object.defineProperty(Definition, \"name\", {\n    value: name19\n  });\n  function _(def) {\n    var _a20;\n    const inst = params?.Parent ? new Definition() : this;\n    init(inst, def);\n    (_a20 = inst._zod).deferred ?? (_a20.deferred = []);\n    for (const fn of inst._zod.deferred) {\n      fn();\n    }\n    return inst;\n  }\n  Object.defineProperty(_, \"init\", {\n    value: init\n  });\n  Object.defineProperty(_, Symbol.hasInstance, {\n    value: inst => {\n      if (params?.Parent && inst instanceof params.Parent) return true;\n      return inst?._zod?.traits?.has(name19);\n    }\n  });\n  Object.defineProperty(_, \"name\", {\n    value: name19\n  });\n  return _;\n}\nvar $brand = Symbol(\"zod_brand\");\nvar $ZodAsyncError = class extends Error {\n  constructor() {\n    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);\n  }\n};\nvar globalConfig = {};\nfunction config(newConfig) {\n  if (newConfig) Object.assign(globalConfig, newConfig);\n  return globalConfig;\n}\n\n// ../../node_modules/zod/v4/core/util.js\nvar util_exports = {};\n__export(util_exports, {\n  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,\n  Class: () => Class,\n  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,\n  aborted: () => aborted,\n  allowsEval: () => allowsEval,\n  assert: () => assert,\n  assertEqual: () => assertEqual,\n  assertIs: () => assertIs,\n  assertNever: () => assertNever,\n  assertNotEqual: () => assertNotEqual,\n  assignProp: () => assignProp,\n  cached: () => cached,\n  captureStackTrace: () => captureStackTrace,\n  cleanEnum: () => cleanEnum,\n  cleanRegex: () => cleanRegex,\n  clone: () => clone,\n  createTransparentProxy: () => createTransparentProxy,\n  defineLazy: () => defineLazy,\n  esc: () => esc,\n  escapeRegex: () => escapeRegex,\n  extend: () => extend,\n  finalizeIssue: () => finalizeIssue,\n  floatSafeRemainder: () => floatSafeRemainder2,\n  getElementAtPath: () => getElementAtPath,\n  getEnumValues: () => getEnumValues,\n  getLengthableOrigin: () => getLengthableOrigin,\n  getParsedType: () => getParsedType2,\n  getSizableOrigin: () => getSizableOrigin,\n  isObject: () => isObject,\n  isPlainObject: () => isPlainObject,\n  issue: () => issue,\n  joinValues: () => joinValues,\n  jsonStringifyReplacer: () => jsonStringifyReplacer,\n  merge: () => merge,\n  normalizeParams: () => normalizeParams,\n  nullish: () => nullish,\n  numKeys: () => numKeys,\n  omit: () => omit,\n  optionalKeys: () => optionalKeys,\n  partial: () => partial,\n  pick: () => pick,\n  prefixIssues: () => prefixIssues,\n  primitiveTypes: () => primitiveTypes,\n  promiseAllObject: () => promiseAllObject,\n  propertyKeyTypes: () => propertyKeyTypes,\n  randomString: () => randomString,\n  required: () => required,\n  stringifyPrimitive: () => stringifyPrimitive,\n  unwrapMessage: () => unwrapMessage\n});\nfunction assertEqual(val) {\n  return val;\n}\nfunction assertNotEqual(val) {\n  return val;\n}\nfunction assertIs(_arg) {}\nfunction assertNever(_x) {\n  throw new Error();\n}\nfunction assert(_) {}\nfunction getEnumValues(entries) {\n  const numericValues = Object.values(entries).filter(v => typeof v === \"number\");\n  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);\n  return values;\n}\nfunction joinValues(array2, separator = \"|\") {\n  return array2.map(val => stringifyPrimitive(val)).join(separator);\n}\nfunction jsonStringifyReplacer(_, value) {\n  if (typeof value === \"bigint\") return value.toString();\n  return value;\n}\nfunction cached(getter) {\n  const set2 = false;\n  return {\n    get value() {\n      if (!set2) {\n        const value = getter();\n        Object.defineProperty(this, \"value\", {\n          value\n        });\n        return value;\n      }\n      throw new Error(\"cached value already set\");\n    }\n  };\n}\nfunction nullish(input) {\n  return input === null || input === void 0;\n}\nfunction cleanRegex(source) {\n  const start = source.startsWith(\"^\") ? 1 : 0;\n  const end = source.endsWith(\"$\") ? source.length - 1 : source.length;\n  return source.slice(start, end);\n}\nfunction floatSafeRemainder2(val, step) {\n  const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n  const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n  const valInt = Number.parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n  const stepInt = Number.parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n  return valInt % stepInt / 10 ** decCount;\n}\nfunction defineLazy(object3, key, getter) {\n  const set2 = false;\n  Object.defineProperty(object3, key, {\n    get() {\n      if (!set2) {\n        const value = getter();\n        object3[key] = value;\n        return value;\n      }\n      throw new Error(\"cached value already set\");\n    },\n    set(v) {\n      Object.defineProperty(object3, key, {\n        value: v\n        // configurable: true,\n      });\n    },\n    configurable: true\n  });\n}\nfunction assignProp(target, prop, value) {\n  Object.defineProperty(target, prop, {\n    value,\n    writable: true,\n    enumerable: true,\n    configurable: true\n  });\n}\nfunction getElementAtPath(obj, path) {\n  if (!path) return obj;\n  return path.reduce((acc, key) => acc?.[key], obj);\n}\nfunction promiseAllObject(promisesObj) {\n  const keys2 = Object.keys(promisesObj);\n  const promises = keys2.map(key => promisesObj[key]);\n  return Promise.all(promises).then(results => {\n    const resolvedObj = {};\n    for (let i = 0; i < keys2.length; i++) {\n      resolvedObj[keys2[i]] = results[i];\n    }\n    return resolvedObj;\n  });\n}\nfunction randomString(length = 10) {\n  const chars = \"abcdefghijklmnopqrstuvwxyz\";\n  let str = \"\";\n  for (let i = 0; i < length; i++) {\n    str += chars[Math.floor(Math.random() * chars.length)];\n  }\n  return str;\n}\nfunction esc(str) {\n  return JSON.stringify(str);\n}\nvar captureStackTrace = Error.captureStackTrace ? Error.captureStackTrace : (..._args) => {};\nfunction isObject(data) {\n  return typeof data === \"object\" && data !== null && !Array.isArray(data);\n}\nvar allowsEval = cached(() => {\n  if (typeof navigator !== \"undefined\" && navigator?.userAgent?.includes(\"Cloudflare\")) {\n    return false;\n  }\n  try {\n    const F = Function;\n    new F(\"\");\n    return true;\n  } catch (_) {\n    return false;\n  }\n});\nfunction isPlainObject(o) {\n  if (isObject(o) === false) return false;\n  const ctor = o.constructor;\n  if (ctor === void 0) return true;\n  const prot = ctor.prototype;\n  if (isObject(prot) === false) return false;\n  if (Object.prototype.hasOwnProperty.call(prot, \"isPrototypeOf\") === false) {\n    return false;\n  }\n  return true;\n}\nfunction numKeys(data) {\n  let keyCount = 0;\n  for (const key in data) {\n    if (Object.prototype.hasOwnProperty.call(data, key)) {\n      keyCount++;\n    }\n  }\n  return keyCount;\n}\nvar getParsedType2 = data => {\n  const t = typeof data;\n  switch (t) {\n    case \"undefined\":\n      return \"undefined\";\n    case \"string\":\n      return \"string\";\n    case \"number\":\n      return Number.isNaN(data) ? \"nan\" : \"number\";\n    case \"boolean\":\n      return \"boolean\";\n    case \"function\":\n      return \"function\";\n    case \"bigint\":\n      return \"bigint\";\n    case \"symbol\":\n      return \"symbol\";\n    case \"object\":\n      if (Array.isArray(data)) {\n        return \"array\";\n      }\n      if (data === null) {\n        return \"null\";\n      }\n      if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n        return \"promise\";\n      }\n      if (typeof Map !== \"undefined\" && data instanceof Map) {\n        return \"map\";\n      }\n      if (typeof Set !== \"undefined\" && data instanceof Set) {\n        return \"set\";\n      }\n      if (typeof Date !== \"undefined\" && data instanceof Date) {\n        return \"date\";\n      }\n      if (typeof File !== \"undefined\" && data instanceof File) {\n        return \"file\";\n      }\n      return \"object\";\n    default:\n      throw new Error(`Unknown data type: ${t}`);\n  }\n};\nvar propertyKeyTypes = /* @__PURE__ */new Set([\"string\", \"number\", \"symbol\"]);\nvar primitiveTypes = /* @__PURE__ */new Set([\"string\", \"number\", \"bigint\", \"boolean\", \"symbol\", \"undefined\"]);\nfunction escapeRegex(str) {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction clone(inst, def, params) {\n  const cl = new inst._zod.constr(def ?? inst._zod.def);\n  if (!def || params?.parent) cl._zod.parent = inst;\n  return cl;\n}\nfunction normalizeParams(_params) {\n  const params = _params;\n  if (!params) return {};\n  if (typeof params === \"string\") return {\n    error: () => params\n  };\n  if (params?.message !== void 0) {\n    if (params?.error !== void 0) throw new Error(\"Cannot specify both `message` and `error` params\");\n    params.error = params.message;\n  }\n  delete params.message;\n  if (typeof params.error === \"string\") return {\n    ...params,\n    error: () => params.error\n  };\n  return params;\n}\nfunction createTransparentProxy(getter) {\n  let target;\n  return new Proxy({}, {\n    get(_, prop, receiver) {\n      target ?? (target = getter());\n      return Reflect.get(target, prop, receiver);\n    },\n    set(_, prop, value, receiver) {\n      target ?? (target = getter());\n      return Reflect.set(target, prop, value, receiver);\n    },\n    has(_, prop) {\n      target ?? (target = getter());\n      return Reflect.has(target, prop);\n    },\n    deleteProperty(_, prop) {\n      target ?? (target = getter());\n      return Reflect.deleteProperty(target, prop);\n    },\n    ownKeys(_) {\n      target ?? (target = getter());\n      return Reflect.ownKeys(target);\n    },\n    getOwnPropertyDescriptor(_, prop) {\n      target ?? (target = getter());\n      return Reflect.getOwnPropertyDescriptor(target, prop);\n    },\n    defineProperty(_, prop, descriptor) {\n      target ?? (target = getter());\n      return Reflect.defineProperty(target, prop, descriptor);\n    }\n  });\n}\nfunction stringifyPrimitive(value) {\n  if (typeof value === \"bigint\") return value.toString() + \"n\";\n  if (typeof value === \"string\") return `\"${value}\"`;\n  return `${value}`;\n}\nfunction optionalKeys(shape) {\n  return Object.keys(shape).filter(k => {\n    return shape[k]._zod.optin === \"optional\" && shape[k]._zod.optout === \"optional\";\n  });\n}\nvar NUMBER_FORMAT_RANGES = {\n  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],\n  int32: [-2147483648, 2147483647],\n  uint32: [0, 4294967295],\n  float32: [-34028234663852886e22, 34028234663852886e22],\n  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]\n};\nvar BIGINT_FORMAT_RANGES = {\n  int64: [/* @__PURE__ */BigInt(\"-9223372036854775808\"), /* @__PURE__ */BigInt(\"9223372036854775807\")],\n  uint64: [/* @__PURE__ */BigInt(0), /* @__PURE__ */BigInt(\"18446744073709551615\")]\n};\nfunction pick(schema, mask) {\n  const newShape = {};\n  const currDef = schema._zod.def;\n  for (const key in mask) {\n    if (!(key in currDef.shape)) {\n      throw new Error(`Unrecognized key: \"${key}\"`);\n    }\n    if (!mask[key]) continue;\n    newShape[key] = currDef.shape[key];\n  }\n  return clone(schema, {\n    ...schema._zod.def,\n    shape: newShape,\n    checks: []\n  });\n}\nfunction omit(schema, mask) {\n  const newShape = {\n    ...schema._zod.def.shape\n  };\n  const currDef = schema._zod.def;\n  for (const key in mask) {\n    if (!(key in currDef.shape)) {\n      throw new Error(`Unrecognized key: \"${key}\"`);\n    }\n    if (!mask[key]) continue;\n    delete newShape[key];\n  }\n  return clone(schema, {\n    ...schema._zod.def,\n    shape: newShape,\n    checks: []\n  });\n}\nfunction extend(schema, shape) {\n  if (!isPlainObject(shape)) {\n    throw new Error(\"Invalid input to extend: expected a plain object\");\n  }\n  const def = {\n    ...schema._zod.def,\n    get shape() {\n      const _shape = {\n        ...schema._zod.def.shape,\n        ...shape\n      };\n      assignProp(this, \"shape\", _shape);\n      return _shape;\n    },\n    checks: []\n    // delete existing checks\n  };\n  return clone(schema, def);\n}\nfunction merge(a, b) {\n  return clone(a, {\n    ...a._zod.def,\n    get shape() {\n      const _shape = {\n        ...a._zod.def.shape,\n        ...b._zod.def.shape\n      };\n      assignProp(this, \"shape\", _shape);\n      return _shape;\n    },\n    catchall: b._zod.def.catchall,\n    checks: []\n    // delete existing checks\n  });\n}\nfunction partial(Class2, schema, mask) {\n  const oldShape = schema._zod.def.shape;\n  const shape = {\n    ...oldShape\n  };\n  if (mask) {\n    for (const key in mask) {\n      if (!(key in oldShape)) {\n        throw new Error(`Unrecognized key: \"${key}\"`);\n      }\n      if (!mask[key]) continue;\n      shape[key] = Class2 ? new Class2({\n        type: \"optional\",\n        innerType: oldShape[key]\n      }) : oldShape[key];\n    }\n  } else {\n    for (const key in oldShape) {\n      shape[key] = Class2 ? new Class2({\n        type: \"optional\",\n        innerType: oldShape[key]\n      }) : oldShape[key];\n    }\n  }\n  return clone(schema, {\n    ...schema._zod.def,\n    shape,\n    checks: []\n  });\n}\nfunction required(Class2, schema, mask) {\n  const oldShape = schema._zod.def.shape;\n  const shape = {\n    ...oldShape\n  };\n  if (mask) {\n    for (const key in mask) {\n      if (!(key in shape)) {\n        throw new Error(`Unrecognized key: \"${key}\"`);\n      }\n      if (!mask[key]) continue;\n      shape[key] = new Class2({\n        type: \"nonoptional\",\n        innerType: oldShape[key]\n      });\n    }\n  } else {\n    for (const key in oldShape) {\n      shape[key] = new Class2({\n        type: \"nonoptional\",\n        innerType: oldShape[key]\n      });\n    }\n  }\n  return clone(schema, {\n    ...schema._zod.def,\n    shape,\n    // optional: [],\n    checks: []\n  });\n}\nfunction aborted(x, startIndex = 0) {\n  for (let i = startIndex; i < x.issues.length; i++) {\n    if (x.issues[i]?.continue !== true) return true;\n  }\n  return false;\n}\nfunction prefixIssues(path, issues) {\n  return issues.map(iss => {\n    var _a20;\n    (_a20 = iss).path ?? (_a20.path = []);\n    iss.path.unshift(path);\n    return iss;\n  });\n}\nfunction unwrapMessage(message) {\n  return typeof message === \"string\" ? message : message?.message;\n}\nfunction finalizeIssue(iss, ctx, config2) {\n  const full = {\n    ...iss,\n    path: iss.path ?? []\n  };\n  if (!iss.message) {\n    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? \"Invalid input\";\n    full.message = message;\n  }\n  delete full.inst;\n  delete full.continue;\n  if (!ctx?.reportInput) {\n    delete full.input;\n  }\n  return full;\n}\nfunction getSizableOrigin(input) {\n  if (input instanceof Set) return \"set\";\n  if (input instanceof Map) return \"map\";\n  if (input instanceof File) return \"file\";\n  return \"unknown\";\n}\nfunction getLengthableOrigin(input) {\n  if (Array.isArray(input)) return \"array\";\n  if (typeof input === \"string\") return \"string\";\n  return \"unknown\";\n}\nfunction issue(...args) {\n  const [iss, input, inst] = args;\n  if (typeof iss === \"string\") {\n    return {\n      message: iss,\n      code: \"custom\",\n      input,\n      inst\n    };\n  }\n  return {\n    ...iss\n  };\n}\nfunction cleanEnum(obj) {\n  return Object.entries(obj).filter(([k, _]) => {\n    return Number.isNaN(Number.parseInt(k, 10));\n  }).map(el => el[1]);\n}\nvar Class = class {\n  constructor(..._args) {}\n};\n\n// ../../node_modules/zod/v4/core/errors.js\nvar initializer = (inst, def) => {\n  inst.name = \"$ZodError\";\n  Object.defineProperty(inst, \"_zod\", {\n    value: inst._zod,\n    enumerable: false\n  });\n  Object.defineProperty(inst, \"issues\", {\n    value: def,\n    enumerable: false\n  });\n  Object.defineProperty(inst, \"message\", {\n    get() {\n      return JSON.stringify(def, jsonStringifyReplacer, 2);\n    },\n    enumerable: true\n    // configurable: false,\n  });\n  Object.defineProperty(inst, \"toString\", {\n    value: () => inst.message,\n    enumerable: false\n  });\n};\nvar $ZodError = $constructor(\"$ZodError\", initializer);\nvar $ZodRealError = $constructor(\"$ZodError\", initializer, {\n  Parent: Error\n});\nfunction flattenError(error40, mapper = issue2 => issue2.message) {\n  const fieldErrors = {};\n  const formErrors = [];\n  for (const sub of error40.issues) {\n    if (sub.path.length > 0) {\n      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n      fieldErrors[sub.path[0]].push(mapper(sub));\n    } else {\n      formErrors.push(mapper(sub));\n    }\n  }\n  return {\n    formErrors,\n    fieldErrors\n  };\n}\nfunction formatError(error40, _mapper) {\n  const mapper = _mapper || function (issue2) {\n    return issue2.message;\n  };\n  const fieldErrors = {\n    _errors: []\n  };\n  const processError = error41 => {\n    for (const issue2 of error41.issues) {\n      if (issue2.code === \"invalid_union\" && issue2.errors.length) {\n        issue2.errors.map(issues => processError({\n          issues\n        }));\n      } else if (issue2.code === \"invalid_key\") {\n        processError({\n          issues: issue2.issues\n        });\n      } else if (issue2.code === \"invalid_element\") {\n        processError({\n          issues: issue2.issues\n        });\n      } else if (issue2.path.length === 0) {\n        fieldErrors._errors.push(mapper(issue2));\n      } else {\n        let curr = fieldErrors;\n        let i = 0;\n        while (i < issue2.path.length) {\n          const el = issue2.path[i];\n          const terminal = i === issue2.path.length - 1;\n          if (!terminal) {\n            curr[el] = curr[el] || {\n              _errors: []\n            };\n          } else {\n            curr[el] = curr[el] || {\n              _errors: []\n            };\n            curr[el]._errors.push(mapper(issue2));\n          }\n          curr = curr[el];\n          i++;\n        }\n      }\n    }\n  };\n  processError(error40);\n  return fieldErrors;\n}\nfunction treeifyError(error40, _mapper) {\n  const mapper = _mapper || function (issue2) {\n    return issue2.message;\n  };\n  const result = {\n    errors: []\n  };\n  const processError = (error41, path = []) => {\n    var _a20, _b8;\n    for (const issue2 of error41.issues) {\n      if (issue2.code === \"invalid_union\" && issue2.errors.length) {\n        issue2.errors.map(issues => processError({\n          issues\n        }, issue2.path));\n      } else if (issue2.code === \"invalid_key\") {\n        processError({\n          issues: issue2.issues\n        }, issue2.path);\n      } else if (issue2.code === \"invalid_element\") {\n        processError({\n          issues: issue2.issues\n        }, issue2.path);\n      } else {\n        const fullpath = [...path, ...issue2.path];\n        if (fullpath.length === 0) {\n          result.errors.push(mapper(issue2));\n          continue;\n        }\n        let curr = result;\n        let i = 0;\n        while (i < fullpath.length) {\n          const el = fullpath[i];\n          const terminal = i === fullpath.length - 1;\n          if (typeof el === \"string\") {\n            curr.properties ?? (curr.properties = {});\n            (_a20 = curr.properties)[el] ?? (_a20[el] = {\n              errors: []\n            });\n            curr = curr.properties[el];\n          } else {\n            curr.items ?? (curr.items = []);\n            (_b8 = curr.items)[el] ?? (_b8[el] = {\n              errors: []\n            });\n            curr = curr.items[el];\n          }\n          if (terminal) {\n            curr.errors.push(mapper(issue2));\n          }\n          i++;\n        }\n      }\n    }\n  };\n  processError(error40);\n  return result;\n}\nfunction toDotPath(path) {\n  const segs = [];\n  for (const seg of path) {\n    if (typeof seg === \"number\") segs.push(`[${seg}]`);else if (typeof seg === \"symbol\") segs.push(`[${JSON.stringify(String(seg))}]`);else if (/[^\\w$]/.test(seg)) segs.push(`[${JSON.stringify(seg)}]`);else {\n      if (segs.length) segs.push(\".\");\n      segs.push(seg);\n    }\n  }\n  return segs.join(\"\");\n}\nfunction prettifyError(error40) {\n  const lines = [];\n  const issues = [...error40.issues].sort((a, b) => a.path.length - b.path.length);\n  for (const issue2 of issues) {\n    lines.push(`\\u2716 ${issue2.message}`);\n    if (issue2.path?.length) lines.push(`  \\u2192 at ${toDotPath(issue2.path)}`);\n  }\n  return lines.join(\"\\n\");\n}\n\n// ../../node_modules/zod/v4/core/parse.js\nvar _parse = _Err => (schema, value, _ctx, _params) => {\n  const ctx = _ctx ? Object.assign(_ctx, {\n    async: false\n  }) : {\n    async: false\n  };\n  const result = schema._zod.run({\n    value,\n    issues: []\n  }, ctx);\n  if (result instanceof Promise) {\n    throw new $ZodAsyncError();\n  }\n  if (result.issues.length) {\n    const e = new (_params?.Err ?? _Err)(result.issues.map(iss => finalizeIssue(iss, ctx, config())));\n    captureStackTrace(e, _params?.callee);\n    throw e;\n  }\n  return result.value;\n};\nvar parse = /* @__PURE__ */_parse($ZodRealError);\nvar _parseAsync = _Err => async (schema, value, _ctx, params) => {\n  const ctx = _ctx ? Object.assign(_ctx, {\n    async: true\n  }) : {\n    async: true\n  };\n  let result = schema._zod.run({\n    value,\n    issues: []\n  }, ctx);\n  if (result instanceof Promise) result = await result;\n  if (result.issues.length) {\n    const e = new (params?.Err ?? _Err)(result.issues.map(iss => finalizeIssue(iss, ctx, config())));\n    captureStackTrace(e, params?.callee);\n    throw e;\n  }\n  return result.value;\n};\nvar parseAsync = /* @__PURE__ */_parseAsync($ZodRealError);\nvar _safeParse = _Err => (schema, value, _ctx) => {\n  const ctx = _ctx ? {\n    ..._ctx,\n    async: false\n  } : {\n    async: false\n  };\n  const result = schema._zod.run({\n    value,\n    issues: []\n  }, ctx);\n  if (result instanceof Promise) {\n    throw new $ZodAsyncError();\n  }\n  return result.issues.length ? {\n    success: false,\n    error: new (_Err ?? $ZodError)(result.issues.map(iss => finalizeIssue(iss, ctx, config())))\n  } : {\n    success: true,\n    data: result.value\n  };\n};\nvar safeParse = /* @__PURE__ */_safeParse($ZodRealError);\nvar _safeParseAsync = _Err => async (schema, value, _ctx) => {\n  const ctx = _ctx ? Object.assign(_ctx, {\n    async: true\n  }) : {\n    async: true\n  };\n  let result = schema._zod.run({\n    value,\n    issues: []\n  }, ctx);\n  if (result instanceof Promise) result = await result;\n  return result.issues.length ? {\n    success: false,\n    error: new _Err(result.issues.map(iss => finalizeIssue(iss, ctx, config())))\n  } : {\n    success: true,\n    data: result.value\n  };\n};\nvar safeParseAsync = /* @__PURE__ */_safeParseAsync($ZodRealError);\n\n// ../../node_modules/zod/v4/core/regexes.js\nvar regexes_exports = {};\n__export(regexes_exports, {\n  _emoji: () => _emoji,\n  base64: () => base64,\n  base64url: () => base64url,\n  bigint: () => bigint,\n  boolean: () => boolean,\n  browserEmail: () => browserEmail,\n  cidrv4: () => cidrv4,\n  cidrv6: () => cidrv6,\n  cuid: () => cuid,\n  cuid2: () => cuid2,\n  date: () => date,\n  datetime: () => datetime,\n  domain: () => domain,\n  duration: () => duration,\n  e164: () => e164,\n  email: () => email,\n  emoji: () => emoji,\n  extendedDuration: () => extendedDuration,\n  guid: () => guid,\n  hostname: () => hostname,\n  html5Email: () => html5Email,\n  integer: () => integer,\n  ipv4: () => ipv4,\n  ipv6: () => ipv6,\n  ksuid: () => ksuid,\n  lowercase: () => lowercase,\n  nanoid: () => nanoid,\n  null: () => _null,\n  number: () => number,\n  rfc5322Email: () => rfc5322Email,\n  string: () => string,\n  time: () => time,\n  ulid: () => ulid,\n  undefined: () => _undefined,\n  unicodeEmail: () => unicodeEmail,\n  uppercase: () => uppercase,\n  uuid: () => uuid,\n  uuid4: () => uuid4,\n  uuid6: () => uuid6,\n  uuid7: () => uuid7,\n  xid: () => xid\n});\nvar cuid = /^[cC][^\\s-]{8,}$/;\nvar cuid2 = /^[0-9a-z]+$/;\nvar ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;\nvar xid = /^[0-9a-vA-V]{20}$/;\nvar ksuid = /^[A-Za-z0-9]{27}$/;\nvar nanoid = /^[a-zA-Z0-9_-]{21}$/;\nvar duration = /^P(?:(\\d+W)|(?!.*W)(?=\\d|T\\d)(\\d+Y)?(\\d+M)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+([.,]\\d+)?S)?)?)$/;\nvar extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/;\nvar guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;\nvar uuid = version2 => {\n  if (!version2) return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/;\n  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);\n};\nvar uuid4 = /* @__PURE__ */uuid(4);\nvar uuid6 = /* @__PURE__ */uuid(6);\nvar uuid7 = /* @__PURE__ */uuid(7);\nvar email = /^(?!\\.)(?!.*\\.\\.)([A-Za-z0-9_'+\\-\\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\\-]*\\.)+[A-Za-z]{2,}$/;\nvar html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\nvar rfc5322Email = /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\nvar unicodeEmail = /^[^\\s@\"]{1,64}@[^\\s@]{1,255}$/u;\nvar browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\nvar _emoji = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\nfunction emoji() {\n  return new RegExp(_emoji, \"u\");\n}\nvar ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\nvar ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/;\nvar cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/([0-9]|[1-2][0-9]|3[0-2])$/;\nvar cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;\nvar base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;\nvar base64url = /^[A-Za-z0-9_-]*$/;\nvar hostname = /^([a-zA-Z0-9-]+\\.)*[a-zA-Z0-9-]+$/;\nvar domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,}$/;\nvar e164 = /^\\+(?:[0-9]){6,14}[0-9]$/;\nvar dateSource = `(?:(?:\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\\\d|30)|(?:02)-(?:0[1-9]|1\\\\d|2[0-8])))`;\nvar date = /* @__PURE__ */new RegExp(`^${dateSource}$`);\nfunction timeSource(args) {\n  const hhmm = `(?:[01]\\\\d|2[0-3]):[0-5]\\\\d`;\n  const regex = typeof args.precision === \"number\" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\\\d` : `${hhmm}:[0-5]\\\\d\\\\.\\\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\\\d(?:\\\\.\\\\d+)?)?`;\n  return regex;\n}\nfunction time(args) {\n  return new RegExp(`^${timeSource(args)}$`);\n}\nfunction datetime(args) {\n  const time3 = timeSource({\n    precision: args.precision\n  });\n  const opts = [\"Z\"];\n  if (args.local) opts.push(\"\");\n  if (args.offset) opts.push(`([+-]\\\\d{2}:\\\\d{2})`);\n  const timeRegex2 = `${time3}(?:${opts.join(\"|\")})`;\n  return new RegExp(`^${dateSource}T(?:${timeRegex2})$`);\n}\nvar string = params => {\n  const regex = params ? `[\\\\s\\\\S]{${params?.minimum ?? 0},${params?.maximum ?? \"\"}}` : `[\\\\s\\\\S]*`;\n  return new RegExp(`^${regex}$`);\n};\nvar bigint = /^\\d+n?$/;\nvar integer = /^\\d+$/;\nvar number = /^-?\\d+(?:\\.\\d+)?/i;\nvar boolean = /true|false/i;\nvar _null = /null/i;\nvar _undefined = /undefined/i;\nvar lowercase = /^[^A-Z]*$/;\nvar uppercase = /^[^a-z]*$/;\n\n// ../../node_modules/zod/v4/core/checks.js\nvar $ZodCheck = /* @__PURE__ */$constructor(\"$ZodCheck\", (inst, def) => {\n  var _a20;\n  inst._zod ?? (inst._zod = {});\n  inst._zod.def = def;\n  (_a20 = inst._zod).onattach ?? (_a20.onattach = []);\n});\nvar numericOriginMap = {\n  number: \"number\",\n  bigint: \"bigint\",\n  object: \"date\"\n};\nvar $ZodCheckLessThan = /* @__PURE__ */$constructor(\"$ZodCheckLessThan\", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  const origin = numericOriginMap[typeof def.value];\n  inst._zod.onattach.push(inst2 => {\n    const bag = inst2._zod.bag;\n    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;\n    if (def.value < curr) {\n      if (def.inclusive) bag.maximum = def.value;else bag.exclusiveMaximum = def.value;\n    }\n  });\n  inst._zod.check = payload => {\n    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {\n      return;\n    }\n    payload.issues.push({\n      origin,\n      code: \"too_big\",\n      maximum: def.value,\n      input: payload.value,\n      inclusive: def.inclusive,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckGreaterThan = /* @__PURE__ */$constructor(\"$ZodCheckGreaterThan\", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  const origin = numericOriginMap[typeof def.value];\n  inst._zod.onattach.push(inst2 => {\n    const bag = inst2._zod.bag;\n    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;\n    if (def.value > curr) {\n      if (def.inclusive) bag.minimum = def.value;else bag.exclusiveMinimum = def.value;\n    }\n  });\n  inst._zod.check = payload => {\n    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {\n      return;\n    }\n    payload.issues.push({\n      origin,\n      code: \"too_small\",\n      minimum: def.value,\n      input: payload.value,\n      inclusive: def.inclusive,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckMultipleOf = /* @__PURE__ */$constructor(\"$ZodCheckMultipleOf\", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  inst._zod.onattach.push(inst2 => {\n    var _a20;\n    (_a20 = inst2._zod.bag).multipleOf ?? (_a20.multipleOf = def.value);\n  });\n  inst._zod.check = payload => {\n    if (typeof payload.value !== typeof def.value) throw new Error(\"Cannot mix number and bigint in multiple_of check.\");\n    const isMultiple = typeof payload.value === \"bigint\" ? payload.value % def.value === BigInt(0) : floatSafeRemainder2(payload.value, def.value) === 0;\n    if (isMultiple) return;\n    payload.issues.push({\n      origin: typeof payload.value,\n      code: \"not_multiple_of\",\n      divisor: def.value,\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckNumberFormat = /* @__PURE__ */$constructor(\"$ZodCheckNumberFormat\", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  def.format = def.format || \"float64\";\n  const isInt = def.format?.includes(\"int\");\n  const origin = isInt ? \"int\" : \"number\";\n  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];\n  inst._zod.onattach.push(inst2 => {\n    const bag = inst2._zod.bag;\n    bag.format = def.format;\n    bag.minimum = minimum;\n    bag.maximum = maximum;\n    if (isInt) bag.pattern = integer;\n  });\n  inst._zod.check = payload => {\n    const input = payload.value;\n    if (isInt) {\n      if (!Number.isInteger(input)) {\n        payload.issues.push({\n          expected: origin,\n          format: def.format,\n          code: \"invalid_type\",\n          input,\n          inst\n        });\n        return;\n      }\n      if (!Number.isSafeInteger(input)) {\n        if (input > 0) {\n          payload.issues.push({\n            input,\n            code: \"too_big\",\n            maximum: Number.MAX_SAFE_INTEGER,\n            note: \"Integers must be within the safe integer range.\",\n            inst,\n            origin,\n            continue: !def.abort\n          });\n        } else {\n          payload.issues.push({\n            input,\n            code: \"too_small\",\n            minimum: Number.MIN_SAFE_INTEGER,\n            note: \"Integers must be within the safe integer range.\",\n            inst,\n            origin,\n            continue: !def.abort\n          });\n        }\n        return;\n      }\n    }\n    if (input < minimum) {\n      payload.issues.push({\n        origin: \"number\",\n        input,\n        code: \"too_small\",\n        minimum,\n        inclusive: true,\n        inst,\n        continue: !def.abort\n      });\n    }\n    if (input > maximum) {\n      payload.issues.push({\n        origin: \"number\",\n        input,\n        code: \"too_big\",\n        maximum,\n        inst\n      });\n    }\n  };\n});\nvar $ZodCheckBigIntFormat = /* @__PURE__ */$constructor(\"$ZodCheckBigIntFormat\", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];\n  inst._zod.onattach.push(inst2 => {\n    const bag = inst2._zod.bag;\n    bag.format = def.format;\n    bag.minimum = minimum;\n    bag.maximum = maximum;\n  });\n  inst._zod.check = payload => {\n    const input = payload.value;\n    if (input < minimum) {\n      payload.issues.push({\n        origin: \"bigint\",\n        input,\n        code: \"too_small\",\n        minimum,\n        inclusive: true,\n        inst,\n        continue: !def.abort\n      });\n    }\n    if (input > maximum) {\n      payload.issues.push({\n        origin: \"bigint\",\n        input,\n        code: \"too_big\",\n        maximum,\n        inst\n      });\n    }\n  };\n});\nvar $ZodCheckMaxSize = /* @__PURE__ */$constructor(\"$ZodCheckMaxSize\", (inst, def) => {\n  var _a20;\n  $ZodCheck.init(inst, def);\n  (_a20 = inst._zod.def).when ?? (_a20.when = payload => {\n    const val = payload.value;\n    return !nullish(val) && val.size !== void 0;\n  });\n  inst._zod.onattach.push(inst2 => {\n    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;\n    if (def.maximum < curr) inst2._zod.bag.maximum = def.maximum;\n  });\n  inst._zod.check = payload => {\n    const input = payload.value;\n    const size = input.size;\n    if (size <= def.maximum) return;\n    payload.issues.push({\n      origin: getSizableOrigin(input),\n      code: \"too_big\",\n      maximum: def.maximum,\n      input,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckMinSize = /* @__PURE__ */$constructor(\"$ZodCheckMinSize\", (inst, def) => {\n  var _a20;\n  $ZodCheck.init(inst, def);\n  (_a20 = inst._zod.def).when ?? (_a20.when = payload => {\n    const val = payload.value;\n    return !nullish(val) && val.size !== void 0;\n  });\n  inst._zod.onattach.push(inst2 => {\n    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;\n    if (def.minimum > curr) inst2._zod.bag.minimum = def.minimum;\n  });\n  inst._zod.check = payload => {\n    const input = payload.value;\n    const size = input.size;\n    if (size >= def.minimum) return;\n    payload.issues.push({\n      origin: getSizableOrigin(input),\n      code: \"too_small\",\n      minimum: def.minimum,\n      input,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckSizeEquals = /* @__PURE__ */$constructor(\"$ZodCheckSizeEquals\", (inst, def) => {\n  var _a20;\n  $ZodCheck.init(inst, def);\n  (_a20 = inst._zod.def).when ?? (_a20.when = payload => {\n    const val = payload.value;\n    return !nullish(val) && val.size !== void 0;\n  });\n  inst._zod.onattach.push(inst2 => {\n    const bag = inst2._zod.bag;\n    bag.minimum = def.size;\n    bag.maximum = def.size;\n    bag.size = def.size;\n  });\n  inst._zod.check = payload => {\n    const input = payload.value;\n    const size = input.size;\n    if (size === def.size) return;\n    const tooBig = size > def.size;\n    payload.issues.push({\n      origin: getSizableOrigin(input),\n      ...(tooBig ? {\n        code: \"too_big\",\n        maximum: def.size\n      } : {\n        code: \"too_small\",\n        minimum: def.size\n      }),\n      inclusive: true,\n      exact: true,\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckMaxLength = /* @__PURE__ */$constructor(\"$ZodCheckMaxLength\", (inst, def) => {\n  var _a20;\n  $ZodCheck.init(inst, def);\n  (_a20 = inst._zod.def).when ?? (_a20.when = payload => {\n    const val = payload.value;\n    return !nullish(val) && val.length !== void 0;\n  });\n  inst._zod.onattach.push(inst2 => {\n    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;\n    if (def.maximum < curr) inst2._zod.bag.maximum = def.maximum;\n  });\n  inst._zod.check = payload => {\n    const input = payload.value;\n    const length = input.length;\n    if (length <= def.maximum) return;\n    const origin = getLengthableOrigin(input);\n    payload.issues.push({\n      origin,\n      code: \"too_big\",\n      maximum: def.maximum,\n      inclusive: true,\n      input,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckMinLength = /* @__PURE__ */$constructor(\"$ZodCheckMinLength\", (inst, def) => {\n  var _a20;\n  $ZodCheck.init(inst, def);\n  (_a20 = inst._zod.def).when ?? (_a20.when = payload => {\n    const val = payload.value;\n    return !nullish(val) && val.length !== void 0;\n  });\n  inst._zod.onattach.push(inst2 => {\n    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;\n    if (def.minimum > curr) inst2._zod.bag.minimum = def.minimum;\n  });\n  inst._zod.check = payload => {\n    const input = payload.value;\n    const length = input.length;\n    if (length >= def.minimum) return;\n    const origin = getLengthableOrigin(input);\n    payload.issues.push({\n      origin,\n      code: \"too_small\",\n      minimum: def.minimum,\n      inclusive: true,\n      input,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckLengthEquals = /* @__PURE__ */$constructor(\"$ZodCheckLengthEquals\", (inst, def) => {\n  var _a20;\n  $ZodCheck.init(inst, def);\n  (_a20 = inst._zod.def).when ?? (_a20.when = payload => {\n    const val = payload.value;\n    return !nullish(val) && val.length !== void 0;\n  });\n  inst._zod.onattach.push(inst2 => {\n    const bag = inst2._zod.bag;\n    bag.minimum = def.length;\n    bag.maximum = def.length;\n    bag.length = def.length;\n  });\n  inst._zod.check = payload => {\n    const input = payload.value;\n    const length = input.length;\n    if (length === def.length) return;\n    const origin = getLengthableOrigin(input);\n    const tooBig = length > def.length;\n    payload.issues.push({\n      origin,\n      ...(tooBig ? {\n        code: \"too_big\",\n        maximum: def.length\n      } : {\n        code: \"too_small\",\n        minimum: def.length\n      }),\n      inclusive: true,\n      exact: true,\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckStringFormat = /* @__PURE__ */$constructor(\"$ZodCheckStringFormat\", (inst, def) => {\n  var _a20, _b8;\n  $ZodCheck.init(inst, def);\n  inst._zod.onattach.push(inst2 => {\n    const bag = inst2._zod.bag;\n    bag.format = def.format;\n    if (def.pattern) {\n      bag.patterns ?? (bag.patterns = /* @__PURE__ */new Set());\n      bag.patterns.add(def.pattern);\n    }\n  });\n  if (def.pattern) (_a20 = inst._zod).check ?? (_a20.check = payload => {\n    def.pattern.lastIndex = 0;\n    if (def.pattern.test(payload.value)) return;\n    payload.issues.push({\n      origin: \"string\",\n      code: \"invalid_format\",\n      format: def.format,\n      input: payload.value,\n      ...(def.pattern ? {\n        pattern: def.pattern.toString()\n      } : {}),\n      inst,\n      continue: !def.abort\n    });\n  });else (_b8 = inst._zod).check ?? (_b8.check = () => {});\n});\nvar $ZodCheckRegex = /* @__PURE__ */$constructor(\"$ZodCheckRegex\", (inst, def) => {\n  $ZodCheckStringFormat.init(inst, def);\n  inst._zod.check = payload => {\n    def.pattern.lastIndex = 0;\n    if (def.pattern.test(payload.value)) return;\n    payload.issues.push({\n      origin: \"string\",\n      code: \"invalid_format\",\n      format: \"regex\",\n      input: payload.value,\n      pattern: def.pattern.toString(),\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckLowerCase = /* @__PURE__ */$constructor(\"$ZodCheckLowerCase\", (inst, def) => {\n  def.pattern ?? (def.pattern = lowercase);\n  $ZodCheckStringFormat.init(inst, def);\n});\nvar $ZodCheckUpperCase = /* @__PURE__ */$constructor(\"$ZodCheckUpperCase\", (inst, def) => {\n  def.pattern ?? (def.pattern = uppercase);\n  $ZodCheckStringFormat.init(inst, def);\n});\nvar $ZodCheckIncludes = /* @__PURE__ */$constructor(\"$ZodCheckIncludes\", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  const escapedRegex = escapeRegex(def.includes);\n  const pattern = new RegExp(typeof def.position === \"number\" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);\n  def.pattern = pattern;\n  inst._zod.onattach.push(inst2 => {\n    const bag = inst2._zod.bag;\n    bag.patterns ?? (bag.patterns = /* @__PURE__ */new Set());\n    bag.patterns.add(pattern);\n  });\n  inst._zod.check = payload => {\n    if (payload.value.includes(def.includes, def.position)) return;\n    payload.issues.push({\n      origin: \"string\",\n      code: \"invalid_format\",\n      format: \"includes\",\n      includes: def.includes,\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckStartsWith = /* @__PURE__ */$constructor(\"$ZodCheckStartsWith\", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);\n  def.pattern ?? (def.pattern = pattern);\n  inst._zod.onattach.push(inst2 => {\n    const bag = inst2._zod.bag;\n    bag.patterns ?? (bag.patterns = /* @__PURE__ */new Set());\n    bag.patterns.add(pattern);\n  });\n  inst._zod.check = payload => {\n    if (payload.value.startsWith(def.prefix)) return;\n    payload.issues.push({\n      origin: \"string\",\n      code: \"invalid_format\",\n      format: \"starts_with\",\n      prefix: def.prefix,\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckEndsWith = /* @__PURE__ */$constructor(\"$ZodCheckEndsWith\", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);\n  def.pattern ?? (def.pattern = pattern);\n  inst._zod.onattach.push(inst2 => {\n    const bag = inst2._zod.bag;\n    bag.patterns ?? (bag.patterns = /* @__PURE__ */new Set());\n    bag.patterns.add(pattern);\n  });\n  inst._zod.check = payload => {\n    if (payload.value.endsWith(def.suffix)) return;\n    payload.issues.push({\n      origin: \"string\",\n      code: \"invalid_format\",\n      format: \"ends_with\",\n      suffix: def.suffix,\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nfunction handleCheckPropertyResult(result, payload, property) {\n  if (result.issues.length) {\n    payload.issues.push(...prefixIssues(property, result.issues));\n  }\n}\nvar $ZodCheckProperty = /* @__PURE__ */$constructor(\"$ZodCheckProperty\", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  inst._zod.check = payload => {\n    const result = def.schema._zod.run({\n      value: payload.value[def.property],\n      issues: []\n    }, {});\n    if (result instanceof Promise) {\n      return result.then(result2 => handleCheckPropertyResult(result2, payload, def.property));\n    }\n    handleCheckPropertyResult(result, payload, def.property);\n    return;\n  };\n});\nvar $ZodCheckMimeType = /* @__PURE__ */$constructor(\"$ZodCheckMimeType\", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  const mimeSet = new Set(def.mime);\n  inst._zod.onattach.push(inst2 => {\n    inst2._zod.bag.mime = def.mime;\n  });\n  inst._zod.check = payload => {\n    if (mimeSet.has(payload.value.type)) return;\n    payload.issues.push({\n      code: \"invalid_value\",\n      values: def.mime,\n      input: payload.value.type,\n      inst\n    });\n  };\n});\nvar $ZodCheckOverwrite = /* @__PURE__ */$constructor(\"$ZodCheckOverwrite\", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  inst._zod.check = payload => {\n    payload.value = def.tx(payload.value);\n  };\n});\n\n// ../../node_modules/zod/v4/core/doc.js\nvar Doc = class {\n  constructor(args = []) {\n    this.content = [];\n    this.indent = 0;\n    if (this) this.args = args;\n  }\n  indented(fn) {\n    this.indent += 1;\n    fn(this);\n    this.indent -= 1;\n  }\n  write(arg) {\n    if (typeof arg === \"function\") {\n      arg(this, {\n        execution: \"sync\"\n      });\n      arg(this, {\n        execution: \"async\"\n      });\n      return;\n    }\n    const content = arg;\n    const lines = content.split(\"\\n\").filter(x => x);\n    const minIndent = Math.min(...lines.map(x => x.length - x.trimStart().length));\n    const dedented = lines.map(x => x.slice(minIndent)).map(x => \" \".repeat(this.indent * 2) + x);\n    for (const line of dedented) {\n      this.content.push(line);\n    }\n  }\n  compile() {\n    const F = Function;\n    const args = this?.args;\n    const content = this?.content ?? [``];\n    const lines = [...content.map(x => `  ${x}`)];\n    return new F(...args, lines.join(\"\\n\"));\n  }\n};\n\n// ../../node_modules/zod/v4/core/versions.js\nvar version = {\n  major: 4,\n  minor: 0,\n  patch: 0\n};\n\n// ../../node_modules/zod/v4/core/schemas.js\nvar $ZodType = /* @__PURE__ */$constructor(\"$ZodType\", (inst, def) => {\n  var _a20;\n  inst ?? (inst = {});\n  inst._zod.def = def;\n  inst._zod.bag = inst._zod.bag || {};\n  inst._zod.version = version;\n  const checks = [...(inst._zod.def.checks ?? [])];\n  if (inst._zod.traits.has(\"$ZodCheck\")) {\n    checks.unshift(inst);\n  }\n  for (const ch of checks) {\n    for (const fn of ch._zod.onattach) {\n      fn(inst);\n    }\n  }\n  if (checks.length === 0) {\n    (_a20 = inst._zod).deferred ?? (_a20.deferred = []);\n    inst._zod.deferred?.push(() => {\n      inst._zod.run = inst._zod.parse;\n    });\n  } else {\n    const runChecks = (payload, checks2, ctx) => {\n      let isAborted2 = aborted(payload);\n      let asyncResult;\n      for (const ch of checks2) {\n        if (ch._zod.def.when) {\n          const shouldRun = ch._zod.def.when(payload);\n          if (!shouldRun) continue;\n        } else if (isAborted2) {\n          continue;\n        }\n        const currLen = payload.issues.length;\n        const _ = ch._zod.check(payload);\n        if (_ instanceof Promise && ctx?.async === false) {\n          throw new $ZodAsyncError();\n        }\n        if (asyncResult || _ instanceof Promise) {\n          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {\n            await _;\n            const nextLen = payload.issues.length;\n            if (nextLen === currLen) return;\n            if (!isAborted2) isAborted2 = aborted(payload, currLen);\n          });\n        } else {\n          const nextLen = payload.issues.length;\n          if (nextLen === currLen) continue;\n          if (!isAborted2) isAborted2 = aborted(payload, currLen);\n        }\n      }\n      if (asyncResult) {\n        return asyncResult.then(() => {\n          return payload;\n        });\n      }\n      return payload;\n    };\n    inst._zod.run = (payload, ctx) => {\n      const result = inst._zod.parse(payload, ctx);\n      if (result instanceof Promise) {\n        if (ctx.async === false) throw new $ZodAsyncError();\n        return result.then(result2 => runChecks(result2, checks, ctx));\n      }\n      return runChecks(result, checks, ctx);\n    };\n  }\n  inst[\"~standard\"] = {\n    validate: value => {\n      try {\n        const r2 = safeParse(inst, value);\n        return r2.success ? {\n          value: r2.data\n        } : {\n          issues: r2.error?.issues\n        };\n      } catch (_) {\n        return safeParseAsync(inst, value).then(r2 => r2.success ? {\n          value: r2.data\n        } : {\n          issues: r2.error?.issues\n        });\n      }\n    },\n    vendor: \"zod\",\n    version: 1\n  };\n});\nvar $ZodString = /* @__PURE__ */$constructor(\"$ZodString\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.pattern = [...(inst?._zod.bag?.patterns ?? [])].pop() ?? string(inst._zod.bag);\n  inst._zod.parse = (payload, _) => {\n    if (def.coerce) try {\n      payload.value = String(payload.value);\n    } catch (_2) {}\n    if (typeof payload.value === \"string\") return payload;\n    payload.issues.push({\n      expected: \"string\",\n      code: \"invalid_type\",\n      input: payload.value,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodStringFormat = /* @__PURE__ */$constructor(\"$ZodStringFormat\", (inst, def) => {\n  $ZodCheckStringFormat.init(inst, def);\n  $ZodString.init(inst, def);\n});\nvar $ZodGUID = /* @__PURE__ */$constructor(\"$ZodGUID\", (inst, def) => {\n  def.pattern ?? (def.pattern = guid);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodUUID = /* @__PURE__ */$constructor(\"$ZodUUID\", (inst, def) => {\n  if (def.version) {\n    const versionMap = {\n      v1: 1,\n      v2: 2,\n      v3: 3,\n      v4: 4,\n      v5: 5,\n      v6: 6,\n      v7: 7,\n      v8: 8\n    };\n    const v = versionMap[def.version];\n    if (v === void 0) throw new Error(`Invalid UUID version: \"${def.version}\"`);\n    def.pattern ?? (def.pattern = uuid(v));\n  } else def.pattern ?? (def.pattern = uuid());\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodEmail = /* @__PURE__ */$constructor(\"$ZodEmail\", (inst, def) => {\n  def.pattern ?? (def.pattern = email);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodURL = /* @__PURE__ */$constructor(\"$ZodURL\", (inst, def) => {\n  $ZodStringFormat.init(inst, def);\n  inst._zod.check = payload => {\n    try {\n      const orig = payload.value;\n      const url2 = new URL(orig);\n      const href = url2.href;\n      if (def.hostname) {\n        def.hostname.lastIndex = 0;\n        if (!def.hostname.test(url2.hostname)) {\n          payload.issues.push({\n            code: \"invalid_format\",\n            format: \"url\",\n            note: \"Invalid hostname\",\n            pattern: hostname.source,\n            input: payload.value,\n            inst,\n            continue: !def.abort\n          });\n        }\n      }\n      if (def.protocol) {\n        def.protocol.lastIndex = 0;\n        if (!def.protocol.test(url2.protocol.endsWith(\":\") ? url2.protocol.slice(0, -1) : url2.protocol)) {\n          payload.issues.push({\n            code: \"invalid_format\",\n            format: \"url\",\n            note: \"Invalid protocol\",\n            pattern: def.protocol.source,\n            input: payload.value,\n            inst,\n            continue: !def.abort\n          });\n        }\n      }\n      if (!orig.endsWith(\"/\") && href.endsWith(\"/\")) {\n        payload.value = href.slice(0, -1);\n      } else {\n        payload.value = href;\n      }\n      return;\n    } catch (_) {\n      payload.issues.push({\n        code: \"invalid_format\",\n        format: \"url\",\n        input: payload.value,\n        inst,\n        continue: !def.abort\n      });\n    }\n  };\n});\nvar $ZodEmoji = /* @__PURE__ */$constructor(\"$ZodEmoji\", (inst, def) => {\n  def.pattern ?? (def.pattern = emoji());\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodNanoID = /* @__PURE__ */$constructor(\"$ZodNanoID\", (inst, def) => {\n  def.pattern ?? (def.pattern = nanoid);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodCUID = /* @__PURE__ */$constructor(\"$ZodCUID\", (inst, def) => {\n  def.pattern ?? (def.pattern = cuid);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodCUID2 = /* @__PURE__ */$constructor(\"$ZodCUID2\", (inst, def) => {\n  def.pattern ?? (def.pattern = cuid2);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodULID = /* @__PURE__ */$constructor(\"$ZodULID\", (inst, def) => {\n  def.pattern ?? (def.pattern = ulid);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodXID = /* @__PURE__ */$constructor(\"$ZodXID\", (inst, def) => {\n  def.pattern ?? (def.pattern = xid);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodKSUID = /* @__PURE__ */$constructor(\"$ZodKSUID\", (inst, def) => {\n  def.pattern ?? (def.pattern = ksuid);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodISODateTime = /* @__PURE__ */$constructor(\"$ZodISODateTime\", (inst, def) => {\n  def.pattern ?? (def.pattern = datetime(def));\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodISODate = /* @__PURE__ */$constructor(\"$ZodISODate\", (inst, def) => {\n  def.pattern ?? (def.pattern = date);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodISOTime = /* @__PURE__ */$constructor(\"$ZodISOTime\", (inst, def) => {\n  def.pattern ?? (def.pattern = time(def));\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodISODuration = /* @__PURE__ */$constructor(\"$ZodISODuration\", (inst, def) => {\n  def.pattern ?? (def.pattern = duration);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodIPv4 = /* @__PURE__ */$constructor(\"$ZodIPv4\", (inst, def) => {\n  def.pattern ?? (def.pattern = ipv4);\n  $ZodStringFormat.init(inst, def);\n  inst._zod.onattach.push(inst2 => {\n    const bag = inst2._zod.bag;\n    bag.format = `ipv4`;\n  });\n});\nvar $ZodIPv6 = /* @__PURE__ */$constructor(\"$ZodIPv6\", (inst, def) => {\n  def.pattern ?? (def.pattern = ipv6);\n  $ZodStringFormat.init(inst, def);\n  inst._zod.onattach.push(inst2 => {\n    const bag = inst2._zod.bag;\n    bag.format = `ipv6`;\n  });\n  inst._zod.check = payload => {\n    try {\n      new URL(`http://[${payload.value}]`);\n    } catch {\n      payload.issues.push({\n        code: \"invalid_format\",\n        format: \"ipv6\",\n        input: payload.value,\n        inst,\n        continue: !def.abort\n      });\n    }\n  };\n});\nvar $ZodCIDRv4 = /* @__PURE__ */$constructor(\"$ZodCIDRv4\", (inst, def) => {\n  def.pattern ?? (def.pattern = cidrv4);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodCIDRv6 = /* @__PURE__ */$constructor(\"$ZodCIDRv6\", (inst, def) => {\n  def.pattern ?? (def.pattern = cidrv6);\n  $ZodStringFormat.init(inst, def);\n  inst._zod.check = payload => {\n    const [address, prefix] = payload.value.split(\"/\");\n    try {\n      if (!prefix) throw new Error();\n      const prefixNum = Number(prefix);\n      if (`${prefixNum}` !== prefix) throw new Error();\n      if (prefixNum < 0 || prefixNum > 128) throw new Error();\n      new URL(`http://[${address}]`);\n    } catch {\n      payload.issues.push({\n        code: \"invalid_format\",\n        format: \"cidrv6\",\n        input: payload.value,\n        inst,\n        continue: !def.abort\n      });\n    }\n  };\n});\nfunction isValidBase64(data) {\n  if (data === \"\") return true;\n  if (data.length % 4 !== 0) return false;\n  try {\n    atob(data);\n    return true;\n  } catch {\n    return false;\n  }\n}\nvar $ZodBase64 = /* @__PURE__ */$constructor(\"$ZodBase64\", (inst, def) => {\n  def.pattern ?? (def.pattern = base64);\n  $ZodStringFormat.init(inst, def);\n  inst._zod.onattach.push(inst2 => {\n    inst2._zod.bag.contentEncoding = \"base64\";\n  });\n  inst._zod.check = payload => {\n    if (isValidBase64(payload.value)) return;\n    payload.issues.push({\n      code: \"invalid_format\",\n      format: \"base64\",\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nfunction isValidBase64URL(data) {\n  if (!base64url.test(data)) return false;\n  const base643 = data.replace(/[-_]/g, c => c === \"-\" ? \"+\" : \"/\");\n  const padded = base643.padEnd(Math.ceil(base643.length / 4) * 4, \"=\");\n  return isValidBase64(padded);\n}\nvar $ZodBase64URL = /* @__PURE__ */$constructor(\"$ZodBase64URL\", (inst, def) => {\n  def.pattern ?? (def.pattern = base64url);\n  $ZodStringFormat.init(inst, def);\n  inst._zod.onattach.push(inst2 => {\n    inst2._zod.bag.contentEncoding = \"base64url\";\n  });\n  inst._zod.check = payload => {\n    if (isValidBase64URL(payload.value)) return;\n    payload.issues.push({\n      code: \"invalid_format\",\n      format: \"base64url\",\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodE164 = /* @__PURE__ */$constructor(\"$ZodE164\", (inst, def) => {\n  def.pattern ?? (def.pattern = e164);\n  $ZodStringFormat.init(inst, def);\n});\nfunction isValidJWT2(token, algorithm = null) {\n  try {\n    const tokensParts = token.split(\".\");\n    if (tokensParts.length !== 3) return false;\n    const [header] = tokensParts;\n    if (!header) return false;\n    const parsedHeader = JSON.parse(atob(header));\n    if (\"typ\" in parsedHeader && parsedHeader?.typ !== \"JWT\") return false;\n    if (!parsedHeader.alg) return false;\n    if (algorithm && (!(\"alg\" in parsedHeader) || parsedHeader.alg !== algorithm)) return false;\n    return true;\n  } catch {\n    return false;\n  }\n}\nvar $ZodJWT = /* @__PURE__ */$constructor(\"$ZodJWT\", (inst, def) => {\n  $ZodStringFormat.init(inst, def);\n  inst._zod.check = payload => {\n    if (isValidJWT2(payload.value, def.alg)) return;\n    payload.issues.push({\n      code: \"invalid_format\",\n      format: \"jwt\",\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCustomStringFormat = /* @__PURE__ */$constructor(\"$ZodCustomStringFormat\", (inst, def) => {\n  $ZodStringFormat.init(inst, def);\n  inst._zod.check = payload => {\n    if (def.fn(payload.value)) return;\n    payload.issues.push({\n      code: \"invalid_format\",\n      format: def.format,\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodNumber = /* @__PURE__ */$constructor(\"$ZodNumber\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.pattern = inst._zod.bag.pattern ?? number;\n  inst._zod.parse = (payload, _ctx) => {\n    if (def.coerce) try {\n      payload.value = Number(payload.value);\n    } catch (_) {}\n    const input = payload.value;\n    if (typeof input === \"number\" && !Number.isNaN(input) && Number.isFinite(input)) {\n      return payload;\n    }\n    const received = typeof input === \"number\" ? Number.isNaN(input) ? \"NaN\" : !Number.isFinite(input) ? \"Infinity\" : void 0 : void 0;\n    payload.issues.push({\n      expected: \"number\",\n      code: \"invalid_type\",\n      input,\n      inst,\n      ...(received ? {\n        received\n      } : {})\n    });\n    return payload;\n  };\n});\nvar $ZodNumberFormat = /* @__PURE__ */$constructor(\"$ZodNumber\", (inst, def) => {\n  $ZodCheckNumberFormat.init(inst, def);\n  $ZodNumber.init(inst, def);\n});\nvar $ZodBoolean = /* @__PURE__ */$constructor(\"$ZodBoolean\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.pattern = boolean;\n  inst._zod.parse = (payload, _ctx) => {\n    if (def.coerce) try {\n      payload.value = Boolean(payload.value);\n    } catch (_) {}\n    const input = payload.value;\n    if (typeof input === \"boolean\") return payload;\n    payload.issues.push({\n      expected: \"boolean\",\n      code: \"invalid_type\",\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodBigInt = /* @__PURE__ */$constructor(\"$ZodBigInt\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.pattern = bigint;\n  inst._zod.parse = (payload, _ctx) => {\n    if (def.coerce) try {\n      payload.value = BigInt(payload.value);\n    } catch (_) {}\n    if (typeof payload.value === \"bigint\") return payload;\n    payload.issues.push({\n      expected: \"bigint\",\n      code: \"invalid_type\",\n      input: payload.value,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodBigIntFormat = /* @__PURE__ */$constructor(\"$ZodBigInt\", (inst, def) => {\n  $ZodCheckBigIntFormat.init(inst, def);\n  $ZodBigInt.init(inst, def);\n});\nvar $ZodSymbol = /* @__PURE__ */$constructor(\"$ZodSymbol\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (typeof input === \"symbol\") return payload;\n    payload.issues.push({\n      expected: \"symbol\",\n      code: \"invalid_type\",\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodUndefined = /* @__PURE__ */$constructor(\"$ZodUndefined\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.pattern = _undefined;\n  inst._zod.values = /* @__PURE__ */new Set([void 0]);\n  inst._zod.optin = \"optional\";\n  inst._zod.optout = \"optional\";\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (typeof input === \"undefined\") return payload;\n    payload.issues.push({\n      expected: \"undefined\",\n      code: \"invalid_type\",\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodNull = /* @__PURE__ */$constructor(\"$ZodNull\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.pattern = _null;\n  inst._zod.values = /* @__PURE__ */new Set([null]);\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (input === null) return payload;\n    payload.issues.push({\n      expected: \"null\",\n      code: \"invalid_type\",\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodAny = /* @__PURE__ */$constructor(\"$ZodAny\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = payload => payload;\n});\nvar $ZodUnknown = /* @__PURE__ */$constructor(\"$ZodUnknown\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = payload => payload;\n});\nvar $ZodNever = /* @__PURE__ */$constructor(\"$ZodNever\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    payload.issues.push({\n      expected: \"never\",\n      code: \"invalid_type\",\n      input: payload.value,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodVoid = /* @__PURE__ */$constructor(\"$ZodVoid\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (typeof input === \"undefined\") return payload;\n    payload.issues.push({\n      expected: \"void\",\n      code: \"invalid_type\",\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodDate = /* @__PURE__ */$constructor(\"$ZodDate\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    if (def.coerce) {\n      try {\n        payload.value = new Date(payload.value);\n      } catch (_err) {}\n    }\n    const input = payload.value;\n    const isDate = input instanceof Date;\n    const isValidDate = isDate && !Number.isNaN(input.getTime());\n    if (isValidDate) return payload;\n    payload.issues.push({\n      expected: \"date\",\n      code: \"invalid_type\",\n      input,\n      ...(isDate ? {\n        received: \"Invalid Date\"\n      } : {}),\n      inst\n    });\n    return payload;\n  };\n});\nfunction handleArrayResult(result, final, index) {\n  if (result.issues.length) {\n    final.issues.push(...prefixIssues(index, result.issues));\n  }\n  final.value[index] = result.value;\n}\nvar $ZodArray = /* @__PURE__ */$constructor(\"$ZodArray\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    if (!Array.isArray(input)) {\n      payload.issues.push({\n        expected: \"array\",\n        code: \"invalid_type\",\n        input,\n        inst\n      });\n      return payload;\n    }\n    payload.value = Array(input.length);\n    const proms = [];\n    for (let i = 0; i < input.length; i++) {\n      const item = input[i];\n      const result = def.element._zod.run({\n        value: item,\n        issues: []\n      }, ctx);\n      if (result instanceof Promise) {\n        proms.push(result.then(result2 => handleArrayResult(result2, payload, i)));\n      } else {\n        handleArrayResult(result, payload, i);\n      }\n    }\n    if (proms.length) {\n      return Promise.all(proms).then(() => payload);\n    }\n    return payload;\n  };\n});\nfunction handleObjectResult(result, final, key) {\n  if (result.issues.length) {\n    final.issues.push(...prefixIssues(key, result.issues));\n  }\n  final.value[key] = result.value;\n}\nfunction handleOptionalObjectResult(result, final, key, input) {\n  if (result.issues.length) {\n    if (input[key] === void 0) {\n      if (key in input) {\n        final.value[key] = void 0;\n      } else {\n        final.value[key] = result.value;\n      }\n    } else {\n      final.issues.push(...prefixIssues(key, result.issues));\n    }\n  } else if (result.value === void 0) {\n    if (key in input) final.value[key] = void 0;\n  } else {\n    final.value[key] = result.value;\n  }\n}\nvar $ZodObject = /* @__PURE__ */$constructor(\"$ZodObject\", (inst, def) => {\n  $ZodType.init(inst, def);\n  const _normalized = cached(() => {\n    const keys2 = Object.keys(def.shape);\n    for (const k of keys2) {\n      if (!(def.shape[k] instanceof $ZodType)) {\n        throw new Error(`Invalid element at key \"${k}\": expected a Zod schema`);\n      }\n    }\n    const okeys = optionalKeys(def.shape);\n    return {\n      shape: def.shape,\n      keys: keys2,\n      keySet: new Set(keys2),\n      numKeys: keys2.length,\n      optionalKeys: new Set(okeys)\n    };\n  });\n  defineLazy(inst._zod, \"propValues\", () => {\n    const shape = def.shape;\n    const propValues = {};\n    for (const key in shape) {\n      const field = shape[key]._zod;\n      if (field.values) {\n        propValues[key] ?? (propValues[key] = /* @__PURE__ */new Set());\n        for (const v of field.values) propValues[key].add(v);\n      }\n    }\n    return propValues;\n  });\n  const generateFastpass = shape => {\n    const doc = new Doc([\"shape\", \"payload\", \"ctx\"]);\n    const normalized = _normalized.value;\n    const parseStr = key => {\n      const k = esc(key);\n      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;\n    };\n    doc.write(`const input = payload.value;`);\n    const ids = /* @__PURE__ */Object.create(null);\n    let counter = 0;\n    for (const key of normalized.keys) {\n      ids[key] = `key_${counter++}`;\n    }\n    doc.write(`const newResult = {}`);\n    for (const key of normalized.keys) {\n      if (normalized.optionalKeys.has(key)) {\n        const id = ids[key];\n        doc.write(`const ${id} = ${parseStr(key)};`);\n        const k = esc(key);\n        doc.write(`\n        if (${id}.issues.length) {\n          if (input[${k}] === undefined) {\n            if (${k} in input) {\n              newResult[${k}] = undefined;\n            }\n          } else {\n            payload.issues = payload.issues.concat(\n              ${id}.issues.map((iss) => ({\n                ...iss,\n                path: iss.path ? [${k}, ...iss.path] : [${k}],\n              }))\n            );\n          }\n        } else if (${id}.value === undefined) {\n          if (${k} in input) newResult[${k}] = undefined;\n        } else {\n          newResult[${k}] = ${id}.value;\n        }\n        `);\n      } else {\n        const id = ids[key];\n        doc.write(`const ${id} = ${parseStr(key)};`);\n        doc.write(`\n          if (${id}.issues.length) payload.issues = payload.issues.concat(${id}.issues.map(iss => ({\n            ...iss,\n            path: iss.path ? [${esc(key)}, ...iss.path] : [${esc(key)}]\n          })));`);\n        doc.write(`newResult[${esc(key)}] = ${id}.value`);\n      }\n    }\n    doc.write(`payload.value = newResult;`);\n    doc.write(`return payload;`);\n    const fn = doc.compile();\n    return (payload, ctx) => fn(shape, payload, ctx);\n  };\n  let fastpass;\n  const isObject2 = isObject;\n  const jit = !globalConfig.jitless;\n  const allowsEval2 = allowsEval;\n  const fastEnabled = jit && allowsEval2.value;\n  const catchall = def.catchall;\n  let value;\n  inst._zod.parse = (payload, ctx) => {\n    value ?? (value = _normalized.value);\n    const input = payload.value;\n    if (!isObject2(input)) {\n      payload.issues.push({\n        expected: \"object\",\n        code: \"invalid_type\",\n        input,\n        inst\n      });\n      return payload;\n    }\n    const proms = [];\n    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {\n      if (!fastpass) fastpass = generateFastpass(def.shape);\n      payload = fastpass(payload, ctx);\n    } else {\n      payload.value = {};\n      const shape = value.shape;\n      for (const key of value.keys) {\n        const el = shape[key];\n        const r2 = el._zod.run({\n          value: input[key],\n          issues: []\n        }, ctx);\n        const isOptional = el._zod.optin === \"optional\" && el._zod.optout === \"optional\";\n        if (r2 instanceof Promise) {\n          proms.push(r2.then(r3 => isOptional ? handleOptionalObjectResult(r3, payload, key, input) : handleObjectResult(r3, payload, key)));\n        } else if (isOptional) {\n          handleOptionalObjectResult(r2, payload, key, input);\n        } else {\n          handleObjectResult(r2, payload, key);\n        }\n      }\n    }\n    if (!catchall) {\n      return proms.length ? Promise.all(proms).then(() => payload) : payload;\n    }\n    const unrecognized = [];\n    const keySet = value.keySet;\n    const _catchall = catchall._zod;\n    const t = _catchall.def.type;\n    for (const key of Object.keys(input)) {\n      if (keySet.has(key)) continue;\n      if (t === \"never\") {\n        unrecognized.push(key);\n        continue;\n      }\n      const r2 = _catchall.run({\n        value: input[key],\n        issues: []\n      }, ctx);\n      if (r2 instanceof Promise) {\n        proms.push(r2.then(r3 => handleObjectResult(r3, payload, key)));\n      } else {\n        handleObjectResult(r2, payload, key);\n      }\n    }\n    if (unrecognized.length) {\n      payload.issues.push({\n        code: \"unrecognized_keys\",\n        keys: unrecognized,\n        input,\n        inst\n      });\n    }\n    if (!proms.length) return payload;\n    return Promise.all(proms).then(() => {\n      return payload;\n    });\n  };\n});\nfunction handleUnionResults(results, final, inst, ctx) {\n  for (const result of results) {\n    if (result.issues.length === 0) {\n      final.value = result.value;\n      return final;\n    }\n  }\n  final.issues.push({\n    code: \"invalid_union\",\n    input: final.value,\n    inst,\n    errors: results.map(result => result.issues.map(iss => finalizeIssue(iss, ctx, config())))\n  });\n  return final;\n}\nvar $ZodUnion = /* @__PURE__ */$constructor(\"$ZodUnion\", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, \"optin\", () => def.options.some(o => o._zod.optin === \"optional\") ? \"optional\" : void 0);\n  defineLazy(inst._zod, \"optout\", () => def.options.some(o => o._zod.optout === \"optional\") ? \"optional\" : void 0);\n  defineLazy(inst._zod, \"values\", () => {\n    if (def.options.every(o => o._zod.values)) {\n      return new Set(def.options.flatMap(option => Array.from(option._zod.values)));\n    }\n    return void 0;\n  });\n  defineLazy(inst._zod, \"pattern\", () => {\n    if (def.options.every(o => o._zod.pattern)) {\n      const patterns = def.options.map(o => o._zod.pattern);\n      return new RegExp(`^(${patterns.map(p => cleanRegex(p.source)).join(\"|\")})$`);\n    }\n    return void 0;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    let async = false;\n    const results = [];\n    for (const option of def.options) {\n      const result = option._zod.run({\n        value: payload.value,\n        issues: []\n      }, ctx);\n      if (result instanceof Promise) {\n        results.push(result);\n        async = true;\n      } else {\n        if (result.issues.length === 0) return result;\n        results.push(result);\n      }\n    }\n    if (!async) return handleUnionResults(results, payload, inst, ctx);\n    return Promise.all(results).then(results2 => {\n      return handleUnionResults(results2, payload, inst, ctx);\n    });\n  };\n});\nvar $ZodDiscriminatedUnion = /* @__PURE__ */$constructor(\"$ZodDiscriminatedUnion\", (inst, def) => {\n  $ZodUnion.init(inst, def);\n  const _super = inst._zod.parse;\n  defineLazy(inst._zod, \"propValues\", () => {\n    const propValues = {};\n    for (const option of def.options) {\n      const pv = option._zod.propValues;\n      if (!pv || Object.keys(pv).length === 0) throw new Error(`Invalid discriminated union option at index \"${def.options.indexOf(option)}\"`);\n      for (const [k, v] of Object.entries(pv)) {\n        if (!propValues[k]) propValues[k] = /* @__PURE__ */new Set();\n        for (const val of v) {\n          propValues[k].add(val);\n        }\n      }\n    }\n    return propValues;\n  });\n  const disc = cached(() => {\n    const opts = def.options;\n    const map2 = /* @__PURE__ */new Map();\n    for (const o of opts) {\n      const values = o._zod.propValues[def.discriminator];\n      if (!values || values.size === 0) throw new Error(`Invalid discriminated union option at index \"${def.options.indexOf(o)}\"`);\n      for (const v of values) {\n        if (map2.has(v)) {\n          throw new Error(`Duplicate discriminator value \"${String(v)}\"`);\n        }\n        map2.set(v, o);\n      }\n    }\n    return map2;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    if (!isObject(input)) {\n      payload.issues.push({\n        code: \"invalid_type\",\n        expected: \"object\",\n        input,\n        inst\n      });\n      return payload;\n    }\n    const opt = disc.value.get(input?.[def.discriminator]);\n    if (opt) {\n      return opt._zod.run(payload, ctx);\n    }\n    if (def.unionFallback) {\n      return _super(payload, ctx);\n    }\n    payload.issues.push({\n      code: \"invalid_union\",\n      errors: [],\n      note: \"No matching discriminator\",\n      input,\n      path: [def.discriminator],\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodIntersection = /* @__PURE__ */$constructor(\"$ZodIntersection\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    const left = def.left._zod.run({\n      value: input,\n      issues: []\n    }, ctx);\n    const right = def.right._zod.run({\n      value: input,\n      issues: []\n    }, ctx);\n    const async = left instanceof Promise || right instanceof Promise;\n    if (async) {\n      return Promise.all([left, right]).then(([left2, right2]) => {\n        return handleIntersectionResults(payload, left2, right2);\n      });\n    }\n    return handleIntersectionResults(payload, left, right);\n  };\n});\nfunction mergeValues2(a, b) {\n  if (a === b) {\n    return {\n      valid: true,\n      data: a\n    };\n  }\n  if (a instanceof Date && b instanceof Date && +a === +b) {\n    return {\n      valid: true,\n      data: a\n    };\n  }\n  if (isPlainObject(a) && isPlainObject(b)) {\n    const bKeys = Object.keys(b);\n    const sharedKeys = Object.keys(a).filter(key => bKeys.indexOf(key) !== -1);\n    const newObj = {\n      ...a,\n      ...b\n    };\n    for (const key of sharedKeys) {\n      const sharedValue = mergeValues2(a[key], b[key]);\n      if (!sharedValue.valid) {\n        return {\n          valid: false,\n          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]\n        };\n      }\n      newObj[key] = sharedValue.data;\n    }\n    return {\n      valid: true,\n      data: newObj\n    };\n  }\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) {\n      return {\n        valid: false,\n        mergeErrorPath: []\n      };\n    }\n    const newArray = [];\n    for (let index = 0; index < a.length; index++) {\n      const itemA = a[index];\n      const itemB = b[index];\n      const sharedValue = mergeValues2(itemA, itemB);\n      if (!sharedValue.valid) {\n        return {\n          valid: false,\n          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]\n        };\n      }\n      newArray.push(sharedValue.data);\n    }\n    return {\n      valid: true,\n      data: newArray\n    };\n  }\n  return {\n    valid: false,\n    mergeErrorPath: []\n  };\n}\nfunction handleIntersectionResults(result, left, right) {\n  if (left.issues.length) {\n    result.issues.push(...left.issues);\n  }\n  if (right.issues.length) {\n    result.issues.push(...right.issues);\n  }\n  if (aborted(result)) return result;\n  const merged = mergeValues2(left.value, right.value);\n  if (!merged.valid) {\n    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);\n  }\n  result.value = merged.data;\n  return result;\n}\nvar $ZodTuple = /* @__PURE__ */$constructor(\"$ZodTuple\", (inst, def) => {\n  $ZodType.init(inst, def);\n  const items = def.items;\n  const optStart = items.length - [...items].reverse().findIndex(item => item._zod.optin !== \"optional\");\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    if (!Array.isArray(input)) {\n      payload.issues.push({\n        input,\n        inst,\n        expected: \"tuple\",\n        code: \"invalid_type\"\n      });\n      return payload;\n    }\n    payload.value = [];\n    const proms = [];\n    if (!def.rest) {\n      const tooBig = input.length > items.length;\n      const tooSmall = input.length < optStart - 1;\n      if (tooBig || tooSmall) {\n        payload.issues.push({\n          input,\n          inst,\n          origin: \"array\",\n          ...(tooBig ? {\n            code: \"too_big\",\n            maximum: items.length\n          } : {\n            code: \"too_small\",\n            minimum: items.length\n          })\n        });\n        return payload;\n      }\n    }\n    let i = -1;\n    for (const item of items) {\n      i++;\n      if (i >= input.length) {\n        if (i >= optStart) continue;\n      }\n      const result = item._zod.run({\n        value: input[i],\n        issues: []\n      }, ctx);\n      if (result instanceof Promise) {\n        proms.push(result.then(result2 => handleTupleResult(result2, payload, i)));\n      } else {\n        handleTupleResult(result, payload, i);\n      }\n    }\n    if (def.rest) {\n      const rest = input.slice(items.length);\n      for (const el of rest) {\n        i++;\n        const result = def.rest._zod.run({\n          value: el,\n          issues: []\n        }, ctx);\n        if (result instanceof Promise) {\n          proms.push(result.then(result2 => handleTupleResult(result2, payload, i)));\n        } else {\n          handleTupleResult(result, payload, i);\n        }\n      }\n    }\n    if (proms.length) return Promise.all(proms).then(() => payload);\n    return payload;\n  };\n});\nfunction handleTupleResult(result, final, index) {\n  if (result.issues.length) {\n    final.issues.push(...prefixIssues(index, result.issues));\n  }\n  final.value[index] = result.value;\n}\nvar $ZodRecord = /* @__PURE__ */$constructor(\"$ZodRecord\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    if (!isPlainObject(input)) {\n      payload.issues.push({\n        expected: \"record\",\n        code: \"invalid_type\",\n        input,\n        inst\n      });\n      return payload;\n    }\n    const proms = [];\n    if (def.keyType._zod.values) {\n      const values = def.keyType._zod.values;\n      payload.value = {};\n      for (const key of values) {\n        if (typeof key === \"string\" || typeof key === \"number\" || typeof key === \"symbol\") {\n          const result = def.valueType._zod.run({\n            value: input[key],\n            issues: []\n          }, ctx);\n          if (result instanceof Promise) {\n            proms.push(result.then(result2 => {\n              if (result2.issues.length) {\n                payload.issues.push(...prefixIssues(key, result2.issues));\n              }\n              payload.value[key] = result2.value;\n            }));\n          } else {\n            if (result.issues.length) {\n              payload.issues.push(...prefixIssues(key, result.issues));\n            }\n            payload.value[key] = result.value;\n          }\n        }\n      }\n      let unrecognized;\n      for (const key in input) {\n        if (!values.has(key)) {\n          unrecognized = unrecognized ?? [];\n          unrecognized.push(key);\n        }\n      }\n      if (unrecognized && unrecognized.length > 0) {\n        payload.issues.push({\n          code: \"unrecognized_keys\",\n          input,\n          inst,\n          keys: unrecognized\n        });\n      }\n    } else {\n      payload.value = {};\n      for (const key of Reflect.ownKeys(input)) {\n        if (key === \"__proto__\") continue;\n        const keyResult = def.keyType._zod.run({\n          value: key,\n          issues: []\n        }, ctx);\n        if (keyResult instanceof Promise) {\n          throw new Error(\"Async schemas not supported in object keys currently\");\n        }\n        if (keyResult.issues.length) {\n          payload.issues.push({\n            origin: \"record\",\n            code: \"invalid_key\",\n            issues: keyResult.issues.map(iss => finalizeIssue(iss, ctx, config())),\n            input: key,\n            path: [key],\n            inst\n          });\n          payload.value[keyResult.value] = keyResult.value;\n          continue;\n        }\n        const result = def.valueType._zod.run({\n          value: input[key],\n          issues: []\n        }, ctx);\n        if (result instanceof Promise) {\n          proms.push(result.then(result2 => {\n            if (result2.issues.length) {\n              payload.issues.push(...prefixIssues(key, result2.issues));\n            }\n            payload.value[keyResult.value] = result2.value;\n          }));\n        } else {\n          if (result.issues.length) {\n            payload.issues.push(...prefixIssues(key, result.issues));\n          }\n          payload.value[keyResult.value] = result.value;\n        }\n      }\n    }\n    if (proms.length) {\n      return Promise.all(proms).then(() => payload);\n    }\n    return payload;\n  };\n});\nvar $ZodMap = /* @__PURE__ */$constructor(\"$ZodMap\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    if (!(input instanceof Map)) {\n      payload.issues.push({\n        expected: \"map\",\n        code: \"invalid_type\",\n        input,\n        inst\n      });\n      return payload;\n    }\n    const proms = [];\n    payload.value = /* @__PURE__ */new Map();\n    for (const [key, value] of input) {\n      const keyResult = def.keyType._zod.run({\n        value: key,\n        issues: []\n      }, ctx);\n      const valueResult = def.valueType._zod.run({\n        value,\n        issues: []\n      }, ctx);\n      if (keyResult instanceof Promise || valueResult instanceof Promise) {\n        proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {\n          handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);\n        }));\n      } else {\n        handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);\n      }\n    }\n    if (proms.length) return Promise.all(proms).then(() => payload);\n    return payload;\n  };\n});\nfunction handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {\n  if (keyResult.issues.length) {\n    if (propertyKeyTypes.has(typeof key)) {\n      final.issues.push(...prefixIssues(key, keyResult.issues));\n    } else {\n      final.issues.push({\n        origin: \"map\",\n        code: \"invalid_key\",\n        input,\n        inst,\n        issues: keyResult.issues.map(iss => finalizeIssue(iss, ctx, config()))\n      });\n    }\n  }\n  if (valueResult.issues.length) {\n    if (propertyKeyTypes.has(typeof key)) {\n      final.issues.push(...prefixIssues(key, valueResult.issues));\n    } else {\n      final.issues.push({\n        origin: \"map\",\n        code: \"invalid_element\",\n        input,\n        inst,\n        key,\n        issues: valueResult.issues.map(iss => finalizeIssue(iss, ctx, config()))\n      });\n    }\n  }\n  final.value.set(keyResult.value, valueResult.value);\n}\nvar $ZodSet = /* @__PURE__ */$constructor(\"$ZodSet\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    if (!(input instanceof Set)) {\n      payload.issues.push({\n        input,\n        inst,\n        expected: \"set\",\n        code: \"invalid_type\"\n      });\n      return payload;\n    }\n    const proms = [];\n    payload.value = /* @__PURE__ */new Set();\n    for (const item of input) {\n      const result = def.valueType._zod.run({\n        value: item,\n        issues: []\n      }, ctx);\n      if (result instanceof Promise) {\n        proms.push(result.then(result2 => handleSetResult(result2, payload)));\n      } else handleSetResult(result, payload);\n    }\n    if (proms.length) return Promise.all(proms).then(() => payload);\n    return payload;\n  };\n});\nfunction handleSetResult(result, final) {\n  if (result.issues.length) {\n    final.issues.push(...result.issues);\n  }\n  final.value.add(result.value);\n}\nvar $ZodEnum = /* @__PURE__ */$constructor(\"$ZodEnum\", (inst, def) => {\n  $ZodType.init(inst, def);\n  const values = getEnumValues(def.entries);\n  inst._zod.values = new Set(values);\n  inst._zod.pattern = new RegExp(`^(${values.filter(k => propertyKeyTypes.has(typeof k)).map(o => typeof o === \"string\" ? escapeRegex(o) : o.toString()).join(\"|\")})$`);\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (inst._zod.values.has(input)) {\n      return payload;\n    }\n    payload.issues.push({\n      code: \"invalid_value\",\n      values,\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodLiteral = /* @__PURE__ */$constructor(\"$ZodLiteral\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.values = new Set(def.values);\n  inst._zod.pattern = new RegExp(`^(${def.values.map(o => typeof o === \"string\" ? escapeRegex(o) : o ? o.toString() : String(o)).join(\"|\")})$`);\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (inst._zod.values.has(input)) {\n      return payload;\n    }\n    payload.issues.push({\n      code: \"invalid_value\",\n      values: def.values,\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodFile = /* @__PURE__ */$constructor(\"$ZodFile\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (input instanceof File) return payload;\n    payload.issues.push({\n      expected: \"file\",\n      code: \"invalid_type\",\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodTransform = /* @__PURE__ */$constructor(\"$ZodTransform\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    const _out = def.transform(payload.value, payload);\n    if (_ctx.async) {\n      const output = _out instanceof Promise ? _out : Promise.resolve(_out);\n      return output.then(output2 => {\n        payload.value = output2;\n        return payload;\n      });\n    }\n    if (_out instanceof Promise) {\n      throw new $ZodAsyncError();\n    }\n    payload.value = _out;\n    return payload;\n  };\n});\nvar $ZodOptional = /* @__PURE__ */$constructor(\"$ZodOptional\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.optin = \"optional\";\n  inst._zod.optout = \"optional\";\n  defineLazy(inst._zod, \"values\", () => {\n    return def.innerType._zod.values ? /* @__PURE__ */new Set([...def.innerType._zod.values, void 0]) : void 0;\n  });\n  defineLazy(inst._zod, \"pattern\", () => {\n    const pattern = def.innerType._zod.pattern;\n    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    if (def.innerType._zod.optin === \"optional\") {\n      return def.innerType._zod.run(payload, ctx);\n    }\n    if (payload.value === void 0) {\n      return payload;\n    }\n    return def.innerType._zod.run(payload, ctx);\n  };\n});\nvar $ZodNullable = /* @__PURE__ */$constructor(\"$ZodNullable\", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, \"optin\", () => def.innerType._zod.optin);\n  defineLazy(inst._zod, \"optout\", () => def.innerType._zod.optout);\n  defineLazy(inst._zod, \"pattern\", () => {\n    const pattern = def.innerType._zod.pattern;\n    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;\n  });\n  defineLazy(inst._zod, \"values\", () => {\n    return def.innerType._zod.values ? /* @__PURE__ */new Set([...def.innerType._zod.values, null]) : void 0;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    if (payload.value === null) return payload;\n    return def.innerType._zod.run(payload, ctx);\n  };\n});\nvar $ZodDefault = /* @__PURE__ */$constructor(\"$ZodDefault\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.optin = \"optional\";\n  defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n  inst._zod.parse = (payload, ctx) => {\n    if (payload.value === void 0) {\n      payload.value = def.defaultValue;\n      return payload;\n    }\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then(result2 => handleDefaultResult(result2, def));\n    }\n    return handleDefaultResult(result, def);\n  };\n});\nfunction handleDefaultResult(payload, def) {\n  if (payload.value === void 0) {\n    payload.value = def.defaultValue;\n  }\n  return payload;\n}\nvar $ZodPrefault = /* @__PURE__ */$constructor(\"$ZodPrefault\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.optin = \"optional\";\n  defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n  inst._zod.parse = (payload, ctx) => {\n    if (payload.value === void 0) {\n      payload.value = def.defaultValue;\n    }\n    return def.innerType._zod.run(payload, ctx);\n  };\n});\nvar $ZodNonOptional = /* @__PURE__ */$constructor(\"$ZodNonOptional\", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, \"values\", () => {\n    const v = def.innerType._zod.values;\n    return v ? new Set([...v].filter(x => x !== void 0)) : void 0;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then(result2 => handleNonOptionalResult(result2, inst));\n    }\n    return handleNonOptionalResult(result, inst);\n  };\n});\nfunction handleNonOptionalResult(payload, inst) {\n  if (!payload.issues.length && payload.value === void 0) {\n    payload.issues.push({\n      code: \"invalid_type\",\n      expected: \"nonoptional\",\n      input: payload.value,\n      inst\n    });\n  }\n  return payload;\n}\nvar $ZodSuccess = /* @__PURE__ */$constructor(\"$ZodSuccess\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then(result2 => {\n        payload.value = result2.issues.length === 0;\n        return payload;\n      });\n    }\n    payload.value = result.issues.length === 0;\n    return payload;\n  };\n});\nvar $ZodCatch = /* @__PURE__ */$constructor(\"$ZodCatch\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.optin = \"optional\";\n  defineLazy(inst._zod, \"optout\", () => def.innerType._zod.optout);\n  defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n  inst._zod.parse = (payload, ctx) => {\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then(result2 => {\n        payload.value = result2.value;\n        if (result2.issues.length) {\n          payload.value = def.catchValue({\n            ...payload,\n            error: {\n              issues: result2.issues.map(iss => finalizeIssue(iss, ctx, config()))\n            },\n            input: payload.value\n          });\n          payload.issues = [];\n        }\n        return payload;\n      });\n    }\n    payload.value = result.value;\n    if (result.issues.length) {\n      payload.value = def.catchValue({\n        ...payload,\n        error: {\n          issues: result.issues.map(iss => finalizeIssue(iss, ctx, config()))\n        },\n        input: payload.value\n      });\n      payload.issues = [];\n    }\n    return payload;\n  };\n});\nvar $ZodNaN = /* @__PURE__ */$constructor(\"$ZodNaN\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    if (typeof payload.value !== \"number\" || !Number.isNaN(payload.value)) {\n      payload.issues.push({\n        input: payload.value,\n        inst,\n        expected: \"nan\",\n        code: \"invalid_type\"\n      });\n      return payload;\n    }\n    return payload;\n  };\n});\nvar $ZodPipe = /* @__PURE__ */$constructor(\"$ZodPipe\", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, \"values\", () => def.in._zod.values);\n  defineLazy(inst._zod, \"optin\", () => def.in._zod.optin);\n  defineLazy(inst._zod, \"optout\", () => def.out._zod.optout);\n  inst._zod.parse = (payload, ctx) => {\n    const left = def.in._zod.run(payload, ctx);\n    if (left instanceof Promise) {\n      return left.then(left2 => handlePipeResult(left2, def, ctx));\n    }\n    return handlePipeResult(left, def, ctx);\n  };\n});\nfunction handlePipeResult(left, def, ctx) {\n  if (aborted(left)) {\n    return left;\n  }\n  return def.out._zod.run({\n    value: left.value,\n    issues: left.issues\n  }, ctx);\n}\nvar $ZodReadonly = /* @__PURE__ */$constructor(\"$ZodReadonly\", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, \"propValues\", () => def.innerType._zod.propValues);\n  defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n  defineLazy(inst._zod, \"optin\", () => def.innerType._zod.optin);\n  defineLazy(inst._zod, \"optout\", () => def.innerType._zod.optout);\n  inst._zod.parse = (payload, ctx) => {\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then(handleReadonlyResult);\n    }\n    return handleReadonlyResult(result);\n  };\n});\nfunction handleReadonlyResult(payload) {\n  payload.value = Object.freeze(payload.value);\n  return payload;\n}\nvar $ZodTemplateLiteral = /* @__PURE__ */$constructor(\"$ZodTemplateLiteral\", (inst, def) => {\n  $ZodType.init(inst, def);\n  const regexParts = [];\n  for (const part of def.parts) {\n    if (part instanceof $ZodType) {\n      if (!part._zod.pattern) {\n        throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);\n      }\n      const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;\n      if (!source) throw new Error(`Invalid template literal part: ${part._zod.traits}`);\n      const start = source.startsWith(\"^\") ? 1 : 0;\n      const end = source.endsWith(\"$\") ? source.length - 1 : source.length;\n      regexParts.push(source.slice(start, end));\n    } else if (part === null || primitiveTypes.has(typeof part)) {\n      regexParts.push(escapeRegex(`${part}`));\n    } else {\n      throw new Error(`Invalid template literal part: ${part}`);\n    }\n  }\n  inst._zod.pattern = new RegExp(`^${regexParts.join(\"\")}$`);\n  inst._zod.parse = (payload, _ctx) => {\n    if (typeof payload.value !== \"string\") {\n      payload.issues.push({\n        input: payload.value,\n        inst,\n        expected: \"template_literal\",\n        code: \"invalid_type\"\n      });\n      return payload;\n    }\n    inst._zod.pattern.lastIndex = 0;\n    if (!inst._zod.pattern.test(payload.value)) {\n      payload.issues.push({\n        input: payload.value,\n        inst,\n        code: \"invalid_format\",\n        format: \"template_literal\",\n        pattern: inst._zod.pattern.source\n      });\n      return payload;\n    }\n    return payload;\n  };\n});\nvar $ZodPromise = /* @__PURE__ */$constructor(\"$ZodPromise\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    return Promise.resolve(payload.value).then(inner => def.innerType._zod.run({\n      value: inner,\n      issues: []\n    }, ctx));\n  };\n});\nvar $ZodLazy = /* @__PURE__ */$constructor(\"$ZodLazy\", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, \"innerType\", () => def.getter());\n  defineLazy(inst._zod, \"pattern\", () => inst._zod.innerType._zod.pattern);\n  defineLazy(inst._zod, \"propValues\", () => inst._zod.innerType._zod.propValues);\n  defineLazy(inst._zod, \"optin\", () => inst._zod.innerType._zod.optin);\n  defineLazy(inst._zod, \"optout\", () => inst._zod.innerType._zod.optout);\n  inst._zod.parse = (payload, ctx) => {\n    const inner = inst._zod.innerType;\n    return inner._zod.run(payload, ctx);\n  };\n});\nvar $ZodCustom = /* @__PURE__ */$constructor(\"$ZodCustom\", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _) => {\n    return payload;\n  };\n  inst._zod.check = payload => {\n    const input = payload.value;\n    const r2 = def.fn(input);\n    if (r2 instanceof Promise) {\n      return r2.then(r3 => handleRefineResult(r3, payload, input, inst));\n    }\n    handleRefineResult(r2, payload, input, inst);\n    return;\n  };\n});\nfunction handleRefineResult(result, payload, input, inst) {\n  if (!result) {\n    const _iss = {\n      code: \"custom\",\n      input,\n      inst,\n      // incorporates params.error into issue reporting\n      path: [...(inst._zod.def.path ?? [])],\n      // incorporates params.error into issue reporting\n      continue: !inst._zod.def.abort\n      // params: inst._zod.def.params,\n    };\n    if (inst._zod.def.params) _iss.params = inst._zod.def.params;\n    payload.issues.push(issue(_iss));\n  }\n}\n\n// ../../node_modules/zod/v4/locales/index.js\nvar locales_exports = {};\n__export(locales_exports, {\n  ar: () => ar_default,\n  az: () => az_default,\n  be: () => be_default,\n  ca: () => ca_default,\n  cs: () => cs_default,\n  de: () => de_default,\n  en: () => en_default2,\n  eo: () => eo_default,\n  es: () => es_default,\n  fa: () => fa_default,\n  fi: () => fi_default,\n  fr: () => fr_default,\n  frCA: () => fr_CA_default,\n  he: () => he_default,\n  hu: () => hu_default,\n  id: () => id_default,\n  it: () => it_default,\n  ja: () => ja_default,\n  kh: () => kh_default,\n  ko: () => ko_default,\n  mk: () => mk_default,\n  ms: () => ms_default,\n  nl: () => nl_default,\n  no: () => no_default,\n  ota: () => ota_default,\n  pl: () => pl_default,\n  ps: () => ps_default,\n  pt: () => pt_default,\n  ru: () => ru_default,\n  sl: () => sl_default,\n  sv: () => sv_default,\n  ta: () => ta_default,\n  th: () => th_default,\n  tr: () => tr_default,\n  ua: () => ua_default,\n  ur: () => ur_default,\n  vi: () => vi_default,\n  zhCN: () => zh_CN_default,\n  zhTW: () => zh_TW_default\n});\n\n// ../../node_modules/zod/v4/locales/ar.js\nvar error = () => {\n  const Sizable = {\n    string: {\n      unit: \"\\u062D\\u0631\\u0641\",\n      verb: \"\\u0623\\u0646 \\u064A\\u062D\\u0648\\u064A\"\n    },\n    file: {\n      unit: \"\\u0628\\u0627\\u064A\\u062A\",\n      verb: \"\\u0623\\u0646 \\u064A\\u062D\\u0648\\u064A\"\n    },\n    array: {\n      unit: \"\\u0639\\u0646\\u0635\\u0631\",\n      verb: \"\\u0623\\u0646 \\u064A\\u062D\\u0648\\u064A\"\n    },\n    set: {\n      unit: \"\\u0639\\u0646\\u0635\\u0631\",\n      verb: \"\\u0623\\u0646 \\u064A\\u062D\\u0648\\u064A\"\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType4 = data => {\n    const t = typeof data;\n    switch (t) {\n      case \"number\":\n        {\n          return Number.isNaN(data) ? \"NaN\" : \"number\";\n        }\n      case \"object\":\n        {\n          if (Array.isArray(data)) {\n            return \"array\";\n          }\n          if (data === null) {\n            return \"null\";\n          }\n          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n            return data.constructor.name;\n          }\n        }\n    }\n    return t;\n  };\n  const Nouns = {\n    regex: \"\\u0645\\u062F\\u062E\\u0644\",\n    email: \"\\u0628\\u0631\\u064A\\u062F \\u0625\\u0644\\u0643\\u062A\\u0631\\u0648\\u0646\\u064A\",\n    url: \"\\u0631\\u0627\\u0628\\u0637\",\n    emoji: \"\\u0625\\u064A\\u0645\\u0648\\u062C\\u064A\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"\\u062A\\u0627\\u0631\\u064A\\u062E \\u0648\\u0648\\u0642\\u062A \\u0628\\u0645\\u0639\\u064A\\u0627\\u0631 ISO\",\n    date: \"\\u062A\\u0627\\u0631\\u064A\\u062E \\u0628\\u0645\\u0639\\u064A\\u0627\\u0631 ISO\",\n    time: \"\\u0648\\u0642\\u062A \\u0628\\u0645\\u0639\\u064A\\u0627\\u0631 ISO\",\n    duration: \"\\u0645\\u062F\\u0629 \\u0628\\u0645\\u0639\\u064A\\u0627\\u0631 ISO\",\n    ipv4: \"\\u0639\\u0646\\u0648\\u0627\\u0646 IPv4\",\n    ipv6: \"\\u0639\\u0646\\u0648\\u0627\\u0646 IPv6\",\n    cidrv4: \"\\u0645\\u062F\\u0649 \\u0639\\u0646\\u0627\\u0648\\u064A\\u0646 \\u0628\\u0635\\u064A\\u063A\\u0629 IPv4\",\n    cidrv6: \"\\u0645\\u062F\\u0649 \\u0639\\u0646\\u0627\\u0648\\u064A\\u0646 \\u0628\\u0635\\u064A\\u063A\\u0629 IPv6\",\n    base64: \"\\u0646\\u064E\\u0635 \\u0628\\u062A\\u0631\\u0645\\u064A\\u0632 base64-encoded\",\n    base64url: \"\\u0646\\u064E\\u0635 \\u0628\\u062A\\u0631\\u0645\\u064A\\u0632 base64url-encoded\",\n    json_string: \"\\u0646\\u064E\\u0635 \\u0639\\u0644\\u0649 \\u0647\\u064A\\u0626\\u0629 JSON\",\n    e164: \"\\u0631\\u0642\\u0645 \\u0647\\u0627\\u062A\\u0641 \\u0628\\u0645\\u0639\\u064A\\u0627\\u0631 E.164\",\n    jwt: \"JWT\",\n    template_literal: \"\\u0645\\u062F\\u062E\\u0644\"\n  };\n  return issue2 => {\n    switch (issue2.code) {\n      case \"invalid_type\":\n        return `\\u0645\\u062F\\u062E\\u0644\\u0627\\u062A \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644\\u0629: \\u064A\\u0641\\u062A\\u0631\\u0636 \\u0625\\u062F\\u062E\\u0627\\u0644 ${issue2.expected}\\u060C \\u0648\\u0644\\u0643\\u0646 \\u062A\\u0645 \\u0625\\u062F\\u062E\\u0627\\u0644 ${parsedType4(issue2.input)}`;\n      case \"invalid_value\":\n        if (issue2.values.length === 1) return `\\u0645\\u062F\\u062E\\u0644\\u0627\\u062A \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644\\u0629: \\u064A\\u0641\\u062A\\u0631\\u0636 \\u0625\\u062F\\u062E\\u0627\\u0644 ${stringifyPrimitive(issue2.values[0])}`;\n        return `\\u0627\\u062E\\u062A\\u064A\\u0627\\u0631 \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644: \\u064A\\u062A\\u0648\\u0642\\u0639 \\u0627\\u0646\\u062A\\u0642\\u0627\\u0621 \\u0623\\u062D\\u062F \\u0647\\u0630\\u0647 \\u0627\\u0644\\u062E\\u064A\\u0627\\u0631\\u0627\\u062A: ${joinValues(issue2.values, \"|\")}`;\n      case \"too_big\":\n        {\n          const adj = issue2.inclusive ? \"<=\" : \"<\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) return ` \\u0623\\u0643\\u0628\\u0631 \\u0645\\u0646 \\u0627\\u0644\\u0644\\u0627\\u0632\\u0645: \\u064A\\u0641\\u062A\\u0631\\u0636 \\u0623\\u0646 \\u062A\\u0643\\u0648\\u0646 ${issue2.origin ?? \"\\u0627\\u0644\\u0642\\u064A\\u0645\\u0629\"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? \"\\u0639\\u0646\\u0635\\u0631\"}`;\n          return `\\u0623\\u0643\\u0628\\u0631 \\u0645\\u0646 \\u0627\\u0644\\u0644\\u0627\\u0632\\u0645: \\u064A\\u0641\\u062A\\u0631\\u0636 \\u0623\\u0646 \\u062A\\u0643\\u0648\\u0646 ${issue2.origin ?? \"\\u0627\\u0644\\u0642\\u064A\\u0645\\u0629\"} ${adj} ${issue2.maximum.toString()}`;\n        }\n      case \"too_small\":\n        {\n          const adj = issue2.inclusive ? \">=\" : \">\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            return `\\u0623\\u0635\\u063A\\u0631 \\u0645\\u0646 \\u0627\\u0644\\u0644\\u0627\\u0632\\u0645: \\u064A\\u0641\\u062A\\u0631\\u0636 \\u0644\\u0640 ${issue2.origin} \\u0623\\u0646 \\u064A\\u0643\\u0648\\u0646 ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;\n          }\n          return `\\u0623\\u0635\\u063A\\u0631 \\u0645\\u0646 \\u0627\\u0644\\u0644\\u0627\\u0632\\u0645: \\u064A\\u0641\\u062A\\u0631\\u0636 \\u0644\\u0640 ${issue2.origin} \\u0623\\u0646 \\u064A\\u0643\\u0648\\u0646 ${adj} ${issue2.minimum.toString()}`;\n        }\n      case \"invalid_format\":\n        {\n          const _issue = issue2;\n          if (_issue.format === \"starts_with\") return `\\u0646\\u064E\\u0635 \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644: \\u064A\\u062C\\u0628 \\u0623\\u0646 \\u064A\\u0628\\u062F\\u0623 \\u0628\\u0640 \"${issue2.prefix}\"`;\n          if (_issue.format === \"ends_with\") return `\\u0646\\u064E\\u0635 \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644: \\u064A\\u062C\\u0628 \\u0623\\u0646 \\u064A\\u0646\\u062A\\u0647\\u064A \\u0628\\u0640 \"${_issue.suffix}\"`;\n          if (_issue.format === \"includes\") return `\\u0646\\u064E\\u0635 \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644: \\u064A\\u062C\\u0628 \\u0623\\u0646 \\u064A\\u062A\\u0636\\u0645\\u0651\\u064E\\u0646 \"${_issue.includes}\"`;\n          if (_issue.format === \"regex\") return `\\u0646\\u064E\\u0635 \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644: \\u064A\\u062C\\u0628 \\u0623\\u0646 \\u064A\\u0637\\u0627\\u0628\\u0642 \\u0627\\u0644\\u0646\\u0645\\u0637 ${_issue.pattern}`;\n          return `${Nouns[_issue.format] ?? issue2.format} \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644`;\n        }\n      case \"not_multiple_of\":\n        return `\\u0631\\u0642\\u0645 \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644: \\u064A\\u062C\\u0628 \\u0623\\u0646 \\u064A\\u0643\\u0648\\u0646 \\u0645\\u0646 \\u0645\\u0636\\u0627\\u0639\\u0641\\u0627\\u062A ${issue2.divisor}`;\n      case \"unrecognized_keys\":\n        return `\\u0645\\u0639\\u0631\\u0641${issue2.keys.length > 1 ? \"\\u0627\\u062A\" : \"\"} \\u063A\\u0631\\u064A\\u0628${issue2.keys.length > 1 ? \"\\u0629\" : \"\"}: ${joinValues(issue2.keys, \"\\u060C \")}`;\n      case \"invalid_key\":\n        return `\\u0645\\u0639\\u0631\\u0641 \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644 \\u0641\\u064A ${issue2.origin}`;\n      case \"invalid_union\":\n        return \"\\u0645\\u062F\\u062E\\u0644 \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644\";\n      case \"invalid_element\":\n        return `\\u0645\\u062F\\u062E\\u0644 \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644 \\u0641\\u064A ${issue2.origin}`;\n      default:\n        return \"\\u0645\\u062F\\u062E\\u0644 \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644\";\n    }\n  };\n};\nfunction ar_default() {\n  return {\n    localeError: error()\n  };\n}\n\n// ../../node_modules/zod/v4/locales/az.js\nvar error2 = () => {\n  const Sizable = {\n    string: {\n      unit: \"simvol\",\n      verb: \"olmal\\u0131d\\u0131r\"\n    },\n    file: {\n      unit: \"bayt\",\n      verb: \"olmal\\u0131d\\u0131r\"\n    },\n    array: {\n      unit: \"element\",\n      verb: \"olmal\\u0131d\\u0131r\"\n    },\n    set: {\n      unit: \"element\",\n      verb: \"olmal\\u0131d\\u0131r\"\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType4 = data => {\n    const t = typeof data;\n    switch (t) {\n      case \"number\":\n        {\n          return Number.isNaN(data) ? \"NaN\" : \"number\";\n        }\n      case \"object\":\n        {\n          if (Array.isArray(data)) {\n            return \"array\";\n          }\n          if (data === null) {\n            return \"null\";\n          }\n          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n            return data.constructor.name;\n          }\n        }\n    }\n    return t;\n  };\n  const Nouns = {\n    regex: \"input\",\n    email: \"email address\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO datetime\",\n    date: \"ISO date\",\n    time: \"ISO time\",\n    duration: \"ISO duration\",\n    ipv4: \"IPv4 address\",\n    ipv6: \"IPv6 address\",\n    cidrv4: \"IPv4 range\",\n    cidrv6: \"IPv6 range\",\n    base64: \"base64-encoded string\",\n    base64url: \"base64url-encoded string\",\n    json_string: \"JSON string\",\n    e164: \"E.164 number\",\n    jwt: \"JWT\",\n    template_literal: \"input\"\n  };\n  return issue2 => {\n    switch (issue2.code) {\n      case \"invalid_type\":\n        return `Yanl\\u0131\\u015F d\\u0259y\\u0259r: g\\xF6zl\\u0259nil\\u0259n ${issue2.expected}, daxil olan ${parsedType4(issue2.input)}`;\n      case \"invalid_value\":\n        if (issue2.values.length === 1) return `Yanl\\u0131\\u015F d\\u0259y\\u0259r: g\\xF6zl\\u0259nil\\u0259n ${stringifyPrimitive(issue2.values[0])}`;\n        return `Yanl\\u0131\\u015F se\\xE7im: a\\u015Fa\\u011F\\u0131dak\\u0131lardan biri olmal\\u0131d\\u0131r: ${joinValues(issue2.values, \"|\")}`;\n      case \"too_big\":\n        {\n          const adj = issue2.inclusive ? \"<=\" : \"<\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) return `\\xC7ox b\\xF6y\\xFCk: g\\xF6zl\\u0259nil\\u0259n ${issue2.origin ?? \"d\\u0259y\\u0259r\"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? \"element\"}`;\n          return `\\xC7ox b\\xF6y\\xFCk: g\\xF6zl\\u0259nil\\u0259n ${issue2.origin ?? \"d\\u0259y\\u0259r\"} ${adj}${issue2.maximum.toString()}`;\n        }\n      case \"too_small\":\n        {\n          const adj = issue2.inclusive ? \">=\" : \">\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) return `\\xC7ox ki\\xE7ik: g\\xF6zl\\u0259nil\\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n          return `\\xC7ox ki\\xE7ik: g\\xF6zl\\u0259nil\\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()}`;\n        }\n      case \"invalid_format\":\n        {\n          const _issue = issue2;\n          if (_issue.format === \"starts_with\") return `Yanl\\u0131\\u015F m\\u0259tn: \"${_issue.prefix}\" il\\u0259 ba\\u015Flamal\\u0131d\\u0131r`;\n          if (_issue.format === \"ends_with\") return `Yanl\\u0131\\u015F m\\u0259tn: \"${_issue.suffix}\" il\\u0259 bitm\\u0259lidir`;\n          if (_issue.format === \"includes\") return `Yanl\\u0131\\u015F m\\u0259tn: \"${_issue.includes}\" daxil olmal\\u0131d\\u0131r`;\n          if (_issue.format === \"regex\") return `Yanl\\u0131\\u015F m\\u0259tn: ${_issue.pattern} \\u015Fablonuna uy\\u011Fun olmal\\u0131d\\u0131r`;\n          return `Yanl\\u0131\\u015F ${Nouns[_issue.format] ?? issue2.format}`;\n        }\n      case \"not_multiple_of\":\n        return `Yanl\\u0131\\u015F \\u0259d\\u0259d: ${issue2.divisor} il\\u0259 b\\xF6l\\xFCn\\u0259 bil\\u0259n olmal\\u0131d\\u0131r`;\n      case \"unrecognized_keys\":\n        return `Tan\\u0131nmayan a\\xE7ar${issue2.keys.length > 1 ? \"lar\" : \"\"}: ${joinValues(issue2.keys, \", \")}`;\n      case \"invalid_key\":\n        return `${issue2.origin} daxilind\\u0259 yanl\\u0131\\u015F a\\xE7ar`;\n      case \"invalid_union\":\n        return \"Yanl\\u0131\\u015F d\\u0259y\\u0259r\";\n      case \"invalid_element\":\n        return `${issue2.origin} daxilind\\u0259 yanl\\u0131\\u015F d\\u0259y\\u0259r`;\n      default:\n        return `Yanl\\u0131\\u015F d\\u0259y\\u0259r`;\n    }\n  };\n};\nfunction az_default() {\n  return {\n    localeError: error2()\n  };\n}\n\n// ../../node_modules/zod/v4/locales/be.js\nfunction getBelarusianPlural(count, one, few, many) {\n  const absCount = Math.abs(count);\n  const lastDigit = absCount % 10;\n  const lastTwoDigits = absCount % 100;\n  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {\n    return many;\n  }\n  if (lastDigit === 1) {\n    return one;\n  }\n  if (lastDigit >= 2 && lastDigit <= 4) {\n    return few;\n  }\n  return many;\n}\nvar error3 = () => {\n  const Sizable = {\n    string: {\n      unit: {\n        one: \"\\u0441\\u0456\\u043C\\u0432\\u0430\\u043B\",\n        few: \"\\u0441\\u0456\\u043C\\u0432\\u0430\\u043B\\u044B\",\n        many: \"\\u0441\\u0456\\u043C\\u0432\\u0430\\u043B\\u0430\\u045E\"\n      },\n      verb: \"\\u043C\\u0435\\u0446\\u044C\"\n    },\n    array: {\n      unit: {\n        one: \"\\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\",\n        few: \"\\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u044B\",\n        many: \"\\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0430\\u045E\"\n      },\n      verb: \"\\u043C\\u0435\\u0446\\u044C\"\n    },\n    set: {\n      unit: {\n        one: \"\\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\",\n        few: \"\\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u044B\",\n        many: \"\\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0430\\u045E\"\n      },\n      verb: \"\\u043C\\u0435\\u0446\\u044C\"\n    },\n    file: {\n      unit: {\n        one: \"\\u0431\\u0430\\u0439\\u0442\",\n        few: \"\\u0431\\u0430\\u0439\\u0442\\u044B\",\n        many: \"\\u0431\\u0430\\u0439\\u0442\\u0430\\u045E\"\n      },\n      verb: \"\\u043C\\u0435\\u0446\\u044C\"\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType4 = data => {\n    const t = typeof data;\n    switch (t) {\n      case \"number\":\n        {\n          return Number.isNaN(data) ? \"NaN\" : \"\\u043B\\u0456\\u043A\";\n        }\n      case \"object\":\n        {\n          if (Array.isArray(data)) {\n            return \"\\u043C\\u0430\\u0441\\u0456\\u045E\";\n          }\n          if (data === null) {\n            return \"null\";\n          }\n          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n            return data.constructor.name;\n          }\n        }\n    }\n    return t;\n  };\n  const Nouns = {\n    regex: \"\\u0443\\u0432\\u043E\\u0434\",\n    email: \"email \\u0430\\u0434\\u0440\\u0430\\u0441\",\n    url: \"URL\",\n    emoji: \"\\u044D\\u043C\\u043E\\u0434\\u0437\\u0456\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO \\u0434\\u0430\\u0442\\u0430 \\u0456 \\u0447\\u0430\\u0441\",\n    date: \"ISO \\u0434\\u0430\\u0442\\u0430\",\n    time: \"ISO \\u0447\\u0430\\u0441\",\n    duration: \"ISO \\u043F\\u0440\\u0430\\u0446\\u044F\\u0433\\u043B\\u0430\\u0441\\u0446\\u044C\",\n    ipv4: \"IPv4 \\u0430\\u0434\\u0440\\u0430\\u0441\",\n    ipv6: \"IPv6 \\u0430\\u0434\\u0440\\u0430\\u0441\",\n    cidrv4: \"IPv4 \\u0434\\u044B\\u044F\\u043F\\u0430\\u0437\\u043E\\u043D\",\n    cidrv6: \"IPv6 \\u0434\\u044B\\u044F\\u043F\\u0430\\u0437\\u043E\\u043D\",\n    base64: \"\\u0440\\u0430\\u0434\\u043E\\u043A \\u0443 \\u0444\\u0430\\u0440\\u043C\\u0430\\u0446\\u0435 base64\",\n    base64url: \"\\u0440\\u0430\\u0434\\u043E\\u043A \\u0443 \\u0444\\u0430\\u0440\\u043C\\u0430\\u0446\\u0435 base64url\",\n    json_string: \"JSON \\u0440\\u0430\\u0434\\u043E\\u043A\",\n    e164: \"\\u043D\\u0443\\u043C\\u0430\\u0440 E.164\",\n    jwt: \"JWT\",\n    template_literal: \"\\u0443\\u0432\\u043E\\u0434\"\n  };\n  return issue2 => {\n    switch (issue2.code) {\n      case \"invalid_type\":\n        return `\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u044B \\u045E\\u0432\\u043E\\u0434: \\u0447\\u0430\\u043A\\u0430\\u045E\\u0441\\u044F ${issue2.expected}, \\u0430\\u0442\\u0440\\u044B\\u043C\\u0430\\u043D\\u0430 ${parsedType4(issue2.input)}`;\n      case \"invalid_value\":\n        if (issue2.values.length === 1) return `\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u044B \\u045E\\u0432\\u043E\\u0434: \\u0447\\u0430\\u043A\\u0430\\u043B\\u0430\\u0441\\u044F ${stringifyPrimitive(issue2.values[0])}`;\n        return `\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u044B \\u0432\\u0430\\u0440\\u044B\\u044F\\u043D\\u0442: \\u0447\\u0430\\u043A\\u0430\\u045E\\u0441\\u044F \\u0430\\u0434\\u0437\\u0456\\u043D \\u0437 ${joinValues(issue2.values, \"|\")}`;\n      case \"too_big\":\n        {\n          const adj = issue2.inclusive ? \"<=\" : \"<\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            const maxValue = Number(issue2.maximum);\n            const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);\n            return `\\u0417\\u0430\\u043D\\u0430\\u0434\\u0442\\u0430 \\u0432\\u044F\\u043B\\u0456\\u043A\\u0456: \\u0447\\u0430\\u043A\\u0430\\u043B\\u0430\\u0441\\u044F, \\u0448\\u0442\\u043E ${issue2.origin ?? \"\\u0437\\u043D\\u0430\\u0447\\u044D\\u043D\\u043D\\u0435\"} \\u043F\\u0430\\u0432\\u0456\\u043D\\u043D\\u0430 ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;\n          }\n          return `\\u0417\\u0430\\u043D\\u0430\\u0434\\u0442\\u0430 \\u0432\\u044F\\u043B\\u0456\\u043A\\u0456: \\u0447\\u0430\\u043A\\u0430\\u043B\\u0430\\u0441\\u044F, \\u0448\\u0442\\u043E ${issue2.origin ?? \"\\u0437\\u043D\\u0430\\u0447\\u044D\\u043D\\u043D\\u0435\"} \\u043F\\u0430\\u0432\\u0456\\u043D\\u043D\\u0430 \\u0431\\u044B\\u0446\\u044C ${adj}${issue2.maximum.toString()}`;\n        }\n      case \"too_small\":\n        {\n          const adj = issue2.inclusive ? \">=\" : \">\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            const minValue = Number(issue2.minimum);\n            const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);\n            return `\\u0417\\u0430\\u043D\\u0430\\u0434\\u0442\\u0430 \\u043C\\u0430\\u043B\\u044B: \\u0447\\u0430\\u043A\\u0430\\u043B\\u0430\\u0441\\u044F, \\u0448\\u0442\\u043E ${issue2.origin} \\u043F\\u0430\\u0432\\u0456\\u043D\\u043D\\u0430 ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;\n          }\n          return `\\u0417\\u0430\\u043D\\u0430\\u0434\\u0442\\u0430 \\u043C\\u0430\\u043B\\u044B: \\u0447\\u0430\\u043A\\u0430\\u043B\\u0430\\u0441\\u044F, \\u0448\\u0442\\u043E ${issue2.origin} \\u043F\\u0430\\u0432\\u0456\\u043D\\u043D\\u0430 \\u0431\\u044B\\u0446\\u044C ${adj}${issue2.minimum.toString()}`;\n        }\n      case \"invalid_format\":\n        {\n          const _issue = issue2;\n          if (_issue.format === \"starts_with\") return `\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u044B \\u0440\\u0430\\u0434\\u043E\\u043A: \\u043F\\u0430\\u0432\\u0456\\u043D\\u0435\\u043D \\u043F\\u0430\\u0447\\u044B\\u043D\\u0430\\u0446\\u0446\\u0430 \\u0437 \"${_issue.prefix}\"`;\n          if (_issue.format === \"ends_with\") return `\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u044B \\u0440\\u0430\\u0434\\u043E\\u043A: \\u043F\\u0430\\u0432\\u0456\\u043D\\u0435\\u043D \\u0437\\u0430\\u043A\\u0430\\u043D\\u0447\\u0432\\u0430\\u0446\\u0446\\u0430 \\u043D\\u0430 \"${_issue.suffix}\"`;\n          if (_issue.format === \"includes\") return `\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u044B \\u0440\\u0430\\u0434\\u043E\\u043A: \\u043F\\u0430\\u0432\\u0456\\u043D\\u0435\\u043D \\u0437\\u043C\\u044F\\u0448\\u0447\\u0430\\u0446\\u044C \"${_issue.includes}\"`;\n          if (_issue.format === \"regex\") return `\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u044B \\u0440\\u0430\\u0434\\u043E\\u043A: \\u043F\\u0430\\u0432\\u0456\\u043D\\u0435\\u043D \\u0430\\u0434\\u043F\\u0430\\u0432\\u044F\\u0434\\u0430\\u0446\\u044C \\u0448\\u0430\\u0431\\u043B\\u043E\\u043D\\u0443 ${_issue.pattern}`;\n          return `\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u044B ${Nouns[_issue.format] ?? issue2.format}`;\n        }\n      case \"not_multiple_of\":\n        return `\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u044B \\u043B\\u0456\\u043A: \\u043F\\u0430\\u0432\\u0456\\u043D\\u0435\\u043D \\u0431\\u044B\\u0446\\u044C \\u043A\\u0440\\u0430\\u0442\\u043D\\u044B\\u043C ${issue2.divisor}`;\n      case \"unrecognized_keys\":\n        return `\\u041D\\u0435\\u0440\\u0430\\u0441\\u043F\\u0430\\u0437\\u043D\\u0430\\u043D\\u044B ${issue2.keys.length > 1 ? \"\\u043A\\u043B\\u044E\\u0447\\u044B\" : \"\\u043A\\u043B\\u044E\\u0447\"}: ${joinValues(issue2.keys, \", \")}`;\n      case \"invalid_key\":\n        return `\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u044B \\u043A\\u043B\\u044E\\u0447 \\u0443 ${issue2.origin}`;\n      case \"invalid_union\":\n        return \"\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u044B \\u045E\\u0432\\u043E\\u0434\";\n      case \"invalid_element\":\n        return `\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u0430\\u0435 \\u0437\\u043D\\u0430\\u0447\\u044D\\u043D\\u043D\\u0435 \\u045E ${issue2.origin}`;\n      default:\n        return `\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u044B \\u045E\\u0432\\u043E\\u0434`;\n    }\n  };\n};\nfunction be_default() {\n  return {\n    localeError: error3()\n  };\n}\n\n// ../../node_modules/zod/v4/locales/ca.js\nvar error4 = () => {\n  const Sizable = {\n    string: {\n      unit: \"car\\xE0cters\",\n      verb: \"contenir\"\n    },\n    file: {\n      unit: \"bytes\",\n      verb: \"contenir\"\n    },\n    array: {\n      unit: \"elements\",\n      verb: \"contenir\"\n    },\n    set: {\n      unit: \"elements\",\n      verb: \"contenir\"\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType4 = data => {\n    const t = typeof data;\n    switch (t) {\n      case \"number\":\n        {\n          return Number.isNaN(data) ? \"NaN\" : \"number\";\n        }\n      case \"object\":\n        {\n          if (Array.isArray(data)) {\n            return \"array\";\n          }\n          if (data === null) {\n            return \"null\";\n          }\n          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n            return data.constructor.name;\n          }\n        }\n    }\n    return t;\n  };\n  const Nouns = {\n    regex: \"entrada\",\n    email: \"adre\\xE7a electr\\xF2nica\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"data i hora ISO\",\n    date: \"data ISO\",\n    time: \"hora ISO\",\n    duration: \"durada ISO\",\n    ipv4: \"adre\\xE7a IPv4\",\n    ipv6: \"adre\\xE7a IPv6\",\n    cidrv4: \"rang IPv4\",\n    cidrv6: \"rang IPv6\",\n    base64: \"cadena codificada en base64\",\n    base64url: \"cadena codificada en base64url\",\n    json_string: \"cadena JSON\",\n    e164: \"n\\xFAmero E.164\",\n    jwt: \"JWT\",\n    template_literal: \"entrada\"\n  };\n  return issue2 => {\n    switch (issue2.code) {\n      case \"invalid_type\":\n        return `Tipus inv\\xE0lid: s'esperava ${issue2.expected}, s'ha rebut ${parsedType4(issue2.input)}`;\n      // return `Tipus invàlid: s'esperava ${issue.expected}, s'ha rebut ${util.getParsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue2.values.length === 1) return `Valor inv\\xE0lid: s'esperava ${stringifyPrimitive(issue2.values[0])}`;\n        return `Opci\\xF3 inv\\xE0lida: s'esperava una de ${joinValues(issue2.values, \" o \")}`;\n      case \"too_big\":\n        {\n          const adj = issue2.inclusive ? \"com a m\\xE0xim\" : \"menys de\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) return `Massa gran: s'esperava que ${issue2.origin ?? \"el valor\"} contingu\\xE9s ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? \"elements\"}`;\n          return `Massa gran: s'esperava que ${issue2.origin ?? \"el valor\"} fos ${adj} ${issue2.maximum.toString()}`;\n        }\n      case \"too_small\":\n        {\n          const adj = issue2.inclusive ? \"com a m\\xEDnim\" : \"m\\xE9s de\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            return `Massa petit: s'esperava que ${issue2.origin} contingu\\xE9s ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;\n          }\n          return `Massa petit: s'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;\n        }\n      case \"invalid_format\":\n        {\n          const _issue = issue2;\n          if (_issue.format === \"starts_with\") {\n            return `Format inv\\xE0lid: ha de comen\\xE7ar amb \"${_issue.prefix}\"`;\n          }\n          if (_issue.format === \"ends_with\") return `Format inv\\xE0lid: ha d'acabar amb \"${_issue.suffix}\"`;\n          if (_issue.format === \"includes\") return `Format inv\\xE0lid: ha d'incloure \"${_issue.includes}\"`;\n          if (_issue.format === \"regex\") return `Format inv\\xE0lid: ha de coincidir amb el patr\\xF3 ${_issue.pattern}`;\n          return `Format inv\\xE0lid per a ${Nouns[_issue.format] ?? issue2.format}`;\n        }\n      case \"not_multiple_of\":\n        return `N\\xFAmero inv\\xE0lid: ha de ser m\\xFAltiple de ${issue2.divisor}`;\n      case \"unrecognized_keys\":\n        return `Clau${issue2.keys.length > 1 ? \"s\" : \"\"} no reconeguda${issue2.keys.length > 1 ? \"s\" : \"\"}: ${joinValues(issue2.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Clau inv\\xE0lida a ${issue2.origin}`;\n      case \"invalid_union\":\n        return \"Entrada inv\\xE0lida\";\n      // Could also be \"Tipus d'unió invàlid\" but \"Entrada invàlida\" is more general\n      case \"invalid_element\":\n        return `Element inv\\xE0lid a ${issue2.origin}`;\n      default:\n        return `Entrada inv\\xE0lida`;\n    }\n  };\n};\nfunction ca_default() {\n  return {\n    localeError: error4()\n  };\n}\n\n// ../../node_modules/zod/v4/locales/cs.js\nvar error5 = () => {\n  const Sizable = {\n    string: {\n      unit: \"znak\\u016F\",\n      verb: \"m\\xEDt\"\n    },\n    file: {\n      unit: \"bajt\\u016F\",\n      verb: \"m\\xEDt\"\n    },\n    array: {\n      unit: \"prvk\\u016F\",\n      verb: \"m\\xEDt\"\n    },\n    set: {\n      unit: \"prvk\\u016F\",\n      verb: \"m\\xEDt\"\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType4 = data => {\n    const t = typeof data;\n    switch (t) {\n      case \"number\":\n        {\n          return Number.isNaN(data) ? \"NaN\" : \"\\u010D\\xEDslo\";\n        }\n      case \"string\":\n        {\n          return \"\\u0159et\\u011Bzec\";\n        }\n      case \"boolean\":\n        {\n          return \"boolean\";\n        }\n      case \"bigint\":\n        {\n          return \"bigint\";\n        }\n      case \"function\":\n        {\n          return \"funkce\";\n        }\n      case \"symbol\":\n        {\n          return \"symbol\";\n        }\n      case \"undefined\":\n        {\n          return \"undefined\";\n        }\n      case \"object\":\n        {\n          if (Array.isArray(data)) {\n            return \"pole\";\n          }\n          if (data === null) {\n            return \"null\";\n          }\n          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n            return data.constructor.name;\n          }\n        }\n    }\n    return t;\n  };\n  const Nouns = {\n    regex: \"regul\\xE1rn\\xED v\\xFDraz\",\n    email: \"e-mailov\\xE1 adresa\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"datum a \\u010Das ve form\\xE1tu ISO\",\n    date: \"datum ve form\\xE1tu ISO\",\n    time: \"\\u010Das ve form\\xE1tu ISO\",\n    duration: \"doba trv\\xE1n\\xED ISO\",\n    ipv4: \"IPv4 adresa\",\n    ipv6: \"IPv6 adresa\",\n    cidrv4: \"rozsah IPv4\",\n    cidrv6: \"rozsah IPv6\",\n    base64: \"\\u0159et\\u011Bzec zak\\xF3dovan\\xFD ve form\\xE1tu base64\",\n    base64url: \"\\u0159et\\u011Bzec zak\\xF3dovan\\xFD ve form\\xE1tu base64url\",\n    json_string: \"\\u0159et\\u011Bzec ve form\\xE1tu JSON\",\n    e164: \"\\u010D\\xEDslo E.164\",\n    jwt: \"JWT\",\n    template_literal: \"vstup\"\n  };\n  return issue2 => {\n    switch (issue2.code) {\n      case \"invalid_type\":\n        return `Neplatn\\xFD vstup: o\\u010Dek\\xE1v\\xE1no ${issue2.expected}, obdr\\u017Eeno ${parsedType4(issue2.input)}`;\n      case \"invalid_value\":\n        if (issue2.values.length === 1) return `Neplatn\\xFD vstup: o\\u010Dek\\xE1v\\xE1no ${stringifyPrimitive(issue2.values[0])}`;\n        return `Neplatn\\xE1 mo\\u017Enost: o\\u010Dek\\xE1v\\xE1na jedna z hodnot ${joinValues(issue2.values, \"|\")}`;\n      case \"too_big\":\n        {\n          const adj = issue2.inclusive ? \"<=\" : \"<\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            return `Hodnota je p\\u0159\\xEDli\\u0161 velk\\xE1: ${issue2.origin ?? \"hodnota\"} mus\\xED m\\xEDt ${adj}${issue2.maximum.toString()} ${sizing.unit ?? \"prvk\\u016F\"}`;\n          }\n          return `Hodnota je p\\u0159\\xEDli\\u0161 velk\\xE1: ${issue2.origin ?? \"hodnota\"} mus\\xED b\\xFDt ${adj}${issue2.maximum.toString()}`;\n        }\n      case \"too_small\":\n        {\n          const adj = issue2.inclusive ? \">=\" : \">\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            return `Hodnota je p\\u0159\\xEDli\\u0161 mal\\xE1: ${issue2.origin ?? \"hodnota\"} mus\\xED m\\xEDt ${adj}${issue2.minimum.toString()} ${sizing.unit ?? \"prvk\\u016F\"}`;\n          }\n          return `Hodnota je p\\u0159\\xEDli\\u0161 mal\\xE1: ${issue2.origin ?? \"hodnota\"} mus\\xED b\\xFDt ${adj}${issue2.minimum.toString()}`;\n        }\n      case \"invalid_format\":\n        {\n          const _issue = issue2;\n          if (_issue.format === \"starts_with\") return `Neplatn\\xFD \\u0159et\\u011Bzec: mus\\xED za\\u010D\\xEDnat na \"${_issue.prefix}\"`;\n          if (_issue.format === \"ends_with\") return `Neplatn\\xFD \\u0159et\\u011Bzec: mus\\xED kon\\u010Dit na \"${_issue.suffix}\"`;\n          if (_issue.format === \"includes\") return `Neplatn\\xFD \\u0159et\\u011Bzec: mus\\xED obsahovat \"${_issue.includes}\"`;\n          if (_issue.format === \"regex\") return `Neplatn\\xFD \\u0159et\\u011Bzec: mus\\xED odpov\\xEDdat vzoru ${_issue.pattern}`;\n          return `Neplatn\\xFD form\\xE1t ${Nouns[_issue.format] ?? issue2.format}`;\n        }\n      case \"not_multiple_of\":\n        return `Neplatn\\xE9 \\u010D\\xEDslo: mus\\xED b\\xFDt n\\xE1sobkem ${issue2.divisor}`;\n      case \"unrecognized_keys\":\n        return `Nezn\\xE1m\\xE9 kl\\xED\\u010De: ${joinValues(issue2.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Neplatn\\xFD kl\\xED\\u010D v ${issue2.origin}`;\n      case \"invalid_union\":\n        return \"Neplatn\\xFD vstup\";\n      case \"invalid_element\":\n        return `Neplatn\\xE1 hodnota v ${issue2.origin}`;\n      default:\n        return `Neplatn\\xFD vstup`;\n    }\n  };\n};\nfunction cs_default() {\n  return {\n    localeError: error5()\n  };\n}\n\n// ../../node_modules/zod/v4/locales/de.js\nvar error6 = () => {\n  const Sizable = {\n    string: {\n      unit: \"Zeichen\",\n      verb: \"zu haben\"\n    },\n    file: {\n      unit: \"Bytes\",\n      verb: \"zu haben\"\n    },\n    array: {\n      unit: \"Elemente\",\n      verb: \"zu haben\"\n    },\n    set: {\n      unit: \"Elemente\",\n      verb: \"zu haben\"\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType4 = data => {\n    const t = typeof data;\n    switch (t) {\n      case \"number\":\n        {\n          return Number.isNaN(data) ? \"NaN\" : \"Zahl\";\n        }\n      case \"object\":\n        {\n          if (Array.isArray(data)) {\n            return \"Array\";\n          }\n          if (data === null) {\n            return \"null\";\n          }\n          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n            return data.constructor.name;\n          }\n        }\n    }\n    return t;\n  };\n  const Nouns = {\n    regex: \"Eingabe\",\n    email: \"E-Mail-Adresse\",\n    url: \"URL\",\n    emoji: \"Emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO-Datum und -Uhrzeit\",\n    date: \"ISO-Datum\",\n    time: \"ISO-Uhrzeit\",\n    duration: \"ISO-Dauer\",\n    ipv4: \"IPv4-Adresse\",\n    ipv6: \"IPv6-Adresse\",\n    cidrv4: \"IPv4-Bereich\",\n    cidrv6: \"IPv6-Bereich\",\n    base64: \"Base64-codierter String\",\n    base64url: \"Base64-URL-codierter String\",\n    json_string: \"JSON-String\",\n    e164: \"E.164-Nummer\",\n    jwt: \"JWT\",\n    template_literal: \"Eingabe\"\n  };\n  return issue2 => {\n    switch (issue2.code) {\n      case \"invalid_type\":\n        return `Ung\\xFCltige Eingabe: erwartet ${issue2.expected}, erhalten ${parsedType4(issue2.input)}`;\n      case \"invalid_value\":\n        if (issue2.values.length === 1) return `Ung\\xFCltige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;\n        return `Ung\\xFCltige Option: erwartet eine von ${joinValues(issue2.values, \"|\")}`;\n      case \"too_big\":\n        {\n          const adj = issue2.inclusive ? \"<=\" : \"<\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) return `Zu gro\\xDF: erwartet, dass ${issue2.origin ?? \"Wert\"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? \"Elemente\"} hat`;\n          return `Zu gro\\xDF: erwartet, dass ${issue2.origin ?? \"Wert\"} ${adj}${issue2.maximum.toString()} ist`;\n        }\n      case \"too_small\":\n        {\n          const adj = issue2.inclusive ? \">=\" : \">\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;\n          }\n          return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;\n        }\n      case \"invalid_format\":\n        {\n          const _issue = issue2;\n          if (_issue.format === \"starts_with\") return `Ung\\xFCltiger String: muss mit \"${_issue.prefix}\" beginnen`;\n          if (_issue.format === \"ends_with\") return `Ung\\xFCltiger String: muss mit \"${_issue.suffix}\" enden`;\n          if (_issue.format === \"includes\") return `Ung\\xFCltiger String: muss \"${_issue.includes}\" enthalten`;\n          if (_issue.format === \"regex\") return `Ung\\xFCltiger String: muss dem Muster ${_issue.pattern} entsprechen`;\n          return `Ung\\xFCltig: ${Nouns[_issue.format] ?? issue2.format}`;\n        }\n      case \"not_multiple_of\":\n        return `Ung\\xFCltige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;\n      case \"unrecognized_keys\":\n        return `${issue2.keys.length > 1 ? \"Unbekannte Schl\\xFCssel\" : \"Unbekannter Schl\\xFCssel\"}: ${joinValues(issue2.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Ung\\xFCltiger Schl\\xFCssel in ${issue2.origin}`;\n      case \"invalid_union\":\n        return \"Ung\\xFCltige Eingabe\";\n      case \"invalid_element\":\n        return `Ung\\xFCltiger Wert in ${issue2.origin}`;\n      default:\n        return `Ung\\xFCltige Eingabe`;\n    }\n  };\n};\nfunction de_default() {\n  return {\n    localeError: error6()\n  };\n}\n\n// ../../node_modules/zod/v4/locales/en.js\nvar parsedType = data => {\n  const t = typeof data;\n  switch (t) {\n    case \"number\":\n      {\n        return Number.isNaN(data) ? \"NaN\" : \"number\";\n      }\n    case \"object\":\n      {\n        if (Array.isArray(data)) {\n          return \"array\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n  }\n  return t;\n};\nvar error7 = () => {\n  const Sizable = {\n    string: {\n      unit: \"characters\",\n      verb: \"to have\"\n    },\n    file: {\n      unit: \"bytes\",\n      verb: \"to have\"\n    },\n    array: {\n      unit: \"items\",\n      verb: \"to have\"\n    },\n    set: {\n      unit: \"items\",\n      verb: \"to have\"\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const Nouns = {\n    regex: \"input\",\n    email: \"email address\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO datetime\",\n    date: \"ISO date\",\n    time: \"ISO time\",\n    duration: \"ISO duration\",\n    ipv4: \"IPv4 address\",\n    ipv6: \"IPv6 address\",\n    cidrv4: \"IPv4 range\",\n    cidrv6: \"IPv6 range\",\n    base64: \"base64-encoded string\",\n    base64url: \"base64url-encoded string\",\n    json_string: \"JSON string\",\n    e164: \"E.164 number\",\n    jwt: \"JWT\",\n    template_literal: \"input\"\n  };\n  return issue2 => {\n    switch (issue2.code) {\n      case \"invalid_type\":\n        return `Invalid input: expected ${issue2.expected}, received ${parsedType(issue2.input)}`;\n      case \"invalid_value\":\n        if (issue2.values.length === 1) return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;\n        return `Invalid option: expected one of ${joinValues(issue2.values, \"|\")}`;\n      case \"too_big\":\n        {\n          const adj = issue2.inclusive ? \"<=\" : \"<\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) return `Too big: expected ${issue2.origin ?? \"value\"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? \"elements\"}`;\n          return `Too big: expected ${issue2.origin ?? \"value\"} to be ${adj}${issue2.maximum.toString()}`;\n        }\n      case \"too_small\":\n        {\n          const adj = issue2.inclusive ? \">=\" : \">\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n          }\n          return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;\n        }\n      case \"invalid_format\":\n        {\n          const _issue = issue2;\n          if (_issue.format === \"starts_with\") {\n            return `Invalid string: must start with \"${_issue.prefix}\"`;\n          }\n          if (_issue.format === \"ends_with\") return `Invalid string: must end with \"${_issue.suffix}\"`;\n          if (_issue.format === \"includes\") return `Invalid string: must include \"${_issue.includes}\"`;\n          if (_issue.format === \"regex\") return `Invalid string: must match pattern ${_issue.pattern}`;\n          return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;\n        }\n      case \"not_multiple_of\":\n        return `Invalid number: must be a multiple of ${issue2.divisor}`;\n      case \"unrecognized_keys\":\n        return `Unrecognized key${issue2.keys.length > 1 ? \"s\" : \"\"}: ${joinValues(issue2.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Invalid key in ${issue2.origin}`;\n      case \"invalid_union\":\n        return \"Invalid input\";\n      case \"invalid_element\":\n        return `Invalid value in ${issue2.origin}`;\n      default:\n        return `Invalid input`;\n    }\n  };\n};\nfunction en_default2() {\n  return {\n    localeError: error7()\n  };\n}\n\n// ../../node_modules/zod/v4/locales/eo.js\nvar parsedType2 = data => {\n  const t = typeof data;\n  switch (t) {\n    case \"number\":\n      {\n        return Number.isNaN(data) ? \"NaN\" : \"nombro\";\n      }\n    case \"object\":\n      {\n        if (Array.isArray(data)) {\n          return \"tabelo\";\n        }\n        if (data === null) {\n          return \"senvalora\";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n  }\n  return t;\n};\nvar error8 = () => {\n  const Sizable = {\n    string: {\n      unit: \"karaktrojn\",\n      verb: \"havi\"\n    },\n    file: {\n      unit: \"bajtojn\",\n      verb: \"havi\"\n    },\n    array: {\n      unit: \"elementojn\",\n      verb: \"havi\"\n    },\n    set: {\n      unit: \"elementojn\",\n      verb: \"havi\"\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const Nouns = {\n    regex: \"enigo\",\n    email: \"retadreso\",\n    url: \"URL\",\n    emoji: \"emo\\u011Dio\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO-datotempo\",\n    date: \"ISO-dato\",\n    time: \"ISO-tempo\",\n    duration: \"ISO-da\\u016Dro\",\n    ipv4: \"IPv4-adreso\",\n    ipv6: \"IPv6-adreso\",\n    cidrv4: \"IPv4-rango\",\n    cidrv6: \"IPv6-rango\",\n    base64: \"64-ume kodita karaktraro\",\n    base64url: \"URL-64-ume kodita karaktraro\",\n    json_string: \"JSON-karaktraro\",\n    e164: \"E.164-nombro\",\n    jwt: \"JWT\",\n    template_literal: \"enigo\"\n  };\n  return issue2 => {\n    switch (issue2.code) {\n      case \"invalid_type\":\n        return `Nevalida enigo: atendi\\u011Dis ${issue2.expected}, ricevi\\u011Dis ${parsedType2(issue2.input)}`;\n      case \"invalid_value\":\n        if (issue2.values.length === 1) return `Nevalida enigo: atendi\\u011Dis ${stringifyPrimitive(issue2.values[0])}`;\n        return `Nevalida opcio: atendi\\u011Dis unu el ${joinValues(issue2.values, \"|\")}`;\n      case \"too_big\":\n        {\n          const adj = issue2.inclusive ? \"<=\" : \"<\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) return `Tro granda: atendi\\u011Dis ke ${issue2.origin ?? \"valoro\"} havu ${adj}${issue2.maximum.toString()} ${sizing.unit ?? \"elementojn\"}`;\n          return `Tro granda: atendi\\u011Dis ke ${issue2.origin ?? \"valoro\"} havu ${adj}${issue2.maximum.toString()}`;\n        }\n      case \"too_small\":\n        {\n          const adj = issue2.inclusive ? \">=\" : \">\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            return `Tro malgranda: atendi\\u011Dis ke ${issue2.origin} havu ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n          }\n          return `Tro malgranda: atendi\\u011Dis ke ${issue2.origin} estu ${adj}${issue2.minimum.toString()}`;\n        }\n      case \"invalid_format\":\n        {\n          const _issue = issue2;\n          if (_issue.format === \"starts_with\") return `Nevalida karaktraro: devas komenci\\u011Di per \"${_issue.prefix}\"`;\n          if (_issue.format === \"ends_with\") return `Nevalida karaktraro: devas fini\\u011Di per \"${_issue.suffix}\"`;\n          if (_issue.format === \"includes\") return `Nevalida karaktraro: devas inkluzivi \"${_issue.includes}\"`;\n          if (_issue.format === \"regex\") return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;\n          return `Nevalida ${Nouns[_issue.format] ?? issue2.format}`;\n        }\n      case \"not_multiple_of\":\n        return `Nevalida nombro: devas esti oblo de ${issue2.divisor}`;\n      case \"unrecognized_keys\":\n        return `Nekonata${issue2.keys.length > 1 ? \"j\" : \"\"} \\u015Dlosilo${issue2.keys.length > 1 ? \"j\" : \"\"}: ${joinValues(issue2.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Nevalida \\u015Dlosilo en ${issue2.origin}`;\n      case \"invalid_union\":\n        return \"Nevalida enigo\";\n      case \"invalid_element\":\n        return `Nevalida valoro en ${issue2.origin}`;\n      default:\n        return `Nevalida enigo`;\n    }\n  };\n};\nfunction eo_default() {\n  return {\n    localeError: error8()\n  };\n}\n\n// ../../node_modules/zod/v4/locales/es.js\nvar error9 = () => {\n  const Sizable = {\n    string: {\n      unit: \"caracteres\",\n      verb: \"tener\"\n    },\n    file: {\n      unit: \"bytes\",\n      verb: \"tener\"\n    },\n    array: {\n      unit: \"elementos\",\n      verb: \"tener\"\n    },\n    set: {\n      unit: \"elementos\",\n      verb: \"tener\"\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType4 = data => {\n    const t = typeof data;\n    switch (t) {\n      case \"number\":\n        {\n          return Number.isNaN(data) ? \"NaN\" : \"n\\xFAmero\";\n        }\n      case \"object\":\n        {\n          if (Array.isArray(data)) {\n            return \"arreglo\";\n          }\n          if (data === null) {\n            return \"nulo\";\n          }\n          if (Object.getPrototypeOf(data) !== Object.prototype) {\n            return data.constructor.name;\n          }\n        }\n    }\n    return t;\n  };\n  const Nouns = {\n    regex: \"entrada\",\n    email: \"direcci\\xF3n de correo electr\\xF3nico\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"fecha y hora ISO\",\n    date: \"fecha ISO\",\n    time: \"hora ISO\",\n    duration: \"duraci\\xF3n ISO\",\n    ipv4: \"direcci\\xF3n IPv4\",\n    ipv6: \"direcci\\xF3n IPv6\",\n    cidrv4: \"rango IPv4\",\n    cidrv6: \"rango IPv6\",\n    base64: \"cadena codificada en base64\",\n    base64url: \"URL codificada en base64\",\n    json_string: \"cadena JSON\",\n    e164: \"n\\xFAmero E.164\",\n    jwt: \"JWT\",\n    template_literal: \"entrada\"\n  };\n  return issue2 => {\n    switch (issue2.code) {\n      case \"invalid_type\":\n        return `Entrada inv\\xE1lida: se esperaba ${issue2.expected}, recibido ${parsedType4(issue2.input)}`;\n      // return `Entrada inválida: se esperaba ${issue.expected}, recibido ${util.getParsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue2.values.length === 1) return `Entrada inv\\xE1lida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;\n        return `Opci\\xF3n inv\\xE1lida: se esperaba una de ${joinValues(issue2.values, \"|\")}`;\n      case \"too_big\":\n        {\n          const adj = issue2.inclusive ? \"<=\" : \"<\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) return `Demasiado grande: se esperaba que ${issue2.origin ?? \"valor\"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? \"elementos\"}`;\n          return `Demasiado grande: se esperaba que ${issue2.origin ?? \"valor\"} fuera ${adj}${issue2.maximum.toString()}`;\n        }\n      case \"too_small\":\n        {\n          const adj = issue2.inclusive ? \">=\" : \">\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            return `Demasiado peque\\xF1o: se esperaba que ${issue2.origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n          }\n          return `Demasiado peque\\xF1o: se esperaba que ${issue2.origin} fuera ${adj}${issue2.minimum.toString()}`;\n        }\n      case \"invalid_format\":\n        {\n          const _issue = issue2;\n          if (_issue.format === \"starts_with\") return `Cadena inv\\xE1lida: debe comenzar con \"${_issue.prefix}\"`;\n          if (_issue.format === \"ends_with\") return `Cadena inv\\xE1lida: debe terminar en \"${_issue.suffix}\"`;\n          if (_issue.format === \"includes\") return `Cadena inv\\xE1lida: debe incluir \"${_issue.includes}\"`;\n          if (_issue.format === \"regex\") return `Cadena inv\\xE1lida: debe coincidir con el patr\\xF3n ${_issue.pattern}`;\n          return `Inv\\xE1lido ${Nouns[_issue.format] ?? issue2.format}`;\n        }\n      case \"not_multiple_of\":\n        return `N\\xFAmero inv\\xE1lido: debe ser m\\xFAltiplo de ${issue2.divisor}`;\n      case \"unrecognized_keys\":\n        return `Llave${issue2.keys.length > 1 ? \"s\" : \"\"} desconocida${issue2.keys.length > 1 ? \"s\" : \"\"}: ${joinValues(issue2.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Llave inv\\xE1lida en ${issue2.origin}`;\n      case \"invalid_union\":\n        return \"Entrada inv\\xE1lida\";\n      case \"invalid_element\":\n        return `Valor inv\\xE1lido en ${issue2.origin}`;\n      default:\n        return `Entrada inv\\xE1lida`;\n    }\n  };\n};\nfunction es_default() {\n  return {\n    localeError: error9()\n  };\n}\n\n// ../../node_modules/zod/v4/locales/fa.js\nvar error10 = () => {\n  const Sizable = {\n    string: {\n      unit: \"\\u06A9\\u0627\\u0631\\u0627\\u06A9\\u062A\\u0631\",\n      verb: \"\\u062F\\u0627\\u0634\\u062A\\u0647 \\u0628\\u0627\\u0634\\u062F\"\n    },\n    file: {\n      unit: \"\\u0628\\u0627\\u06CC\\u062A\",\n      verb: \"\\u062F\\u0627\\u0634\\u062A\\u0647 \\u0628\\u0627\\u0634\\u062F\"\n    },\n    array: {\n      unit: \"\\u0622\\u06CC\\u062A\\u0645\",\n      verb: \"\\u062F\\u0627\\u0634\\u062A\\u0647 \\u0628\\u0627\\u0634\\u062F\"\n    },\n    set: {\n      unit: \"\\u0622\\u06CC\\u062A\\u0645\",\n      verb: \"\\u062F\\u0627\\u0634\\u062A\\u0647 \\u0628\\u0627\\u0634\\u062F\"\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType4 = data => {\n    const t = typeof data;\n    switch (t) {\n      case \"number\":\n        {\n          return Number.isNaN(data) ? \"NaN\" : \"\\u0639\\u062F\\u062F\";\n        }\n      case \"object\":\n        {\n          if (Array.isArray(data)) {\n            return \"\\u0622\\u0631\\u0627\\u06CC\\u0647\";\n          }\n          if (data === null) {\n            return \"null\";\n          }\n          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n            return data.constructor.name;\n          }\n        }\n    }\n    return t;\n  };\n  const Nouns = {\n    regex: \"\\u0648\\u0631\\u0648\\u062F\\u06CC\",\n    email: \"\\u0622\\u062F\\u0631\\u0633 \\u0627\\u06CC\\u0645\\u06CC\\u0644\",\n    url: \"URL\",\n    emoji: \"\\u0627\\u06CC\\u0645\\u0648\\u062C\\u06CC\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"\\u062A\\u0627\\u0631\\u06CC\\u062E \\u0648 \\u0632\\u0645\\u0627\\u0646 \\u0627\\u06CC\\u0632\\u0648\",\n    date: \"\\u062A\\u0627\\u0631\\u06CC\\u062E \\u0627\\u06CC\\u0632\\u0648\",\n    time: \"\\u0632\\u0645\\u0627\\u0646 \\u0627\\u06CC\\u0632\\u0648\",\n    duration: \"\\u0645\\u062F\\u062A \\u0632\\u0645\\u0627\\u0646 \\u0627\\u06CC\\u0632\\u0648\",\n    ipv4: \"IPv4 \\u0622\\u062F\\u0631\\u0633\",\n    ipv6: \"IPv6 \\u0622\\u062F\\u0631\\u0633\",\n    cidrv4: \"IPv4 \\u062F\\u0627\\u0645\\u0646\\u0647\",\n    cidrv6: \"IPv6 \\u062F\\u0627\\u0645\\u0646\\u0647\",\n    base64: \"base64-encoded \\u0631\\u0634\\u062A\\u0647\",\n    base64url: \"base64url-encoded \\u0631\\u0634\\u062A\\u0647\",\n    json_string: \"JSON \\u0631\\u0634\\u062A\\u0647\",\n    e164: \"E.164 \\u0639\\u062F\\u062F\",\n    jwt: \"JWT\",\n    template_literal: \"\\u0648\\u0631\\u0648\\u062F\\u06CC\"\n  };\n  return issue2 => {\n    switch (issue2.code) {\n      case \"invalid_type\":\n        return `\\u0648\\u0631\\u0648\\u062F\\u06CC \\u0646\\u0627\\u0645\\u0639\\u062A\\u0628\\u0631: \\u0645\\u06CC\\u200C\\u0628\\u0627\\u06CC\\u0633\\u062A ${issue2.expected} \\u0645\\u06CC\\u200C\\u0628\\u0648\\u062F\\u060C ${parsedType4(issue2.input)} \\u062F\\u0631\\u06CC\\u0627\\u0641\\u062A \\u0634\\u062F`;\n      case \"invalid_value\":\n        if (issue2.values.length === 1) {\n          return `\\u0648\\u0631\\u0648\\u062F\\u06CC \\u0646\\u0627\\u0645\\u0639\\u062A\\u0628\\u0631: \\u0645\\u06CC\\u200C\\u0628\\u0627\\u06CC\\u0633\\u062A ${stringifyPrimitive(issue2.values[0])} \\u0645\\u06CC\\u200C\\u0628\\u0648\\u062F`;\n        }\n        return `\\u06AF\\u0632\\u06CC\\u0646\\u0647 \\u0646\\u0627\\u0645\\u0639\\u062A\\u0628\\u0631: \\u0645\\u06CC\\u200C\\u0628\\u0627\\u06CC\\u0633\\u062A \\u06CC\\u06A9\\u06CC \\u0627\\u0632 ${joinValues(issue2.values, \"|\")} \\u0645\\u06CC\\u200C\\u0628\\u0648\\u062F`;\n      case \"too_big\":\n        {\n          const adj = issue2.inclusive ? \"<=\" : \"<\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            return `\\u062E\\u06CC\\u0644\\u06CC \\u0628\\u0632\\u0631\\u06AF: ${issue2.origin ?? \"\\u0645\\u0642\\u062F\\u0627\\u0631\"} \\u0628\\u0627\\u06CC\\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? \"\\u0639\\u0646\\u0635\\u0631\"} \\u0628\\u0627\\u0634\\u062F`;\n          }\n          return `\\u062E\\u06CC\\u0644\\u06CC \\u0628\\u0632\\u0631\\u06AF: ${issue2.origin ?? \"\\u0645\\u0642\\u062F\\u0627\\u0631\"} \\u0628\\u0627\\u06CC\\u062F ${adj}${issue2.maximum.toString()} \\u0628\\u0627\\u0634\\u062F`;\n        }\n      case \"too_small\":\n        {\n          const adj = issue2.inclusive ? \">=\" : \">\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            return `\\u062E\\u06CC\\u0644\\u06CC \\u06A9\\u0648\\u0686\\u06A9: ${issue2.origin} \\u0628\\u0627\\u06CC\\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \\u0628\\u0627\\u0634\\u062F`;\n          }\n          return `\\u062E\\u06CC\\u0644\\u06CC \\u06A9\\u0648\\u0686\\u06A9: ${issue2.origin} \\u0628\\u0627\\u06CC\\u062F ${adj}${issue2.minimum.toString()} \\u0628\\u0627\\u0634\\u062F`;\n        }\n      case \"invalid_format\":\n        {\n          const _issue = issue2;\n          if (_issue.format === \"starts_with\") {\n            return `\\u0631\\u0634\\u062A\\u0647 \\u0646\\u0627\\u0645\\u0639\\u062A\\u0628\\u0631: \\u0628\\u0627\\u06CC\\u062F \\u0628\\u0627 \"${_issue.prefix}\" \\u0634\\u0631\\u0648\\u0639 \\u0634\\u0648\\u062F`;\n          }\n          if (_issue.format === \"ends_with\") {\n            return `\\u0631\\u0634\\u062A\\u0647 \\u0646\\u0627\\u0645\\u0639\\u062A\\u0628\\u0631: \\u0628\\u0627\\u06CC\\u062F \\u0628\\u0627 \"${_issue.suffix}\" \\u062A\\u0645\\u0627\\u0645 \\u0634\\u0648\\u062F`;\n          }\n          if (_issue.format === \"includes\") {\n            return `\\u0631\\u0634\\u062A\\u0647 \\u0646\\u0627\\u0645\\u0639\\u062A\\u0628\\u0631: \\u0628\\u0627\\u06CC\\u062F \\u0634\\u0627\\u0645\\u0644 \"${_issue.includes}\" \\u0628\\u0627\\u0634\\u062F`;\n          }\n          if (_issue.format === \"regex\") {\n            return `\\u0631\\u0634\\u062A\\u0647 \\u0646\\u0627\\u0645\\u0639\\u062A\\u0628\\u0631: \\u0628\\u0627\\u06CC\\u062F \\u0628\\u0627 \\u0627\\u0644\\u06AF\\u0648\\u06CC ${_issue.pattern} \\u0645\\u0637\\u0627\\u0628\\u0642\\u062A \\u062F\\u0627\\u0634\\u062A\\u0647 \\u0628\\u0627\\u0634\\u062F`;\n          }\n          return `${Nouns[_issue.format] ?? issue2.format} \\u0646\\u0627\\u0645\\u0639\\u062A\\u0628\\u0631`;\n        }\n      case \"not_multiple_of\":\n        return `\\u0639\\u062F\\u062F \\u0646\\u0627\\u0645\\u0639\\u062A\\u0628\\u0631: \\u0628\\u0627\\u06CC\\u062F \\u0645\\u0636\\u0631\\u0628 ${issue2.divisor} \\u0628\\u0627\\u0634\\u062F`;\n      case \"unrecognized_keys\":\n        return `\\u06A9\\u0644\\u06CC\\u062F${issue2.keys.length > 1 ? \"\\u0647\\u0627\\u06CC\" : \"\"} \\u0646\\u0627\\u0634\\u0646\\u0627\\u0633: ${joinValues(issue2.keys, \", \")}`;\n      case \"invalid_key\":\n        return `\\u06A9\\u0644\\u06CC\\u062F \\u0646\\u0627\\u0634\\u0646\\u0627\\u0633 \\u062F\\u0631 ${issue2.origin}`;\n      case \"invalid_union\":\n        return `\\u0648\\u0631\\u0648\\u062F\\u06CC \\u0646\\u0627\\u0645\\u0639\\u062A\\u0628\\u0631`;\n      case \"invalid_element\":\n        return `\\u0645\\u0642\\u062F\\u0627\\u0631 \\u0646\\u0627\\u0645\\u0639\\u062A\\u0628\\u0631 \\u062F\\u0631 ${issue2.origin}`;\n      default:\n        return `\\u0648\\u0631\\u0648\\u062F\\u06CC \\u0646\\u0627\\u0645\\u0639\\u062A\\u0628\\u0631`;\n    }\n  };\n};\nfunction fa_default() {\n  return {\n    localeError: error10()\n  };\n}\n\n// ../../node_modules/zod/v4/locales/fi.js\nvar error11 = () => {\n  const Sizable = {\n    string: {\n      unit: \"merkki\\xE4\",\n      subject: \"merkkijonon\"\n    },\n    file: {\n      unit: \"tavua\",\n      subject: \"tiedoston\"\n    },\n    array: {\n      unit: \"alkiota\",\n      subject: \"listan\"\n    },\n    set: {\n      unit: \"alkiota\",\n      subject: \"joukon\"\n    },\n    number: {\n      unit: \"\",\n      subject: \"luvun\"\n    },\n    bigint: {\n      unit: \"\",\n      subject: \"suuren kokonaisluvun\"\n    },\n    int: {\n      unit: \"\",\n      subject: \"kokonaisluvun\"\n    },\n    date: {\n      unit: \"\",\n      subject: \"p\\xE4iv\\xE4m\\xE4\\xE4r\\xE4n\"\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType4 = data => {\n    const t = typeof data;\n    switch (t) {\n      case \"number\":\n        {\n          return Number.isNaN(data) ? \"NaN\" : \"number\";\n        }\n      case \"object\":\n        {\n          if (Array.isArray(data)) {\n            return \"array\";\n          }\n          if (data === null) {\n            return \"null\";\n          }\n          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n            return data.constructor.name;\n          }\n        }\n    }\n    return t;\n  };\n  const Nouns = {\n    regex: \"s\\xE4\\xE4nn\\xF6llinen lauseke\",\n    email: \"s\\xE4hk\\xF6postiosoite\",\n    url: \"URL-osoite\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO-aikaleima\",\n    date: \"ISO-p\\xE4iv\\xE4m\\xE4\\xE4r\\xE4\",\n    time: \"ISO-aika\",\n    duration: \"ISO-kesto\",\n    ipv4: \"IPv4-osoite\",\n    ipv6: \"IPv6-osoite\",\n    cidrv4: \"IPv4-alue\",\n    cidrv6: \"IPv6-alue\",\n    base64: \"base64-koodattu merkkijono\",\n    base64url: \"base64url-koodattu merkkijono\",\n    json_string: \"JSON-merkkijono\",\n    e164: \"E.164-luku\",\n    jwt: \"JWT\",\n    template_literal: \"templaattimerkkijono\"\n  };\n  return issue2 => {\n    switch (issue2.code) {\n      case \"invalid_type\":\n        return `Virheellinen tyyppi: odotettiin ${issue2.expected}, oli ${parsedType4(issue2.input)}`;\n      case \"invalid_value\":\n        if (issue2.values.length === 1) return `Virheellinen sy\\xF6te: t\\xE4ytyy olla ${stringifyPrimitive(issue2.values[0])}`;\n        return `Virheellinen valinta: t\\xE4ytyy olla yksi seuraavista: ${joinValues(issue2.values, \"|\")}`;\n      case \"too_big\":\n        {\n          const adj = issue2.inclusive ? \"<=\" : \"<\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            return `Liian suuri: ${sizing.subject} t\\xE4ytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();\n          }\n          return `Liian suuri: arvon t\\xE4ytyy olla ${adj}${issue2.maximum.toString()}`;\n        }\n      case \"too_small\":\n        {\n          const adj = issue2.inclusive ? \">=\" : \">\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            return `Liian pieni: ${sizing.subject} t\\xE4ytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();\n          }\n          return `Liian pieni: arvon t\\xE4ytyy olla ${adj}${issue2.minimum.toString()}`;\n        }\n      case \"invalid_format\":\n        {\n          const _issue = issue2;\n          if (_issue.format === \"starts_with\") return `Virheellinen sy\\xF6te: t\\xE4ytyy alkaa \"${_issue.prefix}\"`;\n          if (_issue.format === \"ends_with\") return `Virheellinen sy\\xF6te: t\\xE4ytyy loppua \"${_issue.suffix}\"`;\n          if (_issue.format === \"includes\") return `Virheellinen sy\\xF6te: t\\xE4ytyy sis\\xE4lt\\xE4\\xE4 \"${_issue.includes}\"`;\n          if (_issue.format === \"regex\") {\n            return `Virheellinen sy\\xF6te: t\\xE4ytyy vastata s\\xE4\\xE4nn\\xF6llist\\xE4 lauseketta ${_issue.pattern}`;\n          }\n          return `Virheellinen ${Nouns[_issue.format] ?? issue2.format}`;\n        }\n      case \"not_multiple_of\":\n        return `Virheellinen luku: t\\xE4ytyy olla luvun ${issue2.divisor} monikerta`;\n      case \"unrecognized_keys\":\n        return `${issue2.keys.length > 1 ? \"Tuntemattomat avaimet\" : \"Tuntematon avain\"}: ${joinValues(issue2.keys, \", \")}`;\n      case \"invalid_key\":\n        return \"Virheellinen avain tietueessa\";\n      case \"invalid_union\":\n        return \"Virheellinen unioni\";\n      case \"invalid_element\":\n        return \"Virheellinen arvo joukossa\";\n      default:\n        return `Virheellinen sy\\xF6te`;\n    }\n  };\n};\nfunction fi_default() {\n  return {\n    localeError: error11()\n  };\n}\n\n// ../../node_modules/zod/v4/locales/fr.js\nvar error12 = () => {\n  const Sizable = {\n    string: {\n      unit: \"caract\\xE8res\",\n      verb: \"avoir\"\n    },\n    file: {\n      unit: \"octets\",\n      verb: \"avoir\"\n    },\n    array: {\n      unit: \"\\xE9l\\xE9ments\",\n      verb: \"avoir\"\n    },\n    set: {\n      unit: \"\\xE9l\\xE9ments\",\n      verb: \"avoir\"\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType4 = data => {\n    const t = typeof data;\n    switch (t) {\n      case \"number\":\n        {\n          return Number.isNaN(data) ? \"NaN\" : \"nombre\";\n        }\n      case \"object\":\n        {\n          if (Array.isArray(data)) {\n            return \"tableau\";\n          }\n          if (data === null) {\n            return \"null\";\n          }\n          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n            return data.constructor.name;\n          }\n        }\n    }\n    return t;\n  };\n  const Nouns = {\n    regex: \"entr\\xE9e\",\n    email: \"adresse e-mail\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"date et heure ISO\",\n    date: \"date ISO\",\n    time: \"heure ISO\",\n    duration: \"dur\\xE9e ISO\",\n    ipv4: \"adresse IPv4\",\n    ipv6: \"adresse IPv6\",\n    cidrv4: \"plage IPv4\",\n    cidrv6: \"plage IPv6\",\n    base64: \"cha\\xEEne encod\\xE9e en base64\",\n    base64url: \"cha\\xEEne encod\\xE9e en base64url\",\n    json_string: \"cha\\xEEne JSON\",\n    e164: \"num\\xE9ro E.164\",\n    jwt: \"JWT\",\n    template_literal: \"entr\\xE9e\"\n  };\n  return issue2 => {\n    switch (issue2.code) {\n      case \"invalid_type\":\n        return `Entr\\xE9e invalide : ${issue2.expected} attendu, ${parsedType4(issue2.input)} re\\xE7u`;\n      case \"invalid_value\":\n        if (issue2.values.length === 1) return `Entr\\xE9e invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;\n        return `Option invalide : une valeur parmi ${joinValues(issue2.values, \"|\")} attendue`;\n      case \"too_big\":\n        {\n          const adj = issue2.inclusive ? \"<=\" : \"<\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) return `Trop grand : ${issue2.origin ?? \"valeur\"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? \"\\xE9l\\xE9ment(s)\"}`;\n          return `Trop grand : ${issue2.origin ?? \"valeur\"} doit \\xEAtre ${adj}${issue2.maximum.toString()}`;\n        }\n      case \"too_small\":\n        {\n          const adj = issue2.inclusive ? \">=\" : \">\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n          }\n          return `Trop petit : ${issue2.origin} doit \\xEAtre ${adj}${issue2.minimum.toString()}`;\n        }\n      case \"invalid_format\":\n        {\n          const _issue = issue2;\n          if (_issue.format === \"starts_with\") return `Cha\\xEEne invalide : doit commencer par \"${_issue.prefix}\"`;\n          if (_issue.format === \"ends_with\") return `Cha\\xEEne invalide : doit se terminer par \"${_issue.suffix}\"`;\n          if (_issue.format === \"includes\") return `Cha\\xEEne invalide : doit inclure \"${_issue.includes}\"`;\n          if (_issue.format === \"regex\") return `Cha\\xEEne invalide : doit correspondre au mod\\xE8le ${_issue.pattern}`;\n          return `${Nouns[_issue.format] ?? issue2.format} invalide`;\n        }\n      case \"not_multiple_of\":\n        return `Nombre invalide : doit \\xEAtre un multiple de ${issue2.divisor}`;\n      case \"unrecognized_keys\":\n        return `Cl\\xE9${issue2.keys.length > 1 ? \"s\" : \"\"} non reconnue${issue2.keys.length > 1 ? \"s\" : \"\"} : ${joinValues(issue2.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Cl\\xE9 invalide dans ${issue2.origin}`;\n      case \"invalid_union\":\n        return \"Entr\\xE9e invalide\";\n      case \"invalid_element\":\n        return `Valeur invalide dans ${issue2.origin}`;\n      default:\n        return `Entr\\xE9e invalide`;\n    }\n  };\n};\nfunction fr_default() {\n  return {\n    localeError: error12()\n  };\n}\n\n// ../../node_modules/zod/v4/locales/fr-CA.js\nvar error13 = () => {\n  const Sizable = {\n    string: {\n      unit: \"caract\\xE8res\",\n      verb: \"avoir\"\n    },\n    file: {\n      unit: \"octets\",\n      verb: \"avoir\"\n    },\n    array: {\n      unit: \"\\xE9l\\xE9ments\",\n      verb: \"avoir\"\n    },\n    set: {\n      unit: \"\\xE9l\\xE9ments\",\n      verb: \"avoir\"\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType4 = data => {\n    const t = typeof data;\n    switch (t) {\n      case \"number\":\n        {\n          return Number.isNaN(data) ? \"NaN\" : \"number\";\n        }\n      case \"object\":\n        {\n          if (Array.isArray(data)) {\n            return \"array\";\n          }\n          if (data === null) {\n            return \"null\";\n          }\n          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n            return data.constructor.name;\n          }\n        }\n    }\n    return t;\n  };\n  const Nouns = {\n    regex: \"entr\\xE9e\",\n    email: \"adresse courriel\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"date-heure ISO\",\n    date: \"date ISO\",\n    time: \"heure ISO\",\n    duration: \"dur\\xE9e ISO\",\n    ipv4: \"adresse IPv4\",\n    ipv6: \"adresse IPv6\",\n    cidrv4: \"plage IPv4\",\n    cidrv6: \"plage IPv6\",\n    base64: \"cha\\xEEne encod\\xE9e en base64\",\n    base64url: \"cha\\xEEne encod\\xE9e en base64url\",\n    json_string: \"cha\\xEEne JSON\",\n    e164: \"num\\xE9ro E.164\",\n    jwt: \"JWT\",\n    template_literal: \"entr\\xE9e\"\n  };\n  return issue2 => {\n    switch (issue2.code) {\n      case \"invalid_type\":\n        return `Entr\\xE9e invalide : attendu ${issue2.expected}, re\\xE7u ${parsedType4(issue2.input)}`;\n      case \"invalid_value\":\n        if (issue2.values.length === 1) return `Entr\\xE9e invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;\n        return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue2.values, \"|\")}`;\n      case \"too_big\":\n        {\n          const adj = issue2.inclusive ? \"\\u2264\" : \"<\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) return `Trop grand : attendu que ${issue2.origin ?? \"la valeur\"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;\n          return `Trop grand : attendu que ${issue2.origin ?? \"la valeur\"} soit ${adj}${issue2.maximum.toString()}`;\n        }\n      case \"too_small\":\n        {\n          const adj = issue2.inclusive ? \"\\u2265\" : \">\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n          }\n          return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;\n        }\n      case \"invalid_format\":\n        {\n          const _issue = issue2;\n          if (_issue.format === \"starts_with\") {\n            return `Cha\\xEEne invalide : doit commencer par \"${_issue.prefix}\"`;\n          }\n          if (_issue.format === \"ends_with\") return `Cha\\xEEne invalide : doit se terminer par \"${_issue.suffix}\"`;\n          if (_issue.format === \"includes\") return `Cha\\xEEne invalide : doit inclure \"${_issue.includes}\"`;\n          if (_issue.format === \"regex\") return `Cha\\xEEne invalide : doit correspondre au motif ${_issue.pattern}`;\n          return `${Nouns[_issue.format] ?? issue2.format} invalide`;\n        }\n      case \"not_multiple_of\":\n        return `Nombre invalide : doit \\xEAtre un multiple de ${issue2.divisor}`;\n      case \"unrecognized_keys\":\n        return `Cl\\xE9${issue2.keys.length > 1 ? \"s\" : \"\"} non reconnue${issue2.keys.length > 1 ? \"s\" : \"\"} : ${joinValues(issue2.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Cl\\xE9 invalide dans ${issue2.origin}`;\n      case \"invalid_union\":\n        return \"Entr\\xE9e invalide\";\n      case \"invalid_element\":\n        return `Valeur invalide dans ${issue2.origin}`;\n      default:\n        return `Entr\\xE9e invalide`;\n    }\n  };\n};\nfunction fr_CA_default() {\n  return {\n    localeError: error13()\n  };\n}\n\n// ../../node_modules/zod/v4/locales/he.js\nvar error14 = () => {\n  const Sizable = {\n    string: {\n      unit: \"\\u05D0\\u05D5\\u05EA\\u05D9\\u05D5\\u05EA\",\n      verb: \"\\u05DC\\u05DB\\u05DC\\u05D5\\u05DC\"\n    },\n    file: {\n      unit: \"\\u05D1\\u05D9\\u05D9\\u05D8\\u05D9\\u05DD\",\n      verb: \"\\u05DC\\u05DB\\u05DC\\u05D5\\u05DC\"\n    },\n    array: {\n      unit: \"\\u05E4\\u05E8\\u05D9\\u05D8\\u05D9\\u05DD\",\n      verb: \"\\u05DC\\u05DB\\u05DC\\u05D5\\u05DC\"\n    },\n    set: {\n      unit: \"\\u05E4\\u05E8\\u05D9\\u05D8\\u05D9\\u05DD\",\n      verb: \"\\u05DC\\u05DB\\u05DC\\u05D5\\u05DC\"\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType4 = data => {\n    const t = typeof data;\n    switch (t) {\n      case \"number\":\n        {\n          return Number.isNaN(data) ? \"NaN\" : \"number\";\n        }\n      case \"object\":\n        {\n          if (Array.isArray(data)) {\n            return \"array\";\n          }\n          if (data === null) {\n            return \"null\";\n          }\n          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n            return data.constructor.name;\n          }\n        }\n    }\n    return t;\n  };\n  const Nouns = {\n    regex: \"\\u05E7\\u05DC\\u05D8\",\n    email: \"\\u05DB\\u05EA\\u05D5\\u05D1\\u05EA \\u05D0\\u05D9\\u05DE\\u05D9\\u05D9\\u05DC\",\n    url: \"\\u05DB\\u05EA\\u05D5\\u05D1\\u05EA \\u05E8\\u05E9\\u05EA\",\n    emoji: \"\\u05D0\\u05D9\\u05DE\\u05D5\\u05D2'\\u05D9\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"\\u05EA\\u05D0\\u05E8\\u05D9\\u05DA \\u05D5\\u05D6\\u05DE\\u05DF ISO\",\n    date: \"\\u05EA\\u05D0\\u05E8\\u05D9\\u05DA ISO\",\n    time: \"\\u05D6\\u05DE\\u05DF ISO\",\n    duration: \"\\u05DE\\u05E9\\u05DA \\u05D6\\u05DE\\u05DF ISO\",\n    ipv4: \"\\u05DB\\u05EA\\u05D5\\u05D1\\u05EA IPv4\",\n    ipv6: \"\\u05DB\\u05EA\\u05D5\\u05D1\\u05EA IPv6\",\n    cidrv4: \"\\u05D8\\u05D5\\u05D5\\u05D7 IPv4\",\n    cidrv6: \"\\u05D8\\u05D5\\u05D5\\u05D7 IPv6\",\n    base64: \"\\u05DE\\u05D7\\u05E8\\u05D5\\u05D6\\u05EA \\u05D1\\u05D1\\u05E1\\u05D9\\u05E1 64\",\n    base64url: \"\\u05DE\\u05D7\\u05E8\\u05D5\\u05D6\\u05EA \\u05D1\\u05D1\\u05E1\\u05D9\\u05E1 64 \\u05DC\\u05DB\\u05EA\\u05D5\\u05D1\\u05D5\\u05EA \\u05E8\\u05E9\\u05EA\",\n    json_string: \"\\u05DE\\u05D7\\u05E8\\u05D5\\u05D6\\u05EA JSON\",\n    e164: \"\\u05DE\\u05E1\\u05E4\\u05E8 E.164\",\n    jwt: \"JWT\",\n    template_literal: \"\\u05E7\\u05DC\\u05D8\"\n  };\n  return issue2 => {\n    switch (issue2.code) {\n      case \"invalid_type\":\n        return `\\u05E7\\u05DC\\u05D8 \\u05DC\\u05D0 \\u05EA\\u05E7\\u05D9\\u05DF: \\u05E6\\u05E8\\u05D9\\u05DA ${issue2.expected}, \\u05D4\\u05EA\\u05E7\\u05D1\\u05DC ${parsedType4(issue2.input)}`;\n      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue2.values.length === 1) return `\\u05E7\\u05DC\\u05D8 \\u05DC\\u05D0 \\u05EA\\u05E7\\u05D9\\u05DF: \\u05E6\\u05E8\\u05D9\\u05DA ${stringifyPrimitive(issue2.values[0])}`;\n        return `\\u05E7\\u05DC\\u05D8 \\u05DC\\u05D0 \\u05EA\\u05E7\\u05D9\\u05DF: \\u05E6\\u05E8\\u05D9\\u05DA \\u05D0\\u05D7\\u05EA \\u05DE\\u05D4\\u05D0\\u05E4\\u05E9\\u05E8\\u05D5\\u05D9\\u05D5\\u05EA  ${joinValues(issue2.values, \"|\")}`;\n      case \"too_big\":\n        {\n          const adj = issue2.inclusive ? \"<=\" : \"<\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) return `\\u05D2\\u05D3\\u05D5\\u05DC \\u05DE\\u05D3\\u05D9: ${issue2.origin ?? \"value\"} \\u05E6\\u05E8\\u05D9\\u05DA \\u05DC\\u05D4\\u05D9\\u05D5\\u05EA ${adj}${issue2.maximum.toString()} ${sizing.unit ?? \"elements\"}`;\n          return `\\u05D2\\u05D3\\u05D5\\u05DC \\u05DE\\u05D3\\u05D9: ${issue2.origin ?? \"value\"} \\u05E6\\u05E8\\u05D9\\u05DA \\u05DC\\u05D4\\u05D9\\u05D5\\u05EA ${adj}${issue2.maximum.toString()}`;\n        }\n      case \"too_small\":\n        {\n          const adj = issue2.inclusive ? \">=\" : \">\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            return `\\u05E7\\u05D8\\u05DF \\u05DE\\u05D3\\u05D9: ${issue2.origin} \\u05E6\\u05E8\\u05D9\\u05DA \\u05DC\\u05D4\\u05D9\\u05D5\\u05EA ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n          }\n          return `\\u05E7\\u05D8\\u05DF \\u05DE\\u05D3\\u05D9: ${issue2.origin} \\u05E6\\u05E8\\u05D9\\u05DA \\u05DC\\u05D4\\u05D9\\u05D5\\u05EA ${adj}${issue2.minimum.toString()}`;\n        }\n      case \"invalid_format\":\n        {\n          const _issue = issue2;\n          if (_issue.format === \"starts_with\") return `\\u05DE\\u05D7\\u05E8\\u05D5\\u05D6\\u05EA \\u05DC\\u05D0 \\u05EA\\u05E7\\u05D9\\u05E0\\u05D4: \\u05D7\\u05D9\\u05D9\\u05D1\\u05EA \\u05DC\\u05D4\\u05EA\\u05D7\\u05D9\\u05DC \\u05D1\"${_issue.prefix}\"`;\n          if (_issue.format === \"ends_with\") return `\\u05DE\\u05D7\\u05E8\\u05D5\\u05D6\\u05EA \\u05DC\\u05D0 \\u05EA\\u05E7\\u05D9\\u05E0\\u05D4: \\u05D7\\u05D9\\u05D9\\u05D1\\u05EA \\u05DC\\u05D4\\u05E1\\u05EA\\u05D9\\u05D9\\u05DD \\u05D1 \"${_issue.suffix}\"`;\n          if (_issue.format === \"includes\") return `\\u05DE\\u05D7\\u05E8\\u05D5\\u05D6\\u05EA \\u05DC\\u05D0 \\u05EA\\u05E7\\u05D9\\u05E0\\u05D4: \\u05D7\\u05D9\\u05D9\\u05D1\\u05EA \\u05DC\\u05DB\\u05DC\\u05D5\\u05DC \"${_issue.includes}\"`;\n          if (_issue.format === \"regex\") return `\\u05DE\\u05D7\\u05E8\\u05D5\\u05D6\\u05EA \\u05DC\\u05D0 \\u05EA\\u05E7\\u05D9\\u05E0\\u05D4: \\u05D7\\u05D9\\u05D9\\u05D1\\u05EA \\u05DC\\u05D4\\u05EA\\u05D0\\u05D9\\u05DD \\u05DC\\u05EA\\u05D1\\u05E0\\u05D9\\u05EA ${_issue.pattern}`;\n          return `${Nouns[_issue.format] ?? issue2.format} \\u05DC\\u05D0 \\u05EA\\u05E7\\u05D9\\u05DF`;\n        }\n      case \"not_multiple_of\":\n        return `\\u05DE\\u05E1\\u05E4\\u05E8 \\u05DC\\u05D0 \\u05EA\\u05E7\\u05D9\\u05DF: \\u05D7\\u05D9\\u05D9\\u05D1 \\u05DC\\u05D4\\u05D9\\u05D5\\u05EA \\u05DE\\u05DB\\u05E4\\u05DC\\u05D4 \\u05E9\\u05DC ${issue2.divisor}`;\n      case \"unrecognized_keys\":\n        return `\\u05DE\\u05E4\\u05EA\\u05D7${issue2.keys.length > 1 ? \"\\u05D5\\u05EA\" : \"\"} \\u05DC\\u05D0 \\u05DE\\u05D6\\u05D5\\u05D4${issue2.keys.length > 1 ? \"\\u05D9\\u05DD\" : \"\\u05D4\"}: ${joinValues(issue2.keys, \", \")}`;\n      case \"invalid_key\":\n        return `\\u05DE\\u05E4\\u05EA\\u05D7 \\u05DC\\u05D0 \\u05EA\\u05E7\\u05D9\\u05DF \\u05D1${issue2.origin}`;\n      case \"invalid_union\":\n        return \"\\u05E7\\u05DC\\u05D8 \\u05DC\\u05D0 \\u05EA\\u05E7\\u05D9\\u05DF\";\n      case \"invalid_element\":\n        return `\\u05E2\\u05E8\\u05DA \\u05DC\\u05D0 \\u05EA\\u05E7\\u05D9\\u05DF \\u05D1${issue2.origin}`;\n      default:\n        return `\\u05E7\\u05DC\\u05D8 \\u05DC\\u05D0 \\u05EA\\u05E7\\u05D9\\u05DF`;\n    }\n  };\n};\nfunction he_default() {\n  return {\n    localeError: error14()\n  };\n}\n\n// ../../node_modules/zod/v4/locales/hu.js\nvar error15 = () => {\n  const Sizable = {\n    string: {\n      unit: \"karakter\",\n      verb: \"legyen\"\n    },\n    file: {\n      unit: \"byte\",\n      verb: \"legyen\"\n    },\n    array: {\n      unit: \"elem\",\n      verb: \"legyen\"\n    },\n    set: {\n      unit: \"elem\",\n      verb: \"legyen\"\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType4 = data => {\n    const t = typeof data;\n    switch (t) {\n      case \"number\":\n        {\n          return Number.isNaN(data) ? \"NaN\" : \"sz\\xE1m\";\n        }\n      case \"object\":\n        {\n          if (Array.isArray(data)) {\n            return \"t\\xF6mb\";\n          }\n          if (data === null) {\n            return \"null\";\n          }\n          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n            return data.constructor.name;\n          }\n        }\n    }\n    return t;\n  };\n  const Nouns = {\n    regex: \"bemenet\",\n    email: \"email c\\xEDm\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO id\\u0151b\\xE9lyeg\",\n    date: \"ISO d\\xE1tum\",\n    time: \"ISO id\\u0151\",\n    duration: \"ISO id\\u0151intervallum\",\n    ipv4: \"IPv4 c\\xEDm\",\n    ipv6: \"IPv6 c\\xEDm\",\n    cidrv4: \"IPv4 tartom\\xE1ny\",\n    cidrv6: \"IPv6 tartom\\xE1ny\",\n    base64: \"base64-k\\xF3dolt string\",\n    base64url: \"base64url-k\\xF3dolt string\",\n    json_string: \"JSON string\",\n    e164: \"E.164 sz\\xE1m\",\n    jwt: \"JWT\",\n    template_literal: \"bemenet\"\n  };\n  return issue2 => {\n    switch (issue2.code) {\n      case \"invalid_type\":\n        return `\\xC9rv\\xE9nytelen bemenet: a v\\xE1rt \\xE9rt\\xE9k ${issue2.expected}, a kapott \\xE9rt\\xE9k ${parsedType4(issue2.input)}`;\n      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue2.values.length === 1) return `\\xC9rv\\xE9nytelen bemenet: a v\\xE1rt \\xE9rt\\xE9k ${stringifyPrimitive(issue2.values[0])}`;\n        return `\\xC9rv\\xE9nytelen opci\\xF3: valamelyik \\xE9rt\\xE9k v\\xE1rt ${joinValues(issue2.values, \"|\")}`;\n      case \"too_big\":\n        {\n          const adj = issue2.inclusive ? \"<=\" : \"<\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) return `T\\xFAl nagy: ${issue2.origin ?? \"\\xE9rt\\xE9k\"} m\\xE9rete t\\xFAl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? \"elem\"}`;\n          return `T\\xFAl nagy: a bemeneti \\xE9rt\\xE9k ${issue2.origin ?? \"\\xE9rt\\xE9k\"} t\\xFAl nagy: ${adj}${issue2.maximum.toString()}`;\n        }\n      case \"too_small\":\n        {\n          const adj = issue2.inclusive ? \">=\" : \">\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            return `T\\xFAl kicsi: a bemeneti \\xE9rt\\xE9k ${issue2.origin} m\\xE9rete t\\xFAl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n          }\n          return `T\\xFAl kicsi: a bemeneti \\xE9rt\\xE9k ${issue2.origin} t\\xFAl kicsi ${adj}${issue2.minimum.toString()}`;\n        }\n      case \"invalid_format\":\n        {\n          const _issue = issue2;\n          if (_issue.format === \"starts_with\") return `\\xC9rv\\xE9nytelen string: \"${_issue.prefix}\" \\xE9rt\\xE9kkel kell kezd\\u0151dnie`;\n          if (_issue.format === \"ends_with\") return `\\xC9rv\\xE9nytelen string: \"${_issue.suffix}\" \\xE9rt\\xE9kkel kell v\\xE9gz\\u0151dnie`;\n          if (_issue.format === \"includes\") return `\\xC9rv\\xE9nytelen string: \"${_issue.includes}\" \\xE9rt\\xE9ket kell tartalmaznia`;\n          if (_issue.format === \"regex\") return `\\xC9rv\\xE9nytelen string: ${_issue.pattern} mint\\xE1nak kell megfelelnie`;\n          return `\\xC9rv\\xE9nytelen ${Nouns[_issue.format] ?? issue2.format}`;\n        }\n      case \"not_multiple_of\":\n        return `\\xC9rv\\xE9nytelen sz\\xE1m: ${issue2.divisor} t\\xF6bbsz\\xF6r\\xF6s\\xE9nek kell lennie`;\n      case \"unrecognized_keys\":\n        return `Ismeretlen kulcs${issue2.keys.length > 1 ? \"s\" : \"\"}: ${joinValues(issue2.keys, \", \")}`;\n      case \"invalid_key\":\n        return `\\xC9rv\\xE9nytelen kulcs ${issue2.origin}`;\n      case \"invalid_union\":\n        return \"\\xC9rv\\xE9nytelen bemenet\";\n      case \"invalid_element\":\n        return `\\xC9rv\\xE9nytelen \\xE9rt\\xE9k: ${issue2.origin}`;\n      default:\n        return `\\xC9rv\\xE9nytelen bemenet`;\n    }\n  };\n};\nfunction hu_default() {\n  return {\n    localeError: error15()\n  };\n}\n\n// ../../node_modules/zod/v4/locales/id.js\nvar error16 = () => {\n  const Sizable = {\n    string: {\n      unit: \"karakter\",\n      verb: \"memiliki\"\n    },\n    file: {\n      unit: \"byte\",\n      verb: \"memiliki\"\n    },\n    array: {\n      unit: \"item\",\n      verb: \"memiliki\"\n    },\n    set: {\n      unit: \"item\",\n      verb: \"memiliki\"\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType4 = data => {\n    const t = typeof data;\n    switch (t) {\n      case \"number\":\n        {\n          return Number.isNaN(data) ? \"NaN\" : \"number\";\n        }\n      case \"object\":\n        {\n          if (Array.isArray(data)) {\n            return \"array\";\n          }\n          if (data === null) {\n            return \"null\";\n          }\n          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n            return data.constructor.name;\n          }\n        }\n    }\n    return t;\n  };\n  const Nouns = {\n    regex: \"input\",\n    email: \"alamat email\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"tanggal dan waktu format ISO\",\n    date: \"tanggal format ISO\",\n    time: \"jam format ISO\",\n    duration: \"durasi format ISO\",\n    ipv4: \"alamat IPv4\",\n    ipv6: \"alamat IPv6\",\n    cidrv4: \"rentang alamat IPv4\",\n    cidrv6: \"rentang alamat IPv6\",\n    base64: \"string dengan enkode base64\",\n    base64url: \"string dengan enkode base64url\",\n    json_string: \"string JSON\",\n    e164: \"angka E.164\",\n    jwt: \"JWT\",\n    template_literal: \"input\"\n  };\n  return issue2 => {\n    switch (issue2.code) {\n      case \"invalid_type\":\n        return `Input tidak valid: diharapkan ${issue2.expected}, diterima ${parsedType4(issue2.input)}`;\n      case \"invalid_value\":\n        if (issue2.values.length === 1) return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;\n        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, \"|\")}`;\n      case \"too_big\":\n        {\n          const adj = issue2.inclusive ? \"<=\" : \"<\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) return `Terlalu besar: diharapkan ${issue2.origin ?? \"value\"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? \"elemen\"}`;\n          return `Terlalu besar: diharapkan ${issue2.origin ?? \"value\"} menjadi ${adj}${issue2.maximum.toString()}`;\n        }\n      case \"too_small\":\n        {\n          const adj = issue2.inclusive ? \">=\" : \">\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n          }\n          return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;\n        }\n      case \"invalid_format\":\n        {\n          const _issue = issue2;\n          if (_issue.format === \"starts_with\") return `String tidak valid: harus dimulai dengan \"${_issue.prefix}\"`;\n          if (_issue.format === \"ends_with\") return `String tidak valid: harus berakhir dengan \"${_issue.suffix}\"`;\n          if (_issue.format === \"includes\") return `String tidak valid: harus menyertakan \"${_issue.includes}\"`;\n          if (_issue.format === \"regex\") return `String tidak valid: harus sesuai pola ${_issue.pattern}`;\n          return `${Nouns[_issue.format] ?? issue2.format} tidak valid`;\n        }\n      case \"not_multiple_of\":\n        return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;\n      case \"unrecognized_keys\":\n        return `Kunci tidak dikenali ${issue2.keys.length > 1 ? \"s\" : \"\"}: ${joinValues(issue2.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Kunci tidak valid di ${issue2.origin}`;\n      case \"invalid_union\":\n        return \"Input tidak valid\";\n      case \"invalid_element\":\n        return `Nilai tidak valid di ${issue2.origin}`;\n      default:\n        return `Input tidak valid`;\n    }\n  };\n};\nfunction id_default() {\n  return {\n    localeError: error16()\n  };\n}\n\n// ../../node_modules/zod/v4/locales/it.js\nvar error17 = () => {\n  const Sizable = {\n    string: {\n      unit: \"caratteri\",\n      verb: \"avere\"\n    },\n    file: {\n      unit: \"byte\",\n      verb: \"avere\"\n    },\n    array: {\n      unit: \"elementi\",\n      verb: \"avere\"\n    },\n    set: {\n      unit: \"elementi\",\n      verb: \"avere\"\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType4 = data => {\n    const t = typeof data;\n    switch (t) {\n      case \"number\":\n        {\n          return Number.isNaN(data) ? \"NaN\" : \"numero\";\n        }\n      case \"object\":\n        {\n          if (Array.isArray(data)) {\n            return \"vettore\";\n          }\n          if (data === null) {\n            return \"null\";\n          }\n          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n            return data.constructor.name;\n          }\n        }\n    }\n    return t;\n  };\n  const Nouns = {\n    regex: \"input\",\n    email: \"indirizzo email\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"data e ora ISO\",\n    date: \"data ISO\",\n    time: \"ora ISO\",\n    duration: \"durata ISO\",\n    ipv4: \"indirizzo IPv4\",\n    ipv6: \"indirizzo IPv6\",\n    cidrv4: \"intervallo IPv4\",\n    cidrv6: \"intervallo IPv6\",\n    base64: \"stringa codificata in base64\",\n    base64url: \"URL codificata in base64\",\n    json_string: \"stringa JSON\",\n    e164: \"numero E.164\",\n    jwt: \"JWT\",\n    template_literal: \"input\"\n  };\n  return issue2 => {\n    switch (issue2.code) {\n      case \"invalid_type\":\n        return `Input non valido: atteso ${issue2.expected}, ricevuto ${parsedType4(issue2.input)}`;\n      // return `Input non valido: atteso ${issue.expected}, ricevuto ${util.getParsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue2.values.length === 1) return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;\n        return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, \"|\")}`;\n      case \"too_big\":\n        {\n          const adj = issue2.inclusive ? \"<=\" : \"<\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) return `Troppo grande: ${issue2.origin ?? \"valore\"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? \"elementi\"}`;\n          return `Troppo grande: ${issue2.origin ?? \"valore\"} deve essere ${adj}${issue2.maximum.toString()}`;\n        }\n      case \"too_small\":\n        {\n          const adj = issue2.inclusive ? \">=\" : \">\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n          }\n          return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;\n        }\n      case \"invalid_format\":\n        {\n          const _issue = issue2;\n          if (_issue.format === \"starts_with\") return `Stringa non valida: deve iniziare con \"${_issue.prefix}\"`;\n          if (_issue.format === \"ends_with\") return `Stringa non valida: deve terminare con \"${_issue.suffix}\"`;\n          if (_issue.format === \"includes\") return `Stringa non valida: deve includere \"${_issue.includes}\"`;\n          if (_issue.format === \"regex\") return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;\n          return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;\n        }\n      case \"not_multiple_of\":\n        return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;\n      case \"unrecognized_keys\":\n        return `Chiav${issue2.keys.length > 1 ? \"i\" : \"e\"} non riconosciut${issue2.keys.length > 1 ? \"e\" : \"a\"}: ${joinValues(issue2.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Chiave non valida in ${issue2.origin}`;\n      case \"invalid_union\":\n        return \"Input non valido\";\n      case \"invalid_element\":\n        return `Valore non valido in ${issue2.origin}`;\n      default:\n        return `Input non valido`;\n    }\n  };\n};\nfunction it_default() {\n  return {\n    localeError: error17()\n  };\n}\n\n// ../../node_modules/zod/v4/locales/ja.js\nvar error18 = () => {\n  const Sizable = {\n    string: {\n      unit: \"\\u6587\\u5B57\",\n      verb: \"\\u3067\\u3042\\u308B\"\n    },\n    file: {\n      unit: \"\\u30D0\\u30A4\\u30C8\",\n      verb: \"\\u3067\\u3042\\u308B\"\n    },\n    array: {\n      unit: \"\\u8981\\u7D20\",\n      verb: \"\\u3067\\u3042\\u308B\"\n    },\n    set: {\n      unit: \"\\u8981\\u7D20\",\n      verb: \"\\u3067\\u3042\\u308B\"\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType4 = data => {\n    const t = typeof data;\n    switch (t) {\n      case \"number\":\n        {\n          return Number.isNaN(data) ? \"NaN\" : \"\\u6570\\u5024\";\n        }\n      case \"object\":\n        {\n          if (Array.isArray(data)) {\n            return \"\\u914D\\u5217\";\n          }\n          if (data === null) {\n            return \"null\";\n          }\n          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n            return data.constructor.name;\n          }\n        }\n    }\n    return t;\n  };\n  const Nouns = {\n    regex: \"\\u5165\\u529B\\u5024\",\n    email: \"\\u30E1\\u30FC\\u30EB\\u30A2\\u30C9\\u30EC\\u30B9\",\n    url: \"URL\",\n    emoji: \"\\u7D75\\u6587\\u5B57\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO\\u65E5\\u6642\",\n    date: \"ISO\\u65E5\\u4ED8\",\n    time: \"ISO\\u6642\\u523B\",\n    duration: \"ISO\\u671F\\u9593\",\n    ipv4: \"IPv4\\u30A2\\u30C9\\u30EC\\u30B9\",\n    ipv6: \"IPv6\\u30A2\\u30C9\\u30EC\\u30B9\",\n    cidrv4: \"IPv4\\u7BC4\\u56F2\",\n    cidrv6: \"IPv6\\u7BC4\\u56F2\",\n    base64: \"base64\\u30A8\\u30F3\\u30B3\\u30FC\\u30C9\\u6587\\u5B57\\u5217\",\n    base64url: \"base64url\\u30A8\\u30F3\\u30B3\\u30FC\\u30C9\\u6587\\u5B57\\u5217\",\n    json_string: \"JSON\\u6587\\u5B57\\u5217\",\n    e164: \"E.164\\u756A\\u53F7\",\n    jwt: \"JWT\",\n    template_literal: \"\\u5165\\u529B\\u5024\"\n  };\n  return issue2 => {\n    switch (issue2.code) {\n      case \"invalid_type\":\n        return `\\u7121\\u52B9\\u306A\\u5165\\u529B: ${issue2.expected}\\u304C\\u671F\\u5F85\\u3055\\u308C\\u307E\\u3057\\u305F\\u304C\\u3001${parsedType4(issue2.input)}\\u304C\\u5165\\u529B\\u3055\\u308C\\u307E\\u3057\\u305F`;\n      case \"invalid_value\":\n        if (issue2.values.length === 1) return `\\u7121\\u52B9\\u306A\\u5165\\u529B: ${stringifyPrimitive(issue2.values[0])}\\u304C\\u671F\\u5F85\\u3055\\u308C\\u307E\\u3057\\u305F`;\n        return `\\u7121\\u52B9\\u306A\\u9078\\u629E: ${joinValues(issue2.values, \"\\u3001\")}\\u306E\\u3044\\u305A\\u308C\\u304B\\u3067\\u3042\\u308B\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059`;\n      case \"too_big\":\n        {\n          const adj = issue2.inclusive ? \"\\u4EE5\\u4E0B\\u3067\\u3042\\u308B\" : \"\\u3088\\u308A\\u5C0F\\u3055\\u3044\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) return `\\u5927\\u304D\\u3059\\u304E\\u308B\\u5024: ${issue2.origin ?? \"\\u5024\"}\\u306F${issue2.maximum.toString()}${sizing.unit ?? \"\\u8981\\u7D20\"}${adj}\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059`;\n          return `\\u5927\\u304D\\u3059\\u304E\\u308B\\u5024: ${issue2.origin ?? \"\\u5024\"}\\u306F${issue2.maximum.toString()}${adj}\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059`;\n        }\n      case \"too_small\":\n        {\n          const adj = issue2.inclusive ? \"\\u4EE5\\u4E0A\\u3067\\u3042\\u308B\" : \"\\u3088\\u308A\\u5927\\u304D\\u3044\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) return `\\u5C0F\\u3055\\u3059\\u304E\\u308B\\u5024: ${issue2.origin}\\u306F${issue2.minimum.toString()}${sizing.unit}${adj}\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059`;\n          return `\\u5C0F\\u3055\\u3059\\u304E\\u308B\\u5024: ${issue2.origin}\\u306F${issue2.minimum.toString()}${adj}\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059`;\n        }\n      case \"invalid_format\":\n        {\n          const _issue = issue2;\n          if (_issue.format === \"starts_with\") return `\\u7121\\u52B9\\u306A\\u6587\\u5B57\\u5217: \"${_issue.prefix}\"\\u3067\\u59CB\\u307E\\u308B\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059`;\n          if (_issue.format === \"ends_with\") return `\\u7121\\u52B9\\u306A\\u6587\\u5B57\\u5217: \"${_issue.suffix}\"\\u3067\\u7D42\\u308F\\u308B\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059`;\n          if (_issue.format === \"includes\") return `\\u7121\\u52B9\\u306A\\u6587\\u5B57\\u5217: \"${_issue.includes}\"\\u3092\\u542B\\u3080\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059`;\n          if (_issue.format === \"regex\") return `\\u7121\\u52B9\\u306A\\u6587\\u5B57\\u5217: \\u30D1\\u30BF\\u30FC\\u30F3${_issue.pattern}\\u306B\\u4E00\\u81F4\\u3059\\u308B\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059`;\n          return `\\u7121\\u52B9\\u306A${Nouns[_issue.format] ?? issue2.format}`;\n        }\n      case \"not_multiple_of\":\n        return `\\u7121\\u52B9\\u306A\\u6570\\u5024: ${issue2.divisor}\\u306E\\u500D\\u6570\\u3067\\u3042\\u308B\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059`;\n      case \"unrecognized_keys\":\n        return `\\u8A8D\\u8B58\\u3055\\u308C\\u3066\\u3044\\u306A\\u3044\\u30AD\\u30FC${issue2.keys.length > 1 ? \"\\u7FA4\" : \"\"}: ${joinValues(issue2.keys, \"\\u3001\")}`;\n      case \"invalid_key\":\n        return `${issue2.origin}\\u5185\\u306E\\u7121\\u52B9\\u306A\\u30AD\\u30FC`;\n      case \"invalid_union\":\n        return \"\\u7121\\u52B9\\u306A\\u5165\\u529B\";\n      case \"invalid_element\":\n        return `${issue2.origin}\\u5185\\u306E\\u7121\\u52B9\\u306A\\u5024`;\n      default:\n        return `\\u7121\\u52B9\\u306A\\u5165\\u529B`;\n    }\n  };\n};\nfunction ja_default() {\n  return {\n    localeError: error18()\n  };\n}\n\n// ../../node_modules/zod/v4/locales/kh.js\nvar error19 = () => {\n  const Sizable = {\n    string: {\n      unit: \"\\u178F\\u17BD\\u17A2\\u1780\\u17D2\\u179F\\u179A\",\n      verb: \"\\u1782\\u17BD\\u179A\\u1798\\u17B6\\u1793\"\n    },\n    file: {\n      unit: \"\\u1794\\u17C3\",\n      verb: \"\\u1782\\u17BD\\u179A\\u1798\\u17B6\\u1793\"\n    },\n    array: {\n      unit: \"\\u1792\\u17B6\\u178F\\u17BB\",\n      verb: \"\\u1782\\u17BD\\u179A\\u1798\\u17B6\\u1793\"\n    },\n    set: {\n      unit: \"\\u1792\\u17B6\\u178F\\u17BB\",\n      verb: \"\\u1782\\u17BD\\u179A\\u1798\\u17B6\\u1793\"\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType4 = data => {\n    const t = typeof data;\n    switch (t) {\n      case \"number\":\n        {\n          return Number.isNaN(data) ? \"\\u1798\\u17B7\\u1793\\u1798\\u17C2\\u1793\\u1787\\u17B6\\u179B\\u17C1\\u1781 (NaN)\" : \"\\u179B\\u17C1\\u1781\";\n        }\n      case \"object\":\n        {\n          if (Array.isArray(data)) {\n            return \"\\u17A2\\u17B6\\u179A\\u17C1 (Array)\";\n          }\n          if (data === null) {\n            return \"\\u1782\\u17D2\\u1798\\u17B6\\u1793\\u178F\\u1798\\u17D2\\u179B\\u17C3 (null)\";\n          }\n          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n            return data.constructor.name;\n          }\n        }\n    }\n    return t;\n  };\n  const Nouns = {\n    regex: \"\\u1791\\u17B7\\u1793\\u17D2\\u1793\\u1793\\u17D0\\u1799\\u1794\\u1789\\u17D2\\u1785\\u17BC\\u179B\",\n    email: \"\\u17A2\\u17B6\\u179F\\u1799\\u178A\\u17D2\\u178B\\u17B6\\u1793\\u17A2\\u17CA\\u17B8\\u1798\\u17C2\\u179B\",\n    url: \"URL\",\n    emoji: \"\\u179F\\u1789\\u17D2\\u1789\\u17B6\\u17A2\\u17B6\\u179A\\u1798\\u17D2\\u1798\\u178E\\u17CD\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"\\u1780\\u17B6\\u179B\\u1794\\u179A\\u17B7\\u1785\\u17D2\\u1786\\u17C1\\u1791 \\u1793\\u17B7\\u1784\\u1798\\u17C9\\u17C4\\u1784 ISO\",\n    date: \"\\u1780\\u17B6\\u179B\\u1794\\u179A\\u17B7\\u1785\\u17D2\\u1786\\u17C1\\u1791 ISO\",\n    time: \"\\u1798\\u17C9\\u17C4\\u1784 ISO\",\n    duration: \"\\u179A\\u1799\\u17C8\\u1796\\u17C1\\u179B ISO\",\n    ipv4: \"\\u17A2\\u17B6\\u179F\\u1799\\u178A\\u17D2\\u178B\\u17B6\\u1793 IPv4\",\n    ipv6: \"\\u17A2\\u17B6\\u179F\\u1799\\u178A\\u17D2\\u178B\\u17B6\\u1793 IPv6\",\n    cidrv4: \"\\u178A\\u17C2\\u1793\\u17A2\\u17B6\\u179F\\u1799\\u178A\\u17D2\\u178B\\u17B6\\u1793 IPv4\",\n    cidrv6: \"\\u178A\\u17C2\\u1793\\u17A2\\u17B6\\u179F\\u1799\\u178A\\u17D2\\u178B\\u17B6\\u1793 IPv6\",\n    base64: \"\\u1781\\u17D2\\u179F\\u17C2\\u17A2\\u1780\\u17D2\\u179F\\u179A\\u17A2\\u17CA\\u17B7\\u1780\\u17BC\\u178A base64\",\n    base64url: \"\\u1781\\u17D2\\u179F\\u17C2\\u17A2\\u1780\\u17D2\\u179F\\u179A\\u17A2\\u17CA\\u17B7\\u1780\\u17BC\\u178A base64url\",\n    json_string: \"\\u1781\\u17D2\\u179F\\u17C2\\u17A2\\u1780\\u17D2\\u179F\\u179A JSON\",\n    e164: \"\\u179B\\u17C1\\u1781 E.164\",\n    jwt: \"JWT\",\n    template_literal: \"\\u1791\\u17B7\\u1793\\u17D2\\u1793\\u1793\\u17D0\\u1799\\u1794\\u1789\\u17D2\\u1785\\u17BC\\u179B\"\n  };\n  return issue2 => {\n    switch (issue2.code) {\n      case \"invalid_type\":\n        return `\\u1791\\u17B7\\u1793\\u17D2\\u1793\\u1793\\u17D0\\u1799\\u1794\\u1789\\u17D2\\u1785\\u17BC\\u179B\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C\\u17D6 \\u178F\\u17D2\\u179A\\u17BC\\u179C\\u1780\\u17B6\\u179A ${issue2.expected} \\u1794\\u17C9\\u17BB\\u1793\\u17D2\\u178F\\u17C2\\u1791\\u1791\\u17BD\\u179B\\u1794\\u17B6\\u1793 ${parsedType4(issue2.input)}`;\n      case \"invalid_value\":\n        if (issue2.values.length === 1) return `\\u1791\\u17B7\\u1793\\u17D2\\u1793\\u1793\\u17D0\\u1799\\u1794\\u1789\\u17D2\\u1785\\u17BC\\u179B\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C\\u17D6 \\u178F\\u17D2\\u179A\\u17BC\\u179C\\u1780\\u17B6\\u179A ${stringifyPrimitive(issue2.values[0])}`;\n        return `\\u1787\\u1798\\u17D2\\u179A\\u17BE\\u179F\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C\\u17D6 \\u178F\\u17D2\\u179A\\u17BC\\u179C\\u1787\\u17B6\\u1798\\u17BD\\u1799\\u1780\\u17D2\\u1793\\u17BB\\u1784\\u1785\\u17C6\\u178E\\u17C4\\u1798 ${joinValues(issue2.values, \"|\")}`;\n      case \"too_big\":\n        {\n          const adj = issue2.inclusive ? \"<=\" : \"<\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) return `\\u1792\\u17C6\\u1796\\u17C1\\u1780\\u17D6 \\u178F\\u17D2\\u179A\\u17BC\\u179C\\u1780\\u17B6\\u179A ${issue2.origin ?? \"\\u178F\\u1798\\u17D2\\u179B\\u17C3\"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? \"\\u1792\\u17B6\\u178F\\u17BB\"}`;\n          return `\\u1792\\u17C6\\u1796\\u17C1\\u1780\\u17D6 \\u178F\\u17D2\\u179A\\u17BC\\u179C\\u1780\\u17B6\\u179A ${issue2.origin ?? \"\\u178F\\u1798\\u17D2\\u179B\\u17C3\"} ${adj} ${issue2.maximum.toString()}`;\n        }\n      case \"too_small\":\n        {\n          const adj = issue2.inclusive ? \">=\" : \">\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            return `\\u178F\\u17BC\\u1785\\u1796\\u17C1\\u1780\\u17D6 \\u178F\\u17D2\\u179A\\u17BC\\u179C\\u1780\\u17B6\\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;\n          }\n          return `\\u178F\\u17BC\\u1785\\u1796\\u17C1\\u1780\\u17D6 \\u178F\\u17D2\\u179A\\u17BC\\u179C\\u1780\\u17B6\\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;\n        }\n      case \"invalid_format\":\n        {\n          const _issue = issue2;\n          if (_issue.format === \"starts_with\") {\n            return `\\u1781\\u17D2\\u179F\\u17C2\\u17A2\\u1780\\u17D2\\u179F\\u179A\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C\\u17D6 \\u178F\\u17D2\\u179A\\u17BC\\u179C\\u1785\\u17B6\\u1794\\u17CB\\u1795\\u17D2\\u178F\\u17BE\\u1798\\u178A\\u17C4\\u1799 \"${_issue.prefix}\"`;\n          }\n          if (_issue.format === \"ends_with\") return `\\u1781\\u17D2\\u179F\\u17C2\\u17A2\\u1780\\u17D2\\u179F\\u179A\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C\\u17D6 \\u178F\\u17D2\\u179A\\u17BC\\u179C\\u1794\\u1789\\u17D2\\u1785\\u1794\\u17CB\\u178A\\u17C4\\u1799 \"${_issue.suffix}\"`;\n          if (_issue.format === \"includes\") return `\\u1781\\u17D2\\u179F\\u17C2\\u17A2\\u1780\\u17D2\\u179F\\u179A\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C\\u17D6 \\u178F\\u17D2\\u179A\\u17BC\\u179C\\u1798\\u17B6\\u1793 \"${_issue.includes}\"`;\n          if (_issue.format === \"regex\") return `\\u1781\\u17D2\\u179F\\u17C2\\u17A2\\u1780\\u17D2\\u179F\\u179A\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C\\u17D6 \\u178F\\u17D2\\u179A\\u17BC\\u179C\\u178F\\u17C2\\u1795\\u17D2\\u1782\\u17BC\\u1795\\u17D2\\u1782\\u1784\\u1793\\u17B9\\u1784\\u1791\\u1798\\u17D2\\u179A\\u1784\\u17CB\\u178A\\u17C2\\u179B\\u1794\\u17B6\\u1793\\u1780\\u17C6\\u178E\\u178F\\u17CB ${_issue.pattern}`;\n          return `\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C\\u17D6 ${Nouns[_issue.format] ?? issue2.format}`;\n        }\n      case \"not_multiple_of\":\n        return `\\u179B\\u17C1\\u1781\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C\\u17D6 \\u178F\\u17D2\\u179A\\u17BC\\u179C\\u178F\\u17C2\\u1787\\u17B6\\u1796\\u17A0\\u17BB\\u1782\\u17BB\\u178E\\u1793\\u17C3 ${issue2.divisor}`;\n      case \"unrecognized_keys\":\n        return `\\u179A\\u1780\\u1783\\u17BE\\u1789\\u179F\\u17C4\\u1798\\u17B7\\u1793\\u179F\\u17D2\\u1782\\u17B6\\u179B\\u17CB\\u17D6 ${joinValues(issue2.keys, \", \")}`;\n      case \"invalid_key\":\n        return `\\u179F\\u17C4\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C\\u1793\\u17C5\\u1780\\u17D2\\u1793\\u17BB\\u1784 ${issue2.origin}`;\n      case \"invalid_union\":\n        return `\\u1791\\u17B7\\u1793\\u17D2\\u1793\\u1793\\u17D0\\u1799\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C`;\n      case \"invalid_element\":\n        return `\\u1791\\u17B7\\u1793\\u17D2\\u1793\\u1793\\u17D0\\u1799\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C\\u1793\\u17C5\\u1780\\u17D2\\u1793\\u17BB\\u1784 ${issue2.origin}`;\n      default:\n        return `\\u1791\\u17B7\\u1793\\u17D2\\u1793\\u1793\\u17D0\\u1799\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C`;\n    }\n  };\n};\nfunction kh_default() {\n  return {\n    localeError: error19()\n  };\n}\n\n// ../../node_modules/zod/v4/locales/ko.js\nvar error20 = () => {\n  const Sizable = {\n    string: {\n      unit: \"\\uBB38\\uC790\",\n      verb: \"to have\"\n    },\n    file: {\n      unit: \"\\uBC14\\uC774\\uD2B8\",\n      verb: \"to have\"\n    },\n    array: {\n      unit: \"\\uAC1C\",\n      verb: \"to have\"\n    },\n    set: {\n      unit: \"\\uAC1C\",\n      verb: \"to have\"\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType4 = data => {\n    const t = typeof data;\n    switch (t) {\n      case \"number\":\n        {\n          return Number.isNaN(data) ? \"NaN\" : \"number\";\n        }\n      case \"object\":\n        {\n          if (Array.isArray(data)) {\n            return \"array\";\n          }\n          if (data === null) {\n            return \"null\";\n          }\n          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n            return data.constructor.name;\n          }\n        }\n    }\n    return t;\n  };\n  const Nouns = {\n    regex: \"\\uC785\\uB825\",\n    email: \"\\uC774\\uBA54\\uC77C \\uC8FC\\uC18C\",\n    url: \"URL\",\n    emoji: \"\\uC774\\uBAA8\\uC9C0\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO \\uB0A0\\uC9DC\\uC2DC\\uAC04\",\n    date: \"ISO \\uB0A0\\uC9DC\",\n    time: \"ISO \\uC2DC\\uAC04\",\n    duration: \"ISO \\uAE30\\uAC04\",\n    ipv4: \"IPv4 \\uC8FC\\uC18C\",\n    ipv6: \"IPv6 \\uC8FC\\uC18C\",\n    cidrv4: \"IPv4 \\uBC94\\uC704\",\n    cidrv6: \"IPv6 \\uBC94\\uC704\",\n    base64: \"base64 \\uC778\\uCF54\\uB529 \\uBB38\\uC790\\uC5F4\",\n    base64url: \"base64url \\uC778\\uCF54\\uB529 \\uBB38\\uC790\\uC5F4\",\n    json_string: \"JSON \\uBB38\\uC790\\uC5F4\",\n    e164: \"E.164 \\uBC88\\uD638\",\n    jwt: \"JWT\",\n    template_literal: \"\\uC785\\uB825\"\n  };\n  return issue2 => {\n    switch (issue2.code) {\n      case \"invalid_type\":\n        return `\\uC798\\uBABB\\uB41C \\uC785\\uB825: \\uC608\\uC0C1 \\uD0C0\\uC785\\uC740 ${issue2.expected}, \\uBC1B\\uC740 \\uD0C0\\uC785\\uC740 ${parsedType4(issue2.input)}\\uC785\\uB2C8\\uB2E4`;\n      case \"invalid_value\":\n        if (issue2.values.length === 1) return `\\uC798\\uBABB\\uB41C \\uC785\\uB825: \\uAC12\\uC740 ${stringifyPrimitive(issue2.values[0])} \\uC774\\uC5B4\\uC57C \\uD569\\uB2C8\\uB2E4`;\n        return `\\uC798\\uBABB\\uB41C \\uC635\\uC158: ${joinValues(issue2.values, \"\\uB610\\uB294 \")} \\uC911 \\uD558\\uB098\\uC5EC\\uC57C \\uD569\\uB2C8\\uB2E4`;\n      case \"too_big\":\n        {\n          const adj = issue2.inclusive ? \"\\uC774\\uD558\" : \"\\uBBF8\\uB9CC\";\n          const suffix = adj === \"\\uBBF8\\uB9CC\" ? \"\\uC774\\uC5B4\\uC57C \\uD569\\uB2C8\\uB2E4\" : \"\\uC5EC\\uC57C \\uD569\\uB2C8\\uB2E4\";\n          const sizing = getSizing(issue2.origin);\n          const unit = sizing?.unit ?? \"\\uC694\\uC18C\";\n          if (sizing) return `${issue2.origin ?? \"\\uAC12\"}\\uC774 \\uB108\\uBB34 \\uD07D\\uB2C8\\uB2E4: ${issue2.maximum.toString()}${unit} ${adj}${suffix}`;\n          return `${issue2.origin ?? \"\\uAC12\"}\\uC774 \\uB108\\uBB34 \\uD07D\\uB2C8\\uB2E4: ${issue2.maximum.toString()} ${adj}${suffix}`;\n        }\n      case \"too_small\":\n        {\n          const adj = issue2.inclusive ? \"\\uC774\\uC0C1\" : \"\\uCD08\\uACFC\";\n          const suffix = adj === \"\\uC774\\uC0C1\" ? \"\\uC774\\uC5B4\\uC57C \\uD569\\uB2C8\\uB2E4\" : \"\\uC5EC\\uC57C \\uD569\\uB2C8\\uB2E4\";\n          const sizing = getSizing(issue2.origin);\n          const unit = sizing?.unit ?? \"\\uC694\\uC18C\";\n          if (sizing) {\n            return `${issue2.origin ?? \"\\uAC12\"}\\uC774 \\uB108\\uBB34 \\uC791\\uC2B5\\uB2C8\\uB2E4: ${issue2.minimum.toString()}${unit} ${adj}${suffix}`;\n          }\n          return `${issue2.origin ?? \"\\uAC12\"}\\uC774 \\uB108\\uBB34 \\uC791\\uC2B5\\uB2C8\\uB2E4: ${issue2.minimum.toString()} ${adj}${suffix}`;\n        }\n      case \"invalid_format\":\n        {\n          const _issue = issue2;\n          if (_issue.format === \"starts_with\") {\n            return `\\uC798\\uBABB\\uB41C \\uBB38\\uC790\\uC5F4: \"${_issue.prefix}\"(\\uC73C)\\uB85C \\uC2DC\\uC791\\uD574\\uC57C \\uD569\\uB2C8\\uB2E4`;\n          }\n          if (_issue.format === \"ends_with\") return `\\uC798\\uBABB\\uB41C \\uBB38\\uC790\\uC5F4: \"${_issue.suffix}\"(\\uC73C)\\uB85C \\uB05D\\uB098\\uC57C \\uD569\\uB2C8\\uB2E4`;\n          if (_issue.format === \"includes\") return `\\uC798\\uBABB\\uB41C \\uBB38\\uC790\\uC5F4: \"${_issue.includes}\"\\uC744(\\uB97C) \\uD3EC\\uD568\\uD574\\uC57C \\uD569\\uB2C8\\uB2E4`;\n          if (_issue.format === \"regex\") return `\\uC798\\uBABB\\uB41C \\uBB38\\uC790\\uC5F4: \\uC815\\uADDC\\uC2DD ${_issue.pattern} \\uD328\\uD134\\uACFC \\uC77C\\uCE58\\uD574\\uC57C \\uD569\\uB2C8\\uB2E4`;\n          return `\\uC798\\uBABB\\uB41C ${Nouns[_issue.format] ?? issue2.format}`;\n        }\n      case \"not_multiple_of\":\n        return `\\uC798\\uBABB\\uB41C \\uC22B\\uC790: ${issue2.divisor}\\uC758 \\uBC30\\uC218\\uC5EC\\uC57C \\uD569\\uB2C8\\uB2E4`;\n      case \"unrecognized_keys\":\n        return `\\uC778\\uC2DD\\uD560 \\uC218 \\uC5C6\\uB294 \\uD0A4: ${joinValues(issue2.keys, \", \")}`;\n      case \"invalid_key\":\n        return `\\uC798\\uBABB\\uB41C \\uD0A4: ${issue2.origin}`;\n      case \"invalid_union\":\n        return `\\uC798\\uBABB\\uB41C \\uC785\\uB825`;\n      case \"invalid_element\":\n        return `\\uC798\\uBABB\\uB41C \\uAC12: ${issue2.origin}`;\n      default:\n        return `\\uC798\\uBABB\\uB41C \\uC785\\uB825`;\n    }\n  };\n};\nfunction ko_default() {\n  return {\n    localeError: error20()\n  };\n}\n\n// ../../node_modules/zod/v4/locales/mk.js\nvar error21 = () => {\n  const Sizable = {\n    string: {\n      unit: \"\\u0437\\u043D\\u0430\\u0446\\u0438\",\n      verb: \"\\u0434\\u0430 \\u0438\\u043C\\u0430\\u0430\\u0442\"\n    },\n    file: {\n      unit: \"\\u0431\\u0430\\u0458\\u0442\\u0438\",\n      verb: \"\\u0434\\u0430 \\u0438\\u043C\\u0430\\u0430\\u0442\"\n    },\n    array: {\n      unit: \"\\u0441\\u0442\\u0430\\u0432\\u043A\\u0438\",\n      verb: \"\\u0434\\u0430 \\u0438\\u043C\\u0430\\u0430\\u0442\"\n    },\n    set: {\n      unit: \"\\u0441\\u0442\\u0430\\u0432\\u043A\\u0438\",\n      verb: \"\\u0434\\u0430 \\u0438\\u043C\\u0430\\u0430\\u0442\"\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType4 = data => {\n    const t = typeof data;\n    switch (t) {\n      case \"number\":\n        {\n          return Number.isNaN(data) ? \"NaN\" : \"\\u0431\\u0440\\u043E\\u0458\";\n        }\n      case \"object\":\n        {\n          if (Array.isArray(data)) {\n            return \"\\u043D\\u0438\\u0437\\u0430\";\n          }\n          if (data === null) {\n            return \"null\";\n          }\n          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n            return data.constructor.name;\n          }\n        }\n    }\n    return t;\n  };\n  const Nouns = {\n    regex: \"\\u0432\\u043D\\u0435\\u0441\",\n    email: \"\\u0430\\u0434\\u0440\\u0435\\u0441\\u0430 \\u043D\\u0430 \\u0435-\\u043F\\u043E\\u0448\\u0442\\u0430\",\n    url: \"URL\",\n    emoji: \"\\u0435\\u043C\\u043E\\u045F\\u0438\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO \\u0434\\u0430\\u0442\\u0443\\u043C \\u0438 \\u0432\\u0440\\u0435\\u043C\\u0435\",\n    date: \"ISO \\u0434\\u0430\\u0442\\u0443\\u043C\",\n    time: \"ISO \\u0432\\u0440\\u0435\\u043C\\u0435\",\n    duration: \"ISO \\u0432\\u0440\\u0435\\u043C\\u0435\\u0442\\u0440\\u0430\\u0435\\u045A\\u0435\",\n    ipv4: \"IPv4 \\u0430\\u0434\\u0440\\u0435\\u0441\\u0430\",\n    ipv6: \"IPv6 \\u0430\\u0434\\u0440\\u0435\\u0441\\u0430\",\n    cidrv4: \"IPv4 \\u043E\\u043F\\u0441\\u0435\\u0433\",\n    cidrv6: \"IPv6 \\u043E\\u043F\\u0441\\u0435\\u0433\",\n    base64: \"base64-\\u0435\\u043D\\u043A\\u043E\\u0434\\u0438\\u0440\\u0430\\u043D\\u0430 \\u043D\\u0438\\u0437\\u0430\",\n    base64url: \"base64url-\\u0435\\u043D\\u043A\\u043E\\u0434\\u0438\\u0440\\u0430\\u043D\\u0430 \\u043D\\u0438\\u0437\\u0430\",\n    json_string: \"JSON \\u043D\\u0438\\u0437\\u0430\",\n    e164: \"E.164 \\u0431\\u0440\\u043E\\u0458\",\n    jwt: \"JWT\",\n    template_literal: \"\\u0432\\u043D\\u0435\\u0441\"\n  };\n  return issue2 => {\n    switch (issue2.code) {\n      case \"invalid_type\":\n        return `\\u0413\\u0440\\u0435\\u0448\\u0435\\u043D \\u0432\\u043D\\u0435\\u0441: \\u0441\\u0435 \\u043E\\u0447\\u0435\\u043A\\u0443\\u0432\\u0430 ${issue2.expected}, \\u043F\\u0440\\u0438\\u043C\\u0435\\u043D\\u043E ${parsedType4(issue2.input)}`;\n      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue2.values.length === 1) return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;\n        return `\\u0413\\u0440\\u0435\\u0448\\u0430\\u043D\\u0430 \\u043E\\u043F\\u0446\\u0438\\u0458\\u0430: \\u0441\\u0435 \\u043E\\u0447\\u0435\\u043A\\u0443\\u0432\\u0430 \\u0435\\u0434\\u043D\\u0430 ${joinValues(issue2.values, \"|\")}`;\n      case \"too_big\":\n        {\n          const adj = issue2.inclusive ? \"<=\" : \"<\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) return `\\u041F\\u0440\\u0435\\u043C\\u043D\\u043E\\u0433\\u0443 \\u0433\\u043E\\u043B\\u0435\\u043C: \\u0441\\u0435 \\u043E\\u0447\\u0435\\u043A\\u0443\\u0432\\u0430 ${issue2.origin ?? \"\\u0432\\u0440\\u0435\\u0434\\u043D\\u043E\\u0441\\u0442\\u0430\"} \\u0434\\u0430 \\u0438\\u043C\\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? \"\\u0435\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0438\"}`;\n          return `\\u041F\\u0440\\u0435\\u043C\\u043D\\u043E\\u0433\\u0443 \\u0433\\u043E\\u043B\\u0435\\u043C: \\u0441\\u0435 \\u043E\\u0447\\u0435\\u043A\\u0443\\u0432\\u0430 ${issue2.origin ?? \"\\u0432\\u0440\\u0435\\u0434\\u043D\\u043E\\u0441\\u0442\\u0430\"} \\u0434\\u0430 \\u0431\\u0438\\u0434\\u0435 ${adj}${issue2.maximum.toString()}`;\n        }\n      case \"too_small\":\n        {\n          const adj = issue2.inclusive ? \">=\" : \">\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            return `\\u041F\\u0440\\u0435\\u043C\\u043D\\u043E\\u0433\\u0443 \\u043C\\u0430\\u043B: \\u0441\\u0435 \\u043E\\u0447\\u0435\\u043A\\u0443\\u0432\\u0430 ${issue2.origin} \\u0434\\u0430 \\u0438\\u043C\\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n          }\n          return `\\u041F\\u0440\\u0435\\u043C\\u043D\\u043E\\u0433\\u0443 \\u043C\\u0430\\u043B: \\u0441\\u0435 \\u043E\\u0447\\u0435\\u043A\\u0443\\u0432\\u0430 ${issue2.origin} \\u0434\\u0430 \\u0431\\u0438\\u0434\\u0435 ${adj}${issue2.minimum.toString()}`;\n        }\n      case \"invalid_format\":\n        {\n          const _issue = issue2;\n          if (_issue.format === \"starts_with\") {\n            return `\\u041D\\u0435\\u0432\\u0430\\u0436\\u0435\\u0447\\u043A\\u0430 \\u043D\\u0438\\u0437\\u0430: \\u043C\\u043E\\u0440\\u0430 \\u0434\\u0430 \\u0437\\u0430\\u043F\\u043E\\u0447\\u043D\\u0443\\u0432\\u0430 \\u0441\\u043E \"${_issue.prefix}\"`;\n          }\n          if (_issue.format === \"ends_with\") return `\\u041D\\u0435\\u0432\\u0430\\u0436\\u0435\\u0447\\u043A\\u0430 \\u043D\\u0438\\u0437\\u0430: \\u043C\\u043E\\u0440\\u0430 \\u0434\\u0430 \\u0437\\u0430\\u0432\\u0440\\u0448\\u0443\\u0432\\u0430 \\u0441\\u043E \"${_issue.suffix}\"`;\n          if (_issue.format === \"includes\") return `\\u041D\\u0435\\u0432\\u0430\\u0436\\u0435\\u0447\\u043A\\u0430 \\u043D\\u0438\\u0437\\u0430: \\u043C\\u043E\\u0440\\u0430 \\u0434\\u0430 \\u0432\\u043A\\u043B\\u0443\\u0447\\u0443\\u0432\\u0430 \"${_issue.includes}\"`;\n          if (_issue.format === \"regex\") return `\\u041D\\u0435\\u0432\\u0430\\u0436\\u0435\\u0447\\u043A\\u0430 \\u043D\\u0438\\u0437\\u0430: \\u043C\\u043E\\u0440\\u0430 \\u0434\\u0430 \\u043E\\u0434\\u0433\\u043E\\u0430\\u0440\\u0430 \\u043D\\u0430 \\u043F\\u0430\\u0442\\u0435\\u0440\\u043D\\u043E\\u0442 ${_issue.pattern}`;\n          return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;\n        }\n      case \"not_multiple_of\":\n        return `\\u0413\\u0440\\u0435\\u0448\\u0435\\u043D \\u0431\\u0440\\u043E\\u0458: \\u043C\\u043E\\u0440\\u0430 \\u0434\\u0430 \\u0431\\u0438\\u0434\\u0435 \\u0434\\u0435\\u043B\\u0438\\u0432 \\u0441\\u043E ${issue2.divisor}`;\n      case \"unrecognized_keys\":\n        return `${issue2.keys.length > 1 ? \"\\u041D\\u0435\\u043F\\u0440\\u0435\\u043F\\u043E\\u0437\\u043D\\u0430\\u0435\\u043D\\u0438 \\u043A\\u043B\\u0443\\u0447\\u0435\\u0432\\u0438\" : \"\\u041D\\u0435\\u043F\\u0440\\u0435\\u043F\\u043E\\u0437\\u043D\\u0430\\u0435\\u043D \\u043A\\u043B\\u0443\\u0447\"}: ${joinValues(issue2.keys, \", \")}`;\n      case \"invalid_key\":\n        return `\\u0413\\u0440\\u0435\\u0448\\u0435\\u043D \\u043A\\u043B\\u0443\\u0447 \\u0432\\u043E ${issue2.origin}`;\n      case \"invalid_union\":\n        return \"\\u0413\\u0440\\u0435\\u0448\\u0435\\u043D \\u0432\\u043D\\u0435\\u0441\";\n      case \"invalid_element\":\n        return `\\u0413\\u0440\\u0435\\u0448\\u043D\\u0430 \\u0432\\u0440\\u0435\\u0434\\u043D\\u043E\\u0441\\u0442 \\u0432\\u043E ${issue2.origin}`;\n      default:\n        return `\\u0413\\u0440\\u0435\\u0448\\u0435\\u043D \\u0432\\u043D\\u0435\\u0441`;\n    }\n  };\n};\nfunction mk_default() {\n  return {\n    localeError: error21()\n  };\n}\n\n// ../../node_modules/zod/v4/locales/ms.js\nvar error22 = () => {\n  const Sizable = {\n    string: {\n      unit: \"aksara\",\n      verb: \"mempunyai\"\n    },\n    file: {\n      unit: \"bait\",\n      verb: \"mempunyai\"\n    },\n    array: {\n      unit: \"elemen\",\n      verb: \"mempunyai\"\n    },\n    set: {\n      unit: \"elemen\",\n      verb: \"mempunyai\"\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType4 = data => {\n    const t = typeof data;\n    switch (t) {\n      case \"number\":\n        {\n          return Number.isNaN(data) ? \"NaN\" : \"nombor\";\n        }\n      case \"object\":\n        {\n          if (Array.isArray(data)) {\n            return \"array\";\n          }\n          if (data === null) {\n            return \"null\";\n          }\n          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n            return data.constructor.name;\n          }\n        }\n    }\n    return t;\n  };\n  const Nouns = {\n    regex: \"input\",\n    email: \"alamat e-mel\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"tarikh masa ISO\",\n    date: \"tarikh ISO\",\n    time: \"masa ISO\",\n    duration: \"tempoh ISO\",\n    ipv4: \"alamat IPv4\",\n    ipv6: \"alamat IPv6\",\n    cidrv4: \"julat IPv4\",\n    cidrv6: \"julat IPv6\",\n    base64: \"string dikodkan base64\",\n    base64url: \"string dikodkan base64url\",\n    json_string: \"string JSON\",\n    e164: \"nombor E.164\",\n    jwt: \"JWT\",\n    template_literal: \"input\"\n  };\n  return issue2 => {\n    switch (issue2.code) {\n      case \"invalid_type\":\n        return `Input tidak sah: dijangka ${issue2.expected}, diterima ${parsedType4(issue2.input)}`;\n      case \"invalid_value\":\n        if (issue2.values.length === 1) return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;\n        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, \"|\")}`;\n      case \"too_big\":\n        {\n          const adj = issue2.inclusive ? \"<=\" : \"<\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) return `Terlalu besar: dijangka ${issue2.origin ?? \"nilai\"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? \"elemen\"}`;\n          return `Terlalu besar: dijangka ${issue2.origin ?? \"nilai\"} adalah ${adj}${issue2.maximum.toString()}`;\n        }\n      case \"too_small\":\n        {\n          const adj = issue2.inclusive ? \">=\" : \">\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n          }\n          return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;\n        }\n      case \"invalid_format\":\n        {\n          const _issue = issue2;\n          if (_issue.format === \"starts_with\") return `String tidak sah: mesti bermula dengan \"${_issue.prefix}\"`;\n          if (_issue.format === \"ends_with\") return `String tidak sah: mesti berakhir dengan \"${_issue.suffix}\"`;\n          if (_issue.format === \"includes\") return `String tidak sah: mesti mengandungi \"${_issue.includes}\"`;\n          if (_issue.format === \"regex\") return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;\n          return `${Nouns[_issue.format] ?? issue2.format} tidak sah`;\n        }\n      case \"not_multiple_of\":\n        return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;\n      case \"unrecognized_keys\":\n        return `Kunci tidak dikenali: ${joinValues(issue2.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Kunci tidak sah dalam ${issue2.origin}`;\n      case \"invalid_union\":\n        return \"Input tidak sah\";\n      case \"invalid_element\":\n        return `Nilai tidak sah dalam ${issue2.origin}`;\n      default:\n        return `Input tidak sah`;\n    }\n  };\n};\nfunction ms_default() {\n  return {\n    localeError: error22()\n  };\n}\n\n// ../../node_modules/zod/v4/locales/nl.js\nvar error23 = () => {\n  const Sizable = {\n    string: {\n      unit: \"tekens\"\n    },\n    file: {\n      unit: \"bytes\"\n    },\n    array: {\n      unit: \"elementen\"\n    },\n    set: {\n      unit: \"elementen\"\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType4 = data => {\n    const t = typeof data;\n    switch (t) {\n      case \"number\":\n        {\n          return Number.isNaN(data) ? \"NaN\" : \"getal\";\n        }\n      case \"object\":\n        {\n          if (Array.isArray(data)) {\n            return \"array\";\n          }\n          if (data === null) {\n            return \"null\";\n          }\n          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n            return data.constructor.name;\n          }\n        }\n    }\n    return t;\n  };\n  const Nouns = {\n    regex: \"invoer\",\n    email: \"emailadres\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO datum en tijd\",\n    date: \"ISO datum\",\n    time: \"ISO tijd\",\n    duration: \"ISO duur\",\n    ipv4: \"IPv4-adres\",\n    ipv6: \"IPv6-adres\",\n    cidrv4: \"IPv4-bereik\",\n    cidrv6: \"IPv6-bereik\",\n    base64: \"base64-gecodeerde tekst\",\n    base64url: \"base64 URL-gecodeerde tekst\",\n    json_string: \"JSON string\",\n    e164: \"E.164-nummer\",\n    jwt: \"JWT\",\n    template_literal: \"invoer\"\n  };\n  return issue2 => {\n    switch (issue2.code) {\n      case \"invalid_type\":\n        return `Ongeldige invoer: verwacht ${issue2.expected}, ontving ${parsedType4(issue2.input)}`;\n      case \"invalid_value\":\n        if (issue2.values.length === 1) return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue2.values[0])}`;\n        return `Ongeldige optie: verwacht \\xE9\\xE9n van ${joinValues(issue2.values, \"|\")}`;\n      case \"too_big\":\n        {\n          const adj = issue2.inclusive ? \"<=\" : \"<\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) return `Te lang: verwacht dat ${issue2.origin ?? \"waarde\"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? \"elementen\"} bevat`;\n          return `Te lang: verwacht dat ${issue2.origin ?? \"waarde\"} ${adj}${issue2.maximum.toString()} is`;\n        }\n      case \"too_small\":\n        {\n          const adj = issue2.inclusive ? \">=\" : \">\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            return `Te kort: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} bevat`;\n          }\n          return `Te kort: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} is`;\n        }\n      case \"invalid_format\":\n        {\n          const _issue = issue2;\n          if (_issue.format === \"starts_with\") {\n            return `Ongeldige tekst: moet met \"${_issue.prefix}\" beginnen`;\n          }\n          if (_issue.format === \"ends_with\") return `Ongeldige tekst: moet op \"${_issue.suffix}\" eindigen`;\n          if (_issue.format === \"includes\") return `Ongeldige tekst: moet \"${_issue.includes}\" bevatten`;\n          if (_issue.format === \"regex\") return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;\n          return `Ongeldig: ${Nouns[_issue.format] ?? issue2.format}`;\n        }\n      case \"not_multiple_of\":\n        return `Ongeldig getal: moet een veelvoud van ${issue2.divisor} zijn`;\n      case \"unrecognized_keys\":\n        return `Onbekende key${issue2.keys.length > 1 ? \"s\" : \"\"}: ${joinValues(issue2.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Ongeldige key in ${issue2.origin}`;\n      case \"invalid_union\":\n        return \"Ongeldige invoer\";\n      case \"invalid_element\":\n        return `Ongeldige waarde in ${issue2.origin}`;\n      default:\n        return `Ongeldige invoer`;\n    }\n  };\n};\nfunction nl_default() {\n  return {\n    localeError: error23()\n  };\n}\n\n// ../../node_modules/zod/v4/locales/no.js\nvar error24 = () => {\n  const Sizable = {\n    string: {\n      unit: \"tegn\",\n      verb: \"\\xE5 ha\"\n    },\n    file: {\n      unit: \"bytes\",\n      verb: \"\\xE5 ha\"\n    },\n    array: {\n      unit: \"elementer\",\n      verb: \"\\xE5 inneholde\"\n    },\n    set: {\n      unit: \"elementer\",\n      verb: \"\\xE5 inneholde\"\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType4 = data => {\n    const t = typeof data;\n    switch (t) {\n      case \"number\":\n        {\n          return Number.isNaN(data) ? \"NaN\" : \"tall\";\n        }\n      case \"object\":\n        {\n          if (Array.isArray(data)) {\n            return \"liste\";\n          }\n          if (data === null) {\n            return \"null\";\n          }\n          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n            return data.constructor.name;\n          }\n        }\n    }\n    return t;\n  };\n  const Nouns = {\n    regex: \"input\",\n    email: \"e-postadresse\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO dato- og klokkeslett\",\n    date: \"ISO-dato\",\n    time: \"ISO-klokkeslett\",\n    duration: \"ISO-varighet\",\n    ipv4: \"IPv4-omr\\xE5de\",\n    ipv6: \"IPv6-omr\\xE5de\",\n    cidrv4: \"IPv4-spekter\",\n    cidrv6: \"IPv6-spekter\",\n    base64: \"base64-enkodet streng\",\n    base64url: \"base64url-enkodet streng\",\n    json_string: \"JSON-streng\",\n    e164: \"E.164-nummer\",\n    jwt: \"JWT\",\n    template_literal: \"input\"\n  };\n  return issue2 => {\n    switch (issue2.code) {\n      case \"invalid_type\":\n        return `Ugyldig input: forventet ${issue2.expected}, fikk ${parsedType4(issue2.input)}`;\n      case \"invalid_value\":\n        if (issue2.values.length === 1) return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;\n        return `Ugyldig valg: forventet en av ${joinValues(issue2.values, \"|\")}`;\n      case \"too_big\":\n        {\n          const adj = issue2.inclusive ? \"<=\" : \"<\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) return `For stor(t): forventet ${issue2.origin ?? \"value\"} til \\xE5 ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? \"elementer\"}`;\n          return `For stor(t): forventet ${issue2.origin ?? \"value\"} til \\xE5 ha ${adj}${issue2.maximum.toString()}`;\n        }\n      case \"too_small\":\n        {\n          const adj = issue2.inclusive ? \">=\" : \">\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            return `For lite(n): forventet ${issue2.origin} til \\xE5 ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n          }\n          return `For lite(n): forventet ${issue2.origin} til \\xE5 ha ${adj}${issue2.minimum.toString()}`;\n        }\n      case \"invalid_format\":\n        {\n          const _issue = issue2;\n          if (_issue.format === \"starts_with\") return `Ugyldig streng: m\\xE5 starte med \"${_issue.prefix}\"`;\n          if (_issue.format === \"ends_with\") return `Ugyldig streng: m\\xE5 ende med \"${_issue.suffix}\"`;\n          if (_issue.format === \"includes\") return `Ugyldig streng: m\\xE5 inneholde \"${_issue.includes}\"`;\n          if (_issue.format === \"regex\") return `Ugyldig streng: m\\xE5 matche m\\xF8nsteret ${_issue.pattern}`;\n          return `Ugyldig ${Nouns[_issue.format] ?? issue2.format}`;\n        }\n      case \"not_multiple_of\":\n        return `Ugyldig tall: m\\xE5 v\\xE6re et multiplum av ${issue2.divisor}`;\n      case \"unrecognized_keys\":\n        return `${issue2.keys.length > 1 ? \"Ukjente n\\xF8kler\" : \"Ukjent n\\xF8kkel\"}: ${joinValues(issue2.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Ugyldig n\\xF8kkel i ${issue2.origin}`;\n      case \"invalid_union\":\n        return \"Ugyldig input\";\n      case \"invalid_element\":\n        return `Ugyldig verdi i ${issue2.origin}`;\n      default:\n        return `Ugyldig input`;\n    }\n  };\n};\nfunction no_default() {\n  return {\n    localeError: error24()\n  };\n}\n\n// ../../node_modules/zod/v4/locales/ota.js\nvar error25 = () => {\n  const Sizable = {\n    string: {\n      unit: \"harf\",\n      verb: \"olmal\\u0131d\\u0131r\"\n    },\n    file: {\n      unit: \"bayt\",\n      verb: \"olmal\\u0131d\\u0131r\"\n    },\n    array: {\n      unit: \"unsur\",\n      verb: \"olmal\\u0131d\\u0131r\"\n    },\n    set: {\n      unit: \"unsur\",\n      verb: \"olmal\\u0131d\\u0131r\"\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType4 = data => {\n    const t = typeof data;\n    switch (t) {\n      case \"number\":\n        {\n          return Number.isNaN(data) ? \"NaN\" : \"numara\";\n        }\n      case \"object\":\n        {\n          if (Array.isArray(data)) {\n            return \"saf\";\n          }\n          if (data === null) {\n            return \"gayb\";\n          }\n          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n            return data.constructor.name;\n          }\n        }\n    }\n    return t;\n  };\n  const Nouns = {\n    regex: \"giren\",\n    email: \"epostag\\xE2h\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO heng\\xE2m\\u0131\",\n    date: \"ISO tarihi\",\n    time: \"ISO zaman\\u0131\",\n    duration: \"ISO m\\xFCddeti\",\n    ipv4: \"IPv4 ni\\u015F\\xE2n\\u0131\",\n    ipv6: \"IPv6 ni\\u015F\\xE2n\\u0131\",\n    cidrv4: \"IPv4 menzili\",\n    cidrv6: \"IPv6 menzili\",\n    base64: \"base64-\\u015Fifreli metin\",\n    base64url: \"base64url-\\u015Fifreli metin\",\n    json_string: \"JSON metin\",\n    e164: \"E.164 say\\u0131s\\u0131\",\n    jwt: \"JWT\",\n    template_literal: \"giren\"\n  };\n  return issue2 => {\n    switch (issue2.code) {\n      case \"invalid_type\":\n        return `F\\xE2sit giren: umulan ${issue2.expected}, al\\u0131nan ${parsedType4(issue2.input)}`;\n      // return `Fâsit giren: umulan ${issue.expected}, alınan ${util.getParsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue2.values.length === 1) return `F\\xE2sit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;\n        return `F\\xE2sit tercih: m\\xFBteberler ${joinValues(issue2.values, \"|\")}`;\n      case \"too_big\":\n        {\n          const adj = issue2.inclusive ? \"<=\" : \"<\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) return `Fazla b\\xFCy\\xFCk: ${issue2.origin ?? \"value\"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? \"elements\"} sahip olmal\\u0131yd\\u0131.`;\n          return `Fazla b\\xFCy\\xFCk: ${issue2.origin ?? \"value\"}, ${adj}${issue2.maximum.toString()} olmal\\u0131yd\\u0131.`;\n        }\n      case \"too_small\":\n        {\n          const adj = issue2.inclusive ? \">=\" : \">\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            return `Fazla k\\xFC\\xE7\\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmal\\u0131yd\\u0131.`;\n          }\n          return `Fazla k\\xFC\\xE7\\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmal\\u0131yd\\u0131.`;\n        }\n      case \"invalid_format\":\n        {\n          const _issue = issue2;\n          if (_issue.format === \"starts_with\") return `F\\xE2sit metin: \"${_issue.prefix}\" ile ba\\u015Flamal\\u0131.`;\n          if (_issue.format === \"ends_with\") return `F\\xE2sit metin: \"${_issue.suffix}\" ile bitmeli.`;\n          if (_issue.format === \"includes\") return `F\\xE2sit metin: \"${_issue.includes}\" ihtiv\\xE2 etmeli.`;\n          if (_issue.format === \"regex\") return `F\\xE2sit metin: ${_issue.pattern} nak\\u015F\\u0131na uymal\\u0131.`;\n          return `F\\xE2sit ${Nouns[_issue.format] ?? issue2.format}`;\n        }\n      case \"not_multiple_of\":\n        return `F\\xE2sit say\\u0131: ${issue2.divisor} kat\\u0131 olmal\\u0131yd\\u0131.`;\n      case \"unrecognized_keys\":\n        return `Tan\\u0131nmayan anahtar ${issue2.keys.length > 1 ? \"s\" : \"\"}: ${joinValues(issue2.keys, \", \")}`;\n      case \"invalid_key\":\n        return `${issue2.origin} i\\xE7in tan\\u0131nmayan anahtar var.`;\n      case \"invalid_union\":\n        return \"Giren tan\\u0131namad\\u0131.\";\n      case \"invalid_element\":\n        return `${issue2.origin} i\\xE7in tan\\u0131nmayan k\\u0131ymet var.`;\n      default:\n        return `K\\u0131ymet tan\\u0131namad\\u0131.`;\n    }\n  };\n};\nfunction ota_default() {\n  return {\n    localeError: error25()\n  };\n}\n\n// ../../node_modules/zod/v4/locales/ps.js\nvar error26 = () => {\n  const Sizable = {\n    string: {\n      unit: \"\\u062A\\u0648\\u06A9\\u064A\",\n      verb: \"\\u0648\\u0644\\u0631\\u064A\"\n    },\n    file: {\n      unit: \"\\u0628\\u0627\\u06CC\\u067C\\u0633\",\n      verb: \"\\u0648\\u0644\\u0631\\u064A\"\n    },\n    array: {\n      unit: \"\\u062A\\u0648\\u06A9\\u064A\",\n      verb: \"\\u0648\\u0644\\u0631\\u064A\"\n    },\n    set: {\n      unit: \"\\u062A\\u0648\\u06A9\\u064A\",\n      verb: \"\\u0648\\u0644\\u0631\\u064A\"\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType4 = data => {\n    const t = typeof data;\n    switch (t) {\n      case \"number\":\n        {\n          return Number.isNaN(data) ? \"NaN\" : \"\\u0639\\u062F\\u062F\";\n        }\n      case \"object\":\n        {\n          if (Array.isArray(data)) {\n            return \"\\u0627\\u0631\\u06D0\";\n          }\n          if (data === null) {\n            return \"null\";\n          }\n          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n            return data.constructor.name;\n          }\n        }\n    }\n    return t;\n  };\n  const Nouns = {\n    regex: \"\\u0648\\u0631\\u0648\\u062F\\u064A\",\n    email: \"\\u0628\\u0631\\u06CC\\u069A\\u0646\\u0627\\u0644\\u06CC\\u06A9\",\n    url: \"\\u06CC\\u0648 \\u0622\\u0631 \\u0627\\u0644\",\n    emoji: \"\\u0627\\u06CC\\u0645\\u0648\\u062C\\u064A\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"\\u0646\\u06CC\\u067C\\u0647 \\u0627\\u0648 \\u0648\\u062E\\u062A\",\n    date: \"\\u0646\\u06D0\\u067C\\u0647\",\n    time: \"\\u0648\\u062E\\u062A\",\n    duration: \"\\u0645\\u0648\\u062F\\u0647\",\n    ipv4: \"\\u062F IPv4 \\u067E\\u062A\\u0647\",\n    ipv6: \"\\u062F IPv6 \\u067E\\u062A\\u0647\",\n    cidrv4: \"\\u062F IPv4 \\u0633\\u0627\\u062D\\u0647\",\n    cidrv6: \"\\u062F IPv6 \\u0633\\u0627\\u062D\\u0647\",\n    base64: \"base64-encoded \\u0645\\u062A\\u0646\",\n    base64url: \"base64url-encoded \\u0645\\u062A\\u0646\",\n    json_string: \"JSON \\u0645\\u062A\\u0646\",\n    e164: \"\\u062F E.164 \\u0634\\u0645\\u06D0\\u0631\\u0647\",\n    jwt: \"JWT\",\n    template_literal: \"\\u0648\\u0631\\u0648\\u062F\\u064A\"\n  };\n  return issue2 => {\n    switch (issue2.code) {\n      case \"invalid_type\":\n        return `\\u0646\\u0627\\u0633\\u0645 \\u0648\\u0631\\u0648\\u062F\\u064A: \\u0628\\u0627\\u06CC\\u062F ${issue2.expected} \\u0648\\u0627\\u06CC, \\u0645\\u06AB\\u0631 ${parsedType4(issue2.input)} \\u062A\\u0631\\u0644\\u0627\\u0633\\u0647 \\u0634\\u0648`;\n      case \"invalid_value\":\n        if (issue2.values.length === 1) {\n          return `\\u0646\\u0627\\u0633\\u0645 \\u0648\\u0631\\u0648\\u062F\\u064A: \\u0628\\u0627\\u06CC\\u062F ${stringifyPrimitive(issue2.values[0])} \\u0648\\u0627\\u06CC`;\n        }\n        return `\\u0646\\u0627\\u0633\\u0645 \\u0627\\u0646\\u062A\\u062E\\u0627\\u0628: \\u0628\\u0627\\u06CC\\u062F \\u06CC\\u0648 \\u0644\\u0647 ${joinValues(issue2.values, \"|\")} \\u0685\\u062E\\u0647 \\u0648\\u0627\\u06CC`;\n      case \"too_big\":\n        {\n          const adj = issue2.inclusive ? \"<=\" : \"<\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            return `\\u0689\\u06CC\\u0631 \\u0644\\u0648\\u06CC: ${issue2.origin ?? \"\\u0627\\u0631\\u0632\\u069A\\u062A\"} \\u0628\\u0627\\u06CC\\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? \"\\u0639\\u0646\\u0635\\u0631\\u0648\\u0646\\u0647\"} \\u0648\\u0644\\u0631\\u064A`;\n          }\n          return `\\u0689\\u06CC\\u0631 \\u0644\\u0648\\u06CC: ${issue2.origin ?? \"\\u0627\\u0631\\u0632\\u069A\\u062A\"} \\u0628\\u0627\\u06CC\\u062F ${adj}${issue2.maximum.toString()} \\u0648\\u064A`;\n        }\n      case \"too_small\":\n        {\n          const adj = issue2.inclusive ? \">=\" : \">\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            return `\\u0689\\u06CC\\u0631 \\u06A9\\u0648\\u0686\\u0646\\u06CC: ${issue2.origin} \\u0628\\u0627\\u06CC\\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \\u0648\\u0644\\u0631\\u064A`;\n          }\n          return `\\u0689\\u06CC\\u0631 \\u06A9\\u0648\\u0686\\u0646\\u06CC: ${issue2.origin} \\u0628\\u0627\\u06CC\\u062F ${adj}${issue2.minimum.toString()} \\u0648\\u064A`;\n        }\n      case \"invalid_format\":\n        {\n          const _issue = issue2;\n          if (_issue.format === \"starts_with\") {\n            return `\\u0646\\u0627\\u0633\\u0645 \\u0645\\u062A\\u0646: \\u0628\\u0627\\u06CC\\u062F \\u062F \"${_issue.prefix}\" \\u0633\\u0631\\u0647 \\u067E\\u06CC\\u0644 \\u0634\\u064A`;\n          }\n          if (_issue.format === \"ends_with\") {\n            return `\\u0646\\u0627\\u0633\\u0645 \\u0645\\u062A\\u0646: \\u0628\\u0627\\u06CC\\u062F \\u062F \"${_issue.suffix}\" \\u0633\\u0631\\u0647 \\u067E\\u0627\\u06CC \\u062A\\u0647 \\u0648\\u0631\\u0633\\u064A\\u0696\\u064A`;\n          }\n          if (_issue.format === \"includes\") {\n            return `\\u0646\\u0627\\u0633\\u0645 \\u0645\\u062A\\u0646: \\u0628\\u0627\\u06CC\\u062F \"${_issue.includes}\" \\u0648\\u0644\\u0631\\u064A`;\n          }\n          if (_issue.format === \"regex\") {\n            return `\\u0646\\u0627\\u0633\\u0645 \\u0645\\u062A\\u0646: \\u0628\\u0627\\u06CC\\u062F \\u062F ${_issue.pattern} \\u0633\\u0631\\u0647 \\u0645\\u0637\\u0627\\u0628\\u0642\\u062A \\u0648\\u0644\\u0631\\u064A`;\n          }\n          return `${Nouns[_issue.format] ?? issue2.format} \\u0646\\u0627\\u0633\\u0645 \\u062F\\u06CC`;\n        }\n      case \"not_multiple_of\":\n        return `\\u0646\\u0627\\u0633\\u0645 \\u0639\\u062F\\u062F: \\u0628\\u0627\\u06CC\\u062F \\u062F ${issue2.divisor} \\u0645\\u0636\\u0631\\u0628 \\u0648\\u064A`;\n      case \"unrecognized_keys\":\n        return `\\u0646\\u0627\\u0633\\u0645 ${issue2.keys.length > 1 ? \"\\u06A9\\u0644\\u06CC\\u0689\\u0648\\u0646\\u0647\" : \"\\u06A9\\u0644\\u06CC\\u0689\"}: ${joinValues(issue2.keys, \", \")}`;\n      case \"invalid_key\":\n        return `\\u0646\\u0627\\u0633\\u0645 \\u06A9\\u0644\\u06CC\\u0689 \\u067E\\u0647 ${issue2.origin} \\u06A9\\u06D0`;\n      case \"invalid_union\":\n        return `\\u0646\\u0627\\u0633\\u0645\\u0647 \\u0648\\u0631\\u0648\\u062F\\u064A`;\n      case \"invalid_element\":\n        return `\\u0646\\u0627\\u0633\\u0645 \\u0639\\u0646\\u0635\\u0631 \\u067E\\u0647 ${issue2.origin} \\u06A9\\u06D0`;\n      default:\n        return `\\u0646\\u0627\\u0633\\u0645\\u0647 \\u0648\\u0631\\u0648\\u062F\\u064A`;\n    }\n  };\n};\nfunction ps_default() {\n  return {\n    localeError: error26()\n  };\n}\n\n// ../../node_modules/zod/v4/locales/pl.js\nvar error27 = () => {\n  const Sizable = {\n    string: {\n      unit: \"znak\\xF3w\",\n      verb: \"mie\\u0107\"\n    },\n    file: {\n      unit: \"bajt\\xF3w\",\n      verb: \"mie\\u0107\"\n    },\n    array: {\n      unit: \"element\\xF3w\",\n      verb: \"mie\\u0107\"\n    },\n    set: {\n      unit: \"element\\xF3w\",\n      verb: \"mie\\u0107\"\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType4 = data => {\n    const t = typeof data;\n    switch (t) {\n      case \"number\":\n        {\n          return Number.isNaN(data) ? \"NaN\" : \"liczba\";\n        }\n      case \"object\":\n        {\n          if (Array.isArray(data)) {\n            return \"tablica\";\n          }\n          if (data === null) {\n            return \"null\";\n          }\n          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n            return data.constructor.name;\n          }\n        }\n    }\n    return t;\n  };\n  const Nouns = {\n    regex: \"wyra\\u017Cenie\",\n    email: \"adres email\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"data i godzina w formacie ISO\",\n    date: \"data w formacie ISO\",\n    time: \"godzina w formacie ISO\",\n    duration: \"czas trwania ISO\",\n    ipv4: \"adres IPv4\",\n    ipv6: \"adres IPv6\",\n    cidrv4: \"zakres IPv4\",\n    cidrv6: \"zakres IPv6\",\n    base64: \"ci\\u0105g znak\\xF3w zakodowany w formacie base64\",\n    base64url: \"ci\\u0105g znak\\xF3w zakodowany w formacie base64url\",\n    json_string: \"ci\\u0105g znak\\xF3w w formacie JSON\",\n    e164: \"liczba E.164\",\n    jwt: \"JWT\",\n    template_literal: \"wej\\u015Bcie\"\n  };\n  return issue2 => {\n    switch (issue2.code) {\n      case \"invalid_type\":\n        return `Nieprawid\\u0142owe dane wej\\u015Bciowe: oczekiwano ${issue2.expected}, otrzymano ${parsedType4(issue2.input)}`;\n      case \"invalid_value\":\n        if (issue2.values.length === 1) return `Nieprawid\\u0142owe dane wej\\u015Bciowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;\n        return `Nieprawid\\u0142owa opcja: oczekiwano jednej z warto\\u015Bci ${joinValues(issue2.values, \"|\")}`;\n      case \"too_big\":\n        {\n          const adj = issue2.inclusive ? \"<=\" : \"<\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            return `Za du\\u017Ca warto\\u015B\\u0107: oczekiwano, \\u017Ce ${issue2.origin ?? \"warto\\u015B\\u0107\"} b\\u0119dzie mie\\u0107 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? \"element\\xF3w\"}`;\n          }\n          return `Zbyt du\\u017C(y/a/e): oczekiwano, \\u017Ce ${issue2.origin ?? \"warto\\u015B\\u0107\"} b\\u0119dzie wynosi\\u0107 ${adj}${issue2.maximum.toString()}`;\n        }\n      case \"too_small\":\n        {\n          const adj = issue2.inclusive ? \">=\" : \">\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            return `Za ma\\u0142a warto\\u015B\\u0107: oczekiwano, \\u017Ce ${issue2.origin ?? \"warto\\u015B\\u0107\"} b\\u0119dzie mie\\u0107 ${adj}${issue2.minimum.toString()} ${sizing.unit ?? \"element\\xF3w\"}`;\n          }\n          return `Zbyt ma\\u0142(y/a/e): oczekiwano, \\u017Ce ${issue2.origin ?? \"warto\\u015B\\u0107\"} b\\u0119dzie wynosi\\u0107 ${adj}${issue2.minimum.toString()}`;\n        }\n      case \"invalid_format\":\n        {\n          const _issue = issue2;\n          if (_issue.format === \"starts_with\") return `Nieprawid\\u0142owy ci\\u0105g znak\\xF3w: musi zaczyna\\u0107 si\\u0119 od \"${_issue.prefix}\"`;\n          if (_issue.format === \"ends_with\") return `Nieprawid\\u0142owy ci\\u0105g znak\\xF3w: musi ko\\u0144czy\\u0107 si\\u0119 na \"${_issue.suffix}\"`;\n          if (_issue.format === \"includes\") return `Nieprawid\\u0142owy ci\\u0105g znak\\xF3w: musi zawiera\\u0107 \"${_issue.includes}\"`;\n          if (_issue.format === \"regex\") return `Nieprawid\\u0142owy ci\\u0105g znak\\xF3w: musi odpowiada\\u0107 wzorcowi ${_issue.pattern}`;\n          return `Nieprawid\\u0142ow(y/a/e) ${Nouns[_issue.format] ?? issue2.format}`;\n        }\n      case \"not_multiple_of\":\n        return `Nieprawid\\u0142owa liczba: musi by\\u0107 wielokrotno\\u015Bci\\u0105 ${issue2.divisor}`;\n      case \"unrecognized_keys\":\n        return `Nierozpoznane klucze${issue2.keys.length > 1 ? \"s\" : \"\"}: ${joinValues(issue2.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Nieprawid\\u0142owy klucz w ${issue2.origin}`;\n      case \"invalid_union\":\n        return \"Nieprawid\\u0142owe dane wej\\u015Bciowe\";\n      case \"invalid_element\":\n        return `Nieprawid\\u0142owa warto\\u015B\\u0107 w ${issue2.origin}`;\n      default:\n        return `Nieprawid\\u0142owe dane wej\\u015Bciowe`;\n    }\n  };\n};\nfunction pl_default() {\n  return {\n    localeError: error27()\n  };\n}\n\n// ../../node_modules/zod/v4/locales/pt.js\nvar error28 = () => {\n  const Sizable = {\n    string: {\n      unit: \"caracteres\",\n      verb: \"ter\"\n    },\n    file: {\n      unit: \"bytes\",\n      verb: \"ter\"\n    },\n    array: {\n      unit: \"itens\",\n      verb: \"ter\"\n    },\n    set: {\n      unit: \"itens\",\n      verb: \"ter\"\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType4 = data => {\n    const t = typeof data;\n    switch (t) {\n      case \"number\":\n        {\n          return Number.isNaN(data) ? \"NaN\" : \"n\\xFAmero\";\n        }\n      case \"object\":\n        {\n          if (Array.isArray(data)) {\n            return \"array\";\n          }\n          if (data === null) {\n            return \"nulo\";\n          }\n          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n            return data.constructor.name;\n          }\n        }\n    }\n    return t;\n  };\n  const Nouns = {\n    regex: \"padr\\xE3o\",\n    email: \"endere\\xE7o de e-mail\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"data e hora ISO\",\n    date: \"data ISO\",\n    time: \"hora ISO\",\n    duration: \"dura\\xE7\\xE3o ISO\",\n    ipv4: \"endere\\xE7o IPv4\",\n    ipv6: \"endere\\xE7o IPv6\",\n    cidrv4: \"faixa de IPv4\",\n    cidrv6: \"faixa de IPv6\",\n    base64: \"texto codificado em base64\",\n    base64url: \"URL codificada em base64\",\n    json_string: \"texto JSON\",\n    e164: \"n\\xFAmero E.164\",\n    jwt: \"JWT\",\n    template_literal: \"entrada\"\n  };\n  return issue2 => {\n    switch (issue2.code) {\n      case \"invalid_type\":\n        return `Tipo inv\\xE1lido: esperado ${issue2.expected}, recebido ${parsedType4(issue2.input)}`;\n      case \"invalid_value\":\n        if (issue2.values.length === 1) return `Entrada inv\\xE1lida: esperado ${stringifyPrimitive(issue2.values[0])}`;\n        return `Op\\xE7\\xE3o inv\\xE1lida: esperada uma das ${joinValues(issue2.values, \"|\")}`;\n      case \"too_big\":\n        {\n          const adj = issue2.inclusive ? \"<=\" : \"<\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) return `Muito grande: esperado que ${issue2.origin ?? \"valor\"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? \"elementos\"}`;\n          return `Muito grande: esperado que ${issue2.origin ?? \"valor\"} fosse ${adj}${issue2.maximum.toString()}`;\n        }\n      case \"too_small\":\n        {\n          const adj = issue2.inclusive ? \">=\" : \">\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n          }\n          return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;\n        }\n      case \"invalid_format\":\n        {\n          const _issue = issue2;\n          if (_issue.format === \"starts_with\") return `Texto inv\\xE1lido: deve come\\xE7ar com \"${_issue.prefix}\"`;\n          if (_issue.format === \"ends_with\") return `Texto inv\\xE1lido: deve terminar com \"${_issue.suffix}\"`;\n          if (_issue.format === \"includes\") return `Texto inv\\xE1lido: deve incluir \"${_issue.includes}\"`;\n          if (_issue.format === \"regex\") return `Texto inv\\xE1lido: deve corresponder ao padr\\xE3o ${_issue.pattern}`;\n          return `${Nouns[_issue.format] ?? issue2.format} inv\\xE1lido`;\n        }\n      case \"not_multiple_of\":\n        return `N\\xFAmero inv\\xE1lido: deve ser m\\xFAltiplo de ${issue2.divisor}`;\n      case \"unrecognized_keys\":\n        return `Chave${issue2.keys.length > 1 ? \"s\" : \"\"} desconhecida${issue2.keys.length > 1 ? \"s\" : \"\"}: ${joinValues(issue2.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Chave inv\\xE1lida em ${issue2.origin}`;\n      case \"invalid_union\":\n        return \"Entrada inv\\xE1lida\";\n      case \"invalid_element\":\n        return `Valor inv\\xE1lido em ${issue2.origin}`;\n      default:\n        return `Campo inv\\xE1lido`;\n    }\n  };\n};\nfunction pt_default() {\n  return {\n    localeError: error28()\n  };\n}\n\n// ../../node_modules/zod/v4/locales/ru.js\nfunction getRussianPlural(count, one, few, many) {\n  const absCount = Math.abs(count);\n  const lastDigit = absCount % 10;\n  const lastTwoDigits = absCount % 100;\n  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {\n    return many;\n  }\n  if (lastDigit === 1) {\n    return one;\n  }\n  if (lastDigit >= 2 && lastDigit <= 4) {\n    return few;\n  }\n  return many;\n}\nvar error29 = () => {\n  const Sizable = {\n    string: {\n      unit: {\n        one: \"\\u0441\\u0438\\u043C\\u0432\\u043E\\u043B\",\n        few: \"\\u0441\\u0438\\u043C\\u0432\\u043E\\u043B\\u0430\",\n        many: \"\\u0441\\u0438\\u043C\\u0432\\u043E\\u043B\\u043E\\u0432\"\n      },\n      verb: \"\\u0438\\u043C\\u0435\\u0442\\u044C\"\n    },\n    file: {\n      unit: {\n        one: \"\\u0431\\u0430\\u0439\\u0442\",\n        few: \"\\u0431\\u0430\\u0439\\u0442\\u0430\",\n        many: \"\\u0431\\u0430\\u0439\\u0442\"\n      },\n      verb: \"\\u0438\\u043C\\u0435\\u0442\\u044C\"\n    },\n    array: {\n      unit: {\n        one: \"\\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\",\n        few: \"\\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0430\",\n        many: \"\\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u043E\\u0432\"\n      },\n      verb: \"\\u0438\\u043C\\u0435\\u0442\\u044C\"\n    },\n    set: {\n      unit: {\n        one: \"\\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\",\n        few: \"\\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0430\",\n        many: \"\\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u043E\\u0432\"\n      },\n      verb: \"\\u0438\\u043C\\u0435\\u0442\\u044C\"\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType4 = data => {\n    const t = typeof data;\n    switch (t) {\n      case \"number\":\n        {\n          return Number.isNaN(data) ? \"NaN\" : \"\\u0447\\u0438\\u0441\\u043B\\u043E\";\n        }\n      case \"object\":\n        {\n          if (Array.isArray(data)) {\n            return \"\\u043C\\u0430\\u0441\\u0441\\u0438\\u0432\";\n          }\n          if (data === null) {\n            return \"null\";\n          }\n          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n            return data.constructor.name;\n          }\n        }\n    }\n    return t;\n  };\n  const Nouns = {\n    regex: \"\\u0432\\u0432\\u043E\\u0434\",\n    email: \"email \\u0430\\u0434\\u0440\\u0435\\u0441\",\n    url: \"URL\",\n    emoji: \"\\u044D\\u043C\\u043E\\u0434\\u0437\\u0438\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO \\u0434\\u0430\\u0442\\u0430 \\u0438 \\u0432\\u0440\\u0435\\u043C\\u044F\",\n    date: \"ISO \\u0434\\u0430\\u0442\\u0430\",\n    time: \"ISO \\u0432\\u0440\\u0435\\u043C\\u044F\",\n    duration: \"ISO \\u0434\\u043B\\u0438\\u0442\\u0435\\u043B\\u044C\\u043D\\u043E\\u0441\\u0442\\u044C\",\n    ipv4: \"IPv4 \\u0430\\u0434\\u0440\\u0435\\u0441\",\n    ipv6: \"IPv6 \\u0430\\u0434\\u0440\\u0435\\u0441\",\n    cidrv4: \"IPv4 \\u0434\\u0438\\u0430\\u043F\\u0430\\u0437\\u043E\\u043D\",\n    cidrv6: \"IPv6 \\u0434\\u0438\\u0430\\u043F\\u0430\\u0437\\u043E\\u043D\",\n    base64: \"\\u0441\\u0442\\u0440\\u043E\\u043A\\u0430 \\u0432 \\u0444\\u043E\\u0440\\u043C\\u0430\\u0442\\u0435 base64\",\n    base64url: \"\\u0441\\u0442\\u0440\\u043E\\u043A\\u0430 \\u0432 \\u0444\\u043E\\u0440\\u043C\\u0430\\u0442\\u0435 base64url\",\n    json_string: \"JSON \\u0441\\u0442\\u0440\\u043E\\u043A\\u0430\",\n    e164: \"\\u043D\\u043E\\u043C\\u0435\\u0440 E.164\",\n    jwt: \"JWT\",\n    template_literal: \"\\u0432\\u0432\\u043E\\u0434\"\n  };\n  return issue2 => {\n    switch (issue2.code) {\n      case \"invalid_type\":\n        return `\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u044B\\u0439 \\u0432\\u0432\\u043E\\u0434: \\u043E\\u0436\\u0438\\u0434\\u0430\\u043B\\u043E\\u0441\\u044C ${issue2.expected}, \\u043F\\u043E\\u043B\\u0443\\u0447\\u0435\\u043D\\u043E ${parsedType4(issue2.input)}`;\n      case \"invalid_value\":\n        if (issue2.values.length === 1) return `\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u044B\\u0439 \\u0432\\u0432\\u043E\\u0434: \\u043E\\u0436\\u0438\\u0434\\u0430\\u043B\\u043E\\u0441\\u044C ${stringifyPrimitive(issue2.values[0])}`;\n        return `\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u044B\\u0439 \\u0432\\u0430\\u0440\\u0438\\u0430\\u043D\\u0442: \\u043E\\u0436\\u0438\\u0434\\u0430\\u043B\\u043E\\u0441\\u044C \\u043E\\u0434\\u043D\\u043E \\u0438\\u0437 ${joinValues(issue2.values, \"|\")}`;\n      case \"too_big\":\n        {\n          const adj = issue2.inclusive ? \"<=\" : \"<\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            const maxValue = Number(issue2.maximum);\n            const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);\n            return `\\u0421\\u043B\\u0438\\u0448\\u043A\\u043E\\u043C \\u0431\\u043E\\u043B\\u044C\\u0448\\u043E\\u0435 \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435: \\u043E\\u0436\\u0438\\u0434\\u0430\\u043B\\u043E\\u0441\\u044C, \\u0447\\u0442\\u043E ${issue2.origin ?? \"\\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435\"} \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0438\\u043C\\u0435\\u0442\\u044C ${adj}${issue2.maximum.toString()} ${unit}`;\n          }\n          return `\\u0421\\u043B\\u0438\\u0448\\u043A\\u043E\\u043C \\u0431\\u043E\\u043B\\u044C\\u0448\\u043E\\u0435 \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435: \\u043E\\u0436\\u0438\\u0434\\u0430\\u043B\\u043E\\u0441\\u044C, \\u0447\\u0442\\u043E ${issue2.origin ?? \"\\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435\"} \\u0431\\u0443\\u0434\\u0435\\u0442 ${adj}${issue2.maximum.toString()}`;\n        }\n      case \"too_small\":\n        {\n          const adj = issue2.inclusive ? \">=\" : \">\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            const minValue = Number(issue2.minimum);\n            const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);\n            return `\\u0421\\u043B\\u0438\\u0448\\u043A\\u043E\\u043C \\u043C\\u0430\\u043B\\u0435\\u043D\\u044C\\u043A\\u043E\\u0435 \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435: \\u043E\\u0436\\u0438\\u0434\\u0430\\u043B\\u043E\\u0441\\u044C, \\u0447\\u0442\\u043E ${issue2.origin} \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0438\\u043C\\u0435\\u0442\\u044C ${adj}${issue2.minimum.toString()} ${unit}`;\n          }\n          return `\\u0421\\u043B\\u0438\\u0448\\u043A\\u043E\\u043C \\u043C\\u0430\\u043B\\u0435\\u043D\\u044C\\u043A\\u043E\\u0435 \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435: \\u043E\\u0436\\u0438\\u0434\\u0430\\u043B\\u043E\\u0441\\u044C, \\u0447\\u0442\\u043E ${issue2.origin} \\u0431\\u0443\\u0434\\u0435\\u0442 ${adj}${issue2.minimum.toString()}`;\n        }\n      case \"invalid_format\":\n        {\n          const _issue = issue2;\n          if (_issue.format === \"starts_with\") return `\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u0430\\u044F \\u0441\\u0442\\u0440\\u043E\\u043A\\u0430: \\u0434\\u043E\\u043B\\u0436\\u043D\\u0430 \\u043D\\u0430\\u0447\\u0438\\u043D\\u0430\\u0442\\u044C\\u0441\\u044F \\u0441 \"${_issue.prefix}\"`;\n          if (_issue.format === \"ends_with\") return `\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u0430\\u044F \\u0441\\u0442\\u0440\\u043E\\u043A\\u0430: \\u0434\\u043E\\u043B\\u0436\\u043D\\u0430 \\u0437\\u0430\\u043A\\u0430\\u043D\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430 \"${_issue.suffix}\"`;\n          if (_issue.format === \"includes\") return `\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u0430\\u044F \\u0441\\u0442\\u0440\\u043E\\u043A\\u0430: \\u0434\\u043E\\u043B\\u0436\\u043D\\u0430 \\u0441\\u043E\\u0434\\u0435\\u0440\\u0436\\u0430\\u0442\\u044C \"${_issue.includes}\"`;\n          if (_issue.format === \"regex\") return `\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u0430\\u044F \\u0441\\u0442\\u0440\\u043E\\u043A\\u0430: \\u0434\\u043E\\u043B\\u0436\\u043D\\u0430 \\u0441\\u043E\\u043E\\u0442\\u0432\\u0435\\u0442\\u0441\\u0442\\u0432\\u043E\\u0432\\u0430\\u0442\\u044C \\u0448\\u0430\\u0431\\u043B\\u043E\\u043D\\u0443 ${_issue.pattern}`;\n          return `\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u044B\\u0439 ${Nouns[_issue.format] ?? issue2.format}`;\n        }\n      case \"not_multiple_of\":\n        return `\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u043E\\u0435 \\u0447\\u0438\\u0441\\u043B\\u043E: \\u0434\\u043E\\u043B\\u0436\\u043D\\u043E \\u0431\\u044B\\u0442\\u044C \\u043A\\u0440\\u0430\\u0442\\u043D\\u044B\\u043C ${issue2.divisor}`;\n      case \"unrecognized_keys\":\n        return `\\u041D\\u0435\\u0440\\u0430\\u0441\\u043F\\u043E\\u0437\\u043D\\u0430\\u043D\\u043D${issue2.keys.length > 1 ? \"\\u044B\\u0435\" : \"\\u044B\\u0439\"} \\u043A\\u043B\\u044E\\u0447${issue2.keys.length > 1 ? \"\\u0438\" : \"\"}: ${joinValues(issue2.keys, \", \")}`;\n      case \"invalid_key\":\n        return `\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u044B\\u0439 \\u043A\\u043B\\u044E\\u0447 \\u0432 ${issue2.origin}`;\n      case \"invalid_union\":\n        return \"\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u044B\\u0435 \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0435 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0435\";\n      case \"invalid_element\":\n        return `\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u043E\\u0435 \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435 \\u0432 ${issue2.origin}`;\n      default:\n        return `\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u044B\\u0435 \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0435 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0435`;\n    }\n  };\n};\nfunction ru_default() {\n  return {\n    localeError: error29()\n  };\n}\n\n// ../../node_modules/zod/v4/locales/sl.js\nvar error30 = () => {\n  const Sizable = {\n    string: {\n      unit: \"znakov\",\n      verb: \"imeti\"\n    },\n    file: {\n      unit: \"bajtov\",\n      verb: \"imeti\"\n    },\n    array: {\n      unit: \"elementov\",\n      verb: \"imeti\"\n    },\n    set: {\n      unit: \"elementov\",\n      verb: \"imeti\"\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType4 = data => {\n    const t = typeof data;\n    switch (t) {\n      case \"number\":\n        {\n          return Number.isNaN(data) ? \"NaN\" : \"\\u0161tevilo\";\n        }\n      case \"object\":\n        {\n          if (Array.isArray(data)) {\n            return \"tabela\";\n          }\n          if (data === null) {\n            return \"null\";\n          }\n          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n            return data.constructor.name;\n          }\n        }\n    }\n    return t;\n  };\n  const Nouns = {\n    regex: \"vnos\",\n    email: \"e-po\\u0161tni naslov\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO datum in \\u010Das\",\n    date: \"ISO datum\",\n    time: \"ISO \\u010Das\",\n    duration: \"ISO trajanje\",\n    ipv4: \"IPv4 naslov\",\n    ipv6: \"IPv6 naslov\",\n    cidrv4: \"obseg IPv4\",\n    cidrv6: \"obseg IPv6\",\n    base64: \"base64 kodiran niz\",\n    base64url: \"base64url kodiran niz\",\n    json_string: \"JSON niz\",\n    e164: \"E.164 \\u0161tevilka\",\n    jwt: \"JWT\",\n    template_literal: \"vnos\"\n  };\n  return issue2 => {\n    switch (issue2.code) {\n      case \"invalid_type\":\n        return `Neveljaven vnos: pri\\u010Dakovano ${issue2.expected}, prejeto ${parsedType4(issue2.input)}`;\n      case \"invalid_value\":\n        if (issue2.values.length === 1) return `Neveljaven vnos: pri\\u010Dakovano ${stringifyPrimitive(issue2.values[0])}`;\n        return `Neveljavna mo\\u017Enost: pri\\u010Dakovano eno izmed ${joinValues(issue2.values, \"|\")}`;\n      case \"too_big\":\n        {\n          const adj = issue2.inclusive ? \"<=\" : \"<\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) return `Preveliko: pri\\u010Dakovano, da bo ${issue2.origin ?? \"vrednost\"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? \"elementov\"}`;\n          return `Preveliko: pri\\u010Dakovano, da bo ${issue2.origin ?? \"vrednost\"} ${adj}${issue2.maximum.toString()}`;\n        }\n      case \"too_small\":\n        {\n          const adj = issue2.inclusive ? \">=\" : \">\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            return `Premajhno: pri\\u010Dakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n          }\n          return `Premajhno: pri\\u010Dakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;\n        }\n      case \"invalid_format\":\n        {\n          const _issue = issue2;\n          if (_issue.format === \"starts_with\") {\n            return `Neveljaven niz: mora se za\\u010Deti z \"${_issue.prefix}\"`;\n          }\n          if (_issue.format === \"ends_with\") return `Neveljaven niz: mora se kon\\u010Dati z \"${_issue.suffix}\"`;\n          if (_issue.format === \"includes\") return `Neveljaven niz: mora vsebovati \"${_issue.includes}\"`;\n          if (_issue.format === \"regex\") return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;\n          return `Neveljaven ${Nouns[_issue.format] ?? issue2.format}`;\n        }\n      case \"not_multiple_of\":\n        return `Neveljavno \\u0161tevilo: mora biti ve\\u010Dkratnik ${issue2.divisor}`;\n      case \"unrecognized_keys\":\n        return `Neprepoznan${issue2.keys.length > 1 ? \"i klju\\u010Di\" : \" klju\\u010D\"}: ${joinValues(issue2.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Neveljaven klju\\u010D v ${issue2.origin}`;\n      case \"invalid_union\":\n        return \"Neveljaven vnos\";\n      case \"invalid_element\":\n        return `Neveljavna vrednost v ${issue2.origin}`;\n      default:\n        return \"Neveljaven vnos\";\n    }\n  };\n};\nfunction sl_default() {\n  return {\n    localeError: error30()\n  };\n}\n\n// ../../node_modules/zod/v4/locales/sv.js\nvar error31 = () => {\n  const Sizable = {\n    string: {\n      unit: \"tecken\",\n      verb: \"att ha\"\n    },\n    file: {\n      unit: \"bytes\",\n      verb: \"att ha\"\n    },\n    array: {\n      unit: \"objekt\",\n      verb: \"att inneh\\xE5lla\"\n    },\n    set: {\n      unit: \"objekt\",\n      verb: \"att inneh\\xE5lla\"\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType4 = data => {\n    const t = typeof data;\n    switch (t) {\n      case \"number\":\n        {\n          return Number.isNaN(data) ? \"NaN\" : \"antal\";\n        }\n      case \"object\":\n        {\n          if (Array.isArray(data)) {\n            return \"lista\";\n          }\n          if (data === null) {\n            return \"null\";\n          }\n          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n            return data.constructor.name;\n          }\n        }\n    }\n    return t;\n  };\n  const Nouns = {\n    regex: \"regulj\\xE4rt uttryck\",\n    email: \"e-postadress\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO-datum och tid\",\n    date: \"ISO-datum\",\n    time: \"ISO-tid\",\n    duration: \"ISO-varaktighet\",\n    ipv4: \"IPv4-intervall\",\n    ipv6: \"IPv6-intervall\",\n    cidrv4: \"IPv4-spektrum\",\n    cidrv6: \"IPv6-spektrum\",\n    base64: \"base64-kodad str\\xE4ng\",\n    base64url: \"base64url-kodad str\\xE4ng\",\n    json_string: \"JSON-str\\xE4ng\",\n    e164: \"E.164-nummer\",\n    jwt: \"JWT\",\n    template_literal: \"mall-literal\"\n  };\n  return issue2 => {\n    switch (issue2.code) {\n      case \"invalid_type\":\n        return `Ogiltig inmatning: f\\xF6rv\\xE4ntat ${issue2.expected}, fick ${parsedType4(issue2.input)}`;\n      case \"invalid_value\":\n        if (issue2.values.length === 1) return `Ogiltig inmatning: f\\xF6rv\\xE4ntat ${stringifyPrimitive(issue2.values[0])}`;\n        return `Ogiltigt val: f\\xF6rv\\xE4ntade en av ${joinValues(issue2.values, \"|\")}`;\n      case \"too_big\":\n        {\n          const adj = issue2.inclusive ? \"<=\" : \"<\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            return `F\\xF6r stor(t): f\\xF6rv\\xE4ntade ${issue2.origin ?? \"v\\xE4rdet\"} att ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? \"element\"}`;\n          }\n          return `F\\xF6r stor(t): f\\xF6rv\\xE4ntat ${issue2.origin ?? \"v\\xE4rdet\"} att ha ${adj}${issue2.maximum.toString()}`;\n        }\n      case \"too_small\":\n        {\n          const adj = issue2.inclusive ? \">=\" : \">\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            return `F\\xF6r lite(t): f\\xF6rv\\xE4ntade ${issue2.origin ?? \"v\\xE4rdet\"} att ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n          }\n          return `F\\xF6r lite(t): f\\xF6rv\\xE4ntade ${issue2.origin ?? \"v\\xE4rdet\"} att ha ${adj}${issue2.minimum.toString()}`;\n        }\n      case \"invalid_format\":\n        {\n          const _issue = issue2;\n          if (_issue.format === \"starts_with\") {\n            return `Ogiltig str\\xE4ng: m\\xE5ste b\\xF6rja med \"${_issue.prefix}\"`;\n          }\n          if (_issue.format === \"ends_with\") return `Ogiltig str\\xE4ng: m\\xE5ste sluta med \"${_issue.suffix}\"`;\n          if (_issue.format === \"includes\") return `Ogiltig str\\xE4ng: m\\xE5ste inneh\\xE5lla \"${_issue.includes}\"`;\n          if (_issue.format === \"regex\") return `Ogiltig str\\xE4ng: m\\xE5ste matcha m\\xF6nstret \"${_issue.pattern}\"`;\n          return `Ogiltig(t) ${Nouns[_issue.format] ?? issue2.format}`;\n        }\n      case \"not_multiple_of\":\n        return `Ogiltigt tal: m\\xE5ste vara en multipel av ${issue2.divisor}`;\n      case \"unrecognized_keys\":\n        return `${issue2.keys.length > 1 ? \"Ok\\xE4nda nycklar\" : \"Ok\\xE4nd nyckel\"}: ${joinValues(issue2.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Ogiltig nyckel i ${issue2.origin ?? \"v\\xE4rdet\"}`;\n      case \"invalid_union\":\n        return \"Ogiltig input\";\n      case \"invalid_element\":\n        return `Ogiltigt v\\xE4rde i ${issue2.origin ?? \"v\\xE4rdet\"}`;\n      default:\n        return `Ogiltig input`;\n    }\n  };\n};\nfunction sv_default() {\n  return {\n    localeError: error31()\n  };\n}\n\n// ../../node_modules/zod/v4/locales/ta.js\nvar error32 = () => {\n  const Sizable = {\n    string: {\n      unit: \"\\u0B8E\\u0BB4\\u0BC1\\u0BA4\\u0BCD\\u0BA4\\u0BC1\\u0B95\\u0BCD\\u0B95\\u0BB3\\u0BCD\",\n      verb: \"\\u0B95\\u0BCA\\u0BA3\\u0BCD\\u0B9F\\u0BBF\\u0BB0\\u0BC1\\u0B95\\u0BCD\\u0B95 \\u0BB5\\u0BC7\\u0BA3\\u0BCD\\u0B9F\\u0BC1\\u0BAE\\u0BCD\"\n    },\n    file: {\n      unit: \"\\u0BAA\\u0BC8\\u0B9F\\u0BCD\\u0B9F\\u0BC1\\u0B95\\u0BB3\\u0BCD\",\n      verb: \"\\u0B95\\u0BCA\\u0BA3\\u0BCD\\u0B9F\\u0BBF\\u0BB0\\u0BC1\\u0B95\\u0BCD\\u0B95 \\u0BB5\\u0BC7\\u0BA3\\u0BCD\\u0B9F\\u0BC1\\u0BAE\\u0BCD\"\n    },\n    array: {\n      unit: \"\\u0B89\\u0BB1\\u0BC1\\u0BAA\\u0BCD\\u0BAA\\u0BC1\\u0B95\\u0BB3\\u0BCD\",\n      verb: \"\\u0B95\\u0BCA\\u0BA3\\u0BCD\\u0B9F\\u0BBF\\u0BB0\\u0BC1\\u0B95\\u0BCD\\u0B95 \\u0BB5\\u0BC7\\u0BA3\\u0BCD\\u0B9F\\u0BC1\\u0BAE\\u0BCD\"\n    },\n    set: {\n      unit: \"\\u0B89\\u0BB1\\u0BC1\\u0BAA\\u0BCD\\u0BAA\\u0BC1\\u0B95\\u0BB3\\u0BCD\",\n      verb: \"\\u0B95\\u0BCA\\u0BA3\\u0BCD\\u0B9F\\u0BBF\\u0BB0\\u0BC1\\u0B95\\u0BCD\\u0B95 \\u0BB5\\u0BC7\\u0BA3\\u0BCD\\u0B9F\\u0BC1\\u0BAE\\u0BCD\"\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType4 = data => {\n    const t = typeof data;\n    switch (t) {\n      case \"number\":\n        {\n          return Number.isNaN(data) ? \"\\u0B8E\\u0BA3\\u0BCD \\u0B85\\u0BB2\\u0BCD\\u0BB2\\u0BBE\\u0BA4\\u0BA4\\u0BC1\" : \"\\u0B8E\\u0BA3\\u0BCD\";\n        }\n      case \"object\":\n        {\n          if (Array.isArray(data)) {\n            return \"\\u0B85\\u0BA3\\u0BBF\";\n          }\n          if (data === null) {\n            return \"\\u0BB5\\u0BC6\\u0BB1\\u0BC1\\u0BAE\\u0BC8\";\n          }\n          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n            return data.constructor.name;\n          }\n        }\n    }\n    return t;\n  };\n  const Nouns = {\n    regex: \"\\u0B89\\u0BB3\\u0BCD\\u0BB3\\u0BC0\\u0B9F\\u0BC1\",\n    email: \"\\u0BAE\\u0BBF\\u0BA9\\u0BCD\\u0BA9\\u0B9E\\u0BCD\\u0B9A\\u0BB2\\u0BCD \\u0BAE\\u0BC1\\u0B95\\u0BB5\\u0BB0\\u0BBF\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO \\u0BA4\\u0BC7\\u0BA4\\u0BBF \\u0BA8\\u0BC7\\u0BB0\\u0BAE\\u0BCD\",\n    date: \"ISO \\u0BA4\\u0BC7\\u0BA4\\u0BBF\",\n    time: \"ISO \\u0BA8\\u0BC7\\u0BB0\\u0BAE\\u0BCD\",\n    duration: \"ISO \\u0B95\\u0BBE\\u0BB2 \\u0B85\\u0BB3\\u0BB5\\u0BC1\",\n    ipv4: \"IPv4 \\u0BAE\\u0BC1\\u0B95\\u0BB5\\u0BB0\\u0BBF\",\n    ipv6: \"IPv6 \\u0BAE\\u0BC1\\u0B95\\u0BB5\\u0BB0\\u0BBF\",\n    cidrv4: \"IPv4 \\u0BB5\\u0BB0\\u0BAE\\u0BCD\\u0BAA\\u0BC1\",\n    cidrv6: \"IPv6 \\u0BB5\\u0BB0\\u0BAE\\u0BCD\\u0BAA\\u0BC1\",\n    base64: \"base64-encoded \\u0B9A\\u0BB0\\u0BAE\\u0BCD\",\n    base64url: \"base64url-encoded \\u0B9A\\u0BB0\\u0BAE\\u0BCD\",\n    json_string: \"JSON \\u0B9A\\u0BB0\\u0BAE\\u0BCD\",\n    e164: \"E.164 \\u0B8E\\u0BA3\\u0BCD\",\n    jwt: \"JWT\",\n    template_literal: \"input\"\n  };\n  return issue2 => {\n    switch (issue2.code) {\n      case \"invalid_type\":\n        return `\\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 \\u0B89\\u0BB3\\u0BCD\\u0BB3\\u0BC0\\u0B9F\\u0BC1: \\u0B8E\\u0BA4\\u0BBF\\u0BB0\\u0BCD\\u0BAA\\u0BBE\\u0BB0\\u0BCD\\u0B95\\u0BCD\\u0B95\\u0BAA\\u0BCD\\u0BAA\\u0B9F\\u0BCD\\u0B9F\\u0BA4\\u0BC1 ${issue2.expected}, \\u0BAA\\u0BC6\\u0BB1\\u0BAA\\u0BCD\\u0BAA\\u0B9F\\u0BCD\\u0B9F\\u0BA4\\u0BC1 ${parsedType4(issue2.input)}`;\n      case \"invalid_value\":\n        if (issue2.values.length === 1) return `\\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 \\u0B89\\u0BB3\\u0BCD\\u0BB3\\u0BC0\\u0B9F\\u0BC1: \\u0B8E\\u0BA4\\u0BBF\\u0BB0\\u0BCD\\u0BAA\\u0BBE\\u0BB0\\u0BCD\\u0B95\\u0BCD\\u0B95\\u0BAA\\u0BCD\\u0BAA\\u0B9F\\u0BCD\\u0B9F\\u0BA4\\u0BC1 ${stringifyPrimitive(issue2.values[0])}`;\n        return `\\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 \\u0BB5\\u0BBF\\u0BB0\\u0BC1\\u0BAA\\u0BCD\\u0BAA\\u0BAE\\u0BCD: \\u0B8E\\u0BA4\\u0BBF\\u0BB0\\u0BCD\\u0BAA\\u0BBE\\u0BB0\\u0BCD\\u0B95\\u0BCD\\u0B95\\u0BAA\\u0BCD\\u0BAA\\u0B9F\\u0BCD\\u0B9F\\u0BA4\\u0BC1 ${joinValues(issue2.values, \"|\")} \\u0B87\\u0BB2\\u0BCD \\u0B92\\u0BA9\\u0BCD\\u0BB1\\u0BC1`;\n      case \"too_big\":\n        {\n          const adj = issue2.inclusive ? \"<=\" : \"<\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            return `\\u0BAE\\u0BBF\\u0B95 \\u0BAA\\u0BC6\\u0BB0\\u0BBF\\u0BAF\\u0BA4\\u0BC1: \\u0B8E\\u0BA4\\u0BBF\\u0BB0\\u0BCD\\u0BAA\\u0BBE\\u0BB0\\u0BCD\\u0B95\\u0BCD\\u0B95\\u0BAA\\u0BCD\\u0BAA\\u0B9F\\u0BCD\\u0B9F\\u0BA4\\u0BC1 ${issue2.origin ?? \"\\u0BAE\\u0BA4\\u0BBF\\u0BAA\\u0BCD\\u0BAA\\u0BC1\"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? \"\\u0B89\\u0BB1\\u0BC1\\u0BAA\\u0BCD\\u0BAA\\u0BC1\\u0B95\\u0BB3\\u0BCD\"} \\u0B86\\u0B95 \\u0B87\\u0BB0\\u0BC1\\u0B95\\u0BCD\\u0B95 \\u0BB5\\u0BC7\\u0BA3\\u0BCD\\u0B9F\\u0BC1\\u0BAE\\u0BCD`;\n          }\n          return `\\u0BAE\\u0BBF\\u0B95 \\u0BAA\\u0BC6\\u0BB0\\u0BBF\\u0BAF\\u0BA4\\u0BC1: \\u0B8E\\u0BA4\\u0BBF\\u0BB0\\u0BCD\\u0BAA\\u0BBE\\u0BB0\\u0BCD\\u0B95\\u0BCD\\u0B95\\u0BAA\\u0BCD\\u0BAA\\u0B9F\\u0BCD\\u0B9F\\u0BA4\\u0BC1 ${issue2.origin ?? \"\\u0BAE\\u0BA4\\u0BBF\\u0BAA\\u0BCD\\u0BAA\\u0BC1\"} ${adj}${issue2.maximum.toString()} \\u0B86\\u0B95 \\u0B87\\u0BB0\\u0BC1\\u0B95\\u0BCD\\u0B95 \\u0BB5\\u0BC7\\u0BA3\\u0BCD\\u0B9F\\u0BC1\\u0BAE\\u0BCD`;\n        }\n      case \"too_small\":\n        {\n          const adj = issue2.inclusive ? \">=\" : \">\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            return `\\u0BAE\\u0BBF\\u0B95\\u0B9A\\u0BCD \\u0B9A\\u0BBF\\u0BB1\\u0BBF\\u0BAF\\u0BA4\\u0BC1: \\u0B8E\\u0BA4\\u0BBF\\u0BB0\\u0BCD\\u0BAA\\u0BBE\\u0BB0\\u0BCD\\u0B95\\u0BCD\\u0B95\\u0BAA\\u0BCD\\u0BAA\\u0B9F\\u0BCD\\u0B9F\\u0BA4\\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} \\u0B86\\u0B95 \\u0B87\\u0BB0\\u0BC1\\u0B95\\u0BCD\\u0B95 \\u0BB5\\u0BC7\\u0BA3\\u0BCD\\u0B9F\\u0BC1\\u0BAE\\u0BCD`;\n          }\n          return `\\u0BAE\\u0BBF\\u0B95\\u0B9A\\u0BCD \\u0B9A\\u0BBF\\u0BB1\\u0BBF\\u0BAF\\u0BA4\\u0BC1: \\u0B8E\\u0BA4\\u0BBF\\u0BB0\\u0BCD\\u0BAA\\u0BBE\\u0BB0\\u0BCD\\u0B95\\u0BCD\\u0B95\\u0BAA\\u0BCD\\u0BAA\\u0B9F\\u0BCD\\u0B9F\\u0BA4\\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} \\u0B86\\u0B95 \\u0B87\\u0BB0\\u0BC1\\u0B95\\u0BCD\\u0B95 \\u0BB5\\u0BC7\\u0BA3\\u0BCD\\u0B9F\\u0BC1\\u0BAE\\u0BCD`;\n        }\n      case \"invalid_format\":\n        {\n          const _issue = issue2;\n          if (_issue.format === \"starts_with\") return `\\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 \\u0B9A\\u0BB0\\u0BAE\\u0BCD: \"${_issue.prefix}\" \\u0B87\\u0BB2\\u0BCD \\u0BA4\\u0BCA\\u0B9F\\u0B99\\u0BCD\\u0B95 \\u0BB5\\u0BC7\\u0BA3\\u0BCD\\u0B9F\\u0BC1\\u0BAE\\u0BCD`;\n          if (_issue.format === \"ends_with\") return `\\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 \\u0B9A\\u0BB0\\u0BAE\\u0BCD: \"${_issue.suffix}\" \\u0B87\\u0BB2\\u0BCD \\u0BAE\\u0BC1\\u0B9F\\u0BBF\\u0BB5\\u0B9F\\u0BC8\\u0BAF \\u0BB5\\u0BC7\\u0BA3\\u0BCD\\u0B9F\\u0BC1\\u0BAE\\u0BCD`;\n          if (_issue.format === \"includes\") return `\\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 \\u0B9A\\u0BB0\\u0BAE\\u0BCD: \"${_issue.includes}\" \\u0B90 \\u0B89\\u0BB3\\u0BCD\\u0BB3\\u0B9F\\u0B95\\u0BCD\\u0B95 \\u0BB5\\u0BC7\\u0BA3\\u0BCD\\u0B9F\\u0BC1\\u0BAE\\u0BCD`;\n          if (_issue.format === \"regex\") return `\\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 \\u0B9A\\u0BB0\\u0BAE\\u0BCD: ${_issue.pattern} \\u0BAE\\u0BC1\\u0BB1\\u0BC8\\u0BAA\\u0BBE\\u0B9F\\u0BCD\\u0B9F\\u0BC1\\u0B9F\\u0BA9\\u0BCD \\u0BAA\\u0BCA\\u0BB0\\u0BC1\\u0BA8\\u0BCD\\u0BA4 \\u0BB5\\u0BC7\\u0BA3\\u0BCD\\u0B9F\\u0BC1\\u0BAE\\u0BCD`;\n          return `\\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 ${Nouns[_issue.format] ?? issue2.format}`;\n        }\n      case \"not_multiple_of\":\n        return `\\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 \\u0B8E\\u0BA3\\u0BCD: ${issue2.divisor} \\u0B87\\u0BA9\\u0BCD \\u0BAA\\u0BB2\\u0BAE\\u0BBE\\u0B95 \\u0B87\\u0BB0\\u0BC1\\u0B95\\u0BCD\\u0B95 \\u0BB5\\u0BC7\\u0BA3\\u0BCD\\u0B9F\\u0BC1\\u0BAE\\u0BCD`;\n      case \"unrecognized_keys\":\n        return `\\u0B85\\u0B9F\\u0BC8\\u0BAF\\u0BBE\\u0BB3\\u0BAE\\u0BCD \\u0BA4\\u0BC6\\u0BB0\\u0BBF\\u0BAF\\u0BBE\\u0BA4 \\u0BB5\\u0BBF\\u0B9A\\u0BC8${issue2.keys.length > 1 ? \"\\u0B95\\u0BB3\\u0BCD\" : \"\"}: ${joinValues(issue2.keys, \", \")}`;\n      case \"invalid_key\":\n        return `${issue2.origin} \\u0B87\\u0BB2\\u0BCD \\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 \\u0BB5\\u0BBF\\u0B9A\\u0BC8`;\n      case \"invalid_union\":\n        return \"\\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 \\u0B89\\u0BB3\\u0BCD\\u0BB3\\u0BC0\\u0B9F\\u0BC1\";\n      case \"invalid_element\":\n        return `${issue2.origin} \\u0B87\\u0BB2\\u0BCD \\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 \\u0BAE\\u0BA4\\u0BBF\\u0BAA\\u0BCD\\u0BAA\\u0BC1`;\n      default:\n        return `\\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 \\u0B89\\u0BB3\\u0BCD\\u0BB3\\u0BC0\\u0B9F\\u0BC1`;\n    }\n  };\n};\nfunction ta_default() {\n  return {\n    localeError: error32()\n  };\n}\n\n// ../../node_modules/zod/v4/locales/th.js\nvar error33 = () => {\n  const Sizable = {\n    string: {\n      unit: \"\\u0E15\\u0E31\\u0E27\\u0E2D\\u0E31\\u0E01\\u0E29\\u0E23\",\n      verb: \"\\u0E04\\u0E27\\u0E23\\u0E21\\u0E35\"\n    },\n    file: {\n      unit: \"\\u0E44\\u0E1A\\u0E15\\u0E4C\",\n      verb: \"\\u0E04\\u0E27\\u0E23\\u0E21\\u0E35\"\n    },\n    array: {\n      unit: \"\\u0E23\\u0E32\\u0E22\\u0E01\\u0E32\\u0E23\",\n      verb: \"\\u0E04\\u0E27\\u0E23\\u0E21\\u0E35\"\n    },\n    set: {\n      unit: \"\\u0E23\\u0E32\\u0E22\\u0E01\\u0E32\\u0E23\",\n      verb: \"\\u0E04\\u0E27\\u0E23\\u0E21\\u0E35\"\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType4 = data => {\n    const t = typeof data;\n    switch (t) {\n      case \"number\":\n        {\n          return Number.isNaN(data) ? \"\\u0E44\\u0E21\\u0E48\\u0E43\\u0E0A\\u0E48\\u0E15\\u0E31\\u0E27\\u0E40\\u0E25\\u0E02 (NaN)\" : \"\\u0E15\\u0E31\\u0E27\\u0E40\\u0E25\\u0E02\";\n        }\n      case \"object\":\n        {\n          if (Array.isArray(data)) {\n            return \"\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C (Array)\";\n          }\n          if (data === null) {\n            return \"\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E04\\u0E48\\u0E32 (null)\";\n          }\n          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n            return data.constructor.name;\n          }\n        }\n    }\n    return t;\n  };\n  const Nouns = {\n    regex: \"\\u0E02\\u0E49\\u0E2D\\u0E21\\u0E39\\u0E25\\u0E17\\u0E35\\u0E48\\u0E1B\\u0E49\\u0E2D\\u0E19\",\n    email: \"\\u0E17\\u0E35\\u0E48\\u0E2D\\u0E22\\u0E39\\u0E48\\u0E2D\\u0E35\\u0E40\\u0E21\\u0E25\",\n    url: \"URL\",\n    emoji: \"\\u0E2D\\u0E34\\u0E42\\u0E21\\u0E08\\u0E34\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"\\u0E27\\u0E31\\u0E19\\u0E17\\u0E35\\u0E48\\u0E40\\u0E27\\u0E25\\u0E32\\u0E41\\u0E1A\\u0E1A ISO\",\n    date: \"\\u0E27\\u0E31\\u0E19\\u0E17\\u0E35\\u0E48\\u0E41\\u0E1A\\u0E1A ISO\",\n    time: \"\\u0E40\\u0E27\\u0E25\\u0E32\\u0E41\\u0E1A\\u0E1A ISO\",\n    duration: \"\\u0E0A\\u0E48\\u0E27\\u0E07\\u0E40\\u0E27\\u0E25\\u0E32\\u0E41\\u0E1A\\u0E1A ISO\",\n    ipv4: \"\\u0E17\\u0E35\\u0E48\\u0E2D\\u0E22\\u0E39\\u0E48 IPv4\",\n    ipv6: \"\\u0E17\\u0E35\\u0E48\\u0E2D\\u0E22\\u0E39\\u0E48 IPv6\",\n    cidrv4: \"\\u0E0A\\u0E48\\u0E27\\u0E07 IP \\u0E41\\u0E1A\\u0E1A IPv4\",\n    cidrv6: \"\\u0E0A\\u0E48\\u0E27\\u0E07 IP \\u0E41\\u0E1A\\u0E1A IPv6\",\n    base64: \"\\u0E02\\u0E49\\u0E2D\\u0E04\\u0E27\\u0E32\\u0E21\\u0E41\\u0E1A\\u0E1A Base64\",\n    base64url: \"\\u0E02\\u0E49\\u0E2D\\u0E04\\u0E27\\u0E32\\u0E21\\u0E41\\u0E1A\\u0E1A Base64 \\u0E2A\\u0E33\\u0E2B\\u0E23\\u0E31\\u0E1A URL\",\n    json_string: \"\\u0E02\\u0E49\\u0E2D\\u0E04\\u0E27\\u0E32\\u0E21\\u0E41\\u0E1A\\u0E1A JSON\",\n    e164: \"\\u0E40\\u0E1A\\u0E2D\\u0E23\\u0E4C\\u0E42\\u0E17\\u0E23\\u0E28\\u0E31\\u0E1E\\u0E17\\u0E4C\\u0E23\\u0E30\\u0E2B\\u0E27\\u0E48\\u0E32\\u0E07\\u0E1B\\u0E23\\u0E30\\u0E40\\u0E17\\u0E28 (E.164)\",\n    jwt: \"\\u0E42\\u0E17\\u0E40\\u0E04\\u0E19 JWT\",\n    template_literal: \"\\u0E02\\u0E49\\u0E2D\\u0E21\\u0E39\\u0E25\\u0E17\\u0E35\\u0E48\\u0E1B\\u0E49\\u0E2D\\u0E19\"\n  };\n  return issue2 => {\n    switch (issue2.code) {\n      case \"invalid_type\":\n        return `\\u0E1B\\u0E23\\u0E30\\u0E40\\u0E20\\u0E17\\u0E02\\u0E49\\u0E2D\\u0E21\\u0E39\\u0E25\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07: \\u0E04\\u0E27\\u0E23\\u0E40\\u0E1B\\u0E47\\u0E19 ${issue2.expected} \\u0E41\\u0E15\\u0E48\\u0E44\\u0E14\\u0E49\\u0E23\\u0E31\\u0E1A ${parsedType4(issue2.input)}`;\n      case \"invalid_value\":\n        if (issue2.values.length === 1) return `\\u0E04\\u0E48\\u0E32\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07: \\u0E04\\u0E27\\u0E23\\u0E40\\u0E1B\\u0E47\\u0E19 ${stringifyPrimitive(issue2.values[0])}`;\n        return `\\u0E15\\u0E31\\u0E27\\u0E40\\u0E25\\u0E37\\u0E2D\\u0E01\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07: \\u0E04\\u0E27\\u0E23\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E43\\u0E19 ${joinValues(issue2.values, \"|\")}`;\n      case \"too_big\":\n        {\n          const adj = issue2.inclusive ? \"\\u0E44\\u0E21\\u0E48\\u0E40\\u0E01\\u0E34\\u0E19\" : \"\\u0E19\\u0E49\\u0E2D\\u0E22\\u0E01\\u0E27\\u0E48\\u0E32\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) return `\\u0E40\\u0E01\\u0E34\\u0E19\\u0E01\\u0E33\\u0E2B\\u0E19\\u0E14: ${issue2.origin ?? \"\\u0E04\\u0E48\\u0E32\"} \\u0E04\\u0E27\\u0E23\\u0E21\\u0E35${adj} ${issue2.maximum.toString()} ${sizing.unit ?? \"\\u0E23\\u0E32\\u0E22\\u0E01\\u0E32\\u0E23\"}`;\n          return `\\u0E40\\u0E01\\u0E34\\u0E19\\u0E01\\u0E33\\u0E2B\\u0E19\\u0E14: ${issue2.origin ?? \"\\u0E04\\u0E48\\u0E32\"} \\u0E04\\u0E27\\u0E23\\u0E21\\u0E35${adj} ${issue2.maximum.toString()}`;\n        }\n      case \"too_small\":\n        {\n          const adj = issue2.inclusive ? \"\\u0E2D\\u0E22\\u0E48\\u0E32\\u0E07\\u0E19\\u0E49\\u0E2D\\u0E22\" : \"\\u0E21\\u0E32\\u0E01\\u0E01\\u0E27\\u0E48\\u0E32\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            return `\\u0E19\\u0E49\\u0E2D\\u0E22\\u0E01\\u0E27\\u0E48\\u0E32\\u0E01\\u0E33\\u0E2B\\u0E19\\u0E14: ${issue2.origin} \\u0E04\\u0E27\\u0E23\\u0E21\\u0E35${adj} ${issue2.minimum.toString()} ${sizing.unit}`;\n          }\n          return `\\u0E19\\u0E49\\u0E2D\\u0E22\\u0E01\\u0E27\\u0E48\\u0E32\\u0E01\\u0E33\\u0E2B\\u0E19\\u0E14: ${issue2.origin} \\u0E04\\u0E27\\u0E23\\u0E21\\u0E35${adj} ${issue2.minimum.toString()}`;\n        }\n      case \"invalid_format\":\n        {\n          const _issue = issue2;\n          if (_issue.format === \"starts_with\") {\n            return `\\u0E23\\u0E39\\u0E1B\\u0E41\\u0E1A\\u0E1A\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07: \\u0E02\\u0E49\\u0E2D\\u0E04\\u0E27\\u0E32\\u0E21\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E02\\u0E36\\u0E49\\u0E19\\u0E15\\u0E49\\u0E19\\u0E14\\u0E49\\u0E27\\u0E22 \"${_issue.prefix}\"`;\n          }\n          if (_issue.format === \"ends_with\") return `\\u0E23\\u0E39\\u0E1B\\u0E41\\u0E1A\\u0E1A\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07: \\u0E02\\u0E49\\u0E2D\\u0E04\\u0E27\\u0E32\\u0E21\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E25\\u0E07\\u0E17\\u0E49\\u0E32\\u0E22\\u0E14\\u0E49\\u0E27\\u0E22 \"${_issue.suffix}\"`;\n          if (_issue.format === \"includes\") return `\\u0E23\\u0E39\\u0E1B\\u0E41\\u0E1A\\u0E1A\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07: \\u0E02\\u0E49\\u0E2D\\u0E04\\u0E27\\u0E32\\u0E21\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E21\\u0E35 \"${_issue.includes}\" \\u0E2D\\u0E22\\u0E39\\u0E48\\u0E43\\u0E19\\u0E02\\u0E49\\u0E2D\\u0E04\\u0E27\\u0E32\\u0E21`;\n          if (_issue.format === \"regex\") return `\\u0E23\\u0E39\\u0E1B\\u0E41\\u0E1A\\u0E1A\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07: \\u0E15\\u0E49\\u0E2D\\u0E07\\u0E15\\u0E23\\u0E07\\u0E01\\u0E31\\u0E1A\\u0E23\\u0E39\\u0E1B\\u0E41\\u0E1A\\u0E1A\\u0E17\\u0E35\\u0E48\\u0E01\\u0E33\\u0E2B\\u0E19\\u0E14 ${_issue.pattern}`;\n          return `\\u0E23\\u0E39\\u0E1B\\u0E41\\u0E1A\\u0E1A\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07: ${Nouns[_issue.format] ?? issue2.format}`;\n        }\n      case \"not_multiple_of\":\n        return `\\u0E15\\u0E31\\u0E27\\u0E40\\u0E25\\u0E02\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07: \\u0E15\\u0E49\\u0E2D\\u0E07\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E33\\u0E19\\u0E27\\u0E19\\u0E17\\u0E35\\u0E48\\u0E2B\\u0E32\\u0E23\\u0E14\\u0E49\\u0E27\\u0E22 ${issue2.divisor} \\u0E44\\u0E14\\u0E49\\u0E25\\u0E07\\u0E15\\u0E31\\u0E27`;\n      case \"unrecognized_keys\":\n        return `\\u0E1E\\u0E1A\\u0E04\\u0E35\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E44\\u0E21\\u0E48\\u0E23\\u0E39\\u0E49\\u0E08\\u0E31\\u0E01: ${joinValues(issue2.keys, \", \")}`;\n      case \"invalid_key\":\n        return `\\u0E04\\u0E35\\u0E22\\u0E4C\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E19 ${issue2.origin}`;\n      case \"invalid_union\":\n        return \"\\u0E02\\u0E49\\u0E2D\\u0E21\\u0E39\\u0E25\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07: \\u0E44\\u0E21\\u0E48\\u0E15\\u0E23\\u0E07\\u0E01\\u0E31\\u0E1A\\u0E23\\u0E39\\u0E1B\\u0E41\\u0E1A\\u0E1A\\u0E22\\u0E39\\u0E40\\u0E19\\u0E35\\u0E22\\u0E19\\u0E17\\u0E35\\u0E48\\u0E01\\u0E33\\u0E2B\\u0E19\\u0E14\\u0E44\\u0E27\\u0E49\";\n      case \"invalid_element\":\n        return `\\u0E02\\u0E49\\u0E2D\\u0E21\\u0E39\\u0E25\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E19 ${issue2.origin}`;\n      default:\n        return `\\u0E02\\u0E49\\u0E2D\\u0E21\\u0E39\\u0E25\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07`;\n    }\n  };\n};\nfunction th_default() {\n  return {\n    localeError: error33()\n  };\n}\n\n// ../../node_modules/zod/v4/locales/tr.js\nvar parsedType3 = data => {\n  const t = typeof data;\n  switch (t) {\n    case \"number\":\n      {\n        return Number.isNaN(data) ? \"NaN\" : \"number\";\n      }\n    case \"object\":\n      {\n        if (Array.isArray(data)) {\n          return \"array\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n  }\n  return t;\n};\nvar error34 = () => {\n  const Sizable = {\n    string: {\n      unit: \"karakter\",\n      verb: \"olmal\\u0131\"\n    },\n    file: {\n      unit: \"bayt\",\n      verb: \"olmal\\u0131\"\n    },\n    array: {\n      unit: \"\\xF6\\u011Fe\",\n      verb: \"olmal\\u0131\"\n    },\n    set: {\n      unit: \"\\xF6\\u011Fe\",\n      verb: \"olmal\\u0131\"\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const Nouns = {\n    regex: \"girdi\",\n    email: \"e-posta adresi\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO tarih ve saat\",\n    date: \"ISO tarih\",\n    time: \"ISO saat\",\n    duration: \"ISO s\\xFCre\",\n    ipv4: \"IPv4 adresi\",\n    ipv6: \"IPv6 adresi\",\n    cidrv4: \"IPv4 aral\\u0131\\u011F\\u0131\",\n    cidrv6: \"IPv6 aral\\u0131\\u011F\\u0131\",\n    base64: \"base64 ile \\u015Fifrelenmi\\u015F metin\",\n    base64url: \"base64url ile \\u015Fifrelenmi\\u015F metin\",\n    json_string: \"JSON dizesi\",\n    e164: \"E.164 say\\u0131s\\u0131\",\n    jwt: \"JWT\",\n    template_literal: \"\\u015Eablon dizesi\"\n  };\n  return issue2 => {\n    switch (issue2.code) {\n      case \"invalid_type\":\n        return `Ge\\xE7ersiz de\\u011Fer: beklenen ${issue2.expected}, al\\u0131nan ${parsedType3(issue2.input)}`;\n      case \"invalid_value\":\n        if (issue2.values.length === 1) return `Ge\\xE7ersiz de\\u011Fer: beklenen ${stringifyPrimitive(issue2.values[0])}`;\n        return `Ge\\xE7ersiz se\\xE7enek: a\\u015Fa\\u011F\\u0131dakilerden biri olmal\\u0131: ${joinValues(issue2.values, \"|\")}`;\n      case \"too_big\":\n        {\n          const adj = issue2.inclusive ? \"<=\" : \"<\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) return `\\xC7ok b\\xFCy\\xFCk: beklenen ${issue2.origin ?? \"de\\u011Fer\"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? \"\\xF6\\u011Fe\"}`;\n          return `\\xC7ok b\\xFCy\\xFCk: beklenen ${issue2.origin ?? \"de\\u011Fer\"} ${adj}${issue2.maximum.toString()}`;\n        }\n      case \"too_small\":\n        {\n          const adj = issue2.inclusive ? \">=\" : \">\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) return `\\xC7ok k\\xFC\\xE7\\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n          return `\\xC7ok k\\xFC\\xE7\\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;\n        }\n      case \"invalid_format\":\n        {\n          const _issue = issue2;\n          if (_issue.format === \"starts_with\") return `Ge\\xE7ersiz metin: \"${_issue.prefix}\" ile ba\\u015Flamal\\u0131`;\n          if (_issue.format === \"ends_with\") return `Ge\\xE7ersiz metin: \"${_issue.suffix}\" ile bitmeli`;\n          if (_issue.format === \"includes\") return `Ge\\xE7ersiz metin: \"${_issue.includes}\" i\\xE7ermeli`;\n          if (_issue.format === \"regex\") return `Ge\\xE7ersiz metin: ${_issue.pattern} desenine uymal\\u0131`;\n          return `Ge\\xE7ersiz ${Nouns[_issue.format] ?? issue2.format}`;\n        }\n      case \"not_multiple_of\":\n        return `Ge\\xE7ersiz say\\u0131: ${issue2.divisor} ile tam b\\xF6l\\xFCnebilmeli`;\n      case \"unrecognized_keys\":\n        return `Tan\\u0131nmayan anahtar${issue2.keys.length > 1 ? \"lar\" : \"\"}: ${joinValues(issue2.keys, \", \")}`;\n      case \"invalid_key\":\n        return `${issue2.origin} i\\xE7inde ge\\xE7ersiz anahtar`;\n      case \"invalid_union\":\n        return \"Ge\\xE7ersiz de\\u011Fer\";\n      case \"invalid_element\":\n        return `${issue2.origin} i\\xE7inde ge\\xE7ersiz de\\u011Fer`;\n      default:\n        return `Ge\\xE7ersiz de\\u011Fer`;\n    }\n  };\n};\nfunction tr_default() {\n  return {\n    localeError: error34()\n  };\n}\n\n// ../../node_modules/zod/v4/locales/ua.js\nvar error35 = () => {\n  const Sizable = {\n    string: {\n      unit: \"\\u0441\\u0438\\u043C\\u0432\\u043E\\u043B\\u0456\\u0432\",\n      verb: \"\\u043C\\u0430\\u0442\\u0438\\u043C\\u0435\"\n    },\n    file: {\n      unit: \"\\u0431\\u0430\\u0439\\u0442\\u0456\\u0432\",\n      verb: \"\\u043C\\u0430\\u0442\\u0438\\u043C\\u0435\"\n    },\n    array: {\n      unit: \"\\u0435\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0456\\u0432\",\n      verb: \"\\u043C\\u0430\\u0442\\u0438\\u043C\\u0435\"\n    },\n    set: {\n      unit: \"\\u0435\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0456\\u0432\",\n      verb: \"\\u043C\\u0430\\u0442\\u0438\\u043C\\u0435\"\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType4 = data => {\n    const t = typeof data;\n    switch (t) {\n      case \"number\":\n        {\n          return Number.isNaN(data) ? \"NaN\" : \"\\u0447\\u0438\\u0441\\u043B\\u043E\";\n        }\n      case \"object\":\n        {\n          if (Array.isArray(data)) {\n            return \"\\u043C\\u0430\\u0441\\u0438\\u0432\";\n          }\n          if (data === null) {\n            return \"null\";\n          }\n          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n            return data.constructor.name;\n          }\n        }\n    }\n    return t;\n  };\n  const Nouns = {\n    regex: \"\\u0432\\u0445\\u0456\\u0434\\u043D\\u0456 \\u0434\\u0430\\u043D\\u0456\",\n    email: \"\\u0430\\u0434\\u0440\\u0435\\u0441\\u0430 \\u0435\\u043B\\u0435\\u043A\\u0442\\u0440\\u043E\\u043D\\u043D\\u043E\\u0457 \\u043F\\u043E\\u0448\\u0442\\u0438\",\n    url: \"URL\",\n    emoji: \"\\u0435\\u043C\\u043E\\u0434\\u0437\\u0456\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"\\u0434\\u0430\\u0442\\u0430 \\u0442\\u0430 \\u0447\\u0430\\u0441 ISO\",\n    date: \"\\u0434\\u0430\\u0442\\u0430 ISO\",\n    time: \"\\u0447\\u0430\\u0441 ISO\",\n    duration: \"\\u0442\\u0440\\u0438\\u0432\\u0430\\u043B\\u0456\\u0441\\u0442\\u044C ISO\",\n    ipv4: \"\\u0430\\u0434\\u0440\\u0435\\u0441\\u0430 IPv4\",\n    ipv6: \"\\u0430\\u0434\\u0440\\u0435\\u0441\\u0430 IPv6\",\n    cidrv4: \"\\u0434\\u0456\\u0430\\u043F\\u0430\\u0437\\u043E\\u043D IPv4\",\n    cidrv6: \"\\u0434\\u0456\\u0430\\u043F\\u0430\\u0437\\u043E\\u043D IPv6\",\n    base64: \"\\u0440\\u044F\\u0434\\u043E\\u043A \\u0443 \\u043A\\u043E\\u0434\\u0443\\u0432\\u0430\\u043D\\u043D\\u0456 base64\",\n    base64url: \"\\u0440\\u044F\\u0434\\u043E\\u043A \\u0443 \\u043A\\u043E\\u0434\\u0443\\u0432\\u0430\\u043D\\u043D\\u0456 base64url\",\n    json_string: \"\\u0440\\u044F\\u0434\\u043E\\u043A JSON\",\n    e164: \"\\u043D\\u043E\\u043C\\u0435\\u0440 E.164\",\n    jwt: \"JWT\",\n    template_literal: \"\\u0432\\u0445\\u0456\\u0434\\u043D\\u0456 \\u0434\\u0430\\u043D\\u0456\"\n  };\n  return issue2 => {\n    switch (issue2.code) {\n      case \"invalid_type\":\n        return `\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0456 \\u0432\\u0445\\u0456\\u0434\\u043D\\u0456 \\u0434\\u0430\\u043D\\u0456: \\u043E\\u0447\\u0456\\u043A\\u0443\\u0454\\u0442\\u044C\\u0441\\u044F ${issue2.expected}, \\u043E\\u0442\\u0440\\u0438\\u043C\\u0430\\u043D\\u043E ${parsedType4(issue2.input)}`;\n      // return `Неправильні вхідні дані: очікується ${issue.expected}, отримано ${util.getParsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue2.values.length === 1) return `\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0456 \\u0432\\u0445\\u0456\\u0434\\u043D\\u0456 \\u0434\\u0430\\u043D\\u0456: \\u043E\\u0447\\u0456\\u043A\\u0443\\u0454\\u0442\\u044C\\u0441\\u044F ${stringifyPrimitive(issue2.values[0])}`;\n        return `\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0430 \\u043E\\u043F\\u0446\\u0456\\u044F: \\u043E\\u0447\\u0456\\u043A\\u0443\\u0454\\u0442\\u044C\\u0441\\u044F \\u043E\\u0434\\u043D\\u0435 \\u0437 ${joinValues(issue2.values, \"|\")}`;\n      case \"too_big\":\n        {\n          const adj = issue2.inclusive ? \"<=\" : \"<\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) return `\\u0417\\u0430\\u043D\\u0430\\u0434\\u0442\\u043E \\u0432\\u0435\\u043B\\u0438\\u043A\\u0435: \\u043E\\u0447\\u0456\\u043A\\u0443\\u0454\\u0442\\u044C\\u0441\\u044F, \\u0449\\u043E ${issue2.origin ?? \"\\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u043D\\u044F\"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? \"\\u0435\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0456\\u0432\"}`;\n          return `\\u0417\\u0430\\u043D\\u0430\\u0434\\u0442\\u043E \\u0432\\u0435\\u043B\\u0438\\u043A\\u0435: \\u043E\\u0447\\u0456\\u043A\\u0443\\u0454\\u0442\\u044C\\u0441\\u044F, \\u0449\\u043E ${issue2.origin ?? \"\\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u043D\\u044F\"} \\u0431\\u0443\\u0434\\u0435 ${adj}${issue2.maximum.toString()}`;\n        }\n      case \"too_small\":\n        {\n          const adj = issue2.inclusive ? \">=\" : \">\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            return `\\u0417\\u0430\\u043D\\u0430\\u0434\\u0442\\u043E \\u043C\\u0430\\u043B\\u0435: \\u043E\\u0447\\u0456\\u043A\\u0443\\u0454\\u0442\\u044C\\u0441\\u044F, \\u0449\\u043E ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n          }\n          return `\\u0417\\u0430\\u043D\\u0430\\u0434\\u0442\\u043E \\u043C\\u0430\\u043B\\u0435: \\u043E\\u0447\\u0456\\u043A\\u0443\\u0454\\u0442\\u044C\\u0441\\u044F, \\u0449\\u043E ${issue2.origin} \\u0431\\u0443\\u0434\\u0435 ${adj}${issue2.minimum.toString()}`;\n        }\n      case \"invalid_format\":\n        {\n          const _issue = issue2;\n          if (_issue.format === \"starts_with\") return `\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0438\\u0439 \\u0440\\u044F\\u0434\\u043E\\u043A: \\u043F\\u043E\\u0432\\u0438\\u043D\\u0435\\u043D \\u043F\\u043E\\u0447\\u0438\\u043D\\u0430\\u0442\\u0438\\u0441\\u044F \\u0437 \"${_issue.prefix}\"`;\n          if (_issue.format === \"ends_with\") return `\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0438\\u0439 \\u0440\\u044F\\u0434\\u043E\\u043A: \\u043F\\u043E\\u0432\\u0438\\u043D\\u0435\\u043D \\u0437\\u0430\\u043A\\u0456\\u043D\\u0447\\u0443\\u0432\\u0430\\u0442\\u0438\\u0441\\u044F \\u043D\\u0430 \"${_issue.suffix}\"`;\n          if (_issue.format === \"includes\") return `\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0438\\u0439 \\u0440\\u044F\\u0434\\u043E\\u043A: \\u043F\\u043E\\u0432\\u0438\\u043D\\u0435\\u043D \\u043C\\u0456\\u0441\\u0442\\u0438\\u0442\\u0438 \"${_issue.includes}\"`;\n          if (_issue.format === \"regex\") return `\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0438\\u0439 \\u0440\\u044F\\u0434\\u043E\\u043A: \\u043F\\u043E\\u0432\\u0438\\u043D\\u0435\\u043D \\u0432\\u0456\\u0434\\u043F\\u043E\\u0432\\u0456\\u0434\\u0430\\u0442\\u0438 \\u0448\\u0430\\u0431\\u043B\\u043E\\u043D\\u0443 ${_issue.pattern}`;\n          return `\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0438\\u0439 ${Nouns[_issue.format] ?? issue2.format}`;\n        }\n      case \"not_multiple_of\":\n        return `\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0435 \\u0447\\u0438\\u0441\\u043B\\u043E: \\u043F\\u043E\\u0432\\u0438\\u043D\\u043D\\u043E \\u0431\\u0443\\u0442\\u0438 \\u043A\\u0440\\u0430\\u0442\\u043D\\u0438\\u043C ${issue2.divisor}`;\n      case \"unrecognized_keys\":\n        return `\\u041D\\u0435\\u0440\\u043E\\u0437\\u043F\\u0456\\u0437\\u043D\\u0430\\u043D\\u0438\\u0439 \\u043A\\u043B\\u044E\\u0447${issue2.keys.length > 1 ? \"\\u0456\" : \"\"}: ${joinValues(issue2.keys, \", \")}`;\n      case \"invalid_key\":\n        return `\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0438\\u0439 \\u043A\\u043B\\u044E\\u0447 \\u0443 ${issue2.origin}`;\n      case \"invalid_union\":\n        return \"\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0456 \\u0432\\u0445\\u0456\\u0434\\u043D\\u0456 \\u0434\\u0430\\u043D\\u0456\";\n      case \"invalid_element\":\n        return `\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0435 \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u043D\\u044F \\u0443 ${issue2.origin}`;\n      default:\n        return `\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0456 \\u0432\\u0445\\u0456\\u0434\\u043D\\u0456 \\u0434\\u0430\\u043D\\u0456`;\n    }\n  };\n};\nfunction ua_default() {\n  return {\n    localeError: error35()\n  };\n}\n\n// ../../node_modules/zod/v4/locales/ur.js\nvar error36 = () => {\n  const Sizable = {\n    string: {\n      unit: \"\\u062D\\u0631\\u0648\\u0641\",\n      verb: \"\\u06C1\\u0648\\u0646\\u0627\"\n    },\n    file: {\n      unit: \"\\u0628\\u0627\\u0626\\u0679\\u0633\",\n      verb: \"\\u06C1\\u0648\\u0646\\u0627\"\n    },\n    array: {\n      unit: \"\\u0622\\u0626\\u0679\\u0645\\u0632\",\n      verb: \"\\u06C1\\u0648\\u0646\\u0627\"\n    },\n    set: {\n      unit: \"\\u0622\\u0626\\u0679\\u0645\\u0632\",\n      verb: \"\\u06C1\\u0648\\u0646\\u0627\"\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType4 = data => {\n    const t = typeof data;\n    switch (t) {\n      case \"number\":\n        {\n          return Number.isNaN(data) ? \"NaN\" : \"\\u0646\\u0645\\u0628\\u0631\";\n        }\n      case \"object\":\n        {\n          if (Array.isArray(data)) {\n            return \"\\u0622\\u0631\\u06D2\";\n          }\n          if (data === null) {\n            return \"\\u0646\\u0644\";\n          }\n          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n            return data.constructor.name;\n          }\n        }\n    }\n    return t;\n  };\n  const Nouns = {\n    regex: \"\\u0627\\u0646 \\u067E\\u0679\",\n    email: \"\\u0627\\u06CC \\u0645\\u06CC\\u0644 \\u0627\\u06CC\\u0688\\u0631\\u06CC\\u0633\",\n    url: \"\\u06CC\\u0648 \\u0622\\u0631 \\u0627\\u06CC\\u0644\",\n    emoji: \"\\u0627\\u06CC\\u0645\\u0648\\u062C\\u06CC\",\n    uuid: \"\\u06CC\\u0648 \\u06CC\\u0648 \\u0622\\u0626\\u06CC \\u0688\\u06CC\",\n    uuidv4: \"\\u06CC\\u0648 \\u06CC\\u0648 \\u0622\\u0626\\u06CC \\u0688\\u06CC \\u0648\\u06CC 4\",\n    uuidv6: \"\\u06CC\\u0648 \\u06CC\\u0648 \\u0622\\u0626\\u06CC \\u0688\\u06CC \\u0648\\u06CC 6\",\n    nanoid: \"\\u0646\\u06CC\\u0646\\u0648 \\u0622\\u0626\\u06CC \\u0688\\u06CC\",\n    guid: \"\\u062C\\u06CC \\u06CC\\u0648 \\u0622\\u0626\\u06CC \\u0688\\u06CC\",\n    cuid: \"\\u0633\\u06CC \\u06CC\\u0648 \\u0622\\u0626\\u06CC \\u0688\\u06CC\",\n    cuid2: \"\\u0633\\u06CC \\u06CC\\u0648 \\u0622\\u0626\\u06CC \\u0688\\u06CC 2\",\n    ulid: \"\\u06CC\\u0648 \\u0627\\u06CC\\u0644 \\u0622\\u0626\\u06CC \\u0688\\u06CC\",\n    xid: \"\\u0627\\u06CC\\u06A9\\u0633 \\u0622\\u0626\\u06CC \\u0688\\u06CC\",\n    ksuid: \"\\u06A9\\u06D2 \\u0627\\u06CC\\u0633 \\u06CC\\u0648 \\u0622\\u0626\\u06CC \\u0688\\u06CC\",\n    datetime: \"\\u0622\\u0626\\u06CC \\u0627\\u06CC\\u0633 \\u0627\\u0648 \\u0688\\u06CC\\u0679 \\u0679\\u0627\\u0626\\u0645\",\n    date: \"\\u0622\\u0626\\u06CC \\u0627\\u06CC\\u0633 \\u0627\\u0648 \\u062A\\u0627\\u0631\\u06CC\\u062E\",\n    time: \"\\u0622\\u0626\\u06CC \\u0627\\u06CC\\u0633 \\u0627\\u0648 \\u0648\\u0642\\u062A\",\n    duration: \"\\u0622\\u0626\\u06CC \\u0627\\u06CC\\u0633 \\u0627\\u0648 \\u0645\\u062F\\u062A\",\n    ipv4: \"\\u0622\\u0626\\u06CC \\u067E\\u06CC \\u0648\\u06CC 4 \\u0627\\u06CC\\u0688\\u0631\\u06CC\\u0633\",\n    ipv6: \"\\u0622\\u0626\\u06CC \\u067E\\u06CC \\u0648\\u06CC 6 \\u0627\\u06CC\\u0688\\u0631\\u06CC\\u0633\",\n    cidrv4: \"\\u0622\\u0626\\u06CC \\u067E\\u06CC \\u0648\\u06CC 4 \\u0631\\u06CC\\u0646\\u062C\",\n    cidrv6: \"\\u0622\\u0626\\u06CC \\u067E\\u06CC \\u0648\\u06CC 6 \\u0631\\u06CC\\u0646\\u062C\",\n    base64: \"\\u0628\\u06CC\\u0633 64 \\u0627\\u0646 \\u06A9\\u0648\\u0688\\u0688 \\u0633\\u0679\\u0631\\u0646\\u06AF\",\n    base64url: \"\\u0628\\u06CC\\u0633 64 \\u06CC\\u0648 \\u0622\\u0631 \\u0627\\u06CC\\u0644 \\u0627\\u0646 \\u06A9\\u0648\\u0688\\u0688 \\u0633\\u0679\\u0631\\u0646\\u06AF\",\n    json_string: \"\\u062C\\u06D2 \\u0627\\u06CC\\u0633 \\u0627\\u0648 \\u0627\\u06CC\\u0646 \\u0633\\u0679\\u0631\\u0646\\u06AF\",\n    e164: \"\\u0627\\u06CC 164 \\u0646\\u0645\\u0628\\u0631\",\n    jwt: \"\\u062C\\u06D2 \\u0688\\u0628\\u0644\\u06CC\\u0648 \\u0679\\u06CC\",\n    template_literal: \"\\u0627\\u0646 \\u067E\\u0679\"\n  };\n  return issue2 => {\n    switch (issue2.code) {\n      case \"invalid_type\":\n        return `\\u063A\\u0644\\u0637 \\u0627\\u0646 \\u067E\\u0679: ${issue2.expected} \\u0645\\u062A\\u0648\\u0642\\u0639 \\u062A\\u06BE\\u0627\\u060C ${parsedType4(issue2.input)} \\u0645\\u0648\\u0635\\u0648\\u0644 \\u06C1\\u0648\\u0627`;\n      case \"invalid_value\":\n        if (issue2.values.length === 1) return `\\u063A\\u0644\\u0637 \\u0627\\u0646 \\u067E\\u0679: ${stringifyPrimitive(issue2.values[0])} \\u0645\\u062A\\u0648\\u0642\\u0639 \\u062A\\u06BE\\u0627`;\n        return `\\u063A\\u0644\\u0637 \\u0622\\u067E\\u0634\\u0646: ${joinValues(issue2.values, \"|\")} \\u0645\\u06CC\\u06BA \\u0633\\u06D2 \\u0627\\u06CC\\u06A9 \\u0645\\u062A\\u0648\\u0642\\u0639 \\u062A\\u06BE\\u0627`;\n      case \"too_big\":\n        {\n          const adj = issue2.inclusive ? \"<=\" : \"<\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) return `\\u0628\\u06C1\\u062A \\u0628\\u0691\\u0627: ${issue2.origin ?? \"\\u0648\\u06CC\\u0644\\u06CC\\u0648\"} \\u06A9\\u06D2 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? \"\\u0639\\u0646\\u0627\\u0635\\u0631\"} \\u06C1\\u0648\\u0646\\u06D2 \\u0645\\u062A\\u0648\\u0642\\u0639 \\u062A\\u06BE\\u06D2`;\n          return `\\u0628\\u06C1\\u062A \\u0628\\u0691\\u0627: ${issue2.origin ?? \"\\u0648\\u06CC\\u0644\\u06CC\\u0648\"} \\u06A9\\u0627 ${adj}${issue2.maximum.toString()} \\u06C1\\u0648\\u0646\\u0627 \\u0645\\u062A\\u0648\\u0642\\u0639 \\u062A\\u06BE\\u0627`;\n        }\n      case \"too_small\":\n        {\n          const adj = issue2.inclusive ? \">=\" : \">\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            return `\\u0628\\u06C1\\u062A \\u0686\\u06BE\\u0648\\u0679\\u0627: ${issue2.origin} \\u06A9\\u06D2 ${adj}${issue2.minimum.toString()} ${sizing.unit} \\u06C1\\u0648\\u0646\\u06D2 \\u0645\\u062A\\u0648\\u0642\\u0639 \\u062A\\u06BE\\u06D2`;\n          }\n          return `\\u0628\\u06C1\\u062A \\u0686\\u06BE\\u0648\\u0679\\u0627: ${issue2.origin} \\u06A9\\u0627 ${adj}${issue2.minimum.toString()} \\u06C1\\u0648\\u0646\\u0627 \\u0645\\u062A\\u0648\\u0642\\u0639 \\u062A\\u06BE\\u0627`;\n        }\n      case \"invalid_format\":\n        {\n          const _issue = issue2;\n          if (_issue.format === \"starts_with\") {\n            return `\\u063A\\u0644\\u0637 \\u0633\\u0679\\u0631\\u0646\\u06AF: \"${_issue.prefix}\" \\u0633\\u06D2 \\u0634\\u0631\\u0648\\u0639 \\u06C1\\u0648\\u0646\\u0627 \\u0686\\u0627\\u06C1\\u06CC\\u06D2`;\n          }\n          if (_issue.format === \"ends_with\") return `\\u063A\\u0644\\u0637 \\u0633\\u0679\\u0631\\u0646\\u06AF: \"${_issue.suffix}\" \\u067E\\u0631 \\u062E\\u062A\\u0645 \\u06C1\\u0648\\u0646\\u0627 \\u0686\\u0627\\u06C1\\u06CC\\u06D2`;\n          if (_issue.format === \"includes\") return `\\u063A\\u0644\\u0637 \\u0633\\u0679\\u0631\\u0646\\u06AF: \"${_issue.includes}\" \\u0634\\u0627\\u0645\\u0644 \\u06C1\\u0648\\u0646\\u0627 \\u0686\\u0627\\u06C1\\u06CC\\u06D2`;\n          if (_issue.format === \"regex\") return `\\u063A\\u0644\\u0637 \\u0633\\u0679\\u0631\\u0646\\u06AF: \\u067E\\u06CC\\u0679\\u0631\\u0646 ${_issue.pattern} \\u0633\\u06D2 \\u0645\\u06CC\\u0686 \\u06C1\\u0648\\u0646\\u0627 \\u0686\\u0627\\u06C1\\u06CC\\u06D2`;\n          return `\\u063A\\u0644\\u0637 ${Nouns[_issue.format] ?? issue2.format}`;\n        }\n      case \"not_multiple_of\":\n        return `\\u063A\\u0644\\u0637 \\u0646\\u0645\\u0628\\u0631: ${issue2.divisor} \\u06A9\\u0627 \\u0645\\u0636\\u0627\\u0639\\u0641 \\u06C1\\u0648\\u0646\\u0627 \\u0686\\u0627\\u06C1\\u06CC\\u06D2`;\n      case \"unrecognized_keys\":\n        return `\\u063A\\u06CC\\u0631 \\u062A\\u0633\\u0644\\u06CC\\u0645 \\u0634\\u062F\\u06C1 \\u06A9\\u06CC${issue2.keys.length > 1 ? \"\\u0632\" : \"\"}: ${joinValues(issue2.keys, \"\\u060C \")}`;\n      case \"invalid_key\":\n        return `${issue2.origin} \\u0645\\u06CC\\u06BA \\u063A\\u0644\\u0637 \\u06A9\\u06CC`;\n      case \"invalid_union\":\n        return \"\\u063A\\u0644\\u0637 \\u0627\\u0646 \\u067E\\u0679\";\n      case \"invalid_element\":\n        return `${issue2.origin} \\u0645\\u06CC\\u06BA \\u063A\\u0644\\u0637 \\u0648\\u06CC\\u0644\\u06CC\\u0648`;\n      default:\n        return `\\u063A\\u0644\\u0637 \\u0627\\u0646 \\u067E\\u0679`;\n    }\n  };\n};\nfunction ur_default() {\n  return {\n    localeError: error36()\n  };\n}\n\n// ../../node_modules/zod/v4/locales/vi.js\nvar error37 = () => {\n  const Sizable = {\n    string: {\n      unit: \"k\\xFD t\\u1EF1\",\n      verb: \"c\\xF3\"\n    },\n    file: {\n      unit: \"byte\",\n      verb: \"c\\xF3\"\n    },\n    array: {\n      unit: \"ph\\u1EA7n t\\u1EED\",\n      verb: \"c\\xF3\"\n    },\n    set: {\n      unit: \"ph\\u1EA7n t\\u1EED\",\n      verb: \"c\\xF3\"\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType4 = data => {\n    const t = typeof data;\n    switch (t) {\n      case \"number\":\n        {\n          return Number.isNaN(data) ? \"NaN\" : \"s\\u1ED1\";\n        }\n      case \"object\":\n        {\n          if (Array.isArray(data)) {\n            return \"m\\u1EA3ng\";\n          }\n          if (data === null) {\n            return \"null\";\n          }\n          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n            return data.constructor.name;\n          }\n        }\n    }\n    return t;\n  };\n  const Nouns = {\n    regex: \"\\u0111\\u1EA7u v\\xE0o\",\n    email: \"\\u0111\\u1ECBa ch\\u1EC9 email\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ng\\xE0y gi\\u1EDD ISO\",\n    date: \"ng\\xE0y ISO\",\n    time: \"gi\\u1EDD ISO\",\n    duration: \"kho\\u1EA3ng th\\u1EDDi gian ISO\",\n    ipv4: \"\\u0111\\u1ECBa ch\\u1EC9 IPv4\",\n    ipv6: \"\\u0111\\u1ECBa ch\\u1EC9 IPv6\",\n    cidrv4: \"d\\u1EA3i IPv4\",\n    cidrv6: \"d\\u1EA3i IPv6\",\n    base64: \"chu\\u1ED7i m\\xE3 h\\xF3a base64\",\n    base64url: \"chu\\u1ED7i m\\xE3 h\\xF3a base64url\",\n    json_string: \"chu\\u1ED7i JSON\",\n    e164: \"s\\u1ED1 E.164\",\n    jwt: \"JWT\",\n    template_literal: \"\\u0111\\u1EA7u v\\xE0o\"\n  };\n  return issue2 => {\n    switch (issue2.code) {\n      case \"invalid_type\":\n        return `\\u0110\\u1EA7u v\\xE0o kh\\xF4ng h\\u1EE3p l\\u1EC7: mong \\u0111\\u1EE3i ${issue2.expected}, nh\\u1EADn \\u0111\\u01B0\\u1EE3c ${parsedType4(issue2.input)}`;\n      case \"invalid_value\":\n        if (issue2.values.length === 1) return `\\u0110\\u1EA7u v\\xE0o kh\\xF4ng h\\u1EE3p l\\u1EC7: mong \\u0111\\u1EE3i ${stringifyPrimitive(issue2.values[0])}`;\n        return `T\\xF9y ch\\u1ECDn kh\\xF4ng h\\u1EE3p l\\u1EC7: mong \\u0111\\u1EE3i m\\u1ED9t trong c\\xE1c gi\\xE1 tr\\u1ECB ${joinValues(issue2.values, \"|\")}`;\n      case \"too_big\":\n        {\n          const adj = issue2.inclusive ? \"<=\" : \"<\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) return `Qu\\xE1 l\\u1EDBn: mong \\u0111\\u1EE3i ${issue2.origin ?? \"gi\\xE1 tr\\u1ECB\"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? \"ph\\u1EA7n t\\u1EED\"}`;\n          return `Qu\\xE1 l\\u1EDBn: mong \\u0111\\u1EE3i ${issue2.origin ?? \"gi\\xE1 tr\\u1ECB\"} ${adj}${issue2.maximum.toString()}`;\n        }\n      case \"too_small\":\n        {\n          const adj = issue2.inclusive ? \">=\" : \">\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            return `Qu\\xE1 nh\\u1ECF: mong \\u0111\\u1EE3i ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n          }\n          return `Qu\\xE1 nh\\u1ECF: mong \\u0111\\u1EE3i ${issue2.origin} ${adj}${issue2.minimum.toString()}`;\n        }\n      case \"invalid_format\":\n        {\n          const _issue = issue2;\n          if (_issue.format === \"starts_with\") return `Chu\\u1ED7i kh\\xF4ng h\\u1EE3p l\\u1EC7: ph\\u1EA3i b\\u1EAFt \\u0111\\u1EA7u b\\u1EB1ng \"${_issue.prefix}\"`;\n          if (_issue.format === \"ends_with\") return `Chu\\u1ED7i kh\\xF4ng h\\u1EE3p l\\u1EC7: ph\\u1EA3i k\\u1EBFt th\\xFAc b\\u1EB1ng \"${_issue.suffix}\"`;\n          if (_issue.format === \"includes\") return `Chu\\u1ED7i kh\\xF4ng h\\u1EE3p l\\u1EC7: ph\\u1EA3i bao g\\u1ED3m \"${_issue.includes}\"`;\n          if (_issue.format === \"regex\") return `Chu\\u1ED7i kh\\xF4ng h\\u1EE3p l\\u1EC7: ph\\u1EA3i kh\\u1EDBp v\\u1EDBi m\\u1EABu ${_issue.pattern}`;\n          return `${Nouns[_issue.format] ?? issue2.format} kh\\xF4ng h\\u1EE3p l\\u1EC7`;\n        }\n      case \"not_multiple_of\":\n        return `S\\u1ED1 kh\\xF4ng h\\u1EE3p l\\u1EC7: ph\\u1EA3i l\\xE0 b\\u1ED9i s\\u1ED1 c\\u1EE7a ${issue2.divisor}`;\n      case \"unrecognized_keys\":\n        return `Kh\\xF3a kh\\xF4ng \\u0111\\u01B0\\u1EE3c nh\\u1EADn d\\u1EA1ng: ${joinValues(issue2.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Kh\\xF3a kh\\xF4ng h\\u1EE3p l\\u1EC7 trong ${issue2.origin}`;\n      case \"invalid_union\":\n        return \"\\u0110\\u1EA7u v\\xE0o kh\\xF4ng h\\u1EE3p l\\u1EC7\";\n      case \"invalid_element\":\n        return `Gi\\xE1 tr\\u1ECB kh\\xF4ng h\\u1EE3p l\\u1EC7 trong ${issue2.origin}`;\n      default:\n        return `\\u0110\\u1EA7u v\\xE0o kh\\xF4ng h\\u1EE3p l\\u1EC7`;\n    }\n  };\n};\nfunction vi_default() {\n  return {\n    localeError: error37()\n  };\n}\n\n// ../../node_modules/zod/v4/locales/zh-CN.js\nvar error38 = () => {\n  const Sizable = {\n    string: {\n      unit: \"\\u5B57\\u7B26\",\n      verb: \"\\u5305\\u542B\"\n    },\n    file: {\n      unit: \"\\u5B57\\u8282\",\n      verb: \"\\u5305\\u542B\"\n    },\n    array: {\n      unit: \"\\u9879\",\n      verb: \"\\u5305\\u542B\"\n    },\n    set: {\n      unit: \"\\u9879\",\n      verb: \"\\u5305\\u542B\"\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType4 = data => {\n    const t = typeof data;\n    switch (t) {\n      case \"number\":\n        {\n          return Number.isNaN(data) ? \"\\u975E\\u6570\\u5B57(NaN)\" : \"\\u6570\\u5B57\";\n        }\n      case \"object\":\n        {\n          if (Array.isArray(data)) {\n            return \"\\u6570\\u7EC4\";\n          }\n          if (data === null) {\n            return \"\\u7A7A\\u503C(null)\";\n          }\n          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n            return data.constructor.name;\n          }\n        }\n    }\n    return t;\n  };\n  const Nouns = {\n    regex: \"\\u8F93\\u5165\",\n    email: \"\\u7535\\u5B50\\u90AE\\u4EF6\",\n    url: \"URL\",\n    emoji: \"\\u8868\\u60C5\\u7B26\\u53F7\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO\\u65E5\\u671F\\u65F6\\u95F4\",\n    date: \"ISO\\u65E5\\u671F\",\n    time: \"ISO\\u65F6\\u95F4\",\n    duration: \"ISO\\u65F6\\u957F\",\n    ipv4: \"IPv4\\u5730\\u5740\",\n    ipv6: \"IPv6\\u5730\\u5740\",\n    cidrv4: \"IPv4\\u7F51\\u6BB5\",\n    cidrv6: \"IPv6\\u7F51\\u6BB5\",\n    base64: \"base64\\u7F16\\u7801\\u5B57\\u7B26\\u4E32\",\n    base64url: \"base64url\\u7F16\\u7801\\u5B57\\u7B26\\u4E32\",\n    json_string: \"JSON\\u5B57\\u7B26\\u4E32\",\n    e164: \"E.164\\u53F7\\u7801\",\n    jwt: \"JWT\",\n    template_literal: \"\\u8F93\\u5165\"\n  };\n  return issue2 => {\n    switch (issue2.code) {\n      case \"invalid_type\":\n        return `\\u65E0\\u6548\\u8F93\\u5165\\uFF1A\\u671F\\u671B ${issue2.expected}\\uFF0C\\u5B9E\\u9645\\u63A5\\u6536 ${parsedType4(issue2.input)}`;\n      case \"invalid_value\":\n        if (issue2.values.length === 1) return `\\u65E0\\u6548\\u8F93\\u5165\\uFF1A\\u671F\\u671B ${stringifyPrimitive(issue2.values[0])}`;\n        return `\\u65E0\\u6548\\u9009\\u9879\\uFF1A\\u671F\\u671B\\u4EE5\\u4E0B\\u4E4B\\u4E00 ${joinValues(issue2.values, \"|\")}`;\n      case \"too_big\":\n        {\n          const adj = issue2.inclusive ? \"<=\" : \"<\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) return `\\u6570\\u503C\\u8FC7\\u5927\\uFF1A\\u671F\\u671B ${issue2.origin ?? \"\\u503C\"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? \"\\u4E2A\\u5143\\u7D20\"}`;\n          return `\\u6570\\u503C\\u8FC7\\u5927\\uFF1A\\u671F\\u671B ${issue2.origin ?? \"\\u503C\"} ${adj}${issue2.maximum.toString()}`;\n        }\n      case \"too_small\":\n        {\n          const adj = issue2.inclusive ? \">=\" : \">\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            return `\\u6570\\u503C\\u8FC7\\u5C0F\\uFF1A\\u671F\\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n          }\n          return `\\u6570\\u503C\\u8FC7\\u5C0F\\uFF1A\\u671F\\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()}`;\n        }\n      case \"invalid_format\":\n        {\n          const _issue = issue2;\n          if (_issue.format === \"starts_with\") return `\\u65E0\\u6548\\u5B57\\u7B26\\u4E32\\uFF1A\\u5FC5\\u987B\\u4EE5 \"${_issue.prefix}\" \\u5F00\\u5934`;\n          if (_issue.format === \"ends_with\") return `\\u65E0\\u6548\\u5B57\\u7B26\\u4E32\\uFF1A\\u5FC5\\u987B\\u4EE5 \"${_issue.suffix}\" \\u7ED3\\u5C3E`;\n          if (_issue.format === \"includes\") return `\\u65E0\\u6548\\u5B57\\u7B26\\u4E32\\uFF1A\\u5FC5\\u987B\\u5305\\u542B \"${_issue.includes}\"`;\n          if (_issue.format === \"regex\") return `\\u65E0\\u6548\\u5B57\\u7B26\\u4E32\\uFF1A\\u5FC5\\u987B\\u6EE1\\u8DB3\\u6B63\\u5219\\u8868\\u8FBE\\u5F0F ${_issue.pattern}`;\n          return `\\u65E0\\u6548${Nouns[_issue.format] ?? issue2.format}`;\n        }\n      case \"not_multiple_of\":\n        return `\\u65E0\\u6548\\u6570\\u5B57\\uFF1A\\u5FC5\\u987B\\u662F ${issue2.divisor} \\u7684\\u500D\\u6570`;\n      case \"unrecognized_keys\":\n        return `\\u51FA\\u73B0\\u672A\\u77E5\\u7684\\u952E(key): ${joinValues(issue2.keys, \", \")}`;\n      case \"invalid_key\":\n        return `${issue2.origin} \\u4E2D\\u7684\\u952E(key)\\u65E0\\u6548`;\n      case \"invalid_union\":\n        return \"\\u65E0\\u6548\\u8F93\\u5165\";\n      case \"invalid_element\":\n        return `${issue2.origin} \\u4E2D\\u5305\\u542B\\u65E0\\u6548\\u503C(value)`;\n      default:\n        return `\\u65E0\\u6548\\u8F93\\u5165`;\n    }\n  };\n};\nfunction zh_CN_default() {\n  return {\n    localeError: error38()\n  };\n}\n\n// ../../node_modules/zod/v4/locales/zh-TW.js\nvar error39 = () => {\n  const Sizable = {\n    string: {\n      unit: \"\\u5B57\\u5143\",\n      verb: \"\\u64C1\\u6709\"\n    },\n    file: {\n      unit: \"\\u4F4D\\u5143\\u7D44\",\n      verb: \"\\u64C1\\u6709\"\n    },\n    array: {\n      unit: \"\\u9805\\u76EE\",\n      verb: \"\\u64C1\\u6709\"\n    },\n    set: {\n      unit: \"\\u9805\\u76EE\",\n      verb: \"\\u64C1\\u6709\"\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType4 = data => {\n    const t = typeof data;\n    switch (t) {\n      case \"number\":\n        {\n          return Number.isNaN(data) ? \"NaN\" : \"number\";\n        }\n      case \"object\":\n        {\n          if (Array.isArray(data)) {\n            return \"array\";\n          }\n          if (data === null) {\n            return \"null\";\n          }\n          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n            return data.constructor.name;\n          }\n        }\n    }\n    return t;\n  };\n  const Nouns = {\n    regex: \"\\u8F38\\u5165\",\n    email: \"\\u90F5\\u4EF6\\u5730\\u5740\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO \\u65E5\\u671F\\u6642\\u9593\",\n    date: \"ISO \\u65E5\\u671F\",\n    time: \"ISO \\u6642\\u9593\",\n    duration: \"ISO \\u671F\\u9593\",\n    ipv4: \"IPv4 \\u4F4D\\u5740\",\n    ipv6: \"IPv6 \\u4F4D\\u5740\",\n    cidrv4: \"IPv4 \\u7BC4\\u570D\",\n    cidrv6: \"IPv6 \\u7BC4\\u570D\",\n    base64: \"base64 \\u7DE8\\u78BC\\u5B57\\u4E32\",\n    base64url: \"base64url \\u7DE8\\u78BC\\u5B57\\u4E32\",\n    json_string: \"JSON \\u5B57\\u4E32\",\n    e164: \"E.164 \\u6578\\u503C\",\n    jwt: \"JWT\",\n    template_literal: \"\\u8F38\\u5165\"\n  };\n  return issue2 => {\n    switch (issue2.code) {\n      case \"invalid_type\":\n        return `\\u7121\\u6548\\u7684\\u8F38\\u5165\\u503C\\uFF1A\\u9810\\u671F\\u70BA ${issue2.expected}\\uFF0C\\u4F46\\u6536\\u5230 ${parsedType4(issue2.input)}`;\n      case \"invalid_value\":\n        if (issue2.values.length === 1) return `\\u7121\\u6548\\u7684\\u8F38\\u5165\\u503C\\uFF1A\\u9810\\u671F\\u70BA ${stringifyPrimitive(issue2.values[0])}`;\n        return `\\u7121\\u6548\\u7684\\u9078\\u9805\\uFF1A\\u9810\\u671F\\u70BA\\u4EE5\\u4E0B\\u5176\\u4E2D\\u4E4B\\u4E00 ${joinValues(issue2.values, \"|\")}`;\n      case \"too_big\":\n        {\n          const adj = issue2.inclusive ? \"<=\" : \"<\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) return `\\u6578\\u503C\\u904E\\u5927\\uFF1A\\u9810\\u671F ${issue2.origin ?? \"\\u503C\"} \\u61C9\\u70BA ${adj}${issue2.maximum.toString()} ${sizing.unit ?? \"\\u500B\\u5143\\u7D20\"}`;\n          return `\\u6578\\u503C\\u904E\\u5927\\uFF1A\\u9810\\u671F ${issue2.origin ?? \"\\u503C\"} \\u61C9\\u70BA ${adj}${issue2.maximum.toString()}`;\n        }\n      case \"too_small\":\n        {\n          const adj = issue2.inclusive ? \">=\" : \">\";\n          const sizing = getSizing(issue2.origin);\n          if (sizing) {\n            return `\\u6578\\u503C\\u904E\\u5C0F\\uFF1A\\u9810\\u671F ${issue2.origin} \\u61C9\\u70BA ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n          }\n          return `\\u6578\\u503C\\u904E\\u5C0F\\uFF1A\\u9810\\u671F ${issue2.origin} \\u61C9\\u70BA ${adj}${issue2.minimum.toString()}`;\n        }\n      case \"invalid_format\":\n        {\n          const _issue = issue2;\n          if (_issue.format === \"starts_with\") {\n            return `\\u7121\\u6548\\u7684\\u5B57\\u4E32\\uFF1A\\u5FC5\\u9808\\u4EE5 \"${_issue.prefix}\" \\u958B\\u982D`;\n          }\n          if (_issue.format === \"ends_with\") return `\\u7121\\u6548\\u7684\\u5B57\\u4E32\\uFF1A\\u5FC5\\u9808\\u4EE5 \"${_issue.suffix}\" \\u7D50\\u5C3E`;\n          if (_issue.format === \"includes\") return `\\u7121\\u6548\\u7684\\u5B57\\u4E32\\uFF1A\\u5FC5\\u9808\\u5305\\u542B \"${_issue.includes}\"`;\n          if (_issue.format === \"regex\") return `\\u7121\\u6548\\u7684\\u5B57\\u4E32\\uFF1A\\u5FC5\\u9808\\u7B26\\u5408\\u683C\\u5F0F ${_issue.pattern}`;\n          return `\\u7121\\u6548\\u7684 ${Nouns[_issue.format] ?? issue2.format}`;\n        }\n      case \"not_multiple_of\":\n        return `\\u7121\\u6548\\u7684\\u6578\\u5B57\\uFF1A\\u5FC5\\u9808\\u70BA ${issue2.divisor} \\u7684\\u500D\\u6578`;\n      case \"unrecognized_keys\":\n        return `\\u7121\\u6CD5\\u8B58\\u5225\\u7684\\u9375\\u503C${issue2.keys.length > 1 ? \"\\u5011\" : \"\"}\\uFF1A${joinValues(issue2.keys, \"\\u3001\")}`;\n      case \"invalid_key\":\n        return `${issue2.origin} \\u4E2D\\u6709\\u7121\\u6548\\u7684\\u9375\\u503C`;\n      case \"invalid_union\":\n        return \"\\u7121\\u6548\\u7684\\u8F38\\u5165\\u503C\";\n      case \"invalid_element\":\n        return `${issue2.origin} \\u4E2D\\u6709\\u7121\\u6548\\u7684\\u503C`;\n      default:\n        return `\\u7121\\u6548\\u7684\\u8F38\\u5165\\u503C`;\n    }\n  };\n};\nfunction zh_TW_default() {\n  return {\n    localeError: error39()\n  };\n}\n\n// ../../node_modules/zod/v4/core/registries.js\nvar $output = Symbol(\"ZodOutput\");\nvar $input = Symbol(\"ZodInput\");\nvar $ZodRegistry = class {\n  constructor() {\n    this._map = /* @__PURE__ */new Map();\n    this._idmap = /* @__PURE__ */new Map();\n  }\n  add(schema, ..._meta) {\n    const meta = _meta[0];\n    this._map.set(schema, meta);\n    if (meta && typeof meta === \"object\" && \"id\" in meta) {\n      if (this._idmap.has(meta.id)) {\n        throw new Error(`ID ${meta.id} already exists in the registry`);\n      }\n      this._idmap.set(meta.id, schema);\n    }\n    return this;\n  }\n  clear() {\n    this._map = /* @__PURE__ */new Map();\n    this._idmap = /* @__PURE__ */new Map();\n    return this;\n  }\n  remove(schema) {\n    const meta = this._map.get(schema);\n    if (meta && typeof meta === \"object\" && \"id\" in meta) {\n      this._idmap.delete(meta.id);\n    }\n    this._map.delete(schema);\n    return this;\n  }\n  get(schema) {\n    const p = schema._zod.parent;\n    if (p) {\n      const pm = {\n        ...(this.get(p) ?? {})\n      };\n      delete pm.id;\n      return {\n        ...pm,\n        ...this._map.get(schema)\n      };\n    }\n    return this._map.get(schema);\n  }\n  has(schema) {\n    return this._map.has(schema);\n  }\n};\nfunction registry() {\n  return new $ZodRegistry();\n}\nvar globalRegistry = /* @__PURE__ */registry();\n\n// ../../node_modules/zod/v4/core/api.js\nfunction _string(Class2, params) {\n  return new Class2({\n    type: \"string\",\n    ...normalizeParams(params)\n  });\n}\nfunction _coercedString(Class2, params) {\n  return new Class2({\n    type: \"string\",\n    coerce: true,\n    ...normalizeParams(params)\n  });\n}\nfunction _email(Class2, params) {\n  return new Class2({\n    type: \"string\",\n    format: \"email\",\n    check: \"string_format\",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _guid(Class2, params) {\n  return new Class2({\n    type: \"string\",\n    format: \"guid\",\n    check: \"string_format\",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _uuid(Class2, params) {\n  return new Class2({\n    type: \"string\",\n    format: \"uuid\",\n    check: \"string_format\",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _uuidv4(Class2, params) {\n  return new Class2({\n    type: \"string\",\n    format: \"uuid\",\n    check: \"string_format\",\n    abort: false,\n    version: \"v4\",\n    ...normalizeParams(params)\n  });\n}\nfunction _uuidv6(Class2, params) {\n  return new Class2({\n    type: \"string\",\n    format: \"uuid\",\n    check: \"string_format\",\n    abort: false,\n    version: \"v6\",\n    ...normalizeParams(params)\n  });\n}\nfunction _uuidv7(Class2, params) {\n  return new Class2({\n    type: \"string\",\n    format: \"uuid\",\n    check: \"string_format\",\n    abort: false,\n    version: \"v7\",\n    ...normalizeParams(params)\n  });\n}\nfunction _url(Class2, params) {\n  return new Class2({\n    type: \"string\",\n    format: \"url\",\n    check: \"string_format\",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _emoji2(Class2, params) {\n  return new Class2({\n    type: \"string\",\n    format: \"emoji\",\n    check: \"string_format\",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _nanoid(Class2, params) {\n  return new Class2({\n    type: \"string\",\n    format: \"nanoid\",\n    check: \"string_format\",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _cuid(Class2, params) {\n  return new Class2({\n    type: \"string\",\n    format: \"cuid\",\n    check: \"string_format\",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _cuid2(Class2, params) {\n  return new Class2({\n    type: \"string\",\n    format: \"cuid2\",\n    check: \"string_format\",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _ulid(Class2, params) {\n  return new Class2({\n    type: \"string\",\n    format: \"ulid\",\n    check: \"string_format\",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _xid(Class2, params) {\n  return new Class2({\n    type: \"string\",\n    format: \"xid\",\n    check: \"string_format\",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _ksuid(Class2, params) {\n  return new Class2({\n    type: \"string\",\n    format: \"ksuid\",\n    check: \"string_format\",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _ipv4(Class2, params) {\n  return new Class2({\n    type: \"string\",\n    format: \"ipv4\",\n    check: \"string_format\",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _ipv6(Class2, params) {\n  return new Class2({\n    type: \"string\",\n    format: \"ipv6\",\n    check: \"string_format\",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _cidrv4(Class2, params) {\n  return new Class2({\n    type: \"string\",\n    format: \"cidrv4\",\n    check: \"string_format\",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _cidrv6(Class2, params) {\n  return new Class2({\n    type: \"string\",\n    format: \"cidrv6\",\n    check: \"string_format\",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _base64(Class2, params) {\n  return new Class2({\n    type: \"string\",\n    format: \"base64\",\n    check: \"string_format\",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _base64url(Class2, params) {\n  return new Class2({\n    type: \"string\",\n    format: \"base64url\",\n    check: \"string_format\",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _e164(Class2, params) {\n  return new Class2({\n    type: \"string\",\n    format: \"e164\",\n    check: \"string_format\",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _jwt(Class2, params) {\n  return new Class2({\n    type: \"string\",\n    format: \"jwt\",\n    check: \"string_format\",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nvar TimePrecision = {\n  Any: null,\n  Minute: -1,\n  Second: 0,\n  Millisecond: 3,\n  Microsecond: 6\n};\nfunction _isoDateTime(Class2, params) {\n  return new Class2({\n    type: \"string\",\n    format: \"datetime\",\n    check: \"string_format\",\n    offset: false,\n    local: false,\n    precision: null,\n    ...normalizeParams(params)\n  });\n}\nfunction _isoDate(Class2, params) {\n  return new Class2({\n    type: \"string\",\n    format: \"date\",\n    check: \"string_format\",\n    ...normalizeParams(params)\n  });\n}\nfunction _isoTime(Class2, params) {\n  return new Class2({\n    type: \"string\",\n    format: \"time\",\n    check: \"string_format\",\n    precision: null,\n    ...normalizeParams(params)\n  });\n}\nfunction _isoDuration(Class2, params) {\n  return new Class2({\n    type: \"string\",\n    format: \"duration\",\n    check: \"string_format\",\n    ...normalizeParams(params)\n  });\n}\nfunction _number(Class2, params) {\n  return new Class2({\n    type: \"number\",\n    checks: [],\n    ...normalizeParams(params)\n  });\n}\nfunction _coercedNumber(Class2, params) {\n  return new Class2({\n    type: \"number\",\n    coerce: true,\n    checks: [],\n    ...normalizeParams(params)\n  });\n}\nfunction _int(Class2, params) {\n  return new Class2({\n    type: \"number\",\n    check: \"number_format\",\n    abort: false,\n    format: \"safeint\",\n    ...normalizeParams(params)\n  });\n}\nfunction _float32(Class2, params) {\n  return new Class2({\n    type: \"number\",\n    check: \"number_format\",\n    abort: false,\n    format: \"float32\",\n    ...normalizeParams(params)\n  });\n}\nfunction _float64(Class2, params) {\n  return new Class2({\n    type: \"number\",\n    check: \"number_format\",\n    abort: false,\n    format: \"float64\",\n    ...normalizeParams(params)\n  });\n}\nfunction _int32(Class2, params) {\n  return new Class2({\n    type: \"number\",\n    check: \"number_format\",\n    abort: false,\n    format: \"int32\",\n    ...normalizeParams(params)\n  });\n}\nfunction _uint32(Class2, params) {\n  return new Class2({\n    type: \"number\",\n    check: \"number_format\",\n    abort: false,\n    format: \"uint32\",\n    ...normalizeParams(params)\n  });\n}\nfunction _boolean(Class2, params) {\n  return new Class2({\n    type: \"boolean\",\n    ...normalizeParams(params)\n  });\n}\nfunction _coercedBoolean(Class2, params) {\n  return new Class2({\n    type: \"boolean\",\n    coerce: true,\n    ...normalizeParams(params)\n  });\n}\nfunction _bigint(Class2, params) {\n  return new Class2({\n    type: \"bigint\",\n    ...normalizeParams(params)\n  });\n}\nfunction _coercedBigint(Class2, params) {\n  return new Class2({\n    type: \"bigint\",\n    coerce: true,\n    ...normalizeParams(params)\n  });\n}\nfunction _int64(Class2, params) {\n  return new Class2({\n    type: \"bigint\",\n    check: \"bigint_format\",\n    abort: false,\n    format: \"int64\",\n    ...normalizeParams(params)\n  });\n}\nfunction _uint64(Class2, params) {\n  return new Class2({\n    type: \"bigint\",\n    check: \"bigint_format\",\n    abort: false,\n    format: \"uint64\",\n    ...normalizeParams(params)\n  });\n}\nfunction _symbol(Class2, params) {\n  return new Class2({\n    type: \"symbol\",\n    ...normalizeParams(params)\n  });\n}\nfunction _undefined2(Class2, params) {\n  return new Class2({\n    type: \"undefined\",\n    ...normalizeParams(params)\n  });\n}\nfunction _null2(Class2, params) {\n  return new Class2({\n    type: \"null\",\n    ...normalizeParams(params)\n  });\n}\nfunction _any(Class2) {\n  return new Class2({\n    type: \"any\"\n  });\n}\nfunction _unknown(Class2) {\n  return new Class2({\n    type: \"unknown\"\n  });\n}\nfunction _never(Class2, params) {\n  return new Class2({\n    type: \"never\",\n    ...normalizeParams(params)\n  });\n}\nfunction _void(Class2, params) {\n  return new Class2({\n    type: \"void\",\n    ...normalizeParams(params)\n  });\n}\nfunction _date(Class2, params) {\n  return new Class2({\n    type: \"date\",\n    ...normalizeParams(params)\n  });\n}\nfunction _coercedDate(Class2, params) {\n  return new Class2({\n    type: \"date\",\n    coerce: true,\n    ...normalizeParams(params)\n  });\n}\nfunction _nan(Class2, params) {\n  return new Class2({\n    type: \"nan\",\n    ...normalizeParams(params)\n  });\n}\nfunction _lt(value, params) {\n  return new $ZodCheckLessThan({\n    check: \"less_than\",\n    ...normalizeParams(params),\n    value,\n    inclusive: false\n  });\n}\nfunction _lte(value, params) {\n  return new $ZodCheckLessThan({\n    check: \"less_than\",\n    ...normalizeParams(params),\n    value,\n    inclusive: true\n  });\n}\nfunction _gt(value, params) {\n  return new $ZodCheckGreaterThan({\n    check: \"greater_than\",\n    ...normalizeParams(params),\n    value,\n    inclusive: false\n  });\n}\nfunction _gte(value, params) {\n  return new $ZodCheckGreaterThan({\n    check: \"greater_than\",\n    ...normalizeParams(params),\n    value,\n    inclusive: true\n  });\n}\nfunction _positive(params) {\n  return _gt(0, params);\n}\nfunction _negative(params) {\n  return _lt(0, params);\n}\nfunction _nonpositive(params) {\n  return _lte(0, params);\n}\nfunction _nonnegative(params) {\n  return _gte(0, params);\n}\nfunction _multipleOf(value, params) {\n  return new $ZodCheckMultipleOf({\n    check: \"multiple_of\",\n    ...normalizeParams(params),\n    value\n  });\n}\nfunction _maxSize(maximum, params) {\n  return new $ZodCheckMaxSize({\n    check: \"max_size\",\n    ...normalizeParams(params),\n    maximum\n  });\n}\nfunction _minSize(minimum, params) {\n  return new $ZodCheckMinSize({\n    check: \"min_size\",\n    ...normalizeParams(params),\n    minimum\n  });\n}\nfunction _size(size, params) {\n  return new $ZodCheckSizeEquals({\n    check: \"size_equals\",\n    ...normalizeParams(params),\n    size\n  });\n}\nfunction _maxLength(maximum, params) {\n  const ch = new $ZodCheckMaxLength({\n    check: \"max_length\",\n    ...normalizeParams(params),\n    maximum\n  });\n  return ch;\n}\nfunction _minLength(minimum, params) {\n  return new $ZodCheckMinLength({\n    check: \"min_length\",\n    ...normalizeParams(params),\n    minimum\n  });\n}\nfunction _length(length, params) {\n  return new $ZodCheckLengthEquals({\n    check: \"length_equals\",\n    ...normalizeParams(params),\n    length\n  });\n}\nfunction _regex(pattern, params) {\n  return new $ZodCheckRegex({\n    check: \"string_format\",\n    format: \"regex\",\n    ...normalizeParams(params),\n    pattern\n  });\n}\nfunction _lowercase(params) {\n  return new $ZodCheckLowerCase({\n    check: \"string_format\",\n    format: \"lowercase\",\n    ...normalizeParams(params)\n  });\n}\nfunction _uppercase(params) {\n  return new $ZodCheckUpperCase({\n    check: \"string_format\",\n    format: \"uppercase\",\n    ...normalizeParams(params)\n  });\n}\nfunction _includes(includes, params) {\n  return new $ZodCheckIncludes({\n    check: \"string_format\",\n    format: \"includes\",\n    ...normalizeParams(params),\n    includes\n  });\n}\nfunction _startsWith(prefix, params) {\n  return new $ZodCheckStartsWith({\n    check: \"string_format\",\n    format: \"starts_with\",\n    ...normalizeParams(params),\n    prefix\n  });\n}\nfunction _endsWith(suffix, params) {\n  return new $ZodCheckEndsWith({\n    check: \"string_format\",\n    format: \"ends_with\",\n    ...normalizeParams(params),\n    suffix\n  });\n}\nfunction _property(property, schema, params) {\n  return new $ZodCheckProperty({\n    check: \"property\",\n    property,\n    schema,\n    ...normalizeParams(params)\n  });\n}\nfunction _mime(types, params) {\n  return new $ZodCheckMimeType({\n    check: \"mime_type\",\n    mime: types,\n    ...normalizeParams(params)\n  });\n}\nfunction _overwrite(tx) {\n  return new $ZodCheckOverwrite({\n    check: \"overwrite\",\n    tx\n  });\n}\nfunction _normalize(form) {\n  return _overwrite(input => input.normalize(form));\n}\nfunction _trim() {\n  return _overwrite(input => input.trim());\n}\nfunction _toLowerCase() {\n  return _overwrite(input => input.toLowerCase());\n}\nfunction _toUpperCase() {\n  return _overwrite(input => input.toUpperCase());\n}\nfunction _array(Class2, element, params) {\n  return new Class2({\n    type: \"array\",\n    element,\n    // get element() {\n    //   return element;\n    // },\n    ...normalizeParams(params)\n  });\n}\nfunction _union(Class2, options, params) {\n  return new Class2({\n    type: \"union\",\n    options,\n    ...normalizeParams(params)\n  });\n}\nfunction _discriminatedUnion(Class2, discriminator, options, params) {\n  return new Class2({\n    type: \"union\",\n    options,\n    discriminator,\n    ...normalizeParams(params)\n  });\n}\nfunction _intersection(Class2, left, right) {\n  return new Class2({\n    type: \"intersection\",\n    left,\n    right\n  });\n}\nfunction _tuple(Class2, items, _paramsOrRest, _params) {\n  const hasRest = _paramsOrRest instanceof $ZodType;\n  const params = hasRest ? _params : _paramsOrRest;\n  const rest = hasRest ? _paramsOrRest : null;\n  return new Class2({\n    type: \"tuple\",\n    items,\n    rest,\n    ...normalizeParams(params)\n  });\n}\nfunction _record(Class2, keyType, valueType, params) {\n  return new Class2({\n    type: \"record\",\n    keyType,\n    valueType,\n    ...normalizeParams(params)\n  });\n}\nfunction _map(Class2, keyType, valueType, params) {\n  return new Class2({\n    type: \"map\",\n    keyType,\n    valueType,\n    ...normalizeParams(params)\n  });\n}\nfunction _set(Class2, valueType, params) {\n  return new Class2({\n    type: \"set\",\n    valueType,\n    ...normalizeParams(params)\n  });\n}\nfunction _enum(Class2, values, params) {\n  const entries = Array.isArray(values) ? Object.fromEntries(values.map(v => [v, v])) : values;\n  return new Class2({\n    type: \"enum\",\n    entries,\n    ...normalizeParams(params)\n  });\n}\nfunction _nativeEnum(Class2, entries, params) {\n  return new Class2({\n    type: \"enum\",\n    entries,\n    ...normalizeParams(params)\n  });\n}\nfunction _literal(Class2, value, params) {\n  return new Class2({\n    type: \"literal\",\n    values: Array.isArray(value) ? value : [value],\n    ...normalizeParams(params)\n  });\n}\nfunction _file(Class2, params) {\n  return new Class2({\n    type: \"file\",\n    ...normalizeParams(params)\n  });\n}\nfunction _transform(Class2, fn) {\n  return new Class2({\n    type: \"transform\",\n    transform: fn\n  });\n}\nfunction _optional(Class2, innerType) {\n  return new Class2({\n    type: \"optional\",\n    innerType\n  });\n}\nfunction _nullable(Class2, innerType) {\n  return new Class2({\n    type: \"nullable\",\n    innerType\n  });\n}\nfunction _default(Class2, innerType, defaultValue) {\n  return new Class2({\n    type: \"default\",\n    innerType,\n    get defaultValue() {\n      return typeof defaultValue === \"function\" ? defaultValue() : defaultValue;\n    }\n  });\n}\nfunction _nonoptional(Class2, innerType, params) {\n  return new Class2({\n    type: \"nonoptional\",\n    innerType,\n    ...normalizeParams(params)\n  });\n}\nfunction _success(Class2, innerType) {\n  return new Class2({\n    type: \"success\",\n    innerType\n  });\n}\nfunction _catch(Class2, innerType, catchValue) {\n  return new Class2({\n    type: \"catch\",\n    innerType,\n    catchValue: typeof catchValue === \"function\" ? catchValue : () => catchValue\n  });\n}\nfunction _pipe(Class2, in_, out) {\n  return new Class2({\n    type: \"pipe\",\n    in: in_,\n    out\n  });\n}\nfunction _readonly(Class2, innerType) {\n  return new Class2({\n    type: \"readonly\",\n    innerType\n  });\n}\nfunction _templateLiteral(Class2, parts, params) {\n  return new Class2({\n    type: \"template_literal\",\n    parts,\n    ...normalizeParams(params)\n  });\n}\nfunction _lazy(Class2, getter) {\n  return new Class2({\n    type: \"lazy\",\n    getter\n  });\n}\nfunction _promise(Class2, innerType) {\n  return new Class2({\n    type: \"promise\",\n    innerType\n  });\n}\nfunction _custom(Class2, fn, _params) {\n  const norm = normalizeParams(_params);\n  norm.abort ?? (norm.abort = true);\n  const schema = new Class2({\n    type: \"custom\",\n    check: \"custom\",\n    fn,\n    ...norm\n  });\n  return schema;\n}\nfunction _refine(Class2, fn, _params) {\n  const schema = new Class2({\n    type: \"custom\",\n    check: \"custom\",\n    fn,\n    ...normalizeParams(_params)\n  });\n  return schema;\n}\nfunction _stringbool(Classes, _params) {\n  const params = normalizeParams(_params);\n  let truthyArray = params.truthy ?? [\"true\", \"1\", \"yes\", \"on\", \"y\", \"enabled\"];\n  let falsyArray = params.falsy ?? [\"false\", \"0\", \"no\", \"off\", \"n\", \"disabled\"];\n  if (params.case !== \"sensitive\") {\n    truthyArray = truthyArray.map(v => typeof v === \"string\" ? v.toLowerCase() : v);\n    falsyArray = falsyArray.map(v => typeof v === \"string\" ? v.toLowerCase() : v);\n  }\n  const truthySet = new Set(truthyArray);\n  const falsySet = new Set(falsyArray);\n  const _Pipe = Classes.Pipe ?? $ZodPipe;\n  const _Boolean = Classes.Boolean ?? $ZodBoolean;\n  const _String = Classes.String ?? $ZodString;\n  const _Transform = Classes.Transform ?? $ZodTransform;\n  const tx = new _Transform({\n    type: \"transform\",\n    transform: (input, payload) => {\n      let data = input;\n      if (params.case !== \"sensitive\") data = data.toLowerCase();\n      if (truthySet.has(data)) {\n        return true;\n      } else if (falsySet.has(data)) {\n        return false;\n      } else {\n        payload.issues.push({\n          code: \"invalid_value\",\n          expected: \"stringbool\",\n          values: [...truthySet, ...falsySet],\n          input: payload.value,\n          inst: tx\n        });\n        return {};\n      }\n    },\n    error: params.error\n  });\n  const innerPipe = new _Pipe({\n    type: \"pipe\",\n    in: new _String({\n      type: \"string\",\n      error: params.error\n    }),\n    out: tx,\n    error: params.error\n  });\n  const outerPipe = new _Pipe({\n    type: \"pipe\",\n    in: innerPipe,\n    out: new _Boolean({\n      type: \"boolean\",\n      error: params.error\n    }),\n    error: params.error\n  });\n  return outerPipe;\n}\nfunction _stringFormat(Class2, format, fnOrRegex, _params = {}) {\n  const params = normalizeParams(_params);\n  const def = {\n    ...normalizeParams(_params),\n    check: \"string_format\",\n    type: \"string\",\n    format,\n    fn: typeof fnOrRegex === \"function\" ? fnOrRegex : val => fnOrRegex.test(val),\n    ...params\n  };\n  if (fnOrRegex instanceof RegExp) {\n    def.pattern = fnOrRegex;\n  }\n  const inst = new Class2(def);\n  return inst;\n}\n\n// ../../node_modules/zod/v4/core/function.js\nvar $ZodFunction = class {\n  constructor(def) {\n    this._def = def;\n    this.def = def;\n  }\n  implement(func) {\n    if (typeof func !== \"function\") {\n      throw new Error(\"implement() must be called with a function\");\n    }\n    const impl = (...args) => {\n      const parsedArgs = this._def.input ? parse(this._def.input, args, void 0, {\n        callee: impl\n      }) : args;\n      if (!Array.isArray(parsedArgs)) {\n        throw new Error(\"Invalid arguments schema: not an array or tuple schema.\");\n      }\n      const output = func(...parsedArgs);\n      return this._def.output ? parse(this._def.output, output, void 0, {\n        callee: impl\n      }) : output;\n    };\n    return impl;\n  }\n  implementAsync(func) {\n    if (typeof func !== \"function\") {\n      throw new Error(\"implement() must be called with a function\");\n    }\n    const impl = async (...args) => {\n      const parsedArgs = this._def.input ? await parseAsync(this._def.input, args, void 0, {\n        callee: impl\n      }) : args;\n      if (!Array.isArray(parsedArgs)) {\n        throw new Error(\"Invalid arguments schema: not an array or tuple schema.\");\n      }\n      const output = await func(...parsedArgs);\n      return this._def.output ? parseAsync(this._def.output, output, void 0, {\n        callee: impl\n      }) : output;\n    };\n    return impl;\n  }\n  input(...args) {\n    const F = this.constructor;\n    if (Array.isArray(args[0])) {\n      return new F({\n        type: \"function\",\n        input: new $ZodTuple({\n          type: \"tuple\",\n          items: args[0],\n          rest: args[1]\n        }),\n        output: this._def.output\n      });\n    }\n    return new F({\n      type: \"function\",\n      input: args[0],\n      output: this._def.output\n    });\n  }\n  output(output) {\n    const F = this.constructor;\n    return new F({\n      type: \"function\",\n      input: this._def.input,\n      output\n    });\n  }\n};\nfunction _function(params) {\n  return new $ZodFunction({\n    type: \"function\",\n    input: Array.isArray(params?.input) ? _tuple($ZodTuple, params?.input) : params?.input ?? _array($ZodArray, _unknown($ZodUnknown)),\n    output: params?.output ?? _unknown($ZodUnknown)\n  });\n}\n\n// ../../node_modules/zod/v4/core/to-json-schema.js\nvar JSONSchemaGenerator = class {\n  constructor(params) {\n    this.counter = 0;\n    this.metadataRegistry = params?.metadata ?? globalRegistry;\n    this.target = params?.target ?? \"draft-2020-12\";\n    this.unrepresentable = params?.unrepresentable ?? \"throw\";\n    this.override = params?.override ?? (() => {});\n    this.io = params?.io ?? \"output\";\n    this.seen = /* @__PURE__ */new Map();\n  }\n  process(schema, _params = {\n    path: [],\n    schemaPath: []\n  }) {\n    var _a20;\n    const def = schema._zod.def;\n    const formatMap = {\n      guid: \"uuid\",\n      url: \"uri\",\n      datetime: \"date-time\",\n      json_string: \"json-string\",\n      regex: \"\"\n      // do not set\n    };\n    const seen = this.seen.get(schema);\n    if (seen) {\n      seen.count++;\n      const isCycle = _params.schemaPath.includes(schema);\n      if (isCycle) {\n        seen.cycle = _params.path;\n      }\n      return seen.schema;\n    }\n    const result = {\n      schema: {},\n      count: 1,\n      cycle: void 0,\n      path: _params.path\n    };\n    this.seen.set(schema, result);\n    const overrideSchema = schema._zod.toJSONSchema?.();\n    if (overrideSchema) {\n      result.schema = overrideSchema;\n    } else {\n      const params = {\n        ..._params,\n        schemaPath: [..._params.schemaPath, schema],\n        path: _params.path\n      };\n      const parent = schema._zod.parent;\n      if (parent) {\n        result.ref = parent;\n        this.process(parent, params);\n        this.seen.get(parent).isParent = true;\n      } else {\n        const _json = result.schema;\n        switch (def.type) {\n          case \"string\":\n            {\n              const json2 = _json;\n              json2.type = \"string\";\n              const {\n                minimum,\n                maximum,\n                format,\n                patterns,\n                contentEncoding\n              } = schema._zod.bag;\n              if (typeof minimum === \"number\") json2.minLength = minimum;\n              if (typeof maximum === \"number\") json2.maxLength = maximum;\n              if (format) {\n                json2.format = formatMap[format] ?? format;\n                if (json2.format === \"\") delete json2.format;\n              }\n              if (contentEncoding) json2.contentEncoding = contentEncoding;\n              if (patterns && patterns.size > 0) {\n                const regexes = [...patterns];\n                if (regexes.length === 1) json2.pattern = regexes[0].source;else if (regexes.length > 1) {\n                  result.schema.allOf = [...regexes.map(regex => ({\n                    ...(this.target === \"draft-7\" ? {\n                      type: \"string\"\n                    } : {}),\n                    pattern: regex.source\n                  }))];\n                }\n              }\n              break;\n            }\n          case \"number\":\n            {\n              const json2 = _json;\n              const {\n                minimum,\n                maximum,\n                format,\n                multipleOf,\n                exclusiveMaximum,\n                exclusiveMinimum\n              } = schema._zod.bag;\n              if (typeof format === \"string\" && format.includes(\"int\")) json2.type = \"integer\";else json2.type = \"number\";\n              if (typeof exclusiveMinimum === \"number\") json2.exclusiveMinimum = exclusiveMinimum;\n              if (typeof minimum === \"number\") {\n                json2.minimum = minimum;\n                if (typeof exclusiveMinimum === \"number\") {\n                  if (exclusiveMinimum >= minimum) delete json2.minimum;else delete json2.exclusiveMinimum;\n                }\n              }\n              if (typeof exclusiveMaximum === \"number\") json2.exclusiveMaximum = exclusiveMaximum;\n              if (typeof maximum === \"number\") {\n                json2.maximum = maximum;\n                if (typeof exclusiveMaximum === \"number\") {\n                  if (exclusiveMaximum <= maximum) delete json2.maximum;else delete json2.exclusiveMaximum;\n                }\n              }\n              if (typeof multipleOf === \"number\") json2.multipleOf = multipleOf;\n              break;\n            }\n          case \"boolean\":\n            {\n              const json2 = _json;\n              json2.type = \"boolean\";\n              break;\n            }\n          case \"bigint\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"BigInt cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"symbol\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"Symbols cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"null\":\n            {\n              _json.type = \"null\";\n              break;\n            }\n          case \"any\":\n            {\n              break;\n            }\n          case \"unknown\":\n            {\n              break;\n            }\n          case \"undefined\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"Undefined cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"void\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"Void cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"never\":\n            {\n              _json.not = {};\n              break;\n            }\n          case \"date\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"Date cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"array\":\n            {\n              const json2 = _json;\n              const {\n                minimum,\n                maximum\n              } = schema._zod.bag;\n              if (typeof minimum === \"number\") json2.minItems = minimum;\n              if (typeof maximum === \"number\") json2.maxItems = maximum;\n              json2.type = \"array\";\n              json2.items = this.process(def.element, {\n                ...params,\n                path: [...params.path, \"items\"]\n              });\n              break;\n            }\n          case \"object\":\n            {\n              const json2 = _json;\n              json2.type = \"object\";\n              json2.properties = {};\n              const shape = def.shape;\n              for (const key in shape) {\n                json2.properties[key] = this.process(shape[key], {\n                  ...params,\n                  path: [...params.path, \"properties\", key]\n                });\n              }\n              const allKeys = new Set(Object.keys(shape));\n              const requiredKeys = new Set([...allKeys].filter(key => {\n                const v = def.shape[key]._zod;\n                if (this.io === \"input\") {\n                  return v.optin === void 0;\n                } else {\n                  return v.optout === void 0;\n                }\n              }));\n              if (requiredKeys.size > 0) {\n                json2.required = Array.from(requiredKeys);\n              }\n              if (def.catchall?._zod.def.type === \"never\") {\n                json2.additionalProperties = false;\n              } else if (!def.catchall) {\n                if (this.io === \"output\") json2.additionalProperties = false;\n              } else if (def.catchall) {\n                json2.additionalProperties = this.process(def.catchall, {\n                  ...params,\n                  path: [...params.path, \"additionalProperties\"]\n                });\n              }\n              break;\n            }\n          case \"union\":\n            {\n              const json2 = _json;\n              json2.anyOf = def.options.map((x, i) => this.process(x, {\n                ...params,\n                path: [...params.path, \"anyOf\", i]\n              }));\n              break;\n            }\n          case \"intersection\":\n            {\n              const json2 = _json;\n              const a = this.process(def.left, {\n                ...params,\n                path: [...params.path, \"allOf\", 0]\n              });\n              const b = this.process(def.right, {\n                ...params,\n                path: [...params.path, \"allOf\", 1]\n              });\n              const isSimpleIntersection = val => \"allOf\" in val && Object.keys(val).length === 1;\n              const allOf = [...(isSimpleIntersection(a) ? a.allOf : [a]), ...(isSimpleIntersection(b) ? b.allOf : [b])];\n              json2.allOf = allOf;\n              break;\n            }\n          case \"tuple\":\n            {\n              const json2 = _json;\n              json2.type = \"array\";\n              const prefixItems = def.items.map((x, i) => this.process(x, {\n                ...params,\n                path: [...params.path, \"prefixItems\", i]\n              }));\n              if (this.target === \"draft-2020-12\") {\n                json2.prefixItems = prefixItems;\n              } else {\n                json2.items = prefixItems;\n              }\n              if (def.rest) {\n                const rest = this.process(def.rest, {\n                  ...params,\n                  path: [...params.path, \"items\"]\n                });\n                if (this.target === \"draft-2020-12\") {\n                  json2.items = rest;\n                } else {\n                  json2.additionalItems = rest;\n                }\n              }\n              if (def.rest) {\n                json2.items = this.process(def.rest, {\n                  ...params,\n                  path: [...params.path, \"items\"]\n                });\n              }\n              const {\n                minimum,\n                maximum\n              } = schema._zod.bag;\n              if (typeof minimum === \"number\") json2.minItems = minimum;\n              if (typeof maximum === \"number\") json2.maxItems = maximum;\n              break;\n            }\n          case \"record\":\n            {\n              const json2 = _json;\n              json2.type = \"object\";\n              json2.propertyNames = this.process(def.keyType, {\n                ...params,\n                path: [...params.path, \"propertyNames\"]\n              });\n              json2.additionalProperties = this.process(def.valueType, {\n                ...params,\n                path: [...params.path, \"additionalProperties\"]\n              });\n              break;\n            }\n          case \"map\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"Map cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"set\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"Set cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"enum\":\n            {\n              const json2 = _json;\n              const values = getEnumValues(def.entries);\n              if (values.every(v => typeof v === \"number\")) json2.type = \"number\";\n              if (values.every(v => typeof v === \"string\")) json2.type = \"string\";\n              json2.enum = values;\n              break;\n            }\n          case \"literal\":\n            {\n              const json2 = _json;\n              const vals = [];\n              for (const val of def.values) {\n                if (val === void 0) {\n                  if (this.unrepresentable === \"throw\") {\n                    throw new Error(\"Literal `undefined` cannot be represented in JSON Schema\");\n                  } else {}\n                } else if (typeof val === \"bigint\") {\n                  if (this.unrepresentable === \"throw\") {\n                    throw new Error(\"BigInt literals cannot be represented in JSON Schema\");\n                  } else {\n                    vals.push(Number(val));\n                  }\n                } else {\n                  vals.push(val);\n                }\n              }\n              if (vals.length === 0) {} else if (vals.length === 1) {\n                const val = vals[0];\n                json2.type = val === null ? \"null\" : typeof val;\n                json2.const = val;\n              } else {\n                if (vals.every(v => typeof v === \"number\")) json2.type = \"number\";\n                if (vals.every(v => typeof v === \"string\")) json2.type = \"string\";\n                if (vals.every(v => typeof v === \"boolean\")) json2.type = \"string\";\n                if (vals.every(v => v === null)) json2.type = \"null\";\n                json2.enum = vals;\n              }\n              break;\n            }\n          case \"file\":\n            {\n              const json2 = _json;\n              const file2 = {\n                type: \"string\",\n                format: \"binary\",\n                contentEncoding: \"binary\"\n              };\n              const {\n                minimum,\n                maximum,\n                mime\n              } = schema._zod.bag;\n              if (minimum !== void 0) file2.minLength = minimum;\n              if (maximum !== void 0) file2.maxLength = maximum;\n              if (mime) {\n                if (mime.length === 1) {\n                  file2.contentMediaType = mime[0];\n                  Object.assign(json2, file2);\n                } else {\n                  json2.anyOf = mime.map(m => {\n                    const mFile = {\n                      ...file2,\n                      contentMediaType: m\n                    };\n                    return mFile;\n                  });\n                }\n              } else {\n                Object.assign(json2, file2);\n              }\n              break;\n            }\n          case \"transform\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"Transforms cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"nullable\":\n            {\n              const inner = this.process(def.innerType, params);\n              _json.anyOf = [inner, {\n                type: \"null\"\n              }];\n              break;\n            }\n          case \"nonoptional\":\n            {\n              this.process(def.innerType, params);\n              result.ref = def.innerType;\n              break;\n            }\n          case \"success\":\n            {\n              const json2 = _json;\n              json2.type = \"boolean\";\n              break;\n            }\n          case \"default\":\n            {\n              this.process(def.innerType, params);\n              result.ref = def.innerType;\n              _json.default = JSON.parse(JSON.stringify(def.defaultValue));\n              break;\n            }\n          case \"prefault\":\n            {\n              this.process(def.innerType, params);\n              result.ref = def.innerType;\n              if (this.io === \"input\") _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));\n              break;\n            }\n          case \"catch\":\n            {\n              this.process(def.innerType, params);\n              result.ref = def.innerType;\n              let catchValue;\n              try {\n                catchValue = def.catchValue(void 0);\n              } catch {\n                throw new Error(\"Dynamic catch values are not supported in JSON Schema\");\n              }\n              _json.default = catchValue;\n              break;\n            }\n          case \"nan\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"NaN cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"template_literal\":\n            {\n              const json2 = _json;\n              const pattern = schema._zod.pattern;\n              if (!pattern) throw new Error(\"Pattern not found in template literal\");\n              json2.type = \"string\";\n              json2.pattern = pattern.source;\n              break;\n            }\n          case \"pipe\":\n            {\n              const innerType = this.io === \"input\" ? def.in._zod.def.type === \"transform\" ? def.out : def.in : def.out;\n              this.process(innerType, params);\n              result.ref = innerType;\n              break;\n            }\n          case \"readonly\":\n            {\n              this.process(def.innerType, params);\n              result.ref = def.innerType;\n              _json.readOnly = true;\n              break;\n            }\n          // passthrough types\n          case \"promise\":\n            {\n              this.process(def.innerType, params);\n              result.ref = def.innerType;\n              break;\n            }\n          case \"optional\":\n            {\n              this.process(def.innerType, params);\n              result.ref = def.innerType;\n              break;\n            }\n          case \"lazy\":\n            {\n              const innerType = schema._zod.innerType;\n              this.process(innerType, params);\n              result.ref = innerType;\n              break;\n            }\n          case \"custom\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"Custom types cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          default:\n            {\n              def;\n            }\n        }\n      }\n    }\n    const meta = this.metadataRegistry.get(schema);\n    if (meta) Object.assign(result.schema, meta);\n    if (this.io === \"input\" && isTransforming(schema)) {\n      delete result.schema.examples;\n      delete result.schema.default;\n    }\n    if (this.io === \"input\" && result.schema._prefault) (_a20 = result.schema).default ?? (_a20.default = result.schema._prefault);\n    delete result.schema._prefault;\n    const _result = this.seen.get(schema);\n    return _result.schema;\n  }\n  emit(schema, _params) {\n    const params = {\n      cycles: _params?.cycles ?? \"ref\",\n      reused: _params?.reused ?? \"inline\",\n      // unrepresentable: _params?.unrepresentable ?? \"throw\",\n      // uri: _params?.uri ?? ((id) => `${id}`),\n      external: _params?.external ?? void 0\n    };\n    const root = this.seen.get(schema);\n    if (!root) throw new Error(\"Unprocessed schema. This is a bug in Zod.\");\n    const makeURI = entry => {\n      const defsSegment = this.target === \"draft-2020-12\" ? \"$defs\" : \"definitions\";\n      if (params.external) {\n        const externalId = params.external.registry.get(entry[0])?.id;\n        const uriGenerator = params.external.uri ?? (id2 => id2);\n        if (externalId) {\n          return {\n            ref: uriGenerator(externalId)\n          };\n        }\n        const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;\n        entry[1].defId = id;\n        return {\n          defId: id,\n          ref: `${uriGenerator(\"__shared\")}#/${defsSegment}/${id}`\n        };\n      }\n      if (entry[1] === root) {\n        return {\n          ref: \"#\"\n        };\n      }\n      const uriPrefix = `#`;\n      const defUriPrefix = `${uriPrefix}/${defsSegment}/`;\n      const defId = entry[1].schema.id ?? `__schema${this.counter++}`;\n      return {\n        defId,\n        ref: defUriPrefix + defId\n      };\n    };\n    const extractToDef = entry => {\n      if (entry[1].schema.$ref) {\n        return;\n      }\n      const seen = entry[1];\n      const {\n        ref,\n        defId\n      } = makeURI(entry);\n      seen.def = {\n        ...seen.schema\n      };\n      if (defId) seen.defId = defId;\n      const schema2 = seen.schema;\n      for (const key in schema2) {\n        delete schema2[key];\n      }\n      schema2.$ref = ref;\n    };\n    if (params.cycles === \"throw\") {\n      for (const entry of this.seen.entries()) {\n        const seen = entry[1];\n        if (seen.cycle) {\n          throw new Error(`Cycle detected: #/${seen.cycle?.join(\"/\")}/<root>\n\nSet the \\`cycles\\` parameter to \\`\"ref\"\\` to resolve cyclical schemas with defs.`);\n        }\n      }\n    }\n    for (const entry of this.seen.entries()) {\n      const seen = entry[1];\n      if (schema === entry[0]) {\n        extractToDef(entry);\n        continue;\n      }\n      if (params.external) {\n        const ext = params.external.registry.get(entry[0])?.id;\n        if (schema !== entry[0] && ext) {\n          extractToDef(entry);\n          continue;\n        }\n      }\n      const id = this.metadataRegistry.get(entry[0])?.id;\n      if (id) {\n        extractToDef(entry);\n        continue;\n      }\n      if (seen.cycle) {\n        extractToDef(entry);\n        continue;\n      }\n      if (seen.count > 1) {\n        if (params.reused === \"ref\") {\n          extractToDef(entry);\n          continue;\n        }\n      }\n    }\n    const flattenRef = (zodSchema2, params2) => {\n      const seen = this.seen.get(zodSchema2);\n      const schema2 = seen.def ?? seen.schema;\n      const _cached = {\n        ...schema2\n      };\n      if (seen.ref === null) {\n        return;\n      }\n      const ref = seen.ref;\n      seen.ref = null;\n      if (ref) {\n        flattenRef(ref, params2);\n        const refSchema = this.seen.get(ref).schema;\n        if (refSchema.$ref && params2.target === \"draft-7\") {\n          schema2.allOf = schema2.allOf ?? [];\n          schema2.allOf.push(refSchema);\n        } else {\n          Object.assign(schema2, refSchema);\n          Object.assign(schema2, _cached);\n        }\n      }\n      if (!seen.isParent) this.override({\n        zodSchema: zodSchema2,\n        jsonSchema: schema2,\n        path: seen.path ?? []\n      });\n    };\n    for (const entry of [...this.seen.entries()].reverse()) {\n      flattenRef(entry[0], {\n        target: this.target\n      });\n    }\n    const result = {};\n    if (this.target === \"draft-2020-12\") {\n      result.$schema = \"https://json-schema.org/draft/2020-12/schema\";\n    } else if (this.target === \"draft-7\") {\n      result.$schema = \"http://json-schema.org/draft-07/schema#\";\n    } else {\n      console.warn(`Invalid target: ${this.target}`);\n    }\n    if (params.external?.uri) {\n      const id = params.external.registry.get(schema)?.id;\n      if (!id) throw new Error(\"Schema is missing an `id` property\");\n      result.$id = params.external.uri(id);\n    }\n    Object.assign(result, root.def);\n    const defs = params.external?.defs ?? {};\n    for (const entry of this.seen.entries()) {\n      const seen = entry[1];\n      if (seen.def && seen.defId) {\n        defs[seen.defId] = seen.def;\n      }\n    }\n    if (params.external) {} else {\n      if (Object.keys(defs).length > 0) {\n        if (this.target === \"draft-2020-12\") {\n          result.$defs = defs;\n        } else {\n          result.definitions = defs;\n        }\n      }\n    }\n    try {\n      return JSON.parse(JSON.stringify(result));\n    } catch (_err) {\n      throw new Error(\"Error converting schema to JSON.\");\n    }\n  }\n};\nfunction toJSONSchema(input, _params) {\n  if (input instanceof $ZodRegistry) {\n    const gen2 = new JSONSchemaGenerator(_params);\n    const defs = {};\n    for (const entry of input._idmap.entries()) {\n      const [_, schema] = entry;\n      gen2.process(schema);\n    }\n    const schemas = {};\n    const external = {\n      registry: input,\n      uri: _params?.uri,\n      defs\n    };\n    for (const entry of input._idmap.entries()) {\n      const [key, schema] = entry;\n      schemas[key] = gen2.emit(schema, {\n        ..._params,\n        external\n      });\n    }\n    if (Object.keys(defs).length > 0) {\n      const defsSegment = gen2.target === \"draft-2020-12\" ? \"$defs\" : \"definitions\";\n      schemas.__shared = {\n        [defsSegment]: defs\n      };\n    }\n    return {\n      schemas\n    };\n  }\n  const gen = new JSONSchemaGenerator(_params);\n  gen.process(input);\n  return gen.emit(input, _params);\n}\nfunction isTransforming(_schema, _ctx) {\n  const ctx = _ctx ?? {\n    seen: /* @__PURE__ */new Set()\n  };\n  if (ctx.seen.has(_schema)) return false;\n  ctx.seen.add(_schema);\n  const schema = _schema;\n  const def = schema._zod.def;\n  switch (def.type) {\n    case \"string\":\n    case \"number\":\n    case \"bigint\":\n    case \"boolean\":\n    case \"date\":\n    case \"symbol\":\n    case \"undefined\":\n    case \"null\":\n    case \"any\":\n    case \"unknown\":\n    case \"never\":\n    case \"void\":\n    case \"literal\":\n    case \"enum\":\n    case \"nan\":\n    case \"file\":\n    case \"template_literal\":\n      return false;\n    case \"array\":\n      {\n        return isTransforming(def.element, ctx);\n      }\n    case \"object\":\n      {\n        for (const key in def.shape) {\n          if (isTransforming(def.shape[key], ctx)) return true;\n        }\n        return false;\n      }\n    case \"union\":\n      {\n        for (const option of def.options) {\n          if (isTransforming(option, ctx)) return true;\n        }\n        return false;\n      }\n    case \"intersection\":\n      {\n        return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);\n      }\n    case \"tuple\":\n      {\n        for (const item of def.items) {\n          if (isTransforming(item, ctx)) return true;\n        }\n        if (def.rest && isTransforming(def.rest, ctx)) return true;\n        return false;\n      }\n    case \"record\":\n      {\n        return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);\n      }\n    case \"map\":\n      {\n        return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);\n      }\n    case \"set\":\n      {\n        return isTransforming(def.valueType, ctx);\n      }\n    // inner types\n    case \"promise\":\n    case \"optional\":\n    case \"nonoptional\":\n    case \"nullable\":\n    case \"readonly\":\n      return isTransforming(def.innerType, ctx);\n    case \"lazy\":\n      return isTransforming(def.getter(), ctx);\n    case \"default\":\n      {\n        return isTransforming(def.innerType, ctx);\n      }\n    case \"prefault\":\n      {\n        return isTransforming(def.innerType, ctx);\n      }\n    case \"custom\":\n      {\n        return false;\n      }\n    case \"transform\":\n      {\n        return true;\n      }\n    case \"pipe\":\n      {\n        return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);\n      }\n    case \"success\":\n      {\n        return false;\n      }\n    case \"catch\":\n      {\n        return false;\n      }\n    default:\n      def;\n  }\n  throw new Error(`Unknown schema type: ${def.type}`);\n}\n\n// ../../node_modules/zod/v4/core/json-schema.js\nvar json_schema_exports = {};\n\n// ../../node_modules/zod/v4/classic/iso.js\nvar iso_exports = {};\n__export(iso_exports, {\n  ZodISODate: () => ZodISODate,\n  ZodISODateTime: () => ZodISODateTime,\n  ZodISODuration: () => ZodISODuration,\n  ZodISOTime: () => ZodISOTime,\n  date: () => date2,\n  datetime: () => datetime2,\n  duration: () => duration2,\n  time: () => time2\n});\nvar ZodISODateTime = /* @__PURE__ */$constructor(\"ZodISODateTime\", (inst, def) => {\n  $ZodISODateTime.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction datetime2(params) {\n  return _isoDateTime(ZodISODateTime, params);\n}\nvar ZodISODate = /* @__PURE__ */$constructor(\"ZodISODate\", (inst, def) => {\n  $ZodISODate.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction date2(params) {\n  return _isoDate(ZodISODate, params);\n}\nvar ZodISOTime = /* @__PURE__ */$constructor(\"ZodISOTime\", (inst, def) => {\n  $ZodISOTime.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction time2(params) {\n  return _isoTime(ZodISOTime, params);\n}\nvar ZodISODuration = /* @__PURE__ */$constructor(\"ZodISODuration\", (inst, def) => {\n  $ZodISODuration.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction duration2(params) {\n  return _isoDuration(ZodISODuration, params);\n}\n\n// ../../node_modules/zod/v4/classic/errors.js\nvar initializer2 = (inst, issues) => {\n  $ZodError.init(inst, issues);\n  inst.name = \"ZodError\";\n  Object.defineProperties(inst, {\n    format: {\n      value: mapper => formatError(inst, mapper)\n      // enumerable: false,\n    },\n    flatten: {\n      value: mapper => flattenError(inst, mapper)\n      // enumerable: false,\n    },\n    addIssue: {\n      value: issue2 => inst.issues.push(issue2)\n      // enumerable: false,\n    },\n    addIssues: {\n      value: issues2 => inst.issues.push(...issues2)\n      // enumerable: false,\n    },\n    isEmpty: {\n      get() {\n        return inst.issues.length === 0;\n      }\n      // enumerable: false,\n    }\n  });\n};\nvar ZodError2 = $constructor(\"ZodError\", initializer2);\nvar ZodRealError = $constructor(\"ZodError\", initializer2, {\n  Parent: Error\n});\n\n// ../../node_modules/zod/v4/classic/parse.js\nvar parse2 = /* @__PURE__ */_parse(ZodRealError);\nvar parseAsync2 = /* @__PURE__ */_parseAsync(ZodRealError);\nvar safeParse2 = /* @__PURE__ */_safeParse(ZodRealError);\nvar safeParseAsync2 = /* @__PURE__ */_safeParseAsync(ZodRealError);\n\n// ../../node_modules/zod/v4/classic/schemas.js\nvar ZodType2 = /* @__PURE__ */$constructor(\"ZodType\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst.def = def;\n  Object.defineProperty(inst, \"_def\", {\n    value: def\n  });\n  inst.check = (...checks) => {\n    return inst.clone({\n      ...def,\n      checks: [...(def.checks ?? []), ...checks.map(ch => typeof ch === \"function\" ? {\n        _zod: {\n          check: ch,\n          def: {\n            check: \"custom\"\n          },\n          onattach: []\n        }\n      } : ch)]\n    }\n    // { parent: true }\n    );\n  };\n  inst.clone = (def2, params) => clone(inst, def2, params);\n  inst.brand = () => inst;\n  inst.register = (reg, meta) => {\n    reg.add(inst, meta);\n    return inst;\n  };\n  inst.parse = (data, params) => parse2(inst, data, params, {\n    callee: inst.parse\n  });\n  inst.safeParse = (data, params) => safeParse2(inst, data, params);\n  inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, {\n    callee: inst.parseAsync\n  });\n  inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);\n  inst.spa = inst.safeParseAsync;\n  inst.refine = (check2, params) => inst.check(refine(check2, params));\n  inst.superRefine = refinement => inst.check(superRefine(refinement));\n  inst.overwrite = fn => inst.check(_overwrite(fn));\n  inst.optional = () => optional(inst);\n  inst.nullable = () => nullable(inst);\n  inst.nullish = () => optional(nullable(inst));\n  inst.nonoptional = params => nonoptional(inst, params);\n  inst.array = () => array(inst);\n  inst.or = arg => union([inst, arg]);\n  inst.and = arg => intersection(inst, arg);\n  inst.transform = tx => pipe(inst, transform(tx));\n  inst.default = def2 => _default2(inst, def2);\n  inst.prefault = def2 => prefault(inst, def2);\n  inst.catch = params => _catch2(inst, params);\n  inst.pipe = target => pipe(inst, target);\n  inst.readonly = () => readonly(inst);\n  inst.describe = description => {\n    const cl = inst.clone();\n    globalRegistry.add(cl, {\n      description\n    });\n    return cl;\n  };\n  Object.defineProperty(inst, \"description\", {\n    get() {\n      return globalRegistry.get(inst)?.description;\n    },\n    configurable: true\n  });\n  inst.meta = (...args) => {\n    if (args.length === 0) {\n      return globalRegistry.get(inst);\n    }\n    const cl = inst.clone();\n    globalRegistry.add(cl, args[0]);\n    return cl;\n  };\n  inst.isOptional = () => inst.safeParse(void 0).success;\n  inst.isNullable = () => inst.safeParse(null).success;\n  return inst;\n});\nvar _ZodString = /* @__PURE__ */$constructor(\"_ZodString\", (inst, def) => {\n  $ZodString.init(inst, def);\n  ZodType2.init(inst, def);\n  const bag = inst._zod.bag;\n  inst.format = bag.format ?? null;\n  inst.minLength = bag.minimum ?? null;\n  inst.maxLength = bag.maximum ?? null;\n  inst.regex = (...args) => inst.check(_regex(...args));\n  inst.includes = (...args) => inst.check(_includes(...args));\n  inst.startsWith = (...args) => inst.check(_startsWith(...args));\n  inst.endsWith = (...args) => inst.check(_endsWith(...args));\n  inst.min = (...args) => inst.check(_minLength(...args));\n  inst.max = (...args) => inst.check(_maxLength(...args));\n  inst.length = (...args) => inst.check(_length(...args));\n  inst.nonempty = (...args) => inst.check(_minLength(1, ...args));\n  inst.lowercase = params => inst.check(_lowercase(params));\n  inst.uppercase = params => inst.check(_uppercase(params));\n  inst.trim = () => inst.check(_trim());\n  inst.normalize = (...args) => inst.check(_normalize(...args));\n  inst.toLowerCase = () => inst.check(_toLowerCase());\n  inst.toUpperCase = () => inst.check(_toUpperCase());\n});\nvar ZodString2 = /* @__PURE__ */$constructor(\"ZodString\", (inst, def) => {\n  $ZodString.init(inst, def);\n  _ZodString.init(inst, def);\n  inst.email = params => inst.check(_email(ZodEmail, params));\n  inst.url = params => inst.check(_url(ZodURL, params));\n  inst.jwt = params => inst.check(_jwt(ZodJWT, params));\n  inst.emoji = params => inst.check(_emoji2(ZodEmoji, params));\n  inst.guid = params => inst.check(_guid(ZodGUID, params));\n  inst.uuid = params => inst.check(_uuid(ZodUUID, params));\n  inst.uuidv4 = params => inst.check(_uuidv4(ZodUUID, params));\n  inst.uuidv6 = params => inst.check(_uuidv6(ZodUUID, params));\n  inst.uuidv7 = params => inst.check(_uuidv7(ZodUUID, params));\n  inst.nanoid = params => inst.check(_nanoid(ZodNanoID, params));\n  inst.guid = params => inst.check(_guid(ZodGUID, params));\n  inst.cuid = params => inst.check(_cuid(ZodCUID, params));\n  inst.cuid2 = params => inst.check(_cuid2(ZodCUID2, params));\n  inst.ulid = params => inst.check(_ulid(ZodULID, params));\n  inst.base64 = params => inst.check(_base64(ZodBase64, params));\n  inst.base64url = params => inst.check(_base64url(ZodBase64URL, params));\n  inst.xid = params => inst.check(_xid(ZodXID, params));\n  inst.ksuid = params => inst.check(_ksuid(ZodKSUID, params));\n  inst.ipv4 = params => inst.check(_ipv4(ZodIPv4, params));\n  inst.ipv6 = params => inst.check(_ipv6(ZodIPv6, params));\n  inst.cidrv4 = params => inst.check(_cidrv4(ZodCIDRv4, params));\n  inst.cidrv6 = params => inst.check(_cidrv6(ZodCIDRv6, params));\n  inst.e164 = params => inst.check(_e164(ZodE164, params));\n  inst.datetime = params => inst.check(datetime2(params));\n  inst.date = params => inst.check(date2(params));\n  inst.time = params => inst.check(time2(params));\n  inst.duration = params => inst.check(duration2(params));\n});\nfunction string2(params) {\n  return _string(ZodString2, params);\n}\nvar ZodStringFormat = /* @__PURE__ */$constructor(\"ZodStringFormat\", (inst, def) => {\n  $ZodStringFormat.init(inst, def);\n  _ZodString.init(inst, def);\n});\nvar ZodEmail = /* @__PURE__ */$constructor(\"ZodEmail\", (inst, def) => {\n  $ZodEmail.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction email2(params) {\n  return _email(ZodEmail, params);\n}\nvar ZodGUID = /* @__PURE__ */$constructor(\"ZodGUID\", (inst, def) => {\n  $ZodGUID.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction guid2(params) {\n  return _guid(ZodGUID, params);\n}\nvar ZodUUID = /* @__PURE__ */$constructor(\"ZodUUID\", (inst, def) => {\n  $ZodUUID.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction uuid2(params) {\n  return _uuid(ZodUUID, params);\n}\nfunction uuidv4(params) {\n  return _uuidv4(ZodUUID, params);\n}\nfunction uuidv6(params) {\n  return _uuidv6(ZodUUID, params);\n}\nfunction uuidv7(params) {\n  return _uuidv7(ZodUUID, params);\n}\nvar ZodURL = /* @__PURE__ */$constructor(\"ZodURL\", (inst, def) => {\n  $ZodURL.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction url(params) {\n  return _url(ZodURL, params);\n}\nvar ZodEmoji = /* @__PURE__ */$constructor(\"ZodEmoji\", (inst, def) => {\n  $ZodEmoji.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction emoji2(params) {\n  return _emoji2(ZodEmoji, params);\n}\nvar ZodNanoID = /* @__PURE__ */$constructor(\"ZodNanoID\", (inst, def) => {\n  $ZodNanoID.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction nanoid2(params) {\n  return _nanoid(ZodNanoID, params);\n}\nvar ZodCUID = /* @__PURE__ */$constructor(\"ZodCUID\", (inst, def) => {\n  $ZodCUID.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction cuid3(params) {\n  return _cuid(ZodCUID, params);\n}\nvar ZodCUID2 = /* @__PURE__ */$constructor(\"ZodCUID2\", (inst, def) => {\n  $ZodCUID2.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction cuid22(params) {\n  return _cuid2(ZodCUID2, params);\n}\nvar ZodULID = /* @__PURE__ */$constructor(\"ZodULID\", (inst, def) => {\n  $ZodULID.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction ulid2(params) {\n  return _ulid(ZodULID, params);\n}\nvar ZodXID = /* @__PURE__ */$constructor(\"ZodXID\", (inst, def) => {\n  $ZodXID.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction xid2(params) {\n  return _xid(ZodXID, params);\n}\nvar ZodKSUID = /* @__PURE__ */$constructor(\"ZodKSUID\", (inst, def) => {\n  $ZodKSUID.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction ksuid2(params) {\n  return _ksuid(ZodKSUID, params);\n}\nvar ZodIPv4 = /* @__PURE__ */$constructor(\"ZodIPv4\", (inst, def) => {\n  $ZodIPv4.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction ipv42(params) {\n  return _ipv4(ZodIPv4, params);\n}\nvar ZodIPv6 = /* @__PURE__ */$constructor(\"ZodIPv6\", (inst, def) => {\n  $ZodIPv6.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction ipv62(params) {\n  return _ipv6(ZodIPv6, params);\n}\nvar ZodCIDRv4 = /* @__PURE__ */$constructor(\"ZodCIDRv4\", (inst, def) => {\n  $ZodCIDRv4.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction cidrv42(params) {\n  return _cidrv4(ZodCIDRv4, params);\n}\nvar ZodCIDRv6 = /* @__PURE__ */$constructor(\"ZodCIDRv6\", (inst, def) => {\n  $ZodCIDRv6.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction cidrv62(params) {\n  return _cidrv6(ZodCIDRv6, params);\n}\nvar ZodBase64 = /* @__PURE__ */$constructor(\"ZodBase64\", (inst, def) => {\n  $ZodBase64.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction base642(params) {\n  return _base64(ZodBase64, params);\n}\nvar ZodBase64URL = /* @__PURE__ */$constructor(\"ZodBase64URL\", (inst, def) => {\n  $ZodBase64URL.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction base64url2(params) {\n  return _base64url(ZodBase64URL, params);\n}\nvar ZodE164 = /* @__PURE__ */$constructor(\"ZodE164\", (inst, def) => {\n  $ZodE164.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction e1642(params) {\n  return _e164(ZodE164, params);\n}\nvar ZodJWT = /* @__PURE__ */$constructor(\"ZodJWT\", (inst, def) => {\n  $ZodJWT.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction jwt(params) {\n  return _jwt(ZodJWT, params);\n}\nvar ZodCustomStringFormat = /* @__PURE__ */$constructor(\"ZodCustomStringFormat\", (inst, def) => {\n  $ZodCustomStringFormat.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction stringFormat(format, fnOrRegex, _params = {}) {\n  return _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);\n}\nvar ZodNumber2 = /* @__PURE__ */$constructor(\"ZodNumber\", (inst, def) => {\n  $ZodNumber.init(inst, def);\n  ZodType2.init(inst, def);\n  inst.gt = (value, params) => inst.check(_gt(value, params));\n  inst.gte = (value, params) => inst.check(_gte(value, params));\n  inst.min = (value, params) => inst.check(_gte(value, params));\n  inst.lt = (value, params) => inst.check(_lt(value, params));\n  inst.lte = (value, params) => inst.check(_lte(value, params));\n  inst.max = (value, params) => inst.check(_lte(value, params));\n  inst.int = params => inst.check(int(params));\n  inst.safe = params => inst.check(int(params));\n  inst.positive = params => inst.check(_gt(0, params));\n  inst.nonnegative = params => inst.check(_gte(0, params));\n  inst.negative = params => inst.check(_lt(0, params));\n  inst.nonpositive = params => inst.check(_lte(0, params));\n  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));\n  inst.step = (value, params) => inst.check(_multipleOf(value, params));\n  inst.finite = () => inst;\n  const bag = inst._zod.bag;\n  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;\n  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;\n  inst.isInt = (bag.format ?? \"\").includes(\"int\") || Number.isSafeInteger(bag.multipleOf ?? 0.5);\n  inst.isFinite = true;\n  inst.format = bag.format ?? null;\n});\nfunction number2(params) {\n  return _number(ZodNumber2, params);\n}\nvar ZodNumberFormat = /* @__PURE__ */$constructor(\"ZodNumberFormat\", (inst, def) => {\n  $ZodNumberFormat.init(inst, def);\n  ZodNumber2.init(inst, def);\n});\nfunction int(params) {\n  return _int(ZodNumberFormat, params);\n}\nfunction float32(params) {\n  return _float32(ZodNumberFormat, params);\n}\nfunction float64(params) {\n  return _float64(ZodNumberFormat, params);\n}\nfunction int32(params) {\n  return _int32(ZodNumberFormat, params);\n}\nfunction uint32(params) {\n  return _uint32(ZodNumberFormat, params);\n}\nvar ZodBoolean2 = /* @__PURE__ */$constructor(\"ZodBoolean\", (inst, def) => {\n  $ZodBoolean.init(inst, def);\n  ZodType2.init(inst, def);\n});\nfunction boolean2(params) {\n  return _boolean(ZodBoolean2, params);\n}\nvar ZodBigInt2 = /* @__PURE__ */$constructor(\"ZodBigInt\", (inst, def) => {\n  $ZodBigInt.init(inst, def);\n  ZodType2.init(inst, def);\n  inst.gte = (value, params) => inst.check(_gte(value, params));\n  inst.min = (value, params) => inst.check(_gte(value, params));\n  inst.gt = (value, params) => inst.check(_gt(value, params));\n  inst.gte = (value, params) => inst.check(_gte(value, params));\n  inst.min = (value, params) => inst.check(_gte(value, params));\n  inst.lt = (value, params) => inst.check(_lt(value, params));\n  inst.lte = (value, params) => inst.check(_lte(value, params));\n  inst.max = (value, params) => inst.check(_lte(value, params));\n  inst.positive = params => inst.check(_gt(BigInt(0), params));\n  inst.negative = params => inst.check(_lt(BigInt(0), params));\n  inst.nonpositive = params => inst.check(_lte(BigInt(0), params));\n  inst.nonnegative = params => inst.check(_gte(BigInt(0), params));\n  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));\n  const bag = inst._zod.bag;\n  inst.minValue = bag.minimum ?? null;\n  inst.maxValue = bag.maximum ?? null;\n  inst.format = bag.format ?? null;\n});\nfunction bigint2(params) {\n  return _bigint(ZodBigInt2, params);\n}\nvar ZodBigIntFormat = /* @__PURE__ */$constructor(\"ZodBigIntFormat\", (inst, def) => {\n  $ZodBigIntFormat.init(inst, def);\n  ZodBigInt2.init(inst, def);\n});\nfunction int64(params) {\n  return _int64(ZodBigIntFormat, params);\n}\nfunction uint64(params) {\n  return _uint64(ZodBigIntFormat, params);\n}\nvar ZodSymbol2 = /* @__PURE__ */$constructor(\"ZodSymbol\", (inst, def) => {\n  $ZodSymbol.init(inst, def);\n  ZodType2.init(inst, def);\n});\nfunction symbol15(params) {\n  return _symbol(ZodSymbol2, params);\n}\nvar ZodUndefined2 = /* @__PURE__ */$constructor(\"ZodUndefined\", (inst, def) => {\n  $ZodUndefined.init(inst, def);\n  ZodType2.init(inst, def);\n});\nfunction _undefined3(params) {\n  return _undefined2(ZodUndefined2, params);\n}\nvar ZodNull2 = /* @__PURE__ */$constructor(\"ZodNull\", (inst, def) => {\n  $ZodNull.init(inst, def);\n  ZodType2.init(inst, def);\n});\nfunction _null3(params) {\n  return _null2(ZodNull2, params);\n}\nvar ZodAny2 = /* @__PURE__ */$constructor(\"ZodAny\", (inst, def) => {\n  $ZodAny.init(inst, def);\n  ZodType2.init(inst, def);\n});\nfunction any() {\n  return _any(ZodAny2);\n}\nvar ZodUnknown2 = /* @__PURE__ */$constructor(\"ZodUnknown\", (inst, def) => {\n  $ZodUnknown.init(inst, def);\n  ZodType2.init(inst, def);\n});\nfunction unknown() {\n  return _unknown(ZodUnknown2);\n}\nvar ZodNever2 = /* @__PURE__ */$constructor(\"ZodNever\", (inst, def) => {\n  $ZodNever.init(inst, def);\n  ZodType2.init(inst, def);\n});\nfunction never(params) {\n  return _never(ZodNever2, params);\n}\nvar ZodVoid2 = /* @__PURE__ */$constructor(\"ZodVoid\", (inst, def) => {\n  $ZodVoid.init(inst, def);\n  ZodType2.init(inst, def);\n});\nfunction _void2(params) {\n  return _void(ZodVoid2, params);\n}\nvar ZodDate2 = /* @__PURE__ */$constructor(\"ZodDate\", (inst, def) => {\n  $ZodDate.init(inst, def);\n  ZodType2.init(inst, def);\n  inst.min = (value, params) => inst.check(_gte(value, params));\n  inst.max = (value, params) => inst.check(_lte(value, params));\n  const c = inst._zod.bag;\n  inst.minDate = c.minimum ? new Date(c.minimum) : null;\n  inst.maxDate = c.maximum ? new Date(c.maximum) : null;\n});\nfunction date3(params) {\n  return _date(ZodDate2, params);\n}\nvar ZodArray2 = /* @__PURE__ */$constructor(\"ZodArray\", (inst, def) => {\n  $ZodArray.init(inst, def);\n  ZodType2.init(inst, def);\n  inst.element = def.element;\n  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));\n  inst.nonempty = params => inst.check(_minLength(1, params));\n  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));\n  inst.length = (len, params) => inst.check(_length(len, params));\n  inst.unwrap = () => inst.element;\n});\nfunction array(element, params) {\n  return _array(ZodArray2, element, params);\n}\nfunction keyof(schema) {\n  const shape = schema._zod.def.shape;\n  return literal(Object.keys(shape));\n}\nvar ZodObject2 = /* @__PURE__ */$constructor(\"ZodObject\", (inst, def) => {\n  $ZodObject.init(inst, def);\n  ZodType2.init(inst, def);\n  util_exports.defineLazy(inst, \"shape\", () => def.shape);\n  inst.keyof = () => _enum2(Object.keys(inst._zod.def.shape));\n  inst.catchall = catchall => inst.clone({\n    ...inst._zod.def,\n    catchall\n  });\n  inst.passthrough = () => inst.clone({\n    ...inst._zod.def,\n    catchall: unknown()\n  });\n  inst.loose = () => inst.clone({\n    ...inst._zod.def,\n    catchall: unknown()\n  });\n  inst.strict = () => inst.clone({\n    ...inst._zod.def,\n    catchall: never()\n  });\n  inst.strip = () => inst.clone({\n    ...inst._zod.def,\n    catchall: void 0\n  });\n  inst.extend = incoming => {\n    return util_exports.extend(inst, incoming);\n  };\n  inst.merge = other => util_exports.merge(inst, other);\n  inst.pick = mask => util_exports.pick(inst, mask);\n  inst.omit = mask => util_exports.omit(inst, mask);\n  inst.partial = (...args) => util_exports.partial(ZodOptional2, inst, args[0]);\n  inst.required = (...args) => util_exports.required(ZodNonOptional, inst, args[0]);\n});\nfunction object(shape, params) {\n  const def = {\n    type: \"object\",\n    get shape() {\n      util_exports.assignProp(this, \"shape\", {\n        ...shape\n      });\n      return this.shape;\n    },\n    ...util_exports.normalizeParams(params)\n  };\n  return new ZodObject2(def);\n}\nfunction strictObject(shape, params) {\n  return new ZodObject2({\n    type: \"object\",\n    get shape() {\n      util_exports.assignProp(this, \"shape\", {\n        ...shape\n      });\n      return this.shape;\n    },\n    catchall: never(),\n    ...util_exports.normalizeParams(params)\n  });\n}\nfunction looseObject(shape, params) {\n  return new ZodObject2({\n    type: \"object\",\n    get shape() {\n      util_exports.assignProp(this, \"shape\", {\n        ...shape\n      });\n      return this.shape;\n    },\n    catchall: unknown(),\n    ...util_exports.normalizeParams(params)\n  });\n}\nvar ZodUnion2 = /* @__PURE__ */$constructor(\"ZodUnion\", (inst, def) => {\n  $ZodUnion.init(inst, def);\n  ZodType2.init(inst, def);\n  inst.options = def.options;\n});\nfunction union(options, params) {\n  return new ZodUnion2({\n    type: \"union\",\n    options,\n    ...util_exports.normalizeParams(params)\n  });\n}\nvar ZodDiscriminatedUnion2 = /* @__PURE__ */$constructor(\"ZodDiscriminatedUnion\", (inst, def) => {\n  ZodUnion2.init(inst, def);\n  $ZodDiscriminatedUnion.init(inst, def);\n});\nfunction discriminatedUnion(discriminator, options, params) {\n  return new ZodDiscriminatedUnion2({\n    type: \"union\",\n    options,\n    discriminator,\n    ...util_exports.normalizeParams(params)\n  });\n}\nvar ZodIntersection2 = /* @__PURE__ */$constructor(\"ZodIntersection\", (inst, def) => {\n  $ZodIntersection.init(inst, def);\n  ZodType2.init(inst, def);\n});\nfunction intersection(left, right) {\n  return new ZodIntersection2({\n    type: \"intersection\",\n    left,\n    right\n  });\n}\nvar ZodTuple2 = /* @__PURE__ */$constructor(\"ZodTuple\", (inst, def) => {\n  $ZodTuple.init(inst, def);\n  ZodType2.init(inst, def);\n  inst.rest = rest => inst.clone({\n    ...inst._zod.def,\n    rest\n  });\n});\nfunction tuple(items, _paramsOrRest, _params) {\n  const hasRest = _paramsOrRest instanceof $ZodType;\n  const params = hasRest ? _params : _paramsOrRest;\n  const rest = hasRest ? _paramsOrRest : null;\n  return new ZodTuple2({\n    type: \"tuple\",\n    items,\n    rest,\n    ...util_exports.normalizeParams(params)\n  });\n}\nvar ZodRecord2 = /* @__PURE__ */$constructor(\"ZodRecord\", (inst, def) => {\n  $ZodRecord.init(inst, def);\n  ZodType2.init(inst, def);\n  inst.keyType = def.keyType;\n  inst.valueType = def.valueType;\n});\nfunction record(keyType, valueType, params) {\n  return new ZodRecord2({\n    type: \"record\",\n    keyType,\n    valueType,\n    ...util_exports.normalizeParams(params)\n  });\n}\nfunction partialRecord(keyType, valueType, params) {\n  return new ZodRecord2({\n    type: \"record\",\n    keyType: union([keyType, never()]),\n    valueType,\n    ...util_exports.normalizeParams(params)\n  });\n}\nvar ZodMap2 = /* @__PURE__ */$constructor(\"ZodMap\", (inst, def) => {\n  $ZodMap.init(inst, def);\n  ZodType2.init(inst, def);\n  inst.keyType = def.keyType;\n  inst.valueType = def.valueType;\n});\nfunction map(keyType, valueType, params) {\n  return new ZodMap2({\n    type: \"map\",\n    keyType,\n    valueType,\n    ...util_exports.normalizeParams(params)\n  });\n}\nvar ZodSet2 = /* @__PURE__ */$constructor(\"ZodSet\", (inst, def) => {\n  $ZodSet.init(inst, def);\n  ZodType2.init(inst, def);\n  inst.min = (...args) => inst.check(_minSize(...args));\n  inst.nonempty = params => inst.check(_minSize(1, params));\n  inst.max = (...args) => inst.check(_maxSize(...args));\n  inst.size = (...args) => inst.check(_size(...args));\n});\nfunction set(valueType, params) {\n  return new ZodSet2({\n    type: \"set\",\n    valueType,\n    ...util_exports.normalizeParams(params)\n  });\n}\nvar ZodEnum2 = /* @__PURE__ */$constructor(\"ZodEnum\", (inst, def) => {\n  $ZodEnum.init(inst, def);\n  ZodType2.init(inst, def);\n  inst.enum = def.entries;\n  inst.options = Object.values(def.entries);\n  const keys2 = new Set(Object.keys(def.entries));\n  inst.extract = (values, params) => {\n    const newEntries = {};\n    for (const value of values) {\n      if (keys2.has(value)) {\n        newEntries[value] = def.entries[value];\n      } else throw new Error(`Key ${value} not found in enum`);\n    }\n    return new ZodEnum2({\n      ...def,\n      checks: [],\n      ...util_exports.normalizeParams(params),\n      entries: newEntries\n    });\n  };\n  inst.exclude = (values, params) => {\n    const newEntries = {\n      ...def.entries\n    };\n    for (const value of values) {\n      if (keys2.has(value)) {\n        delete newEntries[value];\n      } else throw new Error(`Key ${value} not found in enum`);\n    }\n    return new ZodEnum2({\n      ...def,\n      checks: [],\n      ...util_exports.normalizeParams(params),\n      entries: newEntries\n    });\n  };\n});\nfunction _enum2(values, params) {\n  const entries = Array.isArray(values) ? Object.fromEntries(values.map(v => [v, v])) : values;\n  return new ZodEnum2({\n    type: \"enum\",\n    entries,\n    ...util_exports.normalizeParams(params)\n  });\n}\nfunction nativeEnum(entries, params) {\n  return new ZodEnum2({\n    type: \"enum\",\n    entries,\n    ...util_exports.normalizeParams(params)\n  });\n}\nvar ZodLiteral2 = /* @__PURE__ */$constructor(\"ZodLiteral\", (inst, def) => {\n  $ZodLiteral.init(inst, def);\n  ZodType2.init(inst, def);\n  inst.values = new Set(def.values);\n  Object.defineProperty(inst, \"value\", {\n    get() {\n      if (def.values.length > 1) {\n        throw new Error(\"This schema contains multiple valid literal values. Use `.values` instead.\");\n      }\n      return def.values[0];\n    }\n  });\n});\nfunction literal(value, params) {\n  return new ZodLiteral2({\n    type: \"literal\",\n    values: Array.isArray(value) ? value : [value],\n    ...util_exports.normalizeParams(params)\n  });\n}\nvar ZodFile = /* @__PURE__ */$constructor(\"ZodFile\", (inst, def) => {\n  $ZodFile.init(inst, def);\n  ZodType2.init(inst, def);\n  inst.min = (size, params) => inst.check(_minSize(size, params));\n  inst.max = (size, params) => inst.check(_maxSize(size, params));\n  inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));\n});\nfunction file(params) {\n  return _file(ZodFile, params);\n}\nvar ZodTransform = /* @__PURE__ */$constructor(\"ZodTransform\", (inst, def) => {\n  $ZodTransform.init(inst, def);\n  ZodType2.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    payload.addIssue = issue2 => {\n      if (typeof issue2 === \"string\") {\n        payload.issues.push(util_exports.issue(issue2, payload.value, def));\n      } else {\n        const _issue = issue2;\n        if (_issue.fatal) _issue.continue = false;\n        _issue.code ?? (_issue.code = \"custom\");\n        _issue.input ?? (_issue.input = payload.value);\n        _issue.inst ?? (_issue.inst = inst);\n        _issue.continue ?? (_issue.continue = true);\n        payload.issues.push(util_exports.issue(_issue));\n      }\n    };\n    const output = def.transform(payload.value, payload);\n    if (output instanceof Promise) {\n      return output.then(output2 => {\n        payload.value = output2;\n        return payload;\n      });\n    }\n    payload.value = output;\n    return payload;\n  };\n});\nfunction transform(fn) {\n  return new ZodTransform({\n    type: \"transform\",\n    transform: fn\n  });\n}\nvar ZodOptional2 = /* @__PURE__ */$constructor(\"ZodOptional\", (inst, def) => {\n  $ZodOptional.init(inst, def);\n  ZodType2.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction optional(innerType) {\n  return new ZodOptional2({\n    type: \"optional\",\n    innerType\n  });\n}\nvar ZodNullable2 = /* @__PURE__ */$constructor(\"ZodNullable\", (inst, def) => {\n  $ZodNullable.init(inst, def);\n  ZodType2.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction nullable(innerType) {\n  return new ZodNullable2({\n    type: \"nullable\",\n    innerType\n  });\n}\nfunction nullish2(innerType) {\n  return optional(nullable(innerType));\n}\nvar ZodDefault2 = /* @__PURE__ */$constructor(\"ZodDefault\", (inst, def) => {\n  $ZodDefault.init(inst, def);\n  ZodType2.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n  inst.removeDefault = inst.unwrap;\n});\nfunction _default2(innerType, defaultValue) {\n  return new ZodDefault2({\n    type: \"default\",\n    innerType,\n    get defaultValue() {\n      return typeof defaultValue === \"function\" ? defaultValue() : defaultValue;\n    }\n  });\n}\nvar ZodPrefault = /* @__PURE__ */$constructor(\"ZodPrefault\", (inst, def) => {\n  $ZodPrefault.init(inst, def);\n  ZodType2.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction prefault(innerType, defaultValue) {\n  return new ZodPrefault({\n    type: \"prefault\",\n    innerType,\n    get defaultValue() {\n      return typeof defaultValue === \"function\" ? defaultValue() : defaultValue;\n    }\n  });\n}\nvar ZodNonOptional = /* @__PURE__ */$constructor(\"ZodNonOptional\", (inst, def) => {\n  $ZodNonOptional.init(inst, def);\n  ZodType2.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction nonoptional(innerType, params) {\n  return new ZodNonOptional({\n    type: \"nonoptional\",\n    innerType,\n    ...util_exports.normalizeParams(params)\n  });\n}\nvar ZodSuccess = /* @__PURE__ */$constructor(\"ZodSuccess\", (inst, def) => {\n  $ZodSuccess.init(inst, def);\n  ZodType2.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction success(innerType) {\n  return new ZodSuccess({\n    type: \"success\",\n    innerType\n  });\n}\nvar ZodCatch2 = /* @__PURE__ */$constructor(\"ZodCatch\", (inst, def) => {\n  $ZodCatch.init(inst, def);\n  ZodType2.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n  inst.removeCatch = inst.unwrap;\n});\nfunction _catch2(innerType, catchValue) {\n  return new ZodCatch2({\n    type: \"catch\",\n    innerType,\n    catchValue: typeof catchValue === \"function\" ? catchValue : () => catchValue\n  });\n}\nvar ZodNaN2 = /* @__PURE__ */$constructor(\"ZodNaN\", (inst, def) => {\n  $ZodNaN.init(inst, def);\n  ZodType2.init(inst, def);\n});\nfunction nan(params) {\n  return _nan(ZodNaN2, params);\n}\nvar ZodPipe = /* @__PURE__ */$constructor(\"ZodPipe\", (inst, def) => {\n  $ZodPipe.init(inst, def);\n  ZodType2.init(inst, def);\n  inst.in = def.in;\n  inst.out = def.out;\n});\nfunction pipe(in_, out) {\n  return new ZodPipe({\n    type: \"pipe\",\n    in: in_,\n    out\n    // ...util.normalizeParams(params),\n  });\n}\nvar ZodReadonly2 = /* @__PURE__ */$constructor(\"ZodReadonly\", (inst, def) => {\n  $ZodReadonly.init(inst, def);\n  ZodType2.init(inst, def);\n});\nfunction readonly(innerType) {\n  return new ZodReadonly2({\n    type: \"readonly\",\n    innerType\n  });\n}\nvar ZodTemplateLiteral = /* @__PURE__ */$constructor(\"ZodTemplateLiteral\", (inst, def) => {\n  $ZodTemplateLiteral.init(inst, def);\n  ZodType2.init(inst, def);\n});\nfunction templateLiteral(parts, params) {\n  return new ZodTemplateLiteral({\n    type: \"template_literal\",\n    parts,\n    ...util_exports.normalizeParams(params)\n  });\n}\nvar ZodLazy2 = /* @__PURE__ */$constructor(\"ZodLazy\", (inst, def) => {\n  $ZodLazy.init(inst, def);\n  ZodType2.init(inst, def);\n  inst.unwrap = () => inst._zod.def.getter();\n});\nfunction lazy(getter) {\n  return new ZodLazy2({\n    type: \"lazy\",\n    getter\n  });\n}\nvar ZodPromise2 = /* @__PURE__ */$constructor(\"ZodPromise\", (inst, def) => {\n  $ZodPromise.init(inst, def);\n  ZodType2.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction promise(innerType) {\n  return new ZodPromise2({\n    type: \"promise\",\n    innerType\n  });\n}\nvar ZodCustom = /* @__PURE__ */$constructor(\"ZodCustom\", (inst, def) => {\n  $ZodCustom.init(inst, def);\n  ZodType2.init(inst, def);\n});\nfunction check(fn) {\n  const ch = new $ZodCheck({\n    check: \"custom\"\n    // ...util.normalizeParams(params),\n  });\n  ch._zod.check = fn;\n  return ch;\n}\nfunction custom2(fn, _params) {\n  return _custom(ZodCustom, fn ?? (() => true), _params);\n}\nfunction refine(fn, _params = {}) {\n  return _refine(ZodCustom, fn, _params);\n}\nfunction superRefine(fn) {\n  const ch = check(payload => {\n    payload.addIssue = issue2 => {\n      if (typeof issue2 === \"string\") {\n        payload.issues.push(util_exports.issue(issue2, payload.value, ch._zod.def));\n      } else {\n        const _issue = issue2;\n        if (_issue.fatal) _issue.continue = false;\n        _issue.code ?? (_issue.code = \"custom\");\n        _issue.input ?? (_issue.input = payload.value);\n        _issue.inst ?? (_issue.inst = ch);\n        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);\n        payload.issues.push(util_exports.issue(_issue));\n      }\n    };\n    return fn(payload.value, payload);\n  });\n  return ch;\n}\nfunction _instanceof(cls, params = {\n  error: `Input not instance of ${cls.name}`\n}) {\n  const inst = new ZodCustom({\n    type: \"custom\",\n    check: \"custom\",\n    fn: data => data instanceof cls,\n    abort: true,\n    ...util_exports.normalizeParams(params)\n  });\n  inst._zod.bag.Class = cls;\n  return inst;\n}\nvar stringbool = (...args) => _stringbool({\n  Pipe: ZodPipe,\n  Boolean: ZodBoolean2,\n  String: ZodString2,\n  Transform: ZodTransform\n}, ...args);\nfunction json(params) {\n  const jsonSchema2 = lazy(() => {\n    return union([string2(params), number2(), boolean2(), _null3(), array(jsonSchema2), record(string2(), jsonSchema2)]);\n  });\n  return jsonSchema2;\n}\nfunction preprocess(fn, schema) {\n  return pipe(transform(fn), schema);\n}\n\n// ../../node_modules/zod/v4/classic/compat.js\nvar ZodIssueCode2 = {\n  invalid_type: \"invalid_type\",\n  too_big: \"too_big\",\n  too_small: \"too_small\",\n  invalid_format: \"invalid_format\",\n  not_multiple_of: \"not_multiple_of\",\n  unrecognized_keys: \"unrecognized_keys\",\n  invalid_union: \"invalid_union\",\n  invalid_key: \"invalid_key\",\n  invalid_element: \"invalid_element\",\n  invalid_value: \"invalid_value\",\n  custom: \"custom\"\n};\nfunction setErrorMap2(map2) {\n  config({\n    customError: map2\n  });\n}\nfunction getErrorMap2() {\n  return config().customError;\n}\n\n// ../../node_modules/zod/v4/classic/coerce.js\nvar coerce_exports = {};\n__export(coerce_exports, {\n  bigint: () => bigint3,\n  boolean: () => boolean3,\n  date: () => date4,\n  number: () => number3,\n  string: () => string3\n});\nfunction string3(params) {\n  return _coercedString(ZodString2, params);\n}\nfunction number3(params) {\n  return _coercedNumber(ZodNumber2, params);\n}\nfunction boolean3(params) {\n  return _coercedBoolean(ZodBoolean2, params);\n}\nfunction bigint3(params) {\n  return _coercedBigint(ZodBigInt2, params);\n}\nfunction date4(params) {\n  return _coercedDate(ZodDate2, params);\n}\n\n// ../../node_modules/zod/v4/classic/external.js\nconfig(en_default2());\n\n// ../../node_modules/@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/dist/index.mjs\nfunction combineHeaders(...headers) {\n  return headers.reduce((combinedHeaders, currentHeaders) => ({\n    ...combinedHeaders,\n    ...(currentHeaders != null ? currentHeaders : {})\n  }), {});\n}\nfunction extractResponseHeaders(response) {\n  return Object.fromEntries([...response.headers]);\n}\nfunction getRuntimeEnvironmentUserAgent(globalThisAny = globalThis) {\n  var _a20, _b8, _c;\n  if (globalThisAny.window) {\n    return `runtime/browser`;\n  }\n  if ((_a20 = globalThisAny.navigator) == null ? void 0 : _a20.userAgent) {\n    return `runtime/${globalThisAny.navigator.userAgent.toLowerCase()}`;\n  }\n  if ((_c = (_b8 = globalThisAny.process) == null ? void 0 : _b8.versions) == null ? void 0 : _c.node) {\n    return `runtime/node.js/${globalThisAny.process.version.substring(0)}`;\n  }\n  if (globalThisAny.EdgeRuntime) {\n    return `runtime/vercel-edge`;\n  }\n  return \"runtime/unknown\";\n}\nfunction removeUndefinedEntries(record2) {\n  return Object.fromEntries(Object.entries(record2).filter(([_key, value]) => value != null));\n}\nfunction withUserAgentSuffix(headers, ...userAgentSuffixParts) {\n  const cleanedHeaders = removeUndefinedEntries(headers != null ? headers : {});\n  const normalizedHeaders = new Headers(cleanedHeaders);\n  const currentUserAgentHeader = normalizedHeaders.get(\"user-agent\") || \"\";\n  normalizedHeaders.set(\"user-agent\", [currentUserAgentHeader, ...userAgentSuffixParts].filter(Boolean).join(\" \"));\n  return Object.fromEntries(normalizedHeaders);\n}\nvar createIdGenerator = ({\n  prefix,\n  size = 16,\n  alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n  separator = \"-\"\n} = {}) => {\n  const generator = () => {\n    const alphabetLength = alphabet.length;\n    const chars = new Array(size);\n    for (let i = 0; i < size; i++) {\n      chars[i] = alphabet[Math.random() * alphabetLength | 0];\n    }\n    return chars.join(\"\");\n  };\n  if (prefix == null) {\n    return generator;\n  }\n  if (alphabet.includes(separator)) {\n    throw new InvalidArgumentError({\n      argument: \"separator\",\n      message: `The separator \"${separator}\" must not be part of the alphabet \"${alphabet}\".`\n    });\n  }\n  return () => `${prefix}${separator}${generator()}`;\n};\nvar generateId = createIdGenerator();\nfunction isAbortError(error40) {\n  return (error40 instanceof Error || error40 instanceof DOMException) && (error40.name === \"AbortError\" || error40.name === \"ResponseAborted\" ||\n  // Next.js\n  error40.name === \"TimeoutError\");\n}\nvar FETCH_FAILED_ERROR_MESSAGES = [\"fetch failed\", \"failed to fetch\"];\nfunction handleFetchError({\n  error: error40,\n  url: url2,\n  requestBodyValues\n}) {\n  if (isAbortError(error40)) {\n    return error40;\n  }\n  if (error40 instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES.includes(error40.message.toLowerCase())) {\n    const cause = error40.cause;\n    if (cause != null) {\n      return new APICallError({\n        message: `Cannot connect to API: ${cause.message}`,\n        cause,\n        url: url2,\n        requestBodyValues,\n        isRetryable: true\n        // retry when network error\n      });\n    }\n  }\n  return error40;\n}\nvar VERSION = true ? \"3.0.9\" : \"0.0.0-test\";\nvar getOriginalFetch = () => globalThis.fetch;\nvar getFromApi = async ({\n  url: url2,\n  headers = {},\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch: fetch2 = getOriginalFetch()\n}) => {\n  try {\n    const response = await fetch2(url2, {\n      method: \"GET\",\n      headers: withUserAgentSuffix(headers, `ai-sdk/provider-utils/${VERSION}`, getRuntimeEnvironmentUserAgent()),\n      signal: abortSignal\n    });\n    const responseHeaders = extractResponseHeaders(response);\n    if (!response.ok) {\n      let errorInformation;\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url: url2,\n          requestBodyValues: {}\n        });\n      } catch (error40) {\n        if (isAbortError(error40) || APICallError.isInstance(error40)) {\n          throw error40;\n        }\n        throw new APICallError({\n          message: \"Failed to process error response\",\n          cause: error40,\n          statusCode: response.status,\n          url: url2,\n          responseHeaders,\n          requestBodyValues: {}\n        });\n      }\n      throw errorInformation.value;\n    }\n    try {\n      return await successfulResponseHandler({\n        response,\n        url: url2,\n        requestBodyValues: {}\n      });\n    } catch (error40) {\n      if (error40 instanceof Error) {\n        if (isAbortError(error40) || APICallError.isInstance(error40)) {\n          throw error40;\n        }\n      }\n      throw new APICallError({\n        message: \"Failed to process successful response\",\n        cause: error40,\n        statusCode: response.status,\n        url: url2,\n        responseHeaders,\n        requestBodyValues: {}\n      });\n    }\n  } catch (error40) {\n    throw handleFetchError({\n      error: error40,\n      url: url2,\n      requestBodyValues: {}\n    });\n  }\n};\nfunction loadOptionalSetting({\n  settingValue,\n  environmentVariableName\n}) {\n  if (typeof settingValue === \"string\") {\n    return settingValue;\n  }\n  if (settingValue != null || typeof process === \"undefined\") {\n    return void 0;\n  }\n  settingValue = process.env[environmentVariableName];\n  if (settingValue == null || typeof settingValue !== \"string\") {\n    return void 0;\n  }\n  return settingValue;\n}\nvar suspectProtoRx = /\"__proto__\"\\s*:/;\nvar suspectConstructorRx = /\"constructor\"\\s*:/;\nfunction _parse2(text2) {\n  const obj = JSON.parse(text2);\n  if (obj === null || typeof obj !== \"object\") {\n    return obj;\n  }\n  if (suspectProtoRx.test(text2) === false && suspectConstructorRx.test(text2) === false) {\n    return obj;\n  }\n  return filter(obj);\n}\nfunction filter(obj) {\n  let next = [obj];\n  while (next.length) {\n    const nodes = next;\n    next = [];\n    for (const node of nodes) {\n      if (Object.prototype.hasOwnProperty.call(node, \"__proto__\")) {\n        throw new SyntaxError(\"Object contains forbidden prototype property\");\n      }\n      if (Object.prototype.hasOwnProperty.call(node, \"constructor\") && Object.prototype.hasOwnProperty.call(node.constructor, \"prototype\")) {\n        throw new SyntaxError(\"Object contains forbidden prototype property\");\n      }\n      for (const key in node) {\n        const value = node[key];\n        if (value && typeof value === \"object\") {\n          next.push(value);\n        }\n      }\n    }\n  }\n  return obj;\n}\nfunction secureJsonParse(text2) {\n  const {\n    stackTraceLimit\n  } = Error;\n  Error.stackTraceLimit = 0;\n  try {\n    return _parse2(text2);\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit;\n  }\n}\nvar validatorSymbol = Symbol.for(\"vercel.ai.validator\");\nfunction validator(validate) {\n  return {\n    [validatorSymbol]: true,\n    validate\n  };\n}\nfunction isValidator(value) {\n  return typeof value === \"object\" && value !== null && validatorSymbol in value && value[validatorSymbol] === true && \"validate\" in value;\n}\nfunction asValidator(value) {\n  return isValidator(value) ? value : standardSchemaValidator(value);\n}\nfunction standardSchemaValidator(standardSchema) {\n  return validator(async value => {\n    const result = await standardSchema[\"~standard\"].validate(value);\n    return result.issues == null ? {\n      success: true,\n      value: result.value\n    } : {\n      success: false,\n      error: new TypeValidationError({\n        value,\n        cause: result.issues\n      })\n    };\n  });\n}\nasync function validateTypes({\n  value,\n  schema\n}) {\n  const result = await safeValidateTypes({\n    value,\n    schema\n  });\n  if (!result.success) {\n    throw TypeValidationError.wrap({\n      value,\n      cause: result.error\n    });\n  }\n  return result.value;\n}\nasync function safeValidateTypes({\n  value,\n  schema\n}) {\n  const validator22 = asValidator(schema);\n  try {\n    if (validator22.validate == null) {\n      return {\n        success: true,\n        value,\n        rawValue: value\n      };\n    }\n    const result = await validator22.validate(value);\n    if (result.success) {\n      return {\n        success: true,\n        value: result.value,\n        rawValue: value\n      };\n    }\n    return {\n      success: false,\n      error: TypeValidationError.wrap({\n        value,\n        cause: result.error\n      }),\n      rawValue: value\n    };\n  } catch (error40) {\n    return {\n      success: false,\n      error: TypeValidationError.wrap({\n        value,\n        cause: error40\n      }),\n      rawValue: value\n    };\n  }\n}\nasync function parseJSON({\n  text: text2,\n  schema\n}) {\n  try {\n    const value = secureJsonParse(text2);\n    if (schema == null) {\n      return value;\n    }\n    return validateTypes({\n      value,\n      schema\n    });\n  } catch (error40) {\n    if (JSONParseError.isInstance(error40) || TypeValidationError.isInstance(error40)) {\n      throw error40;\n    }\n    throw new JSONParseError({\n      text: text2,\n      cause: error40\n    });\n  }\n}\nasync function safeParseJSON({\n  text: text2,\n  schema\n}) {\n  try {\n    const value = secureJsonParse(text2);\n    if (schema == null) {\n      return {\n        success: true,\n        value,\n        rawValue: value\n      };\n    }\n    return await safeValidateTypes({\n      value,\n      schema\n    });\n  } catch (error40) {\n    return {\n      success: false,\n      error: JSONParseError.isInstance(error40) ? error40 : new JSONParseError({\n        text: text2,\n        cause: error40\n      }),\n      rawValue: void 0\n    };\n  }\n}\nfunction parseJsonEventStream({\n  stream,\n  schema\n}) {\n  return stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream()).pipeThrough(new TransformStream({\n    async transform({\n      data\n    }, controller) {\n      if (data === \"[DONE]\") {\n        return;\n      }\n      controller.enqueue(await safeParseJSON({\n        text: data,\n        schema\n      }));\n    }\n  }));\n}\nvar getOriginalFetch2 = () => globalThis.fetch;\nvar postJsonToApi = async ({\n  url: url2,\n  headers,\n  body,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch: fetch2\n}) => postToApi({\n  url: url2,\n  headers: {\n    \"Content-Type\": \"application/json\",\n    ...headers\n  },\n  body: {\n    content: JSON.stringify(body),\n    values: body\n  },\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch: fetch2\n});\nvar postToApi = async ({\n  url: url2,\n  headers = {},\n  body,\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch: fetch2 = getOriginalFetch2()\n}) => {\n  try {\n    const response = await fetch2(url2, {\n      method: \"POST\",\n      headers: withUserAgentSuffix(headers, `ai-sdk/provider-utils/${VERSION}`, getRuntimeEnvironmentUserAgent()),\n      body: body.content,\n      signal: abortSignal\n    });\n    const responseHeaders = extractResponseHeaders(response);\n    if (!response.ok) {\n      let errorInformation;\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url: url2,\n          requestBodyValues: body.values\n        });\n      } catch (error40) {\n        if (isAbortError(error40) || APICallError.isInstance(error40)) {\n          throw error40;\n        }\n        throw new APICallError({\n          message: \"Failed to process error response\",\n          cause: error40,\n          statusCode: response.status,\n          url: url2,\n          responseHeaders,\n          requestBodyValues: body.values\n        });\n      }\n      throw errorInformation.value;\n    }\n    try {\n      return await successfulResponseHandler({\n        response,\n        url: url2,\n        requestBodyValues: body.values\n      });\n    } catch (error40) {\n      if (error40 instanceof Error) {\n        if (isAbortError(error40) || APICallError.isInstance(error40)) {\n          throw error40;\n        }\n      }\n      throw new APICallError({\n        message: \"Failed to process successful response\",\n        cause: error40,\n        statusCode: response.status,\n        url: url2,\n        responseHeaders,\n        requestBodyValues: body.values\n      });\n    }\n  } catch (error40) {\n    throw handleFetchError({\n      error: error40,\n      url: url2,\n      requestBodyValues: body.values\n    });\n  }\n};\nasync function resolve(value) {\n  if (typeof value === \"function\") {\n    value = value();\n  }\n  return Promise.resolve(value);\n}\nvar createJsonErrorResponseHandler = ({\n  errorSchema,\n  errorToMessage,\n  isRetryable\n}) => async ({\n  response,\n  url: url2,\n  requestBodyValues\n}) => {\n  const responseBody = await response.text();\n  const responseHeaders = extractResponseHeaders(response);\n  if (responseBody.trim() === \"\") {\n    return {\n      responseHeaders,\n      value: new APICallError({\n        message: response.statusText,\n        url: url2,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n  try {\n    const parsedError = await parseJSON({\n      text: responseBody,\n      schema: errorSchema\n    });\n    return {\n      responseHeaders,\n      value: new APICallError({\n        message: errorToMessage(parsedError),\n        url: url2,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        data: parsedError,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)\n      })\n    };\n  } catch (parseError) {\n    return {\n      responseHeaders,\n      value: new APICallError({\n        message: response.statusText,\n        url: url2,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n};\nvar createEventSourceResponseHandler = chunkSchema2 => async ({\n  response\n}) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (response.body == null) {\n    throw new EmptyResponseBodyError({});\n  }\n  return {\n    responseHeaders,\n    value: parseJsonEventStream({\n      stream: response.body,\n      schema: chunkSchema2\n    })\n  };\n};\nvar createJsonResponseHandler = responseSchema2 => async ({\n  response,\n  url: url2,\n  requestBodyValues\n}) => {\n  const responseBody = await response.text();\n  const parsedResult = await safeParseJSON({\n    text: responseBody,\n    schema: responseSchema2\n  });\n  const responseHeaders = extractResponseHeaders(response);\n  if (!parsedResult.success) {\n    throw new APICallError({\n      message: \"Invalid JSON response\",\n      cause: parsedResult.error,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody,\n      url: url2,\n      requestBodyValues\n    });\n  }\n  return {\n    responseHeaders,\n    value: parsedResult.value,\n    rawValue: parsedResult.rawValue\n  };\n};\nvar ignoreOverride2 = Symbol(\"Let zodToJsonSchema decide on which parser to use\");\nvar ALPHA_NUMERIC2 = new Set(\"ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789\");\nvar schemaSymbol = Symbol.for(\"vercel.ai.schema\");\nvar {\n  btoa: btoa2,\n  atob: atob2\n} = globalThis;\nfunction withoutTrailingSlash(url2) {\n  return url2 == null ? void 0 : url2.replace(/\\/$/, \"\");\n}\n\n// ../../node_modules/@ai-sdk/gateway/dist/index.mjs\nvar marker15 = \"vercel.ai.gateway.error\";\nvar symbol16 = Symbol.for(marker15);\nvar _a15;\nvar _b;\nvar GatewayError = class _GatewayError extends (_b = Error, _a15 = symbol16, _b) {\n  constructor({\n    message,\n    statusCode = 500,\n    cause\n  }) {\n    super(message);\n    this[_a15] = true;\n    this.statusCode = statusCode;\n    this.cause = cause;\n  }\n  /**\n   * Checks if the given error is a Gateway Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is a Gateway Error, false otherwise.\n   */\n  static isInstance(error40) {\n    return _GatewayError.hasMarker(error40);\n  }\n  static hasMarker(error40) {\n    return typeof error40 === \"object\" && error40 !== null && symbol16 in error40 && error40[symbol16] === true;\n  }\n};\nvar name14 = \"GatewayAuthenticationError\";\nvar marker22 = `vercel.ai.gateway.error.${name14}`;\nvar symbol22 = Symbol.for(marker22);\nvar _a22;\nvar _b2;\nvar GatewayAuthenticationError = class _GatewayAuthenticationError extends (_b2 = GatewayError, _a22 = symbol22, _b2) {\n  constructor({\n    message = \"Authentication failed\",\n    statusCode = 401,\n    cause\n  } = {}) {\n    super({\n      message,\n      statusCode,\n      cause\n    });\n    this[_a22] = true;\n    this.name = name14;\n    this.type = \"authentication_error\";\n  }\n  static isInstance(error40) {\n    return GatewayError.hasMarker(error40) && symbol22 in error40;\n  }\n  /**\n   * Creates a contextual error message when authentication fails\n   */\n  static createContextualError({\n    apiKeyProvided,\n    oidcTokenProvided,\n    message = \"Authentication failed\",\n    statusCode = 401,\n    cause\n  }) {\n    let contextualMessage;\n    if (apiKeyProvided) {\n      contextualMessage = `AI Gateway authentication failed: Invalid API key provided.\n\nThe token is expected to be provided via the 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.`;\n    } else if (oidcTokenProvided) {\n      contextualMessage = `AI Gateway authentication failed: Invalid OIDC token provided.\n\nThe token is expected to be provided via the 'VERCEL_OIDC_TOKEN' environment variable. It expires every 12 hours.\n- make sure your Vercel project settings have OIDC enabled\n- if running locally with 'vercel dev', the token is automatically obtained and refreshed\n- if running locally with your own dev server, run 'vercel env pull' to fetch the token\n- in production/preview, the token is automatically obtained and refreshed\n\nAlternative: Provide an API key via 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.`;\n    } else {\n      contextualMessage = `AI Gateway authentication failed: No authentication provided.\n\nProvide either an API key or OIDC token.\n\nAPI key instructions:\n\nThe token is expected to be provided via the 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.\n\nOIDC token instructions:\n\nThe token is expected to be provided via the 'VERCEL_OIDC_TOKEN' environment variable. It expires every 12 hours.\n- make sure your Vercel project settings have OIDC enabled\n- if running locally with 'vercel dev', the token is automatically obtained and refreshed\n- if running locally with your own dev server, run 'vercel env pull' to fetch the token\n- in production/preview, the token is automatically obtained and refreshed`;\n    }\n    return new _GatewayAuthenticationError({\n      message: contextualMessage,\n      statusCode,\n      cause\n    });\n  }\n};\nvar name22 = \"GatewayInvalidRequestError\";\nvar marker32 = `vercel.ai.gateway.error.${name22}`;\nvar symbol32 = Symbol.for(marker32);\nvar _a32;\nvar _b3;\nvar GatewayInvalidRequestError = class extends (_b3 = GatewayError, _a32 = symbol32, _b3) {\n  constructor({\n    message = \"Invalid request\",\n    statusCode = 400,\n    cause\n  } = {}) {\n    super({\n      message,\n      statusCode,\n      cause\n    });\n    this[_a32] = true;\n    this.name = name22;\n    this.type = \"invalid_request_error\";\n  }\n  static isInstance(error40) {\n    return GatewayError.hasMarker(error40) && symbol32 in error40;\n  }\n};\nvar name32 = \"GatewayRateLimitError\";\nvar marker42 = `vercel.ai.gateway.error.${name32}`;\nvar symbol42 = Symbol.for(marker42);\nvar _a42;\nvar _b4;\nvar GatewayRateLimitError = class extends (_b4 = GatewayError, _a42 = symbol42, _b4) {\n  constructor({\n    message = \"Rate limit exceeded\",\n    statusCode = 429,\n    cause\n  } = {}) {\n    super({\n      message,\n      statusCode,\n      cause\n    });\n    this[_a42] = true;\n    this.name = name32;\n    this.type = \"rate_limit_exceeded\";\n  }\n  static isInstance(error40) {\n    return GatewayError.hasMarker(error40) && symbol42 in error40;\n  }\n};\nvar name42 = \"GatewayModelNotFoundError\";\nvar marker52 = `vercel.ai.gateway.error.${name42}`;\nvar symbol52 = Symbol.for(marker52);\nvar modelNotFoundParamSchema = external_exports2.object({\n  modelId: external_exports2.string()\n});\nvar _a52;\nvar _b5;\nvar GatewayModelNotFoundError = class extends (_b5 = GatewayError, _a52 = symbol52, _b5) {\n  constructor({\n    message = \"Model not found\",\n    statusCode = 404,\n    modelId,\n    cause\n  } = {}) {\n    super({\n      message,\n      statusCode,\n      cause\n    });\n    this[_a52] = true;\n    this.name = name42;\n    this.type = \"model_not_found\";\n    this.modelId = modelId;\n  }\n  static isInstance(error40) {\n    return GatewayError.hasMarker(error40) && symbol52 in error40;\n  }\n};\nvar name52 = \"GatewayInternalServerError\";\nvar marker62 = `vercel.ai.gateway.error.${name52}`;\nvar symbol62 = Symbol.for(marker62);\nvar _a62;\nvar _b6;\nvar GatewayInternalServerError = class extends (_b6 = GatewayError, _a62 = symbol62, _b6) {\n  constructor({\n    message = \"Internal server error\",\n    statusCode = 500,\n    cause\n  } = {}) {\n    super({\n      message,\n      statusCode,\n      cause\n    });\n    this[_a62] = true;\n    this.name = name52;\n    this.type = \"internal_server_error\";\n  }\n  static isInstance(error40) {\n    return GatewayError.hasMarker(error40) && symbol62 in error40;\n  }\n};\nvar name62 = \"GatewayResponseError\";\nvar marker72 = `vercel.ai.gateway.error.${name62}`;\nvar symbol72 = Symbol.for(marker72);\nvar _a72;\nvar _b7;\nvar GatewayResponseError = class extends (_b7 = GatewayError, _a72 = symbol72, _b7) {\n  constructor({\n    message = \"Invalid response from Gateway\",\n    statusCode = 502,\n    response,\n    validationError,\n    cause\n  } = {}) {\n    super({\n      message,\n      statusCode,\n      cause\n    });\n    this[_a72] = true;\n    this.name = name62;\n    this.type = \"response_error\";\n    this.response = response;\n    this.validationError = validationError;\n  }\n  static isInstance(error40) {\n    return GatewayError.hasMarker(error40) && symbol72 in error40;\n  }\n};\nfunction createGatewayErrorFromResponse({\n  response,\n  statusCode,\n  defaultMessage = \"Gateway request failed\",\n  cause,\n  authMethod\n}) {\n  const parseResult = gatewayErrorResponseSchema.safeParse(response);\n  if (!parseResult.success) {\n    return new GatewayResponseError({\n      message: `Invalid error response format: ${defaultMessage}`,\n      statusCode,\n      response,\n      validationError: parseResult.error,\n      cause\n    });\n  }\n  const validatedResponse = parseResult.data;\n  const errorType = validatedResponse.error.type;\n  const message = validatedResponse.error.message;\n  switch (errorType) {\n    case \"authentication_error\":\n      return GatewayAuthenticationError.createContextualError({\n        apiKeyProvided: authMethod === \"api-key\",\n        oidcTokenProvided: authMethod === \"oidc\",\n        statusCode,\n        cause\n      });\n    case \"invalid_request_error\":\n      return new GatewayInvalidRequestError({\n        message,\n        statusCode,\n        cause\n      });\n    case \"rate_limit_exceeded\":\n      return new GatewayRateLimitError({\n        message,\n        statusCode,\n        cause\n      });\n    case \"model_not_found\":\n      {\n        const modelResult = modelNotFoundParamSchema.safeParse(validatedResponse.error.param);\n        return new GatewayModelNotFoundError({\n          message,\n          statusCode,\n          modelId: modelResult.success ? modelResult.data.modelId : void 0,\n          cause\n        });\n      }\n    case \"internal_server_error\":\n      return new GatewayInternalServerError({\n        message,\n        statusCode,\n        cause\n      });\n    default:\n      return new GatewayInternalServerError({\n        message,\n        statusCode,\n        cause\n      });\n  }\n}\nvar gatewayErrorResponseSchema = external_exports2.object({\n  error: external_exports2.object({\n    message: external_exports2.string(),\n    type: external_exports2.string().nullish(),\n    param: external_exports2.unknown().nullish(),\n    code: external_exports2.union([external_exports2.string(), external_exports2.number()]).nullish()\n  })\n});\nfunction asGatewayError(error40, authMethod) {\n  var _a86;\n  if (GatewayError.isInstance(error40)) {\n    return error40;\n  }\n  if (APICallError.isInstance(error40)) {\n    return createGatewayErrorFromResponse({\n      response: extractApiCallResponse(error40),\n      statusCode: (_a86 = error40.statusCode) != null ? _a86 : 500,\n      defaultMessage: \"Gateway request failed\",\n      cause: error40,\n      authMethod\n    });\n  }\n  return createGatewayErrorFromResponse({\n    response: {},\n    statusCode: 500,\n    defaultMessage: error40 instanceof Error ? `Gateway request failed: ${error40.message}` : \"Unknown Gateway error\",\n    cause: error40,\n    authMethod\n  });\n}\nfunction extractApiCallResponse(error40) {\n  if (error40.data !== void 0) {\n    return error40.data;\n  }\n  if (error40.responseBody != null) {\n    try {\n      return JSON.parse(error40.responseBody);\n    } catch (e) {\n      return error40.responseBody;\n    }\n  }\n  return {};\n}\nvar GATEWAY_AUTH_METHOD_HEADER = \"ai-gateway-auth-method\";\nfunction parseAuthMethod(headers) {\n  const result = gatewayAuthMethodSchema.safeParse(headers[GATEWAY_AUTH_METHOD_HEADER]);\n  return result.success ? result.data : void 0;\n}\nvar gatewayAuthMethodSchema = external_exports2.union([external_exports2.literal(\"api-key\"), external_exports2.literal(\"oidc\")]);\nvar GatewayFetchMetadata = class {\n  constructor(config2) {\n    this.config = config2;\n  }\n  async getAvailableModels() {\n    try {\n      const {\n        value\n      } = await getFromApi({\n        url: `${this.config.baseURL}/config`,\n        headers: await resolve(this.config.headers()),\n        successfulResponseHandler: createJsonResponseHandler(gatewayFetchMetadataSchema),\n        failedResponseHandler: createJsonErrorResponseHandler({\n          errorSchema: external_exports2.any(),\n          errorToMessage: data => data\n        }),\n        fetch: this.config.fetch\n      });\n      return value;\n    } catch (error40) {\n      throw asGatewayError(error40);\n    }\n  }\n};\nvar gatewayLanguageModelSpecificationSchema = external_exports2.object({\n  specificationVersion: external_exports2.literal(\"v2\"),\n  provider: external_exports2.string(),\n  modelId: external_exports2.string()\n});\nvar gatewayLanguageModelPricingSchema = external_exports2.object({\n  input: external_exports2.string(),\n  output: external_exports2.string(),\n  input_cache_read: external_exports2.string().nullish(),\n  input_cache_write: external_exports2.string().nullish()\n}).transform(({\n  input,\n  output,\n  input_cache_read,\n  input_cache_write\n}) => ({\n  input,\n  output,\n  ...(input_cache_read ? {\n    cachedInputTokens: input_cache_read\n  } : {}),\n  ...(input_cache_write ? {\n    cacheCreationInputTokens: input_cache_write\n  } : {})\n}));\nvar gatewayLanguageModelEntrySchema = external_exports2.object({\n  id: external_exports2.string(),\n  name: external_exports2.string(),\n  description: external_exports2.string().nullish(),\n  pricing: gatewayLanguageModelPricingSchema.nullish(),\n  specification: gatewayLanguageModelSpecificationSchema,\n  modelType: external_exports2.enum([\"language\", \"embedding\", \"image\"]).nullish()\n});\nvar gatewayFetchMetadataSchema = external_exports2.object({\n  models: external_exports2.array(gatewayLanguageModelEntrySchema)\n});\nvar GatewayLanguageModel = class {\n  constructor(modelId, config2) {\n    this.modelId = modelId;\n    this.config = config2;\n    this.specificationVersion = \"v2\";\n    this.supportedUrls = {\n      \"*/*\": [/.*/]\n    };\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  async getArgs(options) {\n    const {\n      abortSignal: _abortSignal,\n      ...optionsWithoutSignal\n    } = options;\n    return {\n      args: this.maybeEncodeFileParts(optionsWithoutSignal),\n      warnings: []\n    };\n  }\n  async doGenerate(options) {\n    const {\n      args,\n      warnings\n    } = await this.getArgs(options);\n    const {\n      abortSignal\n    } = options;\n    const resolvedHeaders = await resolve(this.config.headers());\n    try {\n      const {\n        responseHeaders,\n        value: responseBody,\n        rawValue: rawResponse\n      } = await postJsonToApi({\n        url: this.getUrl(),\n        headers: combineHeaders(resolvedHeaders, options.headers, this.getModelConfigHeaders(this.modelId, false), await resolve(this.config.o11yHeaders)),\n        body: args,\n        successfulResponseHandler: createJsonResponseHandler(external_exports2.any()),\n        failedResponseHandler: createJsonErrorResponseHandler({\n          errorSchema: external_exports2.any(),\n          errorToMessage: data => data\n        }),\n        ...(abortSignal && {\n          abortSignal\n        }),\n        fetch: this.config.fetch\n      });\n      return {\n        ...responseBody,\n        request: {\n          body: args\n        },\n        response: {\n          headers: responseHeaders,\n          body: rawResponse\n        },\n        warnings\n      };\n    } catch (error40) {\n      throw asGatewayError(error40, parseAuthMethod(resolvedHeaders));\n    }\n  }\n  async doStream(options) {\n    const {\n      args,\n      warnings\n    } = await this.getArgs(options);\n    const {\n      abortSignal\n    } = options;\n    const resolvedHeaders = await resolve(this.config.headers());\n    try {\n      const {\n        value: response,\n        responseHeaders\n      } = await postJsonToApi({\n        url: this.getUrl(),\n        headers: combineHeaders(resolvedHeaders, options.headers, this.getModelConfigHeaders(this.modelId, true), await resolve(this.config.o11yHeaders)),\n        body: args,\n        successfulResponseHandler: createEventSourceResponseHandler(external_exports2.any()),\n        failedResponseHandler: createJsonErrorResponseHandler({\n          errorSchema: external_exports2.any(),\n          errorToMessage: data => data\n        }),\n        ...(abortSignal && {\n          abortSignal\n        }),\n        fetch: this.config.fetch\n      });\n      return {\n        stream: response.pipeThrough(new TransformStream({\n          start(controller) {\n            if (warnings.length > 0) {\n              controller.enqueue({\n                type: \"stream-start\",\n                warnings\n              });\n            }\n          },\n          transform(chunk, controller) {\n            if (chunk.success) {\n              const streamPart = chunk.value;\n              if (streamPart.type === \"raw\" && !options.includeRawChunks) {\n                return;\n              }\n              if (streamPart.type === \"response-metadata\" && streamPart.timestamp && typeof streamPart.timestamp === \"string\") {\n                streamPart.timestamp = new Date(streamPart.timestamp);\n              }\n              controller.enqueue(streamPart);\n            } else {\n              controller.error(chunk.error);\n            }\n          }\n        })),\n        request: {\n          body: args\n        },\n        response: {\n          headers: responseHeaders\n        }\n      };\n    } catch (error40) {\n      throw asGatewayError(error40, parseAuthMethod(resolvedHeaders));\n    }\n  }\n  isFilePart(part) {\n    return part && typeof part === \"object\" && \"type\" in part && part.type === \"file\";\n  }\n  /**\n   * Encodes file parts in the prompt to base64. Mutates the passed options\n   * instance directly to avoid copying the file data.\n   * @param options - The options to encode.\n   * @returns The options with the file parts encoded.\n   */\n  maybeEncodeFileParts(options) {\n    for (const message of options.prompt) {\n      for (const part of message.content) {\n        if (this.isFilePart(part)) {\n          const filePart = part;\n          if (filePart.data instanceof Uint8Array) {\n            const buffer = Uint8Array.from(filePart.data);\n            const base64Data = Buffer.from(buffer).toString(\"base64\");\n            filePart.data = new URL(`data:${filePart.mediaType || \"application/octet-stream\"};base64,${base64Data}`);\n          }\n        }\n      }\n    }\n    return options;\n  }\n  getUrl() {\n    return `${this.config.baseURL}/language-model`;\n  }\n  getModelConfigHeaders(modelId, streaming) {\n    return {\n      \"ai-language-model-specification-version\": \"2\",\n      \"ai-language-model-id\": modelId,\n      \"ai-language-model-streaming\": String(streaming)\n    };\n  }\n};\nvar GatewayEmbeddingModel = class {\n  constructor(modelId, config2) {\n    this.modelId = modelId;\n    this.config = config2;\n    this.specificationVersion = \"v2\";\n    this.maxEmbeddingsPerCall = 2048;\n    this.supportsParallelCalls = true;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  async doEmbed({\n    values,\n    headers,\n    abortSignal,\n    providerOptions\n  }) {\n    var _a86;\n    const resolvedHeaders = await resolve(this.config.headers());\n    try {\n      const {\n        responseHeaders,\n        value: responseBody,\n        rawValue\n      } = await postJsonToApi({\n        url: this.getUrl(),\n        headers: combineHeaders(resolvedHeaders, headers != null ? headers : {}, this.getModelConfigHeaders(), await resolve(this.config.o11yHeaders)),\n        body: {\n          input: values.length === 1 ? values[0] : values,\n          ...(providerOptions ? {\n            providerOptions\n          } : {})\n        },\n        successfulResponseHandler: createJsonResponseHandler(gatewayEmbeddingResponseSchema),\n        failedResponseHandler: createJsonErrorResponseHandler({\n          errorSchema: external_exports2.any(),\n          errorToMessage: data => data\n        }),\n        ...(abortSignal && {\n          abortSignal\n        }),\n        fetch: this.config.fetch\n      });\n      return {\n        embeddings: responseBody.embeddings,\n        usage: (_a86 = responseBody.usage) != null ? _a86 : void 0,\n        providerMetadata: responseBody.providerMetadata,\n        response: {\n          headers: responseHeaders,\n          body: rawValue\n        }\n      };\n    } catch (error40) {\n      throw asGatewayError(error40, parseAuthMethod(resolvedHeaders));\n    }\n  }\n  getUrl() {\n    return `${this.config.baseURL}/embedding-model`;\n  }\n  getModelConfigHeaders() {\n    return {\n      \"ai-embedding-model-specification-version\": \"2\",\n      \"ai-model-id\": this.modelId\n    };\n  }\n};\nvar gatewayEmbeddingResponseSchema = external_exports2.object({\n  embeddings: external_exports2.array(external_exports2.array(external_exports2.number())),\n  usage: external_exports2.object({\n    tokens: external_exports2.number()\n  }).nullish(),\n  providerMetadata: external_exports2.record(external_exports2.string(), external_exports2.record(external_exports2.string(), external_exports2.unknown())).optional()\n});\nasync function getVercelOidcToken() {\n  var _a86, _b8;\n  const token = (_b8 = (_a86 = getContext().headers) == null ? void 0 : _a86[\"x-vercel-oidc-token\"]) != null ? _b8 : process.env.VERCEL_OIDC_TOKEN;\n  if (!token) {\n    throw new GatewayAuthenticationError({\n      message: \"OIDC token not available\",\n      statusCode: 401\n    });\n  }\n  return token;\n}\nasync function getVercelRequestId() {\n  var _a86;\n  return (_a86 = getContext().headers) == null ? void 0 : _a86[\"x-vercel-id\"];\n}\nvar SYMBOL_FOR_REQ_CONTEXT = Symbol.for(\"@vercel/request-context\");\nfunction getContext() {\n  var _a86, _b8, _c;\n  const fromSymbol = globalThis;\n  return (_c = (_b8 = (_a86 = fromSymbol[SYMBOL_FOR_REQ_CONTEXT]) == null ? void 0 : _a86.get) == null ? void 0 : _b8.call(_a86)) != null ? _c : {};\n}\nvar AI_GATEWAY_PROTOCOL_VERSION = \"0.0.1\";\nfunction createGatewayProvider(options = {}) {\n  var _a86, _b8;\n  let pendingMetadata = null;\n  let metadataCache = null;\n  const cacheRefreshMillis = (_a86 = options.metadataCacheRefreshMillis) != null ? _a86 : 1e3 * 60 * 5;\n  let lastFetchTime = 0;\n  const baseURL = (_b8 = withoutTrailingSlash(options.baseURL)) != null ? _b8 : \"https://ai-gateway.vercel.sh/v1/ai\";\n  const getHeaders = async () => {\n    const auth = await getGatewayAuthToken(options);\n    if (auth) {\n      return {\n        Authorization: `Bearer ${auth.token}`,\n        \"ai-gateway-protocol-version\": AI_GATEWAY_PROTOCOL_VERSION,\n        [GATEWAY_AUTH_METHOD_HEADER]: auth.authMethod,\n        ...options.headers\n      };\n    }\n    throw GatewayAuthenticationError.createContextualError({\n      apiKeyProvided: false,\n      oidcTokenProvided: false,\n      statusCode: 401\n    });\n  };\n  const createO11yHeaders = () => {\n    const deploymentId = loadOptionalSetting({\n      settingValue: void 0,\n      environmentVariableName: \"VERCEL_DEPLOYMENT_ID\"\n    });\n    const environment = loadOptionalSetting({\n      settingValue: void 0,\n      environmentVariableName: \"VERCEL_ENV\"\n    });\n    const region = loadOptionalSetting({\n      settingValue: void 0,\n      environmentVariableName: \"VERCEL_REGION\"\n    });\n    return async () => {\n      const requestId = await getVercelRequestId();\n      return {\n        ...(deploymentId && {\n          \"ai-o11y-deployment-id\": deploymentId\n        }),\n        ...(environment && {\n          \"ai-o11y-environment\": environment\n        }),\n        ...(region && {\n          \"ai-o11y-region\": region\n        }),\n        ...(requestId && {\n          \"ai-o11y-request-id\": requestId\n        })\n      };\n    };\n  };\n  const createLanguageModel = modelId => {\n    return new GatewayLanguageModel(modelId, {\n      provider: \"gateway\",\n      baseURL,\n      headers: getHeaders,\n      fetch: options.fetch,\n      o11yHeaders: createO11yHeaders()\n    });\n  };\n  const getAvailableModels = async () => {\n    var _a96, _b9, _c;\n    const now2 = (_c = (_b9 = (_a96 = options._internal) == null ? void 0 : _a96.currentDate) == null ? void 0 : _b9.call(_a96).getTime()) != null ? _c : Date.now();\n    if (!pendingMetadata || now2 - lastFetchTime > cacheRefreshMillis) {\n      lastFetchTime = now2;\n      pendingMetadata = new GatewayFetchMetadata({\n        baseURL,\n        headers: getHeaders,\n        fetch: options.fetch\n      }).getAvailableModels().then(metadata => {\n        metadataCache = metadata;\n        return metadata;\n      }).catch(async error40 => {\n        throw asGatewayError(error40, parseAuthMethod(await getHeaders()));\n      });\n    }\n    return metadataCache ? Promise.resolve(metadataCache) : pendingMetadata;\n  };\n  const provider = function (modelId) {\n    if (new.target) {\n      throw new Error(\"The Gateway Provider model function cannot be called with the new keyword.\");\n    }\n    return createLanguageModel(modelId);\n  };\n  provider.getAvailableModels = getAvailableModels;\n  provider.imageModel = modelId => {\n    throw new NoSuchModelError({\n      modelId,\n      modelType: \"imageModel\"\n    });\n  };\n  provider.languageModel = createLanguageModel;\n  provider.textEmbeddingModel = modelId => {\n    return new GatewayEmbeddingModel(modelId, {\n      provider: \"gateway\",\n      baseURL,\n      headers: getHeaders,\n      fetch: options.fetch,\n      o11yHeaders: createO11yHeaders()\n    });\n  };\n  return provider;\n}\nvar gateway = createGatewayProvider();\nasync function getGatewayAuthToken(options) {\n  const apiKey = loadOptionalSetting({\n    settingValue: options.apiKey,\n    environmentVariableName: \"AI_GATEWAY_API_KEY\"\n  });\n  if (apiKey) {\n    return {\n      token: apiKey,\n      authMethod: \"api-key\"\n    };\n  }\n  try {\n    const oidcToken = await getVercelOidcToken();\n    return {\n      token: oidcToken,\n      authMethod: \"oidc\"\n    };\n  } catch (e) {\n    return null;\n  }\n}\n\n// ../../node_modules/ai/node_modules/@ai-sdk/provider/dist/index.mjs\nvar marker16 = \"vercel.ai.error\";\nvar symbol17 = Symbol.for(marker16);\nvar _a16;\nvar _AISDKError3 = class _AISDKError4 extends Error {\n  /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */\n  constructor({\n    name: name143,\n    message,\n    cause\n  }) {\n    super(message);\n    this[_a16] = true;\n    this.name = name143;\n    this.cause = cause;\n  }\n  /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */\n  static isInstance(error40) {\n    return _AISDKError4.hasMarker(error40, marker16);\n  }\n  static hasMarker(error40, marker153) {\n    const markerSymbol = Symbol.for(marker153);\n    return error40 != null && typeof error40 === \"object\" && markerSymbol in error40 && typeof error40[markerSymbol] === \"boolean\" && error40[markerSymbol] === true;\n  }\n};\n_a16 = symbol17;\nvar AISDKError2 = _AISDKError3;\nvar name15 = \"AI_APICallError\";\nvar marker23 = `vercel.ai.error.${name15}`;\nvar symbol23 = Symbol.for(marker23);\nvar _a23;\nvar APICallError2 = class extends AISDKError2 {\n  constructor({\n    message,\n    url: url2,\n    requestBodyValues,\n    statusCode,\n    responseHeaders,\n    responseBody,\n    cause,\n    isRetryable = statusCode != null && (statusCode === 408 ||\n    // request timeout\n    statusCode === 409 ||\n    // conflict\n    statusCode === 429 ||\n    // too many requests\n    statusCode >= 500),\n    // server error\n    data\n  }) {\n    super({\n      name: name15,\n      message,\n      cause\n    });\n    this[_a23] = true;\n    this.url = url2;\n    this.requestBodyValues = requestBodyValues;\n    this.statusCode = statusCode;\n    this.responseHeaders = responseHeaders;\n    this.responseBody = responseBody;\n    this.isRetryable = isRetryable;\n    this.data = data;\n  }\n  static isInstance(error40) {\n    return AISDKError2.hasMarker(error40, marker23);\n  }\n};\n_a23 = symbol23;\nvar name23 = \"AI_EmptyResponseBodyError\";\nvar marker33 = `vercel.ai.error.${name23}`;\nvar symbol33 = Symbol.for(marker33);\nvar _a33;\n_a33 = symbol33;\nfunction getErrorMessage2(error40) {\n  if (error40 == null) {\n    return \"unknown error\";\n  }\n  if (typeof error40 === \"string\") {\n    return error40;\n  }\n  if (error40 instanceof Error) {\n    return error40.message;\n  }\n  return JSON.stringify(error40);\n}\nvar name33 = \"AI_InvalidArgumentError\";\nvar marker43 = `vercel.ai.error.${name33}`;\nvar symbol43 = Symbol.for(marker43);\nvar _a43;\nvar InvalidArgumentError2 = class extends AISDKError2 {\n  constructor({\n    message,\n    cause,\n    argument\n  }) {\n    super({\n      name: name33,\n      message,\n      cause\n    });\n    this[_a43] = true;\n    this.argument = argument;\n  }\n  static isInstance(error40) {\n    return AISDKError2.hasMarker(error40, marker43);\n  }\n};\n_a43 = symbol43;\nvar name43 = \"AI_InvalidPromptError\";\nvar marker53 = `vercel.ai.error.${name43}`;\nvar symbol53 = Symbol.for(marker53);\nvar _a53;\nvar InvalidPromptError = class extends AISDKError2 {\n  constructor({\n    prompt,\n    message,\n    cause\n  }) {\n    super({\n      name: name43,\n      message: `Invalid prompt: ${message}`,\n      cause\n    });\n    this[_a53] = true;\n    this.prompt = prompt;\n  }\n  static isInstance(error40) {\n    return AISDKError2.hasMarker(error40, marker53);\n  }\n};\n_a53 = symbol53;\nvar name53 = \"AI_InvalidResponseDataError\";\nvar marker63 = `vercel.ai.error.${name53}`;\nvar symbol63 = Symbol.for(marker63);\nvar _a63;\n_a63 = symbol63;\nvar name63 = \"AI_JSONParseError\";\nvar marker73 = `vercel.ai.error.${name63}`;\nvar symbol73 = Symbol.for(marker73);\nvar _a73;\nvar JSONParseError2 = class extends AISDKError2 {\n  constructor({\n    text: text2,\n    cause\n  }) {\n    super({\n      name: name63,\n      message: `JSON parsing failed: Text: ${text2}.\nError message: ${getErrorMessage2(cause)}`,\n      cause\n    });\n    this[_a73] = true;\n    this.text = text2;\n  }\n  static isInstance(error40) {\n    return AISDKError2.hasMarker(error40, marker73);\n  }\n};\n_a73 = symbol73;\nvar name72 = \"AI_LoadAPIKeyError\";\nvar marker82 = `vercel.ai.error.${name72}`;\nvar symbol82 = Symbol.for(marker82);\nvar _a82;\n_a82 = symbol82;\nvar name82 = \"AI_LoadSettingError\";\nvar marker92 = `vercel.ai.error.${name82}`;\nvar symbol92 = Symbol.for(marker92);\nvar _a92;\n_a92 = symbol92;\nvar name92 = \"AI_NoContentGeneratedError\";\nvar marker102 = `vercel.ai.error.${name92}`;\nvar symbol102 = Symbol.for(marker102);\nvar _a102;\n_a102 = symbol102;\nvar name102 = \"AI_NoSuchModelError\";\nvar marker112 = `vercel.ai.error.${name102}`;\nvar symbol112 = Symbol.for(marker112);\nvar _a112;\n_a112 = symbol112;\nvar name112 = \"AI_TooManyEmbeddingValuesForCallError\";\nvar marker122 = `vercel.ai.error.${name112}`;\nvar symbol122 = Symbol.for(marker122);\nvar _a122;\n_a122 = symbol122;\nvar name122 = \"AI_TypeValidationError\";\nvar marker132 = `vercel.ai.error.${name122}`;\nvar symbol132 = Symbol.for(marker132);\nvar _a132;\nvar _TypeValidationError3 = class _TypeValidationError4 extends AISDKError2 {\n  constructor({\n    value,\n    cause\n  }) {\n    super({\n      name: name122,\n      message: `Type validation failed: Value: ${JSON.stringify(value)}.\nError message: ${getErrorMessage2(cause)}`,\n      cause\n    });\n    this[_a132] = true;\n    this.value = value;\n  }\n  static isInstance(error40) {\n    return AISDKError2.hasMarker(error40, marker132);\n  }\n  /**\n   * Wraps an error into a TypeValidationError.\n   * If the cause is already a TypeValidationError with the same value, it returns the cause.\n   * Otherwise, it creates a new TypeValidationError.\n   *\n   * @param {Object} params - The parameters for wrapping the error.\n   * @param {unknown} params.value - The value that failed validation.\n   * @param {unknown} params.cause - The original error or cause of the validation failure.\n   * @returns {TypeValidationError} A TypeValidationError instance.\n   */\n  static wrap({\n    value,\n    cause\n  }) {\n    return _TypeValidationError4.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError4({\n      value,\n      cause\n    });\n  }\n};\n_a132 = symbol132;\nvar TypeValidationError2 = _TypeValidationError3;\nvar name132 = \"AI_UnsupportedFunctionalityError\";\nvar marker142 = `vercel.ai.error.${name132}`;\nvar symbol142 = Symbol.for(marker142);\nvar _a142;\nvar UnsupportedFunctionalityError = class extends AISDKError2 {\n  constructor({\n    functionality,\n    message = `'${functionality}' functionality not supported.`\n  }) {\n    super({\n      name: name132,\n      message\n    });\n    this[_a142] = true;\n    this.functionality = functionality;\n  }\n  static isInstance(error40) {\n    return AISDKError2.hasMarker(error40, marker142);\n  }\n};\n_a142 = symbol142;\nfunction isJSONValue(value) {\n  if (value === null || typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n    return true;\n  }\n  if (Array.isArray(value)) {\n    return value.every(isJSONValue);\n  }\n  if (typeof value === \"object\") {\n    return Object.entries(value).every(([key, val]) => typeof key === \"string\" && isJSONValue(val));\n  }\n  return false;\n}\nfunction isJSONArray(value) {\n  return Array.isArray(value) && value.every(isJSONValue);\n}\nfunction isJSONObject(value) {\n  return value != null && typeof value === \"object\" && Object.entries(value).every(([key, val]) => typeof key === \"string\" && isJSONValue(val));\n}\n\n// ../../node_modules/ai/node_modules/@ai-sdk/provider-utils/dist/index.mjs\nasync function delay(delayInMs, options) {\n  if (delayInMs == null) {\n    return Promise.resolve();\n  }\n  const signal = options == null ? void 0 : options.abortSignal;\n  return new Promise((resolve22, reject) => {\n    if (signal == null ? void 0 : signal.aborted) {\n      reject(createAbortError());\n      return;\n    }\n    const timeoutId = setTimeout(() => {\n      cleanup();\n      resolve22();\n    }, delayInMs);\n    const cleanup = () => {\n      clearTimeout(timeoutId);\n      signal == null ? void 0 : signal.removeEventListener(\"abort\", onAbort);\n    };\n    const onAbort = () => {\n      cleanup();\n      reject(createAbortError());\n    };\n    signal == null ? void 0 : signal.addEventListener(\"abort\", onAbort);\n  });\n}\nfunction createAbortError() {\n  return new DOMException(\"Delay was aborted\", \"AbortError\");\n}\nfunction removeUndefinedEntries2(record2) {\n  return Object.fromEntries(Object.entries(record2).filter(([_key, value]) => value != null));\n}\nfunction withUserAgentSuffix2(headers, ...userAgentSuffixParts) {\n  const cleanedHeaders = removeUndefinedEntries2(headers != null ? headers : {});\n  const normalizedHeaders = new Headers(cleanedHeaders);\n  const currentUserAgentHeader = normalizedHeaders.get(\"user-agent\") || \"\";\n  normalizedHeaders.set(\"user-agent\", [currentUserAgentHeader, ...userAgentSuffixParts].filter(Boolean).join(\" \"));\n  return Object.fromEntries(normalizedHeaders);\n}\nvar createIdGenerator2 = ({\n  prefix,\n  size = 16,\n  alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n  separator = \"-\"\n} = {}) => {\n  const generator = () => {\n    const alphabetLength = alphabet.length;\n    const chars = new Array(size);\n    for (let i = 0; i < size; i++) {\n      chars[i] = alphabet[Math.random() * alphabetLength | 0];\n    }\n    return chars.join(\"\");\n  };\n  if (prefix == null) {\n    return generator;\n  }\n  if (alphabet.includes(separator)) {\n    throw new InvalidArgumentError2({\n      argument: \"separator\",\n      message: `The separator \"${separator}\" must not be part of the alphabet \"${alphabet}\".`\n    });\n  }\n  return () => `${prefix}${separator}${generator()}`;\n};\nvar generateId2 = createIdGenerator2();\nfunction getErrorMessage3(error40) {\n  if (error40 == null) {\n    return \"unknown error\";\n  }\n  if (typeof error40 === \"string\") {\n    return error40;\n  }\n  if (error40 instanceof Error) {\n    return error40.message;\n  }\n  return JSON.stringify(error40);\n}\nfunction isAbortError2(error40) {\n  return (error40 instanceof Error || error40 instanceof DOMException) && (error40.name === \"AbortError\" || error40.name === \"ResponseAborted\" ||\n  // Next.js\n  error40.name === \"TimeoutError\");\n}\nfunction isUrlSupported({\n  mediaType,\n  url: url2,\n  supportedUrls\n}) {\n  url2 = url2.toLowerCase();\n  mediaType = mediaType.toLowerCase();\n  return Object.entries(supportedUrls).map(([key, value]) => {\n    const mediaType2 = key.toLowerCase();\n    return mediaType2 === \"*\" || mediaType2 === \"*/*\" ? {\n      mediaTypePrefix: \"\",\n      regexes: value\n    } : {\n      mediaTypePrefix: mediaType2.replace(/\\*/, \"\"),\n      regexes: value\n    };\n  }).filter(({\n    mediaTypePrefix\n  }) => mediaType.startsWith(mediaTypePrefix)).flatMap(({\n    regexes\n  }) => regexes).some(pattern => pattern.test(url2));\n}\nvar suspectProtoRx2 = /\"__proto__\"\\s*:/;\nvar suspectConstructorRx2 = /\"constructor\"\\s*:/;\nfunction _parse3(text2) {\n  const obj = JSON.parse(text2);\n  if (obj === null || typeof obj !== \"object\") {\n    return obj;\n  }\n  if (suspectProtoRx2.test(text2) === false && suspectConstructorRx2.test(text2) === false) {\n    return obj;\n  }\n  return filter2(obj);\n}\nfunction filter2(obj) {\n  let next = [obj];\n  while (next.length) {\n    const nodes = next;\n    next = [];\n    for (const node of nodes) {\n      if (Object.prototype.hasOwnProperty.call(node, \"__proto__\")) {\n        throw new SyntaxError(\"Object contains forbidden prototype property\");\n      }\n      if (Object.prototype.hasOwnProperty.call(node, \"constructor\") && Object.prototype.hasOwnProperty.call(node.constructor, \"prototype\")) {\n        throw new SyntaxError(\"Object contains forbidden prototype property\");\n      }\n      for (const key in node) {\n        const value = node[key];\n        if (value && typeof value === \"object\") {\n          next.push(value);\n        }\n      }\n    }\n  }\n  return obj;\n}\nfunction secureJsonParse2(text2) {\n  const {\n    stackTraceLimit\n  } = Error;\n  Error.stackTraceLimit = 0;\n  try {\n    return _parse3(text2);\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit;\n  }\n}\nvar validatorSymbol2 = Symbol.for(\"vercel.ai.validator\");\nfunction validator2(validate) {\n  return {\n    [validatorSymbol2]: true,\n    validate\n  };\n}\nfunction isValidator2(value) {\n  return typeof value === \"object\" && value !== null && validatorSymbol2 in value && value[validatorSymbol2] === true && \"validate\" in value;\n}\nfunction asValidator2(value) {\n  return isValidator2(value) ? value : standardSchemaValidator2(value);\n}\nfunction standardSchemaValidator2(standardSchema) {\n  return validator2(async value => {\n    const result = await standardSchema[\"~standard\"].validate(value);\n    return result.issues == null ? {\n      success: true,\n      value: result.value\n    } : {\n      success: false,\n      error: new TypeValidationError2({\n        value,\n        cause: result.issues\n      })\n    };\n  });\n}\nasync function validateTypes2({\n  value,\n  schema\n}) {\n  const result = await safeValidateTypes2({\n    value,\n    schema\n  });\n  if (!result.success) {\n    throw TypeValidationError2.wrap({\n      value,\n      cause: result.error\n    });\n  }\n  return result.value;\n}\nasync function safeValidateTypes2({\n  value,\n  schema\n}) {\n  const validator22 = asValidator2(schema);\n  try {\n    if (validator22.validate == null) {\n      return {\n        success: true,\n        value,\n        rawValue: value\n      };\n    }\n    const result = await validator22.validate(value);\n    if (result.success) {\n      return {\n        success: true,\n        value: result.value,\n        rawValue: value\n      };\n    }\n    return {\n      success: false,\n      error: TypeValidationError2.wrap({\n        value,\n        cause: result.error\n      }),\n      rawValue: value\n    };\n  } catch (error40) {\n    return {\n      success: false,\n      error: TypeValidationError2.wrap({\n        value,\n        cause: error40\n      }),\n      rawValue: value\n    };\n  }\n}\nasync function safeParseJSON2({\n  text: text2,\n  schema\n}) {\n  try {\n    const value = secureJsonParse2(text2);\n    if (schema == null) {\n      return {\n        success: true,\n        value,\n        rawValue: value\n      };\n    }\n    return await safeValidateTypes2({\n      value,\n      schema\n    });\n  } catch (error40) {\n    return {\n      success: false,\n      error: JSONParseError2.isInstance(error40) ? error40 : new JSONParseError2({\n        text: text2,\n        cause: error40\n      }),\n      rawValue: void 0\n    };\n  }\n}\nvar getRelativePath2 = (pathA, pathB) => {\n  let i = 0;\n  for (; i < pathA.length && i < pathB.length; i++) {\n    if (pathA[i] !== pathB[i]) break;\n  }\n  return [(pathA.length - i).toString(), ...pathB.slice(i)].join(\"/\");\n};\nvar ignoreOverride3 = Symbol(\"Let zodToJsonSchema decide on which parser to use\");\nvar defaultOptions2 = {\n  name: void 0,\n  $refStrategy: \"root\",\n  basePath: [\"#\"],\n  effectStrategy: \"input\",\n  pipeStrategy: \"all\",\n  dateStrategy: \"format:date-time\",\n  mapStrategy: \"entries\",\n  removeAdditionalStrategy: \"passthrough\",\n  allowedAdditionalProperties: true,\n  rejectedAdditionalProperties: false,\n  definitionPath: \"definitions\",\n  strictUnions: false,\n  definitions: {},\n  errorMessages: false,\n  patternStrategy: \"escape\",\n  applyRegexFlags: false,\n  emailStrategy: \"format:email\",\n  base64Strategy: \"contentEncoding:base64\",\n  nameStrategy: \"ref\"\n};\nvar getDefaultOptions2 = options => typeof options === \"string\" ? {\n  ...defaultOptions2,\n  name: options\n} : {\n  ...defaultOptions2,\n  ...options\n};\nfunction parseAnyDef2() {\n  return {};\n}\nfunction parseArrayDef2(def, refs) {\n  var _a20, _b8, _c;\n  const res = {\n    type: \"array\"\n  };\n  if (((_a20 = def.type) == null ? void 0 : _a20._def) && ((_c = (_b8 = def.type) == null ? void 0 : _b8._def) == null ? void 0 : _c.typeName) !== ZodFirstPartyTypeKind.ZodAny) {\n    res.items = parseDef2(def.type._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"items\"]\n    });\n  }\n  if (def.minLength) {\n    res.minItems = def.minLength.value;\n  }\n  if (def.maxLength) {\n    res.maxItems = def.maxLength.value;\n  }\n  if (def.exactLength) {\n    res.minItems = def.exactLength.value;\n    res.maxItems = def.exactLength.value;\n  }\n  return res;\n}\nfunction parseBigintDef2(def) {\n  const res = {\n    type: \"integer\",\n    format: \"int64\"\n  };\n  if (!def.checks) return res;\n  for (const check2 of def.checks) {\n    switch (check2.kind) {\n      case \"min\":\n        if (check2.inclusive) {\n          res.minimum = check2.value;\n        } else {\n          res.exclusiveMinimum = check2.value;\n        }\n        break;\n      case \"max\":\n        if (check2.inclusive) {\n          res.maximum = check2.value;\n        } else {\n          res.exclusiveMaximum = check2.value;\n        }\n        break;\n      case \"multipleOf\":\n        res.multipleOf = check2.value;\n        break;\n    }\n  }\n  return res;\n}\nfunction parseBooleanDef2() {\n  return {\n    type: \"boolean\"\n  };\n}\nfunction parseBrandedDef2(_def, refs) {\n  return parseDef2(_def.type._def, refs);\n}\nvar parseCatchDef2 = (def, refs) => {\n  return parseDef2(def.innerType._def, refs);\n};\nfunction parseDateDef2(def, refs, overrideDateStrategy) {\n  const strategy = overrideDateStrategy != null ? overrideDateStrategy : refs.dateStrategy;\n  if (Array.isArray(strategy)) {\n    return {\n      anyOf: strategy.map((item, i) => parseDateDef2(def, refs, item))\n    };\n  }\n  switch (strategy) {\n    case \"string\":\n    case \"format:date-time\":\n      return {\n        type: \"string\",\n        format: \"date-time\"\n      };\n    case \"format:date\":\n      return {\n        type: \"string\",\n        format: \"date\"\n      };\n    case \"integer\":\n      return integerDateParser2(def);\n  }\n}\nvar integerDateParser2 = def => {\n  const res = {\n    type: \"integer\",\n    format: \"unix-time\"\n  };\n  for (const check2 of def.checks) {\n    switch (check2.kind) {\n      case \"min\":\n        res.minimum = check2.value;\n        break;\n      case \"max\":\n        res.maximum = check2.value;\n        break;\n    }\n  }\n  return res;\n};\nfunction parseDefaultDef2(_def, refs) {\n  return {\n    ...parseDef2(_def.innerType._def, refs),\n    default: _def.defaultValue()\n  };\n}\nfunction parseEffectsDef2(_def, refs) {\n  return refs.effectStrategy === \"input\" ? parseDef2(_def.schema._def, refs) : parseAnyDef2();\n}\nfunction parseEnumDef2(def) {\n  return {\n    type: \"string\",\n    enum: Array.from(def.values)\n  };\n}\nvar isJsonSchema7AllOfType2 = type => {\n  if (\"type\" in type && type.type === \"string\") return false;\n  return \"allOf\" in type;\n};\nfunction parseIntersectionDef2(def, refs) {\n  const allOf = [parseDef2(def.left._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"allOf\", \"0\"]\n  }), parseDef2(def.right._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"allOf\", \"1\"]\n  })].filter(x => !!x);\n  const mergedAllOf = [];\n  allOf.forEach(schema => {\n    if (isJsonSchema7AllOfType2(schema)) {\n      mergedAllOf.push(...schema.allOf);\n    } else {\n      let nestedSchema = schema;\n      if (\"additionalProperties\" in schema && schema.additionalProperties === false) {\n        const {\n          additionalProperties,\n          ...rest\n        } = schema;\n        nestedSchema = rest;\n      }\n      mergedAllOf.push(nestedSchema);\n    }\n  });\n  return mergedAllOf.length ? {\n    allOf: mergedAllOf\n  } : void 0;\n}\nfunction parseLiteralDef2(def) {\n  const parsedType4 = typeof def.value;\n  if (parsedType4 !== \"bigint\" && parsedType4 !== \"number\" && parsedType4 !== \"boolean\" && parsedType4 !== \"string\") {\n    return {\n      type: Array.isArray(def.value) ? \"array\" : \"object\"\n    };\n  }\n  return {\n    type: parsedType4 === \"bigint\" ? \"integer\" : parsedType4,\n    const: def.value\n  };\n}\nvar emojiRegex3 = void 0;\nvar zodPatterns2 = {\n  /**\n   * `c` was changed to `[cC]` to replicate /i flag\n   */\n  cuid: /^[cC][^\\s-]{8,}$/,\n  cuid2: /^[0-9a-z]+$/,\n  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,\n  /**\n   * `a-z` was added to replicate /i flag\n   */\n  email: /^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_'+\\-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$/,\n  /**\n   * Constructed a valid Unicode RegExp\n   *\n   * Lazily instantiate since this type of regex isn't supported\n   * in all envs (e.g. React Native).\n   *\n   * See:\n   * https://github.com/colinhacks/zod/issues/2433\n   * Fix in Zod:\n   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b\n   */\n  emoji: () => {\n    if (emojiRegex3 === void 0) {\n      emojiRegex3 = RegExp(\"^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$\", \"u\");\n    }\n    return emojiRegex3;\n  },\n  /**\n   * Unused\n   */\n  uuid: /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/,\n  /**\n   * Unused\n   */\n  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,\n  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/,\n  /**\n   * Unused\n   */\n  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,\n  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,\n  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,\n  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,\n  nanoid: /^[a-zA-Z0-9_-]{21}$/,\n  jwt: /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/\n};\nfunction parseStringDef2(def, refs) {\n  const res = {\n    type: \"string\"\n  };\n  if (def.checks) {\n    for (const check2 of def.checks) {\n      switch (check2.kind) {\n        case \"min\":\n          res.minLength = typeof res.minLength === \"number\" ? Math.max(res.minLength, check2.value) : check2.value;\n          break;\n        case \"max\":\n          res.maxLength = typeof res.maxLength === \"number\" ? Math.min(res.maxLength, check2.value) : check2.value;\n          break;\n        case \"email\":\n          switch (refs.emailStrategy) {\n            case \"format:email\":\n              addFormat2(res, \"email\", check2.message, refs);\n              break;\n            case \"format:idn-email\":\n              addFormat2(res, \"idn-email\", check2.message, refs);\n              break;\n            case \"pattern:zod\":\n              addPattern2(res, zodPatterns2.email, check2.message, refs);\n              break;\n          }\n          break;\n        case \"url\":\n          addFormat2(res, \"uri\", check2.message, refs);\n          break;\n        case \"uuid\":\n          addFormat2(res, \"uuid\", check2.message, refs);\n          break;\n        case \"regex\":\n          addPattern2(res, check2.regex, check2.message, refs);\n          break;\n        case \"cuid\":\n          addPattern2(res, zodPatterns2.cuid, check2.message, refs);\n          break;\n        case \"cuid2\":\n          addPattern2(res, zodPatterns2.cuid2, check2.message, refs);\n          break;\n        case \"startsWith\":\n          addPattern2(res, RegExp(`^${escapeLiteralCheckValue2(check2.value, refs)}`), check2.message, refs);\n          break;\n        case \"endsWith\":\n          addPattern2(res, RegExp(`${escapeLiteralCheckValue2(check2.value, refs)}$`), check2.message, refs);\n          break;\n        case \"datetime\":\n          addFormat2(res, \"date-time\", check2.message, refs);\n          break;\n        case \"date\":\n          addFormat2(res, \"date\", check2.message, refs);\n          break;\n        case \"time\":\n          addFormat2(res, \"time\", check2.message, refs);\n          break;\n        case \"duration\":\n          addFormat2(res, \"duration\", check2.message, refs);\n          break;\n        case \"length\":\n          res.minLength = typeof res.minLength === \"number\" ? Math.max(res.minLength, check2.value) : check2.value;\n          res.maxLength = typeof res.maxLength === \"number\" ? Math.min(res.maxLength, check2.value) : check2.value;\n          break;\n        case \"includes\":\n          {\n            addPattern2(res, RegExp(escapeLiteralCheckValue2(check2.value, refs)), check2.message, refs);\n            break;\n          }\n        case \"ip\":\n          {\n            if (check2.version !== \"v6\") {\n              addFormat2(res, \"ipv4\", check2.message, refs);\n            }\n            if (check2.version !== \"v4\") {\n              addFormat2(res, \"ipv6\", check2.message, refs);\n            }\n            break;\n          }\n        case \"base64url\":\n          addPattern2(res, zodPatterns2.base64url, check2.message, refs);\n          break;\n        case \"jwt\":\n          addPattern2(res, zodPatterns2.jwt, check2.message, refs);\n          break;\n        case \"cidr\":\n          {\n            if (check2.version !== \"v6\") {\n              addPattern2(res, zodPatterns2.ipv4Cidr, check2.message, refs);\n            }\n            if (check2.version !== \"v4\") {\n              addPattern2(res, zodPatterns2.ipv6Cidr, check2.message, refs);\n            }\n            break;\n          }\n        case \"emoji\":\n          addPattern2(res, zodPatterns2.emoji(), check2.message, refs);\n          break;\n        case \"ulid\":\n          {\n            addPattern2(res, zodPatterns2.ulid, check2.message, refs);\n            break;\n          }\n        case \"base64\":\n          {\n            switch (refs.base64Strategy) {\n              case \"format:binary\":\n                {\n                  addFormat2(res, \"binary\", check2.message, refs);\n                  break;\n                }\n              case \"contentEncoding:base64\":\n                {\n                  res.contentEncoding = \"base64\";\n                  break;\n                }\n              case \"pattern:zod\":\n                {\n                  addPattern2(res, zodPatterns2.base64, check2.message, refs);\n                  break;\n                }\n            }\n            break;\n          }\n        case \"nanoid\":\n          {\n            addPattern2(res, zodPatterns2.nanoid, check2.message, refs);\n          }\n        case \"toLowerCase\":\n        case \"toUpperCase\":\n        case \"trim\":\n          break;\n        default:\n          /* @__PURE__ */(_ => {})(check2);\n      }\n    }\n  }\n  return res;\n}\nfunction escapeLiteralCheckValue2(literal2, refs) {\n  return refs.patternStrategy === \"escape\" ? escapeNonAlphaNumeric2(literal2) : literal2;\n}\nvar ALPHA_NUMERIC3 = new Set(\"ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789\");\nfunction escapeNonAlphaNumeric2(source) {\n  let result = \"\";\n  for (let i = 0; i < source.length; i++) {\n    if (!ALPHA_NUMERIC3.has(source[i])) {\n      result += \"\\\\\";\n    }\n    result += source[i];\n  }\n  return result;\n}\nfunction addFormat2(schema, value, message, refs) {\n  var _a20;\n  if (schema.format || ((_a20 = schema.anyOf) == null ? void 0 : _a20.some(x => x.format))) {\n    if (!schema.anyOf) {\n      schema.anyOf = [];\n    }\n    if (schema.format) {\n      schema.anyOf.push({\n        format: schema.format\n      });\n      delete schema.format;\n    }\n    schema.anyOf.push({\n      format: value,\n      ...(message && refs.errorMessages && {\n        errorMessage: {\n          format: message\n        }\n      })\n    });\n  } else {\n    schema.format = value;\n  }\n}\nfunction addPattern2(schema, regex, message, refs) {\n  var _a20;\n  if (schema.pattern || ((_a20 = schema.allOf) == null ? void 0 : _a20.some(x => x.pattern))) {\n    if (!schema.allOf) {\n      schema.allOf = [];\n    }\n    if (schema.pattern) {\n      schema.allOf.push({\n        pattern: schema.pattern\n      });\n      delete schema.pattern;\n    }\n    schema.allOf.push({\n      pattern: stringifyRegExpWithFlags2(regex, refs),\n      ...(message && refs.errorMessages && {\n        errorMessage: {\n          pattern: message\n        }\n      })\n    });\n  } else {\n    schema.pattern = stringifyRegExpWithFlags2(regex, refs);\n  }\n}\nfunction stringifyRegExpWithFlags2(regex, refs) {\n  var _a20;\n  if (!refs.applyRegexFlags || !regex.flags) {\n    return regex.source;\n  }\n  const flags = {\n    i: regex.flags.includes(\"i\"),\n    // Case-insensitive\n    m: regex.flags.includes(\"m\"),\n    // `^` and `$` matches adjacent to newline characters\n    s: regex.flags.includes(\"s\")\n    // `.` matches newlines\n  };\n  const source = flags.i ? regex.source.toLowerCase() : regex.source;\n  let pattern = \"\";\n  let isEscaped = false;\n  let inCharGroup = false;\n  let inCharRange = false;\n  for (let i = 0; i < source.length; i++) {\n    if (isEscaped) {\n      pattern += source[i];\n      isEscaped = false;\n      continue;\n    }\n    if (flags.i) {\n      if (inCharGroup) {\n        if (source[i].match(/[a-z]/)) {\n          if (inCharRange) {\n            pattern += source[i];\n            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();\n            inCharRange = false;\n          } else if (source[i + 1] === \"-\" && ((_a20 = source[i + 2]) == null ? void 0 : _a20.match(/[a-z]/))) {\n            pattern += source[i];\n            inCharRange = true;\n          } else {\n            pattern += `${source[i]}${source[i].toUpperCase()}`;\n          }\n          continue;\n        }\n      } else if (source[i].match(/[a-z]/)) {\n        pattern += `[${source[i]}${source[i].toUpperCase()}]`;\n        continue;\n      }\n    }\n    if (flags.m) {\n      if (source[i] === \"^\") {\n        pattern += `(^|(?<=[\\r\n]))`;\n        continue;\n      } else if (source[i] === \"$\") {\n        pattern += `($|(?=[\\r\n]))`;\n        continue;\n      }\n    }\n    if (flags.s && source[i] === \".\") {\n      pattern += inCharGroup ? `${source[i]}\\r\n` : `[${source[i]}\\r\n]`;\n      continue;\n    }\n    pattern += source[i];\n    if (source[i] === \"\\\\\") {\n      isEscaped = true;\n    } else if (inCharGroup && source[i] === \"]\") {\n      inCharGroup = false;\n    } else if (!inCharGroup && source[i] === \"[\") {\n      inCharGroup = true;\n    }\n  }\n  try {\n    new RegExp(pattern);\n  } catch (e) {\n    console.warn(`Could not convert regex pattern at ${refs.currentPath.join(\"/\")} to a flag-independent form! Falling back to the flag-ignorant source`);\n    return regex.source;\n  }\n  return pattern;\n}\nfunction parseRecordDef2(def, refs) {\n  var _a20, _b8, _c, _d, _e, _f;\n  const schema = {\n    type: \"object\",\n    additionalProperties: (_a20 = parseDef2(def.valueType._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"additionalProperties\"]\n    })) != null ? _a20 : refs.allowedAdditionalProperties\n  };\n  if (((_b8 = def.keyType) == null ? void 0 : _b8._def.typeName) === ZodFirstPartyTypeKind.ZodString && ((_c = def.keyType._def.checks) == null ? void 0 : _c.length)) {\n    const {\n      type,\n      ...keyType\n    } = parseStringDef2(def.keyType._def, refs);\n    return {\n      ...schema,\n      propertyNames: keyType\n    };\n  } else if (((_d = def.keyType) == null ? void 0 : _d._def.typeName) === ZodFirstPartyTypeKind.ZodEnum) {\n    return {\n      ...schema,\n      propertyNames: {\n        enum: def.keyType._def.values\n      }\n    };\n  } else if (((_e = def.keyType) == null ? void 0 : _e._def.typeName) === ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString && ((_f = def.keyType._def.type._def.checks) == null ? void 0 : _f.length)) {\n    const {\n      type,\n      ...keyType\n    } = parseBrandedDef2(def.keyType._def, refs);\n    return {\n      ...schema,\n      propertyNames: keyType\n    };\n  }\n  return schema;\n}\nfunction parseMapDef2(def, refs) {\n  if (refs.mapStrategy === \"record\") {\n    return parseRecordDef2(def, refs);\n  }\n  const keys2 = parseDef2(def.keyType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"items\", \"items\", \"0\"]\n  }) || parseAnyDef2();\n  const values = parseDef2(def.valueType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"items\", \"items\", \"1\"]\n  }) || parseAnyDef2();\n  return {\n    type: \"array\",\n    maxItems: 125,\n    items: {\n      type: \"array\",\n      items: [keys2, values],\n      minItems: 2,\n      maxItems: 2\n    }\n  };\n}\nfunction parseNativeEnumDef2(def) {\n  const object3 = def.values;\n  const actualKeys = Object.keys(def.values).filter(key => {\n    return typeof object3[object3[key]] !== \"number\";\n  });\n  const actualValues = actualKeys.map(key => object3[key]);\n  const parsedTypes = Array.from(new Set(actualValues.map(values => typeof values)));\n  return {\n    type: parsedTypes.length === 1 ? parsedTypes[0] === \"string\" ? \"string\" : \"number\" : [\"string\", \"number\"],\n    enum: actualValues\n  };\n}\nfunction parseNeverDef2() {\n  return {\n    not: parseAnyDef2()\n  };\n}\nfunction parseNullDef2() {\n  return {\n    type: \"null\"\n  };\n}\nvar primitiveMappings2 = {\n  ZodString: \"string\",\n  ZodNumber: \"number\",\n  ZodBigInt: \"integer\",\n  ZodBoolean: \"boolean\",\n  ZodNull: \"null\"\n};\nfunction parseUnionDef2(def, refs) {\n  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;\n  if (options.every(x => x._def.typeName in primitiveMappings2 && (!x._def.checks || !x._def.checks.length))) {\n    const types = options.reduce((types2, x) => {\n      const type = primitiveMappings2[x._def.typeName];\n      return type && !types2.includes(type) ? [...types2, type] : types2;\n    }, []);\n    return {\n      type: types.length > 1 ? types : types[0]\n    };\n  } else if (options.every(x => x._def.typeName === \"ZodLiteral\" && !x.description)) {\n    const types = options.reduce((acc, x) => {\n      const type = typeof x._def.value;\n      switch (type) {\n        case \"string\":\n        case \"number\":\n        case \"boolean\":\n          return [...acc, type];\n        case \"bigint\":\n          return [...acc, \"integer\"];\n        case \"object\":\n          if (x._def.value === null) return [...acc, \"null\"];\n        case \"symbol\":\n        case \"undefined\":\n        case \"function\":\n        default:\n          return acc;\n      }\n    }, []);\n    if (types.length === options.length) {\n      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);\n      return {\n        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],\n        enum: options.reduce((acc, x) => {\n          return acc.includes(x._def.value) ? acc : [...acc, x._def.value];\n        }, [])\n      };\n    }\n  } else if (options.every(x => x._def.typeName === \"ZodEnum\")) {\n    return {\n      type: \"string\",\n      enum: options.reduce((acc, x) => [...acc, ...x._def.values.filter(x2 => !acc.includes(x2))], [])\n    };\n  }\n  return asAnyOf2(def, refs);\n}\nvar asAnyOf2 = (def, refs) => {\n  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i) => parseDef2(x._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"anyOf\", `${i}`]\n  })).filter(x => !!x && (!refs.strictUnions || typeof x === \"object\" && Object.keys(x).length > 0));\n  return anyOf.length ? {\n    anyOf\n  } : void 0;\n};\nfunction parseNullableDef2(def, refs) {\n  if ([\"ZodString\", \"ZodNumber\", \"ZodBigInt\", \"ZodBoolean\", \"ZodNull\"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {\n    return {\n      type: [primitiveMappings2[def.innerType._def.typeName], \"null\"]\n    };\n  }\n  const base = parseDef2(def.innerType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"anyOf\", \"0\"]\n  });\n  return base && {\n    anyOf: [base, {\n      type: \"null\"\n    }]\n  };\n}\nfunction parseNumberDef2(def) {\n  const res = {\n    type: \"number\"\n  };\n  if (!def.checks) return res;\n  for (const check2 of def.checks) {\n    switch (check2.kind) {\n      case \"int\":\n        res.type = \"integer\";\n        break;\n      case \"min\":\n        if (check2.inclusive) {\n          res.minimum = check2.value;\n        } else {\n          res.exclusiveMinimum = check2.value;\n        }\n        break;\n      case \"max\":\n        if (check2.inclusive) {\n          res.maximum = check2.value;\n        } else {\n          res.exclusiveMaximum = check2.value;\n        }\n        break;\n      case \"multipleOf\":\n        res.multipleOf = check2.value;\n        break;\n    }\n  }\n  return res;\n}\nfunction parseObjectDef2(def, refs) {\n  const result = {\n    type: \"object\",\n    properties: {}\n  };\n  const required2 = [];\n  const shape = def.shape();\n  for (const propName in shape) {\n    let propDef = shape[propName];\n    if (propDef === void 0 || propDef._def === void 0) {\n      continue;\n    }\n    const propOptional = safeIsOptional2(propDef);\n    const parsedDef = parseDef2(propDef._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"properties\", propName],\n      propertyPath: [...refs.currentPath, \"properties\", propName]\n    });\n    if (parsedDef === void 0) {\n      continue;\n    }\n    result.properties[propName] = parsedDef;\n    if (!propOptional) {\n      required2.push(propName);\n    }\n  }\n  if (required2.length) {\n    result.required = required2;\n  }\n  const additionalProperties = decideAdditionalProperties2(def, refs);\n  if (additionalProperties !== void 0) {\n    result.additionalProperties = additionalProperties;\n  }\n  return result;\n}\nfunction decideAdditionalProperties2(def, refs) {\n  if (def.catchall._def.typeName !== \"ZodNever\") {\n    return parseDef2(def.catchall._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"additionalProperties\"]\n    });\n  }\n  switch (def.unknownKeys) {\n    case \"passthrough\":\n      return refs.allowedAdditionalProperties;\n    case \"strict\":\n      return refs.rejectedAdditionalProperties;\n    case \"strip\":\n      return refs.removeAdditionalStrategy === \"strict\" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;\n  }\n}\nfunction safeIsOptional2(schema) {\n  try {\n    return schema.isOptional();\n  } catch (e) {\n    return true;\n  }\n}\nvar parseOptionalDef2 = (def, refs) => {\n  var _a20;\n  if (refs.currentPath.toString() === ((_a20 = refs.propertyPath) == null ? void 0 : _a20.toString())) {\n    return parseDef2(def.innerType._def, refs);\n  }\n  const innerSchema = parseDef2(def.innerType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"anyOf\", \"1\"]\n  });\n  return innerSchema ? {\n    anyOf: [{\n      not: parseAnyDef2()\n    }, innerSchema]\n  } : parseAnyDef2();\n};\nvar parsePipelineDef2 = (def, refs) => {\n  if (refs.pipeStrategy === \"input\") {\n    return parseDef2(def.in._def, refs);\n  } else if (refs.pipeStrategy === \"output\") {\n    return parseDef2(def.out._def, refs);\n  }\n  const a = parseDef2(def.in._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"allOf\", \"0\"]\n  });\n  const b = parseDef2(def.out._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"allOf\", a ? \"1\" : \"0\"]\n  });\n  return {\n    allOf: [a, b].filter(x => x !== void 0)\n  };\n};\nfunction parsePromiseDef2(def, refs) {\n  return parseDef2(def.type._def, refs);\n}\nfunction parseSetDef2(def, refs) {\n  const items = parseDef2(def.valueType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"items\"]\n  });\n  const schema = {\n    type: \"array\",\n    uniqueItems: true,\n    items\n  };\n  if (def.minSize) {\n    schema.minItems = def.minSize.value;\n  }\n  if (def.maxSize) {\n    schema.maxItems = def.maxSize.value;\n  }\n  return schema;\n}\nfunction parseTupleDef2(def, refs) {\n  if (def.rest) {\n    return {\n      type: \"array\",\n      minItems: def.items.length,\n      items: def.items.map((x, i) => parseDef2(x._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"items\", `${i}`]\n      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], []),\n      additionalItems: parseDef2(def.rest._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"additionalItems\"]\n      })\n    };\n  } else {\n    return {\n      type: \"array\",\n      minItems: def.items.length,\n      maxItems: def.items.length,\n      items: def.items.map((x, i) => parseDef2(x._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"items\", `${i}`]\n      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], [])\n    };\n  }\n}\nfunction parseUndefinedDef2() {\n  return {\n    not: parseAnyDef2()\n  };\n}\nfunction parseUnknownDef2() {\n  return parseAnyDef2();\n}\nvar parseReadonlyDef2 = (def, refs) => {\n  return parseDef2(def.innerType._def, refs);\n};\nvar selectParser2 = (def, typeName, refs) => {\n  switch (typeName) {\n    case ZodFirstPartyTypeKind.ZodString:\n      return parseStringDef2(def, refs);\n    case ZodFirstPartyTypeKind.ZodNumber:\n      return parseNumberDef2(def);\n    case ZodFirstPartyTypeKind.ZodObject:\n      return parseObjectDef2(def, refs);\n    case ZodFirstPartyTypeKind.ZodBigInt:\n      return parseBigintDef2(def);\n    case ZodFirstPartyTypeKind.ZodBoolean:\n      return parseBooleanDef2();\n    case ZodFirstPartyTypeKind.ZodDate:\n      return parseDateDef2(def, refs);\n    case ZodFirstPartyTypeKind.ZodUndefined:\n      return parseUndefinedDef2();\n    case ZodFirstPartyTypeKind.ZodNull:\n      return parseNullDef2();\n    case ZodFirstPartyTypeKind.ZodArray:\n      return parseArrayDef2(def, refs);\n    case ZodFirstPartyTypeKind.ZodUnion:\n    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:\n      return parseUnionDef2(def, refs);\n    case ZodFirstPartyTypeKind.ZodIntersection:\n      return parseIntersectionDef2(def, refs);\n    case ZodFirstPartyTypeKind.ZodTuple:\n      return parseTupleDef2(def, refs);\n    case ZodFirstPartyTypeKind.ZodRecord:\n      return parseRecordDef2(def, refs);\n    case ZodFirstPartyTypeKind.ZodLiteral:\n      return parseLiteralDef2(def);\n    case ZodFirstPartyTypeKind.ZodEnum:\n      return parseEnumDef2(def);\n    case ZodFirstPartyTypeKind.ZodNativeEnum:\n      return parseNativeEnumDef2(def);\n    case ZodFirstPartyTypeKind.ZodNullable:\n      return parseNullableDef2(def, refs);\n    case ZodFirstPartyTypeKind.ZodOptional:\n      return parseOptionalDef2(def, refs);\n    case ZodFirstPartyTypeKind.ZodMap:\n      return parseMapDef2(def, refs);\n    case ZodFirstPartyTypeKind.ZodSet:\n      return parseSetDef2(def, refs);\n    case ZodFirstPartyTypeKind.ZodLazy:\n      return () => def.getter()._def;\n    case ZodFirstPartyTypeKind.ZodPromise:\n      return parsePromiseDef2(def, refs);\n    case ZodFirstPartyTypeKind.ZodNaN:\n    case ZodFirstPartyTypeKind.ZodNever:\n      return parseNeverDef2();\n    case ZodFirstPartyTypeKind.ZodEffects:\n      return parseEffectsDef2(def, refs);\n    case ZodFirstPartyTypeKind.ZodAny:\n      return parseAnyDef2();\n    case ZodFirstPartyTypeKind.ZodUnknown:\n      return parseUnknownDef2();\n    case ZodFirstPartyTypeKind.ZodDefault:\n      return parseDefaultDef2(def, refs);\n    case ZodFirstPartyTypeKind.ZodBranded:\n      return parseBrandedDef2(def, refs);\n    case ZodFirstPartyTypeKind.ZodReadonly:\n      return parseReadonlyDef2(def, refs);\n    case ZodFirstPartyTypeKind.ZodCatch:\n      return parseCatchDef2(def, refs);\n    case ZodFirstPartyTypeKind.ZodPipeline:\n      return parsePipelineDef2(def, refs);\n    case ZodFirstPartyTypeKind.ZodFunction:\n    case ZodFirstPartyTypeKind.ZodVoid:\n    case ZodFirstPartyTypeKind.ZodSymbol:\n      return void 0;\n    default:\n      return /* @__PURE__ */(_ => void 0)(typeName);\n  }\n};\nfunction parseDef2(def, refs, forceResolution = false) {\n  var _a20;\n  const seenItem = refs.seen.get(def);\n  if (refs.override) {\n    const overrideResult = (_a20 = refs.override) == null ? void 0 : _a20.call(refs, def, refs, seenItem, forceResolution);\n    if (overrideResult !== ignoreOverride3) {\n      return overrideResult;\n    }\n  }\n  if (seenItem && !forceResolution) {\n    const seenSchema = get$ref2(seenItem, refs);\n    if (seenSchema !== void 0) {\n      return seenSchema;\n    }\n  }\n  const newItem = {\n    def,\n    path: refs.currentPath,\n    jsonSchema: void 0\n  };\n  refs.seen.set(def, newItem);\n  const jsonSchemaOrGetter = selectParser2(def, def.typeName, refs);\n  const jsonSchema2 = typeof jsonSchemaOrGetter === \"function\" ? parseDef2(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;\n  if (jsonSchema2) {\n    addMeta2(def, refs, jsonSchema2);\n  }\n  if (refs.postProcess) {\n    const postProcessResult = refs.postProcess(jsonSchema2, def, refs);\n    newItem.jsonSchema = jsonSchema2;\n    return postProcessResult;\n  }\n  newItem.jsonSchema = jsonSchema2;\n  return jsonSchema2;\n}\nvar get$ref2 = (item, refs) => {\n  switch (refs.$refStrategy) {\n    case \"root\":\n      return {\n        $ref: item.path.join(\"/\")\n      };\n    case \"relative\":\n      return {\n        $ref: getRelativePath2(refs.currentPath, item.path)\n      };\n    case \"none\":\n    case \"seen\":\n      {\n        if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {\n          console.warn(`Recursive reference detected at ${refs.currentPath.join(\"/\")}! Defaulting to any`);\n          return parseAnyDef2();\n        }\n        return refs.$refStrategy === \"seen\" ? parseAnyDef2() : void 0;\n      }\n  }\n};\nvar addMeta2 = (def, refs, jsonSchema2) => {\n  if (def.description) {\n    jsonSchema2.description = def.description;\n  }\n  return jsonSchema2;\n};\nvar getRefs2 = options => {\n  const _options = getDefaultOptions2(options);\n  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;\n  return {\n    ..._options,\n    currentPath,\n    propertyPath: void 0,\n    seen: new Map(Object.entries(_options.definitions).map(([name19, def]) => [def._def, {\n      def: def._def,\n      path: [..._options.basePath, _options.definitionPath, name19],\n      // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.\n      jsonSchema: void 0\n    }]))\n  };\n};\nvar zodToJsonSchema2 = (schema, options) => {\n  var _a20;\n  const refs = getRefs2(options);\n  let definitions = typeof options === \"object\" && options.definitions ? Object.entries(options.definitions).reduce((acc, [name27, schema2]) => {\n    var _a27;\n    return {\n      ...acc,\n      [name27]: (_a27 = parseDef2(schema2._def, {\n        ...refs,\n        currentPath: [...refs.basePath, refs.definitionPath, name27]\n      }, true)) != null ? _a27 : parseAnyDef2()\n    };\n  }, {}) : void 0;\n  const name19 = typeof options === \"string\" ? options : (options == null ? void 0 : options.nameStrategy) === \"title\" ? void 0 : options == null ? void 0 : options.name;\n  const main = (_a20 = parseDef2(schema._def, name19 === void 0 ? refs : {\n    ...refs,\n    currentPath: [...refs.basePath, refs.definitionPath, name19]\n  }, false)) != null ? _a20 : parseAnyDef2();\n  const title = typeof options === \"object\" && options.name !== void 0 && options.nameStrategy === \"title\" ? options.name : void 0;\n  if (title !== void 0) {\n    main.title = title;\n  }\n  const combined = name19 === void 0 ? definitions ? {\n    ...main,\n    [refs.definitionPath]: definitions\n  } : main : {\n    $ref: [...(refs.$refStrategy === \"relative\" ? [] : refs.basePath), refs.definitionPath, name19].join(\"/\"),\n    [refs.definitionPath]: {\n      ...definitions,\n      [name19]: main\n    }\n  };\n  combined.$schema = \"http://json-schema.org/draft-07/schema#\";\n  return combined;\n};\nvar zod_to_json_schema_default = zodToJsonSchema2;\nfunction zod3Schema(zodSchema2, options) {\n  var _a20;\n  const useReferences = (_a20 = options == null ? void 0 : options.useReferences) != null ? _a20 : false;\n  return jsonSchema(zod_to_json_schema_default(zodSchema2, {\n    $refStrategy: useReferences ? \"root\" : \"none\"\n  }), {\n    validate: async value => {\n      const result = await zodSchema2.safeParseAsync(value);\n      return result.success ? {\n        success: true,\n        value: result.data\n      } : {\n        success: false,\n        error: result.error\n      };\n    }\n  });\n}\nfunction zod4Schema(zodSchema2, options) {\n  var _a20;\n  const useReferences = (_a20 = options == null ? void 0 : options.useReferences) != null ? _a20 : false;\n  const z4JSONSchema = toJSONSchema(zodSchema2, {\n    target: \"draft-7\",\n    io: \"output\",\n    reused: useReferences ? \"ref\" : \"inline\"\n  });\n  return jsonSchema(z4JSONSchema, {\n    validate: async value => {\n      const result = await safeParseAsync2(zodSchema2, value);\n      return result.success ? {\n        success: true,\n        value: result.data\n      } : {\n        success: false,\n        error: result.error\n      };\n    }\n  });\n}\nfunction isZod4Schema(zodSchema2) {\n  return \"_zod\" in zodSchema2;\n}\nfunction zodSchema(zodSchema2, options) {\n  if (isZod4Schema(zodSchema2)) {\n    return zod4Schema(zodSchema2, options);\n  } else {\n    return zod3Schema(zodSchema2, options);\n  }\n}\nvar schemaSymbol2 = Symbol.for(\"vercel.ai.schema\");\nfunction jsonSchema(jsonSchema2, {\n  validate\n} = {}) {\n  return {\n    [schemaSymbol2]: true,\n    _type: void 0,\n    // should never be used directly\n    [validatorSymbol2]: true,\n    jsonSchema: jsonSchema2,\n    validate\n  };\n}\nfunction isSchema(value) {\n  return typeof value === \"object\" && value !== null && schemaSymbol2 in value && value[schemaSymbol2] === true && \"jsonSchema\" in value && \"validate\" in value;\n}\nfunction asSchema(schema) {\n  return schema == null ? jsonSchema({\n    properties: {},\n    additionalProperties: false\n  }) : isSchema(schema) ? schema : zodSchema(schema);\n}\nvar {\n  btoa: btoa3,\n  atob: atob3\n} = globalThis;\nfunction convertBase64ToUint8Array(base64String) {\n  const base64Url = base64String.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  const latin1string = atob3(base64Url);\n  return Uint8Array.from(latin1string, byte => byte.codePointAt(0));\n}\nfunction convertUint8ArrayToBase64(array2) {\n  let latin1string = \"\";\n  for (let i = 0; i < array2.length; i++) {\n    latin1string += String.fromCodePoint(array2[i]);\n  }\n  return btoa3(latin1string);\n}\nfunction isAsyncIterable(obj) {\n  return obj != null && typeof obj[Symbol.asyncIterator] === \"function\";\n}\nasync function* executeTool({\n  execute,\n  input,\n  options\n}) {\n  const result = execute(input, options);\n  if (isAsyncIterable(result)) {\n    let lastOutput;\n    for await (const output of result) {\n      lastOutput = output;\n      yield {\n        type: \"preliminary\",\n        output\n      };\n    }\n    yield {\n      type: \"final\",\n      output: lastOutput\n    };\n  } else {\n    yield {\n      type: \"final\",\n      output: await result\n    };\n  }\n}\n\n// ../../node_modules/@opentelemetry/api/build/esm/platform/node/globalThis.js\nvar _globalThis = typeof globalThis === \"object\" ? globalThis : global;\n\n// ../../node_modules/@opentelemetry/api/build/esm/version.js\nvar VERSION2 = \"1.9.0\";\n\n// ../../node_modules/@opentelemetry/api/build/esm/internal/semver.js\nvar re = /^(\\d+)\\.(\\d+)\\.(\\d+)(-(.+))?$/;\nfunction _makeCompatibilityCheck(ownVersion) {\n  var acceptedVersions = /* @__PURE__ */new Set([ownVersion]);\n  var rejectedVersions = /* @__PURE__ */new Set();\n  var myVersionMatch = ownVersion.match(re);\n  if (!myVersionMatch) {\n    return function () {\n      return false;\n    };\n  }\n  var ownVersionParsed = {\n    major: +myVersionMatch[1],\n    minor: +myVersionMatch[2],\n    patch: +myVersionMatch[3],\n    prerelease: myVersionMatch[4]\n  };\n  if (ownVersionParsed.prerelease != null) {\n    return function isExactmatch(globalVersion) {\n      return globalVersion === ownVersion;\n    };\n  }\n  function _reject(v) {\n    rejectedVersions.add(v);\n    return false;\n  }\n  function _accept(v) {\n    acceptedVersions.add(v);\n    return true;\n  }\n  return function isCompatible2(globalVersion) {\n    if (acceptedVersions.has(globalVersion)) {\n      return true;\n    }\n    if (rejectedVersions.has(globalVersion)) {\n      return false;\n    }\n    var globalVersionMatch = globalVersion.match(re);\n    if (!globalVersionMatch) {\n      return _reject(globalVersion);\n    }\n    var globalVersionParsed = {\n      major: +globalVersionMatch[1],\n      minor: +globalVersionMatch[2],\n      patch: +globalVersionMatch[3],\n      prerelease: globalVersionMatch[4]\n    };\n    if (globalVersionParsed.prerelease != null) {\n      return _reject(globalVersion);\n    }\n    if (ownVersionParsed.major !== globalVersionParsed.major) {\n      return _reject(globalVersion);\n    }\n    if (ownVersionParsed.major === 0) {\n      if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {\n        return _accept(globalVersion);\n      }\n      return _reject(globalVersion);\n    }\n    if (ownVersionParsed.minor <= globalVersionParsed.minor) {\n      return _accept(globalVersion);\n    }\n    return _reject(globalVersion);\n  };\n}\nvar isCompatible = _makeCompatibilityCheck(VERSION2);\n\n// ../../node_modules/@opentelemetry/api/build/esm/internal/global-utils.js\nvar major = VERSION2.split(\".\")[0];\nvar GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for(\"opentelemetry.js.api.\" + major);\nvar _global = _globalThis;\nfunction registerGlobal(type, instance, diag, allowOverride) {\n  var _a20;\n  if (allowOverride === void 0) {\n    allowOverride = false;\n  }\n  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a20 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a20 !== void 0 ? _a20 : {\n    version: VERSION2\n  };\n  if (!allowOverride && api[type]) {\n    var err = new Error(\"@opentelemetry/api: Attempted duplicate registration of API: \" + type);\n    diag.error(err.stack || err.message);\n    return false;\n  }\n  if (api.version !== VERSION2) {\n    var err = new Error(\"@opentelemetry/api: Registration of version v\" + api.version + \" for \" + type + \" does not match previously registered API v\" + VERSION2);\n    diag.error(err.stack || err.message);\n    return false;\n  }\n  api[type] = instance;\n  diag.debug(\"@opentelemetry/api: Registered a global for \" + type + \" v\" + VERSION2 + \".\");\n  return true;\n}\nfunction getGlobal(type) {\n  var _a20, _b8;\n  var globalVersion = (_a20 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a20 === void 0 ? void 0 : _a20.version;\n  if (!globalVersion || !isCompatible(globalVersion)) {\n    return;\n  }\n  return (_b8 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b8 === void 0 ? void 0 : _b8[type];\n}\nfunction unregisterGlobal(type, diag) {\n  diag.debug(\"@opentelemetry/api: Unregistering a global for \" + type + \" v\" + VERSION2 + \".\");\n  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];\n  if (api) {\n    delete api[type];\n  }\n}\n\n// ../../node_modules/@opentelemetry/api/build/esm/diag/ComponentLogger.js\nvar __read = function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r2,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r2 = i.next()).done) ar.push(r2.value);\n  } catch (error40) {\n    e = {\n      error: error40\n    };\n  } finally {\n    try {\n      if (r2 && !r2.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar DiagComponentLogger = /** @class */\nfunction () {\n  function DiagComponentLogger2(props) {\n    this._namespace = props.namespace || \"DiagComponentLogger\";\n  }\n  DiagComponentLogger2.prototype.debug = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return logProxy(\"debug\", this._namespace, args);\n  };\n  DiagComponentLogger2.prototype.error = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return logProxy(\"error\", this._namespace, args);\n  };\n  DiagComponentLogger2.prototype.info = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return logProxy(\"info\", this._namespace, args);\n  };\n  DiagComponentLogger2.prototype.warn = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return logProxy(\"warn\", this._namespace, args);\n  };\n  DiagComponentLogger2.prototype.verbose = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return logProxy(\"verbose\", this._namespace, args);\n  };\n  return DiagComponentLogger2;\n}();\nfunction logProxy(funcName, namespace, args) {\n  var logger = getGlobal(\"diag\");\n  if (!logger) {\n    return;\n  }\n  args.unshift(namespace);\n  return logger[funcName].apply(logger, __spreadArray([], __read(args), false));\n}\n\n// ../../node_modules/@opentelemetry/api/build/esm/diag/types.js\nvar DiagLogLevel;\n(function (DiagLogLevel2) {\n  DiagLogLevel2[DiagLogLevel2[\"NONE\"] = 0] = \"NONE\";\n  DiagLogLevel2[DiagLogLevel2[\"ERROR\"] = 30] = \"ERROR\";\n  DiagLogLevel2[DiagLogLevel2[\"WARN\"] = 50] = \"WARN\";\n  DiagLogLevel2[DiagLogLevel2[\"INFO\"] = 60] = \"INFO\";\n  DiagLogLevel2[DiagLogLevel2[\"DEBUG\"] = 70] = \"DEBUG\";\n  DiagLogLevel2[DiagLogLevel2[\"VERBOSE\"] = 80] = \"VERBOSE\";\n  DiagLogLevel2[DiagLogLevel2[\"ALL\"] = 9999] = \"ALL\";\n})(DiagLogLevel || (DiagLogLevel = {}));\n\n// ../../node_modules/@opentelemetry/api/build/esm/diag/internal/logLevelLogger.js\nfunction createLogLevelDiagLogger(maxLevel, logger) {\n  if (maxLevel < DiagLogLevel.NONE) {\n    maxLevel = DiagLogLevel.NONE;\n  } else if (maxLevel > DiagLogLevel.ALL) {\n    maxLevel = DiagLogLevel.ALL;\n  }\n  logger = logger || {};\n  function _filterFunc(funcName, theLevel) {\n    var theFunc = logger[funcName];\n    if (typeof theFunc === \"function\" && maxLevel >= theLevel) {\n      return theFunc.bind(logger);\n    }\n    return function () {};\n  }\n  return {\n    error: _filterFunc(\"error\", DiagLogLevel.ERROR),\n    warn: _filterFunc(\"warn\", DiagLogLevel.WARN),\n    info: _filterFunc(\"info\", DiagLogLevel.INFO),\n    debug: _filterFunc(\"debug\", DiagLogLevel.DEBUG),\n    verbose: _filterFunc(\"verbose\", DiagLogLevel.VERBOSE)\n  };\n}\n\n// ../../node_modules/@opentelemetry/api/build/esm/api/diag.js\nvar __read2 = function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r2,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r2 = i.next()).done) ar.push(r2.value);\n  } catch (error40) {\n    e = {\n      error: error40\n    };\n  } finally {\n    try {\n      if (r2 && !r2.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray2 = function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar API_NAME = \"diag\";\nvar DiagAPI = /** @class */\nfunction () {\n  function DiagAPI2() {\n    function _logProxy(funcName) {\n      return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        var logger = getGlobal(\"diag\");\n        if (!logger) return;\n        return logger[funcName].apply(logger, __spreadArray2([], __read2(args), false));\n      };\n    }\n    var self = this;\n    var setLogger = function (logger, optionsOrLogLevel) {\n      var _a20, _b8, _c;\n      if (optionsOrLogLevel === void 0) {\n        optionsOrLogLevel = {\n          logLevel: DiagLogLevel.INFO\n        };\n      }\n      if (logger === self) {\n        var err = new Error(\"Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation\");\n        self.error((_a20 = err.stack) !== null && _a20 !== void 0 ? _a20 : err.message);\n        return false;\n      }\n      if (typeof optionsOrLogLevel === \"number\") {\n        optionsOrLogLevel = {\n          logLevel: optionsOrLogLevel\n        };\n      }\n      var oldLogger = getGlobal(\"diag\");\n      var newLogger = createLogLevelDiagLogger((_b8 = optionsOrLogLevel.logLevel) !== null && _b8 !== void 0 ? _b8 : DiagLogLevel.INFO, logger);\n      if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {\n        var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : \"<failed to generate stacktrace>\";\n        oldLogger.warn(\"Current logger will be overwritten from \" + stack);\n        newLogger.warn(\"Current logger will overwrite one already registered from \" + stack);\n      }\n      return registerGlobal(\"diag\", newLogger, self, true);\n    };\n    self.setLogger = setLogger;\n    self.disable = function () {\n      unregisterGlobal(API_NAME, self);\n    };\n    self.createComponentLogger = function (options) {\n      return new DiagComponentLogger(options);\n    };\n    self.verbose = _logProxy(\"verbose\");\n    self.debug = _logProxy(\"debug\");\n    self.info = _logProxy(\"info\");\n    self.warn = _logProxy(\"warn\");\n    self.error = _logProxy(\"error\");\n  }\n  DiagAPI2.instance = function () {\n    if (!this._instance) {\n      this._instance = new DiagAPI2();\n    }\n    return this._instance;\n  };\n  return DiagAPI2;\n}();\n\n// ../../node_modules/@opentelemetry/api/build/esm/context/context.js\nfunction createContextKey(description) {\n  return Symbol.for(description);\n}\nvar BaseContext = /** @class */\n/* @__PURE__ */function () {\n  function BaseContext2(parentContext) {\n    var self = this;\n    self._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */new Map();\n    self.getValue = function (key) {\n      return self._currentContext.get(key);\n    };\n    self.setValue = function (key, value) {\n      var context = new BaseContext2(self._currentContext);\n      context._currentContext.set(key, value);\n      return context;\n    };\n    self.deleteValue = function (key) {\n      var context = new BaseContext2(self._currentContext);\n      context._currentContext.delete(key);\n      return context;\n    };\n  }\n  return BaseContext2;\n}();\nvar ROOT_CONTEXT = new BaseContext();\n\n// ../../node_modules/@opentelemetry/api/build/esm/context/NoopContextManager.js\nvar __read3 = function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r2,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r2 = i.next()).done) ar.push(r2.value);\n  } catch (error40) {\n    e = {\n      error: error40\n    };\n  } finally {\n    try {\n      if (r2 && !r2.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray3 = function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar NoopContextManager = /** @class */\nfunction () {\n  function NoopContextManager2() {}\n  NoopContextManager2.prototype.active = function () {\n    return ROOT_CONTEXT;\n  };\n  NoopContextManager2.prototype.with = function (_context, fn, thisArg) {\n    var args = [];\n    for (var _i = 3; _i < arguments.length; _i++) {\n      args[_i - 3] = arguments[_i];\n    }\n    return fn.call.apply(fn, __spreadArray3([thisArg], __read3(args), false));\n  };\n  NoopContextManager2.prototype.bind = function (_context, target) {\n    return target;\n  };\n  NoopContextManager2.prototype.enable = function () {\n    return this;\n  };\n  NoopContextManager2.prototype.disable = function () {\n    return this;\n  };\n  return NoopContextManager2;\n}();\n\n// ../../node_modules/@opentelemetry/api/build/esm/api/context.js\nvar __read4 = function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r2,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r2 = i.next()).done) ar.push(r2.value);\n  } catch (error40) {\n    e = {\n      error: error40\n    };\n  } finally {\n    try {\n      if (r2 && !r2.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray4 = function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar API_NAME2 = \"context\";\nvar NOOP_CONTEXT_MANAGER = new NoopContextManager();\nvar ContextAPI = /** @class */\nfunction () {\n  function ContextAPI2() {}\n  ContextAPI2.getInstance = function () {\n    if (!this._instance) {\n      this._instance = new ContextAPI2();\n    }\n    return this._instance;\n  };\n  ContextAPI2.prototype.setGlobalContextManager = function (contextManager) {\n    return registerGlobal(API_NAME2, contextManager, DiagAPI.instance());\n  };\n  ContextAPI2.prototype.active = function () {\n    return this._getContextManager().active();\n  };\n  ContextAPI2.prototype.with = function (context, fn, thisArg) {\n    var _a20;\n    var args = [];\n    for (var _i = 3; _i < arguments.length; _i++) {\n      args[_i - 3] = arguments[_i];\n    }\n    return (_a20 = this._getContextManager()).with.apply(_a20, __spreadArray4([context, fn, thisArg], __read4(args), false));\n  };\n  ContextAPI2.prototype.bind = function (context, target) {\n    return this._getContextManager().bind(context, target);\n  };\n  ContextAPI2.prototype._getContextManager = function () {\n    return getGlobal(API_NAME2) || NOOP_CONTEXT_MANAGER;\n  };\n  ContextAPI2.prototype.disable = function () {\n    this._getContextManager().disable();\n    unregisterGlobal(API_NAME2, DiagAPI.instance());\n  };\n  return ContextAPI2;\n}();\n\n// ../../node_modules/@opentelemetry/api/build/esm/trace/trace_flags.js\nvar TraceFlags;\n(function (TraceFlags2) {\n  TraceFlags2[TraceFlags2[\"NONE\"] = 0] = \"NONE\";\n  TraceFlags2[TraceFlags2[\"SAMPLED\"] = 1] = \"SAMPLED\";\n})(TraceFlags || (TraceFlags = {}));\n\n// ../../node_modules/@opentelemetry/api/build/esm/trace/invalid-span-constants.js\nvar INVALID_SPANID = \"0000000000000000\";\nvar INVALID_TRACEID = \"00000000000000000000000000000000\";\nvar INVALID_SPAN_CONTEXT = {\n  traceId: INVALID_TRACEID,\n  spanId: INVALID_SPANID,\n  traceFlags: TraceFlags.NONE\n};\n\n// ../../node_modules/@opentelemetry/api/build/esm/trace/NonRecordingSpan.js\nvar NonRecordingSpan = /** @class */\nfunction () {\n  function NonRecordingSpan2(_spanContext) {\n    if (_spanContext === void 0) {\n      _spanContext = INVALID_SPAN_CONTEXT;\n    }\n    this._spanContext = _spanContext;\n  }\n  NonRecordingSpan2.prototype.spanContext = function () {\n    return this._spanContext;\n  };\n  NonRecordingSpan2.prototype.setAttribute = function (_key, _value) {\n    return this;\n  };\n  NonRecordingSpan2.prototype.setAttributes = function (_attributes) {\n    return this;\n  };\n  NonRecordingSpan2.prototype.addEvent = function (_name, _attributes) {\n    return this;\n  };\n  NonRecordingSpan2.prototype.addLink = function (_link) {\n    return this;\n  };\n  NonRecordingSpan2.prototype.addLinks = function (_links) {\n    return this;\n  };\n  NonRecordingSpan2.prototype.setStatus = function (_status) {\n    return this;\n  };\n  NonRecordingSpan2.prototype.updateName = function (_name) {\n    return this;\n  };\n  NonRecordingSpan2.prototype.end = function (_endTime) {};\n  NonRecordingSpan2.prototype.isRecording = function () {\n    return false;\n  };\n  NonRecordingSpan2.prototype.recordException = function (_exception, _time) {};\n  return NonRecordingSpan2;\n}();\n\n// ../../node_modules/@opentelemetry/api/build/esm/trace/context-utils.js\nvar SPAN_KEY = createContextKey(\"OpenTelemetry Context Key SPAN\");\nfunction getSpan(context) {\n  return context.getValue(SPAN_KEY) || void 0;\n}\nfunction getActiveSpan() {\n  return getSpan(ContextAPI.getInstance().active());\n}\nfunction setSpan(context, span) {\n  return context.setValue(SPAN_KEY, span);\n}\nfunction deleteSpan(context) {\n  return context.deleteValue(SPAN_KEY);\n}\nfunction setSpanContext(context, spanContext) {\n  return setSpan(context, new NonRecordingSpan(spanContext));\n}\nfunction getSpanContext(context) {\n  var _a20;\n  return (_a20 = getSpan(context)) === null || _a20 === void 0 ? void 0 : _a20.spanContext();\n}\n\n// ../../node_modules/@opentelemetry/api/build/esm/trace/spancontext-utils.js\nvar VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;\nvar VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;\nfunction isValidTraceId(traceId) {\n  return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;\n}\nfunction isValidSpanId(spanId) {\n  return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;\n}\nfunction isSpanContextValid(spanContext) {\n  return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);\n}\nfunction wrapSpanContext(spanContext) {\n  return new NonRecordingSpan(spanContext);\n}\n\n// ../../node_modules/@opentelemetry/api/build/esm/trace/NoopTracer.js\nvar contextApi = ContextAPI.getInstance();\nvar NoopTracer = /** @class */\nfunction () {\n  function NoopTracer2() {}\n  NoopTracer2.prototype.startSpan = function (name19, options, context) {\n    if (context === void 0) {\n      context = contextApi.active();\n    }\n    var root = Boolean(options === null || options === void 0 ? void 0 : options.root);\n    if (root) {\n      return new NonRecordingSpan();\n    }\n    var parentFromContext = context && getSpanContext(context);\n    if (isSpanContext(parentFromContext) && isSpanContextValid(parentFromContext)) {\n      return new NonRecordingSpan(parentFromContext);\n    } else {\n      return new NonRecordingSpan();\n    }\n  };\n  NoopTracer2.prototype.startActiveSpan = function (name19, arg2, arg3, arg4) {\n    var opts;\n    var ctx;\n    var fn;\n    if (arguments.length < 2) {\n      return;\n    } else if (arguments.length === 2) {\n      fn = arg2;\n    } else if (arguments.length === 3) {\n      opts = arg2;\n      fn = arg3;\n    } else {\n      opts = arg2;\n      ctx = arg3;\n      fn = arg4;\n    }\n    var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi.active();\n    var span = this.startSpan(name19, opts, parentContext);\n    var contextWithSpanSet = setSpan(parentContext, span);\n    return contextApi.with(contextWithSpanSet, fn, void 0, span);\n  };\n  return NoopTracer2;\n}();\nfunction isSpanContext(spanContext) {\n  return typeof spanContext === \"object\" && typeof spanContext[\"spanId\"] === \"string\" && typeof spanContext[\"traceId\"] === \"string\" && typeof spanContext[\"traceFlags\"] === \"number\";\n}\n\n// ../../node_modules/@opentelemetry/api/build/esm/trace/ProxyTracer.js\nvar NOOP_TRACER = new NoopTracer();\nvar ProxyTracer = /** @class */\nfunction () {\n  function ProxyTracer2(_provider, name19, version2, options) {\n    this._provider = _provider;\n    this.name = name19;\n    this.version = version2;\n    this.options = options;\n  }\n  ProxyTracer2.prototype.startSpan = function (name19, options, context) {\n    return this._getTracer().startSpan(name19, options, context);\n  };\n  ProxyTracer2.prototype.startActiveSpan = function (_name, _options, _context, _fn) {\n    var tracer = this._getTracer();\n    return Reflect.apply(tracer.startActiveSpan, tracer, arguments);\n  };\n  ProxyTracer2.prototype._getTracer = function () {\n    if (this._delegate) {\n      return this._delegate;\n    }\n    var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);\n    if (!tracer) {\n      return NOOP_TRACER;\n    }\n    this._delegate = tracer;\n    return this._delegate;\n  };\n  return ProxyTracer2;\n}();\n\n// ../../node_modules/@opentelemetry/api/build/esm/trace/NoopTracerProvider.js\nvar NoopTracerProvider = /** @class */\nfunction () {\n  function NoopTracerProvider2() {}\n  NoopTracerProvider2.prototype.getTracer = function (_name, _version, _options) {\n    return new NoopTracer();\n  };\n  return NoopTracerProvider2;\n}();\n\n// ../../node_modules/@opentelemetry/api/build/esm/trace/ProxyTracerProvider.js\nvar NOOP_TRACER_PROVIDER = new NoopTracerProvider();\nvar ProxyTracerProvider = /** @class */\nfunction () {\n  function ProxyTracerProvider2() {}\n  ProxyTracerProvider2.prototype.getTracer = function (name19, version2, options) {\n    var _a20;\n    return (_a20 = this.getDelegateTracer(name19, version2, options)) !== null && _a20 !== void 0 ? _a20 : new ProxyTracer(this, name19, version2, options);\n  };\n  ProxyTracerProvider2.prototype.getDelegate = function () {\n    var _a20;\n    return (_a20 = this._delegate) !== null && _a20 !== void 0 ? _a20 : NOOP_TRACER_PROVIDER;\n  };\n  ProxyTracerProvider2.prototype.setDelegate = function (delegate) {\n    this._delegate = delegate;\n  };\n  ProxyTracerProvider2.prototype.getDelegateTracer = function (name19, version2, options) {\n    var _a20;\n    return (_a20 = this._delegate) === null || _a20 === void 0 ? void 0 : _a20.getTracer(name19, version2, options);\n  };\n  return ProxyTracerProvider2;\n}();\n\n// ../../node_modules/@opentelemetry/api/build/esm/trace/status.js\nvar SpanStatusCode;\n(function (SpanStatusCode2) {\n  SpanStatusCode2[SpanStatusCode2[\"UNSET\"] = 0] = \"UNSET\";\n  SpanStatusCode2[SpanStatusCode2[\"OK\"] = 1] = \"OK\";\n  SpanStatusCode2[SpanStatusCode2[\"ERROR\"] = 2] = \"ERROR\";\n})(SpanStatusCode || (SpanStatusCode = {}));\n\n// ../../node_modules/@opentelemetry/api/build/esm/api/trace.js\nvar API_NAME3 = \"trace\";\nvar TraceAPI = /** @class */\nfunction () {\n  function TraceAPI2() {\n    this._proxyTracerProvider = new ProxyTracerProvider();\n    this.wrapSpanContext = wrapSpanContext;\n    this.isSpanContextValid = isSpanContextValid;\n    this.deleteSpan = deleteSpan;\n    this.getSpan = getSpan;\n    this.getActiveSpan = getActiveSpan;\n    this.getSpanContext = getSpanContext;\n    this.setSpan = setSpan;\n    this.setSpanContext = setSpanContext;\n  }\n  TraceAPI2.getInstance = function () {\n    if (!this._instance) {\n      this._instance = new TraceAPI2();\n    }\n    return this._instance;\n  };\n  TraceAPI2.prototype.setGlobalTracerProvider = function (provider) {\n    var success2 = registerGlobal(API_NAME3, this._proxyTracerProvider, DiagAPI.instance());\n    if (success2) {\n      this._proxyTracerProvider.setDelegate(provider);\n    }\n    return success2;\n  };\n  TraceAPI2.prototype.getTracerProvider = function () {\n    return getGlobal(API_NAME3) || this._proxyTracerProvider;\n  };\n  TraceAPI2.prototype.getTracer = function (name19, version2) {\n    return this.getTracerProvider().getTracer(name19, version2);\n  };\n  TraceAPI2.prototype.disable = function () {\n    unregisterGlobal(API_NAME3, DiagAPI.instance());\n    this._proxyTracerProvider = new ProxyTracerProvider();\n  };\n  return TraceAPI2;\n}();\n\n// ../../node_modules/@opentelemetry/api/build/esm/trace-api.js\nvar trace = TraceAPI.getInstance();\n\n// ../../node_modules/ai/dist/index.mjs\nvar __defProp2 = Object.defineProperty;\nvar __export2 = (target, all) => {\n  for (var name172 in all) __defProp2(target, name172, {\n    get: all[name172],\n    enumerable: true\n  });\n};\nvar name16 = \"AI_NoOutputSpecifiedError\";\nvar marker17 = `vercel.ai.error.${name16}`;\nvar symbol18 = Symbol.for(marker17);\nvar _a17;\nvar NoOutputSpecifiedError = class extends AISDKError2 {\n  // used in isInstance\n  constructor({\n    message = \"No output specified.\"\n  } = {}) {\n    super({\n      name: name16,\n      message\n    });\n    this[_a17] = true;\n  }\n  static isInstance(error40) {\n    return AISDKError2.hasMarker(error40, marker17);\n  }\n};\n_a17 = symbol18;\nfunction formatWarning(warning) {\n  const prefix = \"AI SDK Warning:\";\n  switch (warning.type) {\n    case \"unsupported-setting\":\n      {\n        let message = `${prefix} The \"${warning.setting}\" setting is not supported by this model`;\n        if (warning.details) {\n          message += ` - ${warning.details}`;\n        }\n        return message;\n      }\n    case \"unsupported-tool\":\n      {\n        const toolName = \"name\" in warning.tool ? warning.tool.name : \"unknown tool\";\n        let message = `${prefix} The tool \"${toolName}\" is not supported by this model`;\n        if (warning.details) {\n          message += ` - ${warning.details}`;\n        }\n        return message;\n      }\n    case \"other\":\n      {\n        return `${prefix} ${warning.message}`;\n      }\n    default:\n      {\n        return `${prefix} ${JSON.stringify(warning, null, 2)}`;\n      }\n  }\n}\nvar FIRST_WARNING_INFO_MESSAGE = \"AI SDK Warning System: To turn off warning logging, set the AI_SDK_LOG_WARNINGS global to false.\";\nvar hasLoggedBefore = false;\nvar logWarnings = warnings => {\n  if (warnings.length === 0) {\n    return;\n  }\n  const logger = globalThis.AI_SDK_LOG_WARNINGS;\n  if (logger === false) {\n    return;\n  }\n  if (typeof logger === \"function\") {\n    logger(warnings);\n    return;\n  }\n  if (!hasLoggedBefore) {\n    hasLoggedBefore = true;\n    console.info(FIRST_WARNING_INFO_MESSAGE);\n  }\n  for (const warning of warnings) {\n    console.warn(formatWarning(warning));\n  }\n};\nvar name24 = \"AI_InvalidArgumentError\";\nvar marker24 = `vercel.ai.error.${name24}`;\nvar symbol24 = Symbol.for(marker24);\nvar _a24;\nvar InvalidArgumentError3 = class extends AISDKError2 {\n  constructor({\n    parameter,\n    value,\n    message\n  }) {\n    super({\n      name: name24,\n      message: `Invalid argument for parameter ${parameter}: ${message}`\n    });\n    this[_a24] = true;\n    this.parameter = parameter;\n    this.value = value;\n  }\n  static isInstance(error40) {\n    return AISDKError2.hasMarker(error40, marker24);\n  }\n};\n_a24 = symbol24;\nvar name34 = \"AI_InvalidStreamPartError\";\nvar marker34 = `vercel.ai.error.${name34}`;\nvar symbol34 = Symbol.for(marker34);\nvar _a34;\n_a34 = symbol34;\nvar name44 = \"AI_InvalidToolInputError\";\nvar marker44 = `vercel.ai.error.${name44}`;\nvar symbol44 = Symbol.for(marker44);\nvar _a44;\nvar InvalidToolInputError = class extends AISDKError2 {\n  constructor({\n    toolInput,\n    toolName,\n    cause,\n    message = `Invalid input for tool ${toolName}: ${getErrorMessage2(cause)}`\n  }) {\n    super({\n      name: name44,\n      message,\n      cause\n    });\n    this[_a44] = true;\n    this.toolInput = toolInput;\n    this.toolName = toolName;\n  }\n  static isInstance(error40) {\n    return AISDKError2.hasMarker(error40, marker44);\n  }\n};\n_a44 = symbol44;\nvar name54 = \"AI_MCPClientError\";\nvar marker54 = `vercel.ai.error.${name54}`;\nvar symbol54 = Symbol.for(marker54);\nvar _a54;\n_a54 = symbol54;\nvar name64 = \"AI_NoImageGeneratedError\";\nvar marker64 = `vercel.ai.error.${name64}`;\nvar symbol64 = Symbol.for(marker64);\nvar _a64;\n_a64 = symbol64;\nvar name73 = \"AI_NoObjectGeneratedError\";\nvar marker74 = `vercel.ai.error.${name73}`;\nvar symbol74 = Symbol.for(marker74);\nvar _a74;\nvar NoObjectGeneratedError = class extends AISDKError2 {\n  constructor({\n    message = \"No object generated.\",\n    cause,\n    text: text2,\n    response,\n    usage,\n    finishReason\n  }) {\n    super({\n      name: name73,\n      message,\n      cause\n    });\n    this[_a74] = true;\n    this.text = text2;\n    this.response = response;\n    this.usage = usage;\n    this.finishReason = finishReason;\n  }\n  static isInstance(error40) {\n    return AISDKError2.hasMarker(error40, marker74);\n  }\n};\n_a74 = symbol74;\nvar name83 = \"AI_NoOutputGeneratedError\";\nvar marker83 = `vercel.ai.error.${name83}`;\nvar symbol83 = Symbol.for(marker83);\nvar _a83;\nvar NoOutputGeneratedError = class extends AISDKError2 {\n  // used in isInstance\n  constructor({\n    message = \"No output generated.\",\n    cause\n  } = {}) {\n    super({\n      name: name83,\n      message,\n      cause\n    });\n    this[_a83] = true;\n  }\n  static isInstance(error40) {\n    return AISDKError2.hasMarker(error40, marker83);\n  }\n};\n_a83 = symbol83;\nvar name93 = \"AI_NoSuchToolError\";\nvar marker93 = `vercel.ai.error.${name93}`;\nvar symbol93 = Symbol.for(marker93);\nvar _a93;\nvar NoSuchToolError = class extends AISDKError2 {\n  constructor({\n    toolName,\n    availableTools = void 0,\n    message = `Model tried to call unavailable tool '${toolName}'. ${availableTools === void 0 ? \"No tools are available.\" : `Available tools: ${availableTools.join(\", \")}.`}`\n  }) {\n    super({\n      name: name93,\n      message\n    });\n    this[_a93] = true;\n    this.toolName = toolName;\n    this.availableTools = availableTools;\n  }\n  static isInstance(error40) {\n    return AISDKError2.hasMarker(error40, marker93);\n  }\n};\n_a93 = symbol93;\nvar name103 = \"AI_ToolCallRepairError\";\nvar marker103 = `vercel.ai.error.${name103}`;\nvar symbol103 = Symbol.for(marker103);\nvar _a103;\nvar ToolCallRepairError = class extends AISDKError2 {\n  constructor({\n    cause,\n    originalError,\n    message = `Error repairing tool call: ${getErrorMessage2(cause)}`\n  }) {\n    super({\n      name: name103,\n      message,\n      cause\n    });\n    this[_a103] = true;\n    this.originalError = originalError;\n  }\n  static isInstance(error40) {\n    return AISDKError2.hasMarker(error40, marker103);\n  }\n};\n_a103 = symbol103;\nvar UnsupportedModelVersionError = class extends AISDKError2 {\n  constructor(options) {\n    super({\n      name: \"AI_UnsupportedModelVersionError\",\n      message: `Unsupported model version ${options.version} for provider \"${options.provider}\" and model \"${options.modelId}\". AI SDK 5 only supports models that implement specification version \"v2\".`\n    });\n    this.version = options.version;\n    this.provider = options.provider;\n    this.modelId = options.modelId;\n  }\n};\nvar name113 = \"AI_InvalidDataContentError\";\nvar marker113 = `vercel.ai.error.${name113}`;\nvar symbol113 = Symbol.for(marker113);\nvar _a113;\nvar InvalidDataContentError = class extends AISDKError2 {\n  constructor({\n    content,\n    cause,\n    message = `Invalid data content. Expected a base64 string, Uint8Array, ArrayBuffer, or Buffer, but got ${typeof content}.`\n  }) {\n    super({\n      name: name113,\n      message,\n      cause\n    });\n    this[_a113] = true;\n    this.content = content;\n  }\n  static isInstance(error40) {\n    return AISDKError2.hasMarker(error40, marker113);\n  }\n};\n_a113 = symbol113;\nvar name123 = \"AI_InvalidMessageRoleError\";\nvar marker123 = `vercel.ai.error.${name123}`;\nvar symbol123 = Symbol.for(marker123);\nvar _a123;\nvar InvalidMessageRoleError = class extends AISDKError2 {\n  constructor({\n    role,\n    message = `Invalid message role: '${role}'. Must be one of: \"system\", \"user\", \"assistant\", \"tool\".`\n  }) {\n    super({\n      name: name123,\n      message\n    });\n    this[_a123] = true;\n    this.role = role;\n  }\n  static isInstance(error40) {\n    return AISDKError2.hasMarker(error40, marker123);\n  }\n};\n_a123 = symbol123;\nvar name133 = \"AI_MessageConversionError\";\nvar marker133 = `vercel.ai.error.${name133}`;\nvar symbol133 = Symbol.for(marker133);\nvar _a133;\n_a133 = symbol133;\nvar name142 = \"AI_DownloadError\";\nvar marker143 = `vercel.ai.error.${name142}`;\nvar symbol143 = Symbol.for(marker143);\nvar _a143;\nvar DownloadError = class extends AISDKError2 {\n  constructor({\n    url: url2,\n    statusCode,\n    statusText,\n    cause,\n    message = cause == null ? `Failed to download ${url2}: ${statusCode} ${statusText}` : `Failed to download ${url2}: ${cause}`\n  }) {\n    super({\n      name: name142,\n      message,\n      cause\n    });\n    this[_a143] = true;\n    this.url = url2;\n    this.statusCode = statusCode;\n    this.statusText = statusText;\n  }\n  static isInstance(error40) {\n    return AISDKError2.hasMarker(error40, marker143);\n  }\n};\n_a143 = symbol143;\nvar name152 = \"AI_RetryError\";\nvar marker152 = `vercel.ai.error.${name152}`;\nvar symbol152 = Symbol.for(marker152);\nvar _a152;\nvar RetryError = class extends AISDKError2 {\n  constructor({\n    message,\n    reason,\n    errors\n  }) {\n    super({\n      name: name152,\n      message\n    });\n    this[_a152] = true;\n    this.reason = reason;\n    this.errors = errors;\n    this.lastError = errors[errors.length - 1];\n  }\n  static isInstance(error40) {\n    return AISDKError2.hasMarker(error40, marker152);\n  }\n};\n_a152 = symbol152;\nfunction resolveLanguageModel(model) {\n  if (typeof model !== \"string\") {\n    if (model.specificationVersion !== \"v2\") {\n      throw new UnsupportedModelVersionError({\n        version: model.specificationVersion,\n        provider: model.provider,\n        modelId: model.modelId\n      });\n    }\n    return model;\n  }\n  return getGlobalProvider().languageModel(model);\n}\nfunction getGlobalProvider() {\n  var _a172;\n  return (_a172 = globalThis.AI_SDK_DEFAULT_PROVIDER) != null ? _a172 : gateway;\n}\nvar imageMediaTypeSignatures = [{\n  mediaType: \"image/gif\",\n  bytesPrefix: [71, 73, 70],\n  base64Prefix: \"R0lG\"\n}, {\n  mediaType: \"image/png\",\n  bytesPrefix: [137, 80, 78, 71],\n  base64Prefix: \"iVBORw\"\n}, {\n  mediaType: \"image/jpeg\",\n  bytesPrefix: [255, 216],\n  base64Prefix: \"/9j/\"\n}, {\n  mediaType: \"image/webp\",\n  bytesPrefix: [82, 73, 70, 70],\n  base64Prefix: \"UklGRg\"\n}, {\n  mediaType: \"image/bmp\",\n  bytesPrefix: [66, 77],\n  base64Prefix: \"Qk\"\n}, {\n  mediaType: \"image/tiff\",\n  bytesPrefix: [73, 73, 42, 0],\n  base64Prefix: \"SUkqAA\"\n}, {\n  mediaType: \"image/tiff\",\n  bytesPrefix: [77, 77, 0, 42],\n  base64Prefix: \"TU0AKg\"\n}, {\n  mediaType: \"image/avif\",\n  bytesPrefix: [0, 0, 0, 32, 102, 116, 121, 112, 97, 118, 105, 102],\n  base64Prefix: \"AAAAIGZ0eXBhdmlm\"\n}, {\n  mediaType: \"image/heic\",\n  bytesPrefix: [0, 0, 0, 32, 102, 116, 121, 112, 104, 101, 105, 99],\n  base64Prefix: \"AAAAIGZ0eXBoZWlj\"\n}];\nvar audioMediaTypeSignatures = [{\n  mediaType: \"audio/mpeg\",\n  bytesPrefix: [255, 251],\n  base64Prefix: \"//s=\"\n}, {\n  mediaType: \"audio/mpeg\",\n  bytesPrefix: [255, 250],\n  base64Prefix: \"//o=\"\n}, {\n  mediaType: \"audio/mpeg\",\n  bytesPrefix: [255, 243],\n  base64Prefix: \"//M=\"\n}, {\n  mediaType: \"audio/mpeg\",\n  bytesPrefix: [255, 242],\n  base64Prefix: \"//I=\"\n}, {\n  mediaType: \"audio/mpeg\",\n  bytesPrefix: [255, 227],\n  base64Prefix: \"/+M=\"\n}, {\n  mediaType: \"audio/mpeg\",\n  bytesPrefix: [255, 226],\n  base64Prefix: \"/+I=\"\n}, {\n  mediaType: \"audio/wav\",\n  bytesPrefix: [82, 73, 70, 70],\n  base64Prefix: \"UklGR\"\n}, {\n  mediaType: \"audio/ogg\",\n  bytesPrefix: [79, 103, 103, 83],\n  base64Prefix: \"T2dnUw\"\n}, {\n  mediaType: \"audio/flac\",\n  bytesPrefix: [102, 76, 97, 67],\n  base64Prefix: \"ZkxhQw\"\n}, {\n  mediaType: \"audio/aac\",\n  bytesPrefix: [64, 21, 0, 0],\n  base64Prefix: \"QBUA\"\n}, {\n  mediaType: \"audio/mp4\",\n  bytesPrefix: [102, 116, 121, 112],\n  base64Prefix: \"ZnR5cA\"\n}, {\n  mediaType: \"audio/webm\",\n  bytesPrefix: [26, 69, 223, 163],\n  base64Prefix: \"GkXf\"\n}];\nvar stripID3 = data => {\n  const bytes = typeof data === \"string\" ? convertBase64ToUint8Array(data) : data;\n  const id3Size = (bytes[6] & 127) << 21 | (bytes[7] & 127) << 14 | (bytes[8] & 127) << 7 | bytes[9] & 127;\n  return bytes.slice(id3Size + 10);\n};\nfunction stripID3TagsIfPresent(data) {\n  const hasId3 = typeof data === \"string\" && data.startsWith(\"SUQz\") || typeof data !== \"string\" && data.length > 10 && data[0] === 73 &&\n  // 'I'\n  data[1] === 68 &&\n  // 'D'\n  data[2] === 51;\n  return hasId3 ? stripID3(data) : data;\n}\nfunction detectMediaType({\n  data,\n  signatures\n}) {\n  const processedData = stripID3TagsIfPresent(data);\n  for (const signature of signatures) {\n    if (typeof processedData === \"string\" ? processedData.startsWith(signature.base64Prefix) : processedData.length >= signature.bytesPrefix.length && signature.bytesPrefix.every((byte, index) => processedData[index] === byte)) {\n      return signature.mediaType;\n    }\n  }\n  return void 0;\n}\nvar download = async ({\n  url: url2\n}) => {\n  var _a172;\n  const urlText = url2.toString();\n  try {\n    const response = await fetch(urlText);\n    if (!response.ok) {\n      throw new DownloadError({\n        url: urlText,\n        statusCode: response.status,\n        statusText: response.statusText\n      });\n    }\n    return {\n      data: new Uint8Array(await response.arrayBuffer()),\n      mediaType: (_a172 = response.headers.get(\"content-type\")) != null ? _a172 : void 0\n    };\n  } catch (error40) {\n    if (DownloadError.isInstance(error40)) {\n      throw error40;\n    }\n    throw new DownloadError({\n      url: urlText,\n      cause: error40\n    });\n  }\n};\nvar createDefaultDownloadFunction = (download2 = download) => requestedDownloads => Promise.all(requestedDownloads.map(async requestedDownload => requestedDownload.isUrlSupportedByModel ? null : download2(requestedDownload)));\nfunction splitDataUrl(dataUrl) {\n  try {\n    const [header, base64Content] = dataUrl.split(\",\");\n    return {\n      mediaType: header.split(\";\")[0].split(\":\")[1],\n      base64Content\n    };\n  } catch (error40) {\n    return {\n      mediaType: void 0,\n      base64Content: void 0\n    };\n  }\n}\nvar dataContentSchema = external_exports2.union([external_exports2.string(), external_exports2.instanceof(Uint8Array), external_exports2.instanceof(ArrayBuffer), external_exports2.custom(\n// Buffer might not be available in some environments such as CloudFlare:\nvalue => {\n  var _a172, _b8;\n  return (_b8 = (_a172 = globalThis.Buffer) == null ? void 0 : _a172.isBuffer(value)) != null ? _b8 : false;\n}, {\n  message: \"Must be a Buffer\"\n})]);\nfunction convertToLanguageModelV2DataContent(content) {\n  if (content instanceof Uint8Array) {\n    return {\n      data: content,\n      mediaType: void 0\n    };\n  }\n  if (content instanceof ArrayBuffer) {\n    return {\n      data: new Uint8Array(content),\n      mediaType: void 0\n    };\n  }\n  if (typeof content === \"string\") {\n    try {\n      content = new URL(content);\n    } catch (error40) {}\n  }\n  if (content instanceof URL && content.protocol === \"data:\") {\n    const {\n      mediaType: dataUrlMediaType,\n      base64Content\n    } = splitDataUrl(content.toString());\n    if (dataUrlMediaType == null || base64Content == null) {\n      throw new AISDKError2({\n        name: \"InvalidDataContentError\",\n        message: `Invalid data URL format in content ${content.toString()}`\n      });\n    }\n    return {\n      data: base64Content,\n      mediaType: dataUrlMediaType\n    };\n  }\n  return {\n    data: content,\n    mediaType: void 0\n  };\n}\nfunction convertDataContentToBase64String(content) {\n  if (typeof content === \"string\") {\n    return content;\n  }\n  if (content instanceof ArrayBuffer) {\n    return convertUint8ArrayToBase64(new Uint8Array(content));\n  }\n  return convertUint8ArrayToBase64(content);\n}\nfunction convertDataContentToUint8Array(content) {\n  if (content instanceof Uint8Array) {\n    return content;\n  }\n  if (typeof content === \"string\") {\n    try {\n      return convertBase64ToUint8Array(content);\n    } catch (error40) {\n      throw new InvalidDataContentError({\n        message: \"Invalid data content. Content string is not a base64-encoded media.\",\n        content,\n        cause: error40\n      });\n    }\n  }\n  if (content instanceof ArrayBuffer) {\n    return new Uint8Array(content);\n  }\n  throw new InvalidDataContentError({\n    content\n  });\n}\nasync function convertToLanguageModelPrompt({\n  prompt,\n  supportedUrls,\n  download: download2 = createDefaultDownloadFunction()\n}) {\n  const downloadedAssets = await downloadAssets(prompt.messages, download2, supportedUrls);\n  return [...(prompt.system != null ? [{\n    role: \"system\",\n    content: prompt.system\n  }] : []), ...prompt.messages.map(message => convertToLanguageModelMessage({\n    message,\n    downloadedAssets\n  }))];\n}\nfunction convertToLanguageModelMessage({\n  message,\n  downloadedAssets\n}) {\n  const role = message.role;\n  switch (role) {\n    case \"system\":\n      {\n        return {\n          role: \"system\",\n          content: message.content,\n          providerOptions: message.providerOptions\n        };\n      }\n    case \"user\":\n      {\n        if (typeof message.content === \"string\") {\n          return {\n            role: \"user\",\n            content: [{\n              type: \"text\",\n              text: message.content\n            }],\n            providerOptions: message.providerOptions\n          };\n        }\n        return {\n          role: \"user\",\n          content: message.content.map(part => convertPartToLanguageModelPart(part, downloadedAssets)).filter(part => part.type !== \"text\" || part.text !== \"\"),\n          providerOptions: message.providerOptions\n        };\n      }\n    case \"assistant\":\n      {\n        if (typeof message.content === \"string\") {\n          return {\n            role: \"assistant\",\n            content: [{\n              type: \"text\",\n              text: message.content\n            }],\n            providerOptions: message.providerOptions\n          };\n        }\n        return {\n          role: \"assistant\",\n          content: message.content.filter(\n          // remove empty text parts:\n          part => part.type !== \"text\" || part.text !== \"\").map(part => {\n            const providerOptions = part.providerOptions;\n            switch (part.type) {\n              case \"file\":\n                {\n                  const {\n                    data,\n                    mediaType\n                  } = convertToLanguageModelV2DataContent(part.data);\n                  return {\n                    type: \"file\",\n                    data,\n                    filename: part.filename,\n                    mediaType: mediaType != null ? mediaType : part.mediaType,\n                    providerOptions\n                  };\n                }\n              case \"reasoning\":\n                {\n                  return {\n                    type: \"reasoning\",\n                    text: part.text,\n                    providerOptions\n                  };\n                }\n              case \"text\":\n                {\n                  return {\n                    type: \"text\",\n                    text: part.text,\n                    providerOptions\n                  };\n                }\n              case \"tool-call\":\n                {\n                  return {\n                    type: \"tool-call\",\n                    toolCallId: part.toolCallId,\n                    toolName: part.toolName,\n                    input: part.input,\n                    providerExecuted: part.providerExecuted,\n                    providerOptions\n                  };\n                }\n              case \"tool-result\":\n                {\n                  return {\n                    type: \"tool-result\",\n                    toolCallId: part.toolCallId,\n                    toolName: part.toolName,\n                    output: part.output,\n                    providerOptions\n                  };\n                }\n            }\n          }),\n          providerOptions: message.providerOptions\n        };\n      }\n    case \"tool\":\n      {\n        return {\n          role: \"tool\",\n          content: message.content.map(part => ({\n            type: \"tool-result\",\n            toolCallId: part.toolCallId,\n            toolName: part.toolName,\n            output: part.output,\n            providerOptions: part.providerOptions\n          })),\n          providerOptions: message.providerOptions\n        };\n      }\n    default:\n      {\n        const _exhaustiveCheck = role;\n        throw new InvalidMessageRoleError({\n          role: _exhaustiveCheck\n        });\n      }\n  }\n}\nasync function downloadAssets(messages, download2, supportedUrls) {\n  const plannedDownloads = messages.filter(message => message.role === \"user\").map(message => message.content).filter(content => Array.isArray(content)).flat().filter(part => part.type === \"image\" || part.type === \"file\").map(part => {\n    var _a172;\n    const mediaType = (_a172 = part.mediaType) != null ? _a172 : part.type === \"image\" ? \"image/*\" : void 0;\n    let data = part.type === \"image\" ? part.image : part.data;\n    if (typeof data === \"string\") {\n      try {\n        data = new URL(data);\n      } catch (ignored) {}\n    }\n    return {\n      mediaType,\n      data\n    };\n  }).filter(part => part.data instanceof URL).map(part => ({\n    url: part.data,\n    isUrlSupportedByModel: part.mediaType != null && isUrlSupported({\n      url: part.data.toString(),\n      mediaType: part.mediaType,\n      supportedUrls\n    })\n  }));\n  const downloadedFiles = await download2(plannedDownloads);\n  return Object.fromEntries(downloadedFiles.filter(downloadedFile => (downloadedFile == null ? void 0 : downloadedFile.data) != null).map(({\n    data,\n    mediaType\n  }, index) => [plannedDownloads[index].url.toString(), {\n    data,\n    mediaType\n  }]));\n}\nfunction convertPartToLanguageModelPart(part, downloadedAssets) {\n  var _a172;\n  if (part.type === \"text\") {\n    return {\n      type: \"text\",\n      text: part.text,\n      providerOptions: part.providerOptions\n    };\n  }\n  let originalData;\n  const type = part.type;\n  switch (type) {\n    case \"image\":\n      originalData = part.image;\n      break;\n    case \"file\":\n      originalData = part.data;\n      break;\n    default:\n      throw new Error(`Unsupported part type: ${type}`);\n  }\n  const {\n    data: convertedData,\n    mediaType: convertedMediaType\n  } = convertToLanguageModelV2DataContent(originalData);\n  let mediaType = convertedMediaType != null ? convertedMediaType : part.mediaType;\n  let data = convertedData;\n  if (data instanceof URL) {\n    const downloadedFile = downloadedAssets[data.toString()];\n    if (downloadedFile) {\n      data = downloadedFile.data;\n      mediaType != null ? mediaType : mediaType = downloadedFile.mediaType;\n    }\n  }\n  switch (type) {\n    case \"image\":\n      {\n        if (data instanceof Uint8Array || typeof data === \"string\") {\n          mediaType = (_a172 = detectMediaType({\n            data,\n            signatures: imageMediaTypeSignatures\n          })) != null ? _a172 : mediaType;\n        }\n        return {\n          type: \"file\",\n          mediaType: mediaType != null ? mediaType : \"image/*\",\n          // any image\n          filename: void 0,\n          data,\n          providerOptions: part.providerOptions\n        };\n      }\n    case \"file\":\n      {\n        if (mediaType == null) {\n          throw new Error(`Media type is missing for file part`);\n        }\n        return {\n          type: \"file\",\n          mediaType,\n          filename: part.filename,\n          data,\n          providerOptions: part.providerOptions\n        };\n      }\n  }\n}\nfunction prepareCallSettings({\n  maxOutputTokens,\n  temperature,\n  topP,\n  topK,\n  presencePenalty,\n  frequencyPenalty,\n  seed,\n  stopSequences\n}) {\n  if (maxOutputTokens != null) {\n    if (!Number.isInteger(maxOutputTokens)) {\n      throw new InvalidArgumentError3({\n        parameter: \"maxOutputTokens\",\n        value: maxOutputTokens,\n        message: \"maxOutputTokens must be an integer\"\n      });\n    }\n    if (maxOutputTokens < 1) {\n      throw new InvalidArgumentError3({\n        parameter: \"maxOutputTokens\",\n        value: maxOutputTokens,\n        message: \"maxOutputTokens must be >= 1\"\n      });\n    }\n  }\n  if (temperature != null) {\n    if (typeof temperature !== \"number\") {\n      throw new InvalidArgumentError3({\n        parameter: \"temperature\",\n        value: temperature,\n        message: \"temperature must be a number\"\n      });\n    }\n  }\n  if (topP != null) {\n    if (typeof topP !== \"number\") {\n      throw new InvalidArgumentError3({\n        parameter: \"topP\",\n        value: topP,\n        message: \"topP must be a number\"\n      });\n    }\n  }\n  if (topK != null) {\n    if (typeof topK !== \"number\") {\n      throw new InvalidArgumentError3({\n        parameter: \"topK\",\n        value: topK,\n        message: \"topK must be a number\"\n      });\n    }\n  }\n  if (presencePenalty != null) {\n    if (typeof presencePenalty !== \"number\") {\n      throw new InvalidArgumentError3({\n        parameter: \"presencePenalty\",\n        value: presencePenalty,\n        message: \"presencePenalty must be a number\"\n      });\n    }\n  }\n  if (frequencyPenalty != null) {\n    if (typeof frequencyPenalty !== \"number\") {\n      throw new InvalidArgumentError3({\n        parameter: \"frequencyPenalty\",\n        value: frequencyPenalty,\n        message: \"frequencyPenalty must be a number\"\n      });\n    }\n  }\n  if (seed != null) {\n    if (!Number.isInteger(seed)) {\n      throw new InvalidArgumentError3({\n        parameter: \"seed\",\n        value: seed,\n        message: \"seed must be an integer\"\n      });\n    }\n  }\n  return {\n    maxOutputTokens,\n    temperature,\n    topP,\n    topK,\n    presencePenalty,\n    frequencyPenalty,\n    stopSequences,\n    seed\n  };\n}\nfunction isNonEmptyObject(object22) {\n  return object22 != null && Object.keys(object22).length > 0;\n}\nfunction prepareToolsAndToolChoice({\n  tools,\n  toolChoice,\n  activeTools\n}) {\n  if (!isNonEmptyObject(tools)) {\n    return {\n      tools: void 0,\n      toolChoice: void 0\n    };\n  }\n  const filteredTools = activeTools != null ? Object.entries(tools).filter(([name172]) => activeTools.includes(name172)) : Object.entries(tools);\n  return {\n    tools: filteredTools.map(([name172, tool3]) => {\n      const toolType = tool3.type;\n      switch (toolType) {\n        case void 0:\n        case \"dynamic\":\n        case \"function\":\n          return {\n            type: \"function\",\n            name: name172,\n            description: tool3.description,\n            inputSchema: asSchema(tool3.inputSchema).jsonSchema,\n            providerOptions: tool3.providerOptions\n          };\n        case \"provider-defined\":\n          return {\n            type: \"provider-defined\",\n            name: name172,\n            id: tool3.id,\n            args: tool3.args\n          };\n        default:\n          {\n            const exhaustiveCheck = toolType;\n            throw new Error(`Unsupported tool type: ${exhaustiveCheck}`);\n          }\n      }\n    }),\n    toolChoice: toolChoice == null ? {\n      type: \"auto\"\n    } : typeof toolChoice === \"string\" ? {\n      type: toolChoice\n    } : {\n      type: \"tool\",\n      toolName: toolChoice.toolName\n    }\n  };\n}\nvar jsonValueSchema = external_exports2.lazy(() => external_exports2.union([external_exports2.null(), external_exports2.string(), external_exports2.number(), external_exports2.boolean(), external_exports2.record(external_exports2.string(), jsonValueSchema), external_exports2.array(jsonValueSchema)]));\nvar providerMetadataSchema = external_exports2.record(external_exports2.string(), external_exports2.record(external_exports2.string(), jsonValueSchema));\nvar textPartSchema = external_exports2.object({\n  type: external_exports2.literal(\"text\"),\n  text: external_exports2.string(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar imagePartSchema = external_exports2.object({\n  type: external_exports2.literal(\"image\"),\n  image: external_exports2.union([dataContentSchema, external_exports2.instanceof(URL)]),\n  mediaType: external_exports2.string().optional(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar filePartSchema = external_exports2.object({\n  type: external_exports2.literal(\"file\"),\n  data: external_exports2.union([dataContentSchema, external_exports2.instanceof(URL)]),\n  filename: external_exports2.string().optional(),\n  mediaType: external_exports2.string(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar reasoningPartSchema = external_exports2.object({\n  type: external_exports2.literal(\"reasoning\"),\n  text: external_exports2.string(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar toolCallPartSchema = external_exports2.object({\n  type: external_exports2.literal(\"tool-call\"),\n  toolCallId: external_exports2.string(),\n  toolName: external_exports2.string(),\n  input: external_exports2.unknown(),\n  providerOptions: providerMetadataSchema.optional(),\n  providerExecuted: external_exports2.boolean().optional()\n});\nvar outputSchema = external_exports2.discriminatedUnion(\"type\", [external_exports2.object({\n  type: external_exports2.literal(\"text\"),\n  value: external_exports2.string()\n}), external_exports2.object({\n  type: external_exports2.literal(\"json\"),\n  value: jsonValueSchema\n}), external_exports2.object({\n  type: external_exports2.literal(\"error-text\"),\n  value: external_exports2.string()\n}), external_exports2.object({\n  type: external_exports2.literal(\"error-json\"),\n  value: jsonValueSchema\n}), external_exports2.object({\n  type: external_exports2.literal(\"content\"),\n  value: external_exports2.array(external_exports2.union([external_exports2.object({\n    type: external_exports2.literal(\"text\"),\n    text: external_exports2.string()\n  }), external_exports2.object({\n    type: external_exports2.literal(\"media\"),\n    data: external_exports2.string(),\n    mediaType: external_exports2.string()\n  })]))\n})]);\nvar toolResultPartSchema = external_exports2.object({\n  type: external_exports2.literal(\"tool-result\"),\n  toolCallId: external_exports2.string(),\n  toolName: external_exports2.string(),\n  output: outputSchema,\n  providerOptions: providerMetadataSchema.optional()\n});\nvar systemModelMessageSchema = external_exports2.object({\n  role: external_exports2.literal(\"system\"),\n  content: external_exports2.string(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar userModelMessageSchema = external_exports2.object({\n  role: external_exports2.literal(\"user\"),\n  content: external_exports2.union([external_exports2.string(), external_exports2.array(external_exports2.union([textPartSchema, imagePartSchema, filePartSchema]))]),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar assistantModelMessageSchema = external_exports2.object({\n  role: external_exports2.literal(\"assistant\"),\n  content: external_exports2.union([external_exports2.string(), external_exports2.array(external_exports2.union([textPartSchema, filePartSchema, reasoningPartSchema, toolCallPartSchema, toolResultPartSchema]))]),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar toolModelMessageSchema = external_exports2.object({\n  role: external_exports2.literal(\"tool\"),\n  content: external_exports2.array(toolResultPartSchema),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar modelMessageSchema = external_exports2.union([systemModelMessageSchema, userModelMessageSchema, assistantModelMessageSchema, toolModelMessageSchema]);\nasync function standardizePrompt(prompt) {\n  if (prompt.prompt == null && prompt.messages == null) {\n    throw new InvalidPromptError({\n      prompt,\n      message: \"prompt or messages must be defined\"\n    });\n  }\n  if (prompt.prompt != null && prompt.messages != null) {\n    throw new InvalidPromptError({\n      prompt,\n      message: \"prompt and messages cannot be defined at the same time\"\n    });\n  }\n  if (prompt.system != null && typeof prompt.system !== \"string\") {\n    throw new InvalidPromptError({\n      prompt,\n      message: \"system must be a string\"\n    });\n  }\n  let messages;\n  if (prompt.prompt != null && typeof prompt.prompt === \"string\") {\n    messages = [{\n      role: \"user\",\n      content: prompt.prompt\n    }];\n  } else if (prompt.prompt != null && Array.isArray(prompt.prompt)) {\n    messages = prompt.prompt;\n  } else if (prompt.messages != null) {\n    messages = prompt.messages;\n  } else {\n    throw new InvalidPromptError({\n      prompt,\n      message: \"prompt or messages must be defined\"\n    });\n  }\n  if (messages.length === 0) {\n    throw new InvalidPromptError({\n      prompt,\n      message: \"messages must not be empty\"\n    });\n  }\n  const validationResult = await safeValidateTypes2({\n    value: messages,\n    schema: external_exports2.array(modelMessageSchema)\n  });\n  if (!validationResult.success) {\n    throw new InvalidPromptError({\n      prompt,\n      message: \"The messages must be a ModelMessage[]. If you have passed a UIMessage[], you can use convertToModelMessages to convert them.\",\n      cause: validationResult.error\n    });\n  }\n  return {\n    messages,\n    system: prompt.system\n  };\n}\nfunction wrapGatewayError(error40) {\n  if (GatewayAuthenticationError.isInstance(error40) || GatewayModelNotFoundError.isInstance(error40)) {\n    return new AISDKError2({\n      name: \"GatewayError\",\n      message: \"Vercel AI Gateway access failed. If you want to use AI SDK providers directly, use the providers, e.g. @ai-sdk/openai, or register a different global default provider.\",\n      cause: error40\n    });\n  }\n  return error40;\n}\nfunction assembleOperationName({\n  operationId,\n  telemetry\n}) {\n  return {\n    // standardized operation and resource name:\n    \"operation.name\": `${operationId}${(telemetry == null ? void 0 : telemetry.functionId) != null ? ` ${telemetry.functionId}` : \"\"}`,\n    \"resource.name\": telemetry == null ? void 0 : telemetry.functionId,\n    // detailed, AI SDK specific data:\n    \"ai.operationId\": operationId,\n    \"ai.telemetry.functionId\": telemetry == null ? void 0 : telemetry.functionId\n  };\n}\nfunction getBaseTelemetryAttributes({\n  model,\n  settings,\n  telemetry,\n  headers\n}) {\n  var _a172;\n  return {\n    \"ai.model.provider\": model.provider,\n    \"ai.model.id\": model.modelId,\n    // settings:\n    ...Object.entries(settings).reduce((attributes, [key, value]) => {\n      attributes[`ai.settings.${key}`] = value;\n      return attributes;\n    }, {}),\n    // add metadata as attributes:\n    ...Object.entries((_a172 = telemetry == null ? void 0 : telemetry.metadata) != null ? _a172 : {}).reduce((attributes, [key, value]) => {\n      attributes[`ai.telemetry.metadata.${key}`] = value;\n      return attributes;\n    }, {}),\n    // request headers\n    ...Object.entries(headers != null ? headers : {}).reduce((attributes, [key, value]) => {\n      if (value !== void 0) {\n        attributes[`ai.request.headers.${key}`] = value;\n      }\n      return attributes;\n    }, {})\n  };\n}\nvar noopTracer = {\n  startSpan() {\n    return noopSpan;\n  },\n  startActiveSpan(name172, arg1, arg2, arg3) {\n    if (typeof arg1 === \"function\") {\n      return arg1(noopSpan);\n    }\n    if (typeof arg2 === \"function\") {\n      return arg2(noopSpan);\n    }\n    if (typeof arg3 === \"function\") {\n      return arg3(noopSpan);\n    }\n  }\n};\nvar noopSpan = {\n  spanContext() {\n    return noopSpanContext;\n  },\n  setAttribute() {\n    return this;\n  },\n  setAttributes() {\n    return this;\n  },\n  addEvent() {\n    return this;\n  },\n  addLink() {\n    return this;\n  },\n  addLinks() {\n    return this;\n  },\n  setStatus() {\n    return this;\n  },\n  updateName() {\n    return this;\n  },\n  end() {\n    return this;\n  },\n  isRecording() {\n    return false;\n  },\n  recordException() {\n    return this;\n  }\n};\nvar noopSpanContext = {\n  traceId: \"\",\n  spanId: \"\",\n  traceFlags: 0\n};\nfunction getTracer({\n  isEnabled = false,\n  tracer\n} = {}) {\n  if (!isEnabled) {\n    return noopTracer;\n  }\n  if (tracer) {\n    return tracer;\n  }\n  return trace.getTracer(\"ai\");\n}\nfunction recordSpan({\n  name: name172,\n  tracer,\n  attributes,\n  fn,\n  endWhenDone = true\n}) {\n  return tracer.startActiveSpan(name172, {\n    attributes\n  }, async span => {\n    try {\n      const result = await fn(span);\n      if (endWhenDone) {\n        span.end();\n      }\n      return result;\n    } catch (error40) {\n      try {\n        recordErrorOnSpan(span, error40);\n      } finally {\n        span.end();\n      }\n      throw error40;\n    }\n  });\n}\nfunction recordErrorOnSpan(span, error40) {\n  if (error40 instanceof Error) {\n    span.recordException({\n      name: error40.name,\n      message: error40.message,\n      stack: error40.stack\n    });\n    span.setStatus({\n      code: SpanStatusCode.ERROR,\n      message: error40.message\n    });\n  } else {\n    span.setStatus({\n      code: SpanStatusCode.ERROR\n    });\n  }\n}\nfunction selectTelemetryAttributes({\n  telemetry,\n  attributes\n}) {\n  if ((telemetry == null ? void 0 : telemetry.isEnabled) !== true) {\n    return {};\n  }\n  return Object.entries(attributes).reduce((attributes2, [key, value]) => {\n    if (value == null) {\n      return attributes2;\n    }\n    if (typeof value === \"object\" && \"input\" in value && typeof value.input === \"function\") {\n      if ((telemetry == null ? void 0 : telemetry.recordInputs) === false) {\n        return attributes2;\n      }\n      const result = value.input();\n      return result == null ? attributes2 : {\n        ...attributes2,\n        [key]: result\n      };\n    }\n    if (typeof value === \"object\" && \"output\" in value && typeof value.output === \"function\") {\n      if ((telemetry == null ? void 0 : telemetry.recordOutputs) === false) {\n        return attributes2;\n      }\n      const result = value.output();\n      return result == null ? attributes2 : {\n        ...attributes2,\n        [key]: result\n      };\n    }\n    return {\n      ...attributes2,\n      [key]: value\n    };\n  }, {});\n}\nfunction stringifyForTelemetry(prompt) {\n  return JSON.stringify(prompt.map(message => ({\n    ...message,\n    content: typeof message.content === \"string\" ? message.content : message.content.map(part => part.type === \"file\" ? {\n      ...part,\n      data: part.data instanceof Uint8Array ? convertDataContentToBase64String(part.data) : part.data\n    } : part)\n  })));\n}\nfunction addLanguageModelUsage(usage1, usage2) {\n  return {\n    inputTokens: addTokenCounts(usage1.inputTokens, usage2.inputTokens),\n    outputTokens: addTokenCounts(usage1.outputTokens, usage2.outputTokens),\n    totalTokens: addTokenCounts(usage1.totalTokens, usage2.totalTokens),\n    reasoningTokens: addTokenCounts(usage1.reasoningTokens, usage2.reasoningTokens),\n    cachedInputTokens: addTokenCounts(usage1.cachedInputTokens, usage2.cachedInputTokens)\n  };\n}\nfunction addTokenCounts(tokenCount1, tokenCount2) {\n  return tokenCount1 == null && tokenCount2 == null ? void 0 : (tokenCount1 != null ? tokenCount1 : 0) + (tokenCount2 != null ? tokenCount2 : 0);\n}\nfunction asArray(value) {\n  return value === void 0 ? [] : Array.isArray(value) ? value : [value];\n}\nfunction getRetryDelayInMs({\n  error: error40,\n  exponentialBackoffDelay\n}) {\n  const headers = error40.responseHeaders;\n  if (!headers) return exponentialBackoffDelay;\n  let ms;\n  const retryAfterMs = headers[\"retry-after-ms\"];\n  if (retryAfterMs) {\n    const timeoutMs = parseFloat(retryAfterMs);\n    if (!Number.isNaN(timeoutMs)) {\n      ms = timeoutMs;\n    }\n  }\n  const retryAfter = headers[\"retry-after\"];\n  if (retryAfter && ms === void 0) {\n    const timeoutSeconds = parseFloat(retryAfter);\n    if (!Number.isNaN(timeoutSeconds)) {\n      ms = timeoutSeconds * 1e3;\n    } else {\n      ms = Date.parse(retryAfter) - Date.now();\n    }\n  }\n  if (ms != null && !Number.isNaN(ms) && 0 <= ms && (ms < 60 * 1e3 || ms < exponentialBackoffDelay)) {\n    return ms;\n  }\n  return exponentialBackoffDelay;\n}\nvar retryWithExponentialBackoffRespectingRetryHeaders = ({\n  maxRetries = 2,\n  initialDelayInMs = 2e3,\n  backoffFactor = 2,\n  abortSignal\n} = {}) => async f => _retryWithExponentialBackoff(f, {\n  maxRetries,\n  delayInMs: initialDelayInMs,\n  backoffFactor,\n  abortSignal\n});\nasync function _retryWithExponentialBackoff(f, {\n  maxRetries,\n  delayInMs,\n  backoffFactor,\n  abortSignal\n}, errors = []) {\n  try {\n    return await f();\n  } catch (error40) {\n    if (isAbortError2(error40)) {\n      throw error40;\n    }\n    if (maxRetries === 0) {\n      throw error40;\n    }\n    const errorMessage = getErrorMessage3(error40);\n    const newErrors = [...errors, error40];\n    const tryNumber = newErrors.length;\n    if (tryNumber > maxRetries) {\n      throw new RetryError({\n        message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n        reason: \"maxRetriesExceeded\",\n        errors: newErrors\n      });\n    }\n    if (error40 instanceof Error && APICallError2.isInstance(error40) && error40.isRetryable === true && tryNumber <= maxRetries) {\n      await delay(getRetryDelayInMs({\n        error: error40,\n        exponentialBackoffDelay: delayInMs\n      }), {\n        abortSignal\n      });\n      return _retryWithExponentialBackoff(f, {\n        maxRetries,\n        delayInMs: backoffFactor * delayInMs,\n        backoffFactor,\n        abortSignal\n      }, newErrors);\n    }\n    if (tryNumber === 1) {\n      throw error40;\n    }\n    throw new RetryError({\n      message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n      reason: \"errorNotRetryable\",\n      errors: newErrors\n    });\n  }\n}\nfunction prepareRetries({\n  maxRetries,\n  abortSignal\n}) {\n  if (maxRetries != null) {\n    if (!Number.isInteger(maxRetries)) {\n      throw new InvalidArgumentError3({\n        parameter: \"maxRetries\",\n        value: maxRetries,\n        message: \"maxRetries must be an integer\"\n      });\n    }\n    if (maxRetries < 0) {\n      throw new InvalidArgumentError3({\n        parameter: \"maxRetries\",\n        value: maxRetries,\n        message: \"maxRetries must be >= 0\"\n      });\n    }\n  }\n  const maxRetriesResult = maxRetries != null ? maxRetries : 2;\n  return {\n    maxRetries: maxRetriesResult,\n    retry: retryWithExponentialBackoffRespectingRetryHeaders({\n      maxRetries: maxRetriesResult,\n      abortSignal\n    })\n  };\n}\nfunction extractTextContent(content) {\n  const parts = content.filter(content2 => content2.type === \"text\");\n  if (parts.length === 0) {\n    return void 0;\n  }\n  return parts.map(content2 => content2.text).join(\"\");\n}\nvar DefaultGeneratedFile = class {\n  constructor({\n    data,\n    mediaType\n  }) {\n    const isUint8Array = data instanceof Uint8Array;\n    this.base64Data = isUint8Array ? void 0 : data;\n    this.uint8ArrayData = isUint8Array ? data : void 0;\n    this.mediaType = mediaType;\n  }\n  // lazy conversion with caching to avoid unnecessary conversion overhead:\n  get base64() {\n    if (this.base64Data == null) {\n      this.base64Data = convertUint8ArrayToBase64(this.uint8ArrayData);\n    }\n    return this.base64Data;\n  }\n  // lazy conversion with caching to avoid unnecessary conversion overhead:\n  get uint8Array() {\n    if (this.uint8ArrayData == null) {\n      this.uint8ArrayData = convertBase64ToUint8Array(this.base64Data);\n    }\n    return this.uint8ArrayData;\n  }\n};\nvar DefaultGeneratedFileWithType = class extends DefaultGeneratedFile {\n  constructor(options) {\n    super(options);\n    this.type = \"file\";\n  }\n};\nasync function parseToolCall({\n  toolCall,\n  tools,\n  repairToolCall,\n  system,\n  messages\n}) {\n  try {\n    if (tools == null) {\n      throw new NoSuchToolError({\n        toolName: toolCall.toolName\n      });\n    }\n    try {\n      return await doParseToolCall({\n        toolCall,\n        tools\n      });\n    } catch (error40) {\n      if (repairToolCall == null || !(NoSuchToolError.isInstance(error40) || InvalidToolInputError.isInstance(error40))) {\n        throw error40;\n      }\n      let repairedToolCall = null;\n      try {\n        repairedToolCall = await repairToolCall({\n          toolCall,\n          tools,\n          inputSchema: ({\n            toolName\n          }) => {\n            const {\n              inputSchema\n            } = tools[toolName];\n            return asSchema(inputSchema).jsonSchema;\n          },\n          system,\n          messages,\n          error: error40\n        });\n      } catch (repairError) {\n        throw new ToolCallRepairError({\n          cause: repairError,\n          originalError: error40\n        });\n      }\n      if (repairedToolCall == null) {\n        throw error40;\n      }\n      return await doParseToolCall({\n        toolCall: repairedToolCall,\n        tools\n      });\n    }\n  } catch (error40) {\n    const parsedInput = await safeParseJSON2({\n      text: toolCall.input\n    });\n    const input = parsedInput.success ? parsedInput.value : toolCall.input;\n    return {\n      type: \"tool-call\",\n      toolCallId: toolCall.toolCallId,\n      toolName: toolCall.toolName,\n      input,\n      dynamic: true,\n      invalid: true,\n      error: error40\n    };\n  }\n}\nasync function doParseToolCall({\n  toolCall,\n  tools\n}) {\n  const toolName = toolCall.toolName;\n  const tool3 = tools[toolName];\n  if (tool3 == null) {\n    throw new NoSuchToolError({\n      toolName: toolCall.toolName,\n      availableTools: Object.keys(tools)\n    });\n  }\n  const schema = asSchema(tool3.inputSchema);\n  const parseResult = toolCall.input.trim() === \"\" ? await safeValidateTypes2({\n    value: {},\n    schema\n  }) : await safeParseJSON2({\n    text: toolCall.input,\n    schema\n  });\n  if (parseResult.success === false) {\n    throw new InvalidToolInputError({\n      toolName,\n      toolInput: toolCall.input,\n      cause: parseResult.error\n    });\n  }\n  return tool3.type === \"dynamic\" ? {\n    type: \"tool-call\",\n    toolCallId: toolCall.toolCallId,\n    toolName: toolCall.toolName,\n    input: parseResult.value,\n    providerExecuted: toolCall.providerExecuted,\n    providerMetadata: toolCall.providerMetadata,\n    dynamic: true\n  } : {\n    type: \"tool-call\",\n    toolCallId: toolCall.toolCallId,\n    toolName,\n    input: parseResult.value,\n    providerExecuted: toolCall.providerExecuted,\n    providerMetadata: toolCall.providerMetadata\n  };\n}\nvar DefaultStepResult = class {\n  constructor({\n    content,\n    finishReason,\n    usage,\n    warnings,\n    request,\n    response,\n    providerMetadata\n  }) {\n    this.content = content;\n    this.finishReason = finishReason;\n    this.usage = usage;\n    this.warnings = warnings;\n    this.request = request;\n    this.response = response;\n    this.providerMetadata = providerMetadata;\n  }\n  get text() {\n    return this.content.filter(part => part.type === \"text\").map(part => part.text).join(\"\");\n  }\n  get reasoning() {\n    return this.content.filter(part => part.type === \"reasoning\");\n  }\n  get reasoningText() {\n    return this.reasoning.length === 0 ? void 0 : this.reasoning.map(part => part.text).join(\"\");\n  }\n  get files() {\n    return this.content.filter(part => part.type === \"file\").map(part => part.file);\n  }\n  get sources() {\n    return this.content.filter(part => part.type === \"source\");\n  }\n  get toolCalls() {\n    return this.content.filter(part => part.type === \"tool-call\");\n  }\n  get staticToolCalls() {\n    return this.toolCalls.filter(toolCall => toolCall.dynamic === false);\n  }\n  get dynamicToolCalls() {\n    return this.toolCalls.filter(toolCall => toolCall.dynamic === true);\n  }\n  get toolResults() {\n    return this.content.filter(part => part.type === \"tool-result\");\n  }\n  get staticToolResults() {\n    return this.toolResults.filter(toolResult => toolResult.dynamic === false);\n  }\n  get dynamicToolResults() {\n    return this.toolResults.filter(toolResult => toolResult.dynamic === true);\n  }\n};\nfunction stepCountIs(stepCount) {\n  return ({\n    steps\n  }) => steps.length === stepCount;\n}\nasync function isStopConditionMet({\n  stopConditions,\n  steps\n}) {\n  return (await Promise.all(stopConditions.map(condition => condition({\n    steps\n  })))).some(result => result);\n}\nfunction createToolModelOutput({\n  output,\n  tool: tool3,\n  errorMode\n}) {\n  if (errorMode === \"text\") {\n    return {\n      type: \"error-text\",\n      value: getErrorMessage2(output)\n    };\n  } else if (errorMode === \"json\") {\n    return {\n      type: \"error-json\",\n      value: toJSONValue(output)\n    };\n  }\n  if (tool3 == null ? void 0 : tool3.toModelOutput) {\n    return tool3.toModelOutput(output);\n  }\n  return typeof output === \"string\" ? {\n    type: \"text\",\n    value: output\n  } : {\n    type: \"json\",\n    value: toJSONValue(output)\n  };\n}\nfunction toJSONValue(value) {\n  return value === void 0 ? null : value;\n}\nfunction toResponseMessages({\n  content: inputContent,\n  tools\n}) {\n  const responseMessages = [];\n  const content = inputContent.filter(part => part.type !== \"source\").filter(part => (part.type !== \"tool-result\" || part.providerExecuted) && (part.type !== \"tool-error\" || part.providerExecuted)).filter(part => part.type !== \"text\" || part.text.length > 0).map(part => {\n    switch (part.type) {\n      case \"text\":\n        return {\n          type: \"text\",\n          text: part.text,\n          providerOptions: part.providerMetadata\n        };\n      case \"reasoning\":\n        return {\n          type: \"reasoning\",\n          text: part.text,\n          providerOptions: part.providerMetadata\n        };\n      case \"file\":\n        return {\n          type: \"file\",\n          data: part.file.base64,\n          mediaType: part.file.mediaType,\n          providerOptions: part.providerMetadata\n        };\n      case \"tool-call\":\n        return {\n          type: \"tool-call\",\n          toolCallId: part.toolCallId,\n          toolName: part.toolName,\n          input: part.input,\n          providerExecuted: part.providerExecuted,\n          providerOptions: part.providerMetadata\n        };\n      case \"tool-result\":\n        return {\n          type: \"tool-result\",\n          toolCallId: part.toolCallId,\n          toolName: part.toolName,\n          output: createToolModelOutput({\n            tool: tools == null ? void 0 : tools[part.toolName],\n            output: part.output,\n            errorMode: \"none\"\n          }),\n          providerExecuted: true,\n          providerOptions: part.providerMetadata\n        };\n      case \"tool-error\":\n        return {\n          type: \"tool-result\",\n          toolCallId: part.toolCallId,\n          toolName: part.toolName,\n          output: createToolModelOutput({\n            tool: tools == null ? void 0 : tools[part.toolName],\n            output: part.error,\n            errorMode: \"json\"\n          }),\n          providerOptions: part.providerMetadata\n        };\n    }\n  });\n  if (content.length > 0) {\n    responseMessages.push({\n      role: \"assistant\",\n      content\n    });\n  }\n  const toolResultContent = inputContent.filter(part => part.type === \"tool-result\" || part.type === \"tool-error\").filter(part => !part.providerExecuted).map(toolResult => ({\n    type: \"tool-result\",\n    toolCallId: toolResult.toolCallId,\n    toolName: toolResult.toolName,\n    output: createToolModelOutput({\n      tool: tools == null ? void 0 : tools[toolResult.toolName],\n      output: toolResult.type === \"tool-result\" ? toolResult.output : toolResult.error,\n      errorMode: toolResult.type === \"tool-error\" ? \"text\" : \"none\"\n    })\n  }));\n  if (toolResultContent.length > 0) {\n    responseMessages.push({\n      role: \"tool\",\n      content: toolResultContent\n    });\n  }\n  return responseMessages;\n}\nvar VERSION3 = true ? \"5.0.43\" : \"0.0.0-test\";\nvar originalGenerateId = createIdGenerator2({\n  prefix: \"aitxt\",\n  size: 24\n});\nasync function generateText({\n  model: modelArg,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  stopWhen = stepCountIs(1),\n  experimental_output: output,\n  experimental_telemetry: telemetry,\n  providerOptions,\n  experimental_activeTools,\n  activeTools = experimental_activeTools,\n  experimental_prepareStep,\n  prepareStep = experimental_prepareStep,\n  experimental_repairToolCall: repairToolCall,\n  experimental_download: download2,\n  experimental_context,\n  _internal: {\n    generateId: generateId32 = originalGenerateId,\n    currentDate = () => /* @__PURE__ */new Date()\n  } = {},\n  onStepFinish,\n  ...settings\n}) {\n  const model = resolveLanguageModel(modelArg);\n  const stopConditions = asArray(stopWhen);\n  const {\n    maxRetries,\n    retry\n  } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const callSettings = prepareCallSettings(settings);\n  const headersWithUserAgent = withUserAgentSuffix2(headers != null ? headers : {}, `ai/${VERSION3}`);\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers: headersWithUserAgent,\n    settings: {\n      ...callSettings,\n      maxRetries\n    }\n  });\n  const initialPrompt = await standardizePrompt({\n    system,\n    prompt,\n    messages\n  });\n  const tracer = getTracer(telemetry);\n  try {\n    return await recordSpan({\n      name: \"ai.generateText\",\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({\n            operationId: \"ai.generateText\",\n            telemetry\n          }),\n          ...baseTelemetryAttributes,\n          // model:\n          \"ai.model.provider\": model.provider,\n          \"ai.model.id\": model.modelId,\n          // specific settings that only make sense on the outer level:\n          \"ai.prompt\": {\n            input: () => JSON.stringify({\n              system,\n              prompt,\n              messages\n            })\n          }\n        }\n      }),\n      tracer,\n      fn: async span => {\n        var _a172, _b8, _c, _d, _e, _f, _g;\n        const callSettings2 = prepareCallSettings(settings);\n        let currentModelResponse;\n        let clientToolCalls = [];\n        let clientToolOutputs = [];\n        const responseMessages = [];\n        const steps = [];\n        do {\n          const stepInputMessages = [...initialPrompt.messages, ...responseMessages];\n          const prepareStepResult = await (prepareStep == null ? void 0 : prepareStep({\n            model,\n            steps,\n            stepNumber: steps.length,\n            messages: stepInputMessages\n          }));\n          const promptMessages = await convertToLanguageModelPrompt({\n            prompt: {\n              system: (_a172 = prepareStepResult == null ? void 0 : prepareStepResult.system) != null ? _a172 : initialPrompt.system,\n              messages: (_b8 = prepareStepResult == null ? void 0 : prepareStepResult.messages) != null ? _b8 : stepInputMessages\n            },\n            supportedUrls: await model.supportedUrls,\n            download: download2\n          });\n          const stepModel = resolveLanguageModel((_c = prepareStepResult == null ? void 0 : prepareStepResult.model) != null ? _c : model);\n          const {\n            toolChoice: stepToolChoice,\n            tools: stepTools\n          } = prepareToolsAndToolChoice({\n            tools,\n            toolChoice: (_d = prepareStepResult == null ? void 0 : prepareStepResult.toolChoice) != null ? _d : toolChoice,\n            activeTools: (_e = prepareStepResult == null ? void 0 : prepareStepResult.activeTools) != null ? _e : activeTools\n          });\n          currentModelResponse = await retry(() => {\n            var _a182;\n            return recordSpan({\n              name: \"ai.generateText.doGenerate\",\n              attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  ...assembleOperationName({\n                    operationId: \"ai.generateText.doGenerate\",\n                    telemetry\n                  }),\n                  ...baseTelemetryAttributes,\n                  // model:\n                  \"ai.model.provider\": stepModel.provider,\n                  \"ai.model.id\": stepModel.modelId,\n                  // prompt:\n                  \"ai.prompt.messages\": {\n                    input: () => stringifyForTelemetry(promptMessages)\n                  },\n                  \"ai.prompt.tools\": {\n                    // convert the language model level tools:\n                    input: () => stepTools == null ? void 0 : stepTools.map(tool3 => JSON.stringify(tool3))\n                  },\n                  \"ai.prompt.toolChoice\": {\n                    input: () => stepToolChoice != null ? JSON.stringify(stepToolChoice) : void 0\n                  },\n                  // standardized gen-ai llm span attributes:\n                  \"gen_ai.system\": stepModel.provider,\n                  \"gen_ai.request.model\": stepModel.modelId,\n                  \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                  \"gen_ai.request.max_tokens\": settings.maxOutputTokens,\n                  \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                  \"gen_ai.request.stop_sequences\": settings.stopSequences,\n                  \"gen_ai.request.temperature\": (_a182 = settings.temperature) != null ? _a182 : void 0,\n                  \"gen_ai.request.top_k\": settings.topK,\n                  \"gen_ai.request.top_p\": settings.topP\n                }\n              }),\n              tracer,\n              fn: async span2 => {\n                var _a192, _b22, _c2, _d2, _e2, _f2, _g2, _h;\n                const result = await stepModel.doGenerate({\n                  ...callSettings2,\n                  tools: stepTools,\n                  toolChoice: stepToolChoice,\n                  responseFormat: output == null ? void 0 : output.responseFormat,\n                  prompt: promptMessages,\n                  providerOptions,\n                  abortSignal,\n                  headers: headersWithUserAgent\n                });\n                const responseData = {\n                  id: (_b22 = (_a192 = result.response) == null ? void 0 : _a192.id) != null ? _b22 : generateId32(),\n                  timestamp: (_d2 = (_c2 = result.response) == null ? void 0 : _c2.timestamp) != null ? _d2 : currentDate(),\n                  modelId: (_f2 = (_e2 = result.response) == null ? void 0 : _e2.modelId) != null ? _f2 : stepModel.modelId,\n                  headers: (_g2 = result.response) == null ? void 0 : _g2.headers,\n                  body: (_h = result.response) == null ? void 0 : _h.body\n                };\n                span2.setAttributes(selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.response.finishReason\": result.finishReason,\n                    \"ai.response.text\": {\n                      output: () => extractTextContent(result.content)\n                    },\n                    \"ai.response.toolCalls\": {\n                      output: () => {\n                        const toolCalls = asToolCalls(result.content);\n                        return toolCalls == null ? void 0 : JSON.stringify(toolCalls);\n                      }\n                    },\n                    \"ai.response.id\": responseData.id,\n                    \"ai.response.model\": responseData.modelId,\n                    \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                    \"ai.response.providerMetadata\": JSON.stringify(result.providerMetadata),\n                    // TODO rename telemetry attributes to inputTokens and outputTokens\n                    \"ai.usage.promptTokens\": result.usage.inputTokens,\n                    \"ai.usage.completionTokens\": result.usage.outputTokens,\n                    // standardized gen-ai llm span attributes:\n                    \"gen_ai.response.finish_reasons\": [result.finishReason],\n                    \"gen_ai.response.id\": responseData.id,\n                    \"gen_ai.response.model\": responseData.modelId,\n                    \"gen_ai.usage.input_tokens\": result.usage.inputTokens,\n                    \"gen_ai.usage.output_tokens\": result.usage.outputTokens\n                  }\n                }));\n                return {\n                  ...result,\n                  response: responseData\n                };\n              }\n            });\n          });\n          const stepToolCalls = await Promise.all(currentModelResponse.content.filter(part => part.type === \"tool-call\").map(toolCall => parseToolCall({\n            toolCall,\n            tools,\n            repairToolCall,\n            system,\n            messages: stepInputMessages\n          })));\n          for (const toolCall of stepToolCalls) {\n            if (toolCall.invalid) {\n              continue;\n            }\n            const tool3 = tools[toolCall.toolName];\n            if ((tool3 == null ? void 0 : tool3.onInputAvailable) != null) {\n              await tool3.onInputAvailable({\n                input: toolCall.input,\n                toolCallId: toolCall.toolCallId,\n                messages: stepInputMessages,\n                abortSignal,\n                experimental_context\n              });\n            }\n          }\n          const invalidToolCalls = stepToolCalls.filter(toolCall => toolCall.invalid && toolCall.dynamic);\n          clientToolOutputs = [];\n          for (const toolCall of invalidToolCalls) {\n            clientToolOutputs.push({\n              type: \"tool-error\",\n              toolCallId: toolCall.toolCallId,\n              toolName: toolCall.toolName,\n              input: toolCall.input,\n              error: getErrorMessage3(toolCall.error),\n              dynamic: true\n            });\n          }\n          clientToolCalls = stepToolCalls.filter(toolCall => !toolCall.providerExecuted);\n          if (tools != null) {\n            clientToolOutputs.push(...(await executeTools({\n              toolCalls: clientToolCalls.filter(toolCall => !toolCall.invalid),\n              tools,\n              tracer,\n              telemetry,\n              messages: stepInputMessages,\n              abortSignal,\n              experimental_context\n            })));\n          }\n          const stepContent = asContent({\n            content: currentModelResponse.content,\n            toolCalls: stepToolCalls,\n            toolOutputs: clientToolOutputs\n          });\n          responseMessages.push(...toResponseMessages({\n            content: stepContent,\n            tools\n          }));\n          const currentStepResult = new DefaultStepResult({\n            content: stepContent,\n            finishReason: currentModelResponse.finishReason,\n            usage: currentModelResponse.usage,\n            warnings: currentModelResponse.warnings,\n            providerMetadata: currentModelResponse.providerMetadata,\n            request: (_f = currentModelResponse.request) != null ? _f : {},\n            response: {\n              ...currentModelResponse.response,\n              // deep clone msgs to avoid mutating past messages in multi-step:\n              messages: structuredClone(responseMessages)\n            }\n          });\n          logWarnings((_g = currentModelResponse.warnings) != null ? _g : []);\n          steps.push(currentStepResult);\n          await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));\n        } while (\n        // there are tool calls:\n        clientToolCalls.length > 0 &&\n        // all current tool calls have outputs (incl. execution errors):\n        clientToolOutputs.length === clientToolCalls.length &&\n        // continue until a stop condition is met:\n        !(await isStopConditionMet({\n          stopConditions,\n          steps\n        })));\n        span.setAttributes(selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            \"ai.response.finishReason\": currentModelResponse.finishReason,\n            \"ai.response.text\": {\n              output: () => extractTextContent(currentModelResponse.content)\n            },\n            \"ai.response.toolCalls\": {\n              output: () => {\n                const toolCalls = asToolCalls(currentModelResponse.content);\n                return toolCalls == null ? void 0 : JSON.stringify(toolCalls);\n              }\n            },\n            \"ai.response.providerMetadata\": JSON.stringify(currentModelResponse.providerMetadata),\n            // TODO rename telemetry attributes to inputTokens and outputTokens\n            \"ai.usage.promptTokens\": currentModelResponse.usage.inputTokens,\n            \"ai.usage.completionTokens\": currentModelResponse.usage.outputTokens\n          }\n        }));\n        const lastStep = steps[steps.length - 1];\n        return new DefaultGenerateTextResult({\n          steps,\n          resolvedOutput: await (output == null ? void 0 : output.parseOutput({\n            text: lastStep.text\n          }, {\n            response: lastStep.response,\n            usage: lastStep.usage,\n            finishReason: lastStep.finishReason\n          }))\n        });\n      }\n    });\n  } catch (error40) {\n    throw wrapGatewayError(error40);\n  }\n}\nasync function executeTools({\n  toolCalls,\n  tools,\n  tracer,\n  telemetry,\n  messages,\n  abortSignal,\n  experimental_context\n}) {\n  const toolOutputs = await Promise.all(toolCalls.map(async ({\n    toolCallId,\n    toolName,\n    input\n  }) => {\n    const tool3 = tools[toolName];\n    if ((tool3 == null ? void 0 : tool3.execute) == null) {\n      return void 0;\n    }\n    return recordSpan({\n      name: \"ai.toolCall\",\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({\n            operationId: \"ai.toolCall\",\n            telemetry\n          }),\n          \"ai.toolCall.name\": toolName,\n          \"ai.toolCall.id\": toolCallId,\n          \"ai.toolCall.args\": {\n            output: () => JSON.stringify(input)\n          }\n        }\n      }),\n      tracer,\n      fn: async span => {\n        try {\n          const stream = executeTool({\n            execute: tool3.execute.bind(tool3),\n            input,\n            options: {\n              toolCallId,\n              messages,\n              abortSignal,\n              experimental_context\n            }\n          });\n          let output;\n          for await (const part of stream) {\n            if (part.type === \"final\") {\n              output = part.output;\n            }\n          }\n          try {\n            span.setAttributes(selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                \"ai.toolCall.result\": {\n                  output: () => JSON.stringify(output)\n                }\n              }\n            }));\n          } catch (ignored) {}\n          return {\n            type: \"tool-result\",\n            toolCallId,\n            toolName,\n            input,\n            output,\n            dynamic: tool3.type === \"dynamic\"\n          };\n        } catch (error40) {\n          recordErrorOnSpan(span, error40);\n          return {\n            type: \"tool-error\",\n            toolCallId,\n            toolName,\n            input,\n            error: error40,\n            dynamic: tool3.type === \"dynamic\"\n          };\n        }\n      }\n    });\n  }));\n  return toolOutputs.filter(output => output != null);\n}\nvar DefaultGenerateTextResult = class {\n  constructor(options) {\n    this.steps = options.steps;\n    this.resolvedOutput = options.resolvedOutput;\n  }\n  get finalStep() {\n    return this.steps[this.steps.length - 1];\n  }\n  get content() {\n    return this.finalStep.content;\n  }\n  get text() {\n    return this.finalStep.text;\n  }\n  get files() {\n    return this.finalStep.files;\n  }\n  get reasoningText() {\n    return this.finalStep.reasoningText;\n  }\n  get reasoning() {\n    return this.finalStep.reasoning;\n  }\n  get toolCalls() {\n    return this.finalStep.toolCalls;\n  }\n  get staticToolCalls() {\n    return this.finalStep.staticToolCalls;\n  }\n  get dynamicToolCalls() {\n    return this.finalStep.dynamicToolCalls;\n  }\n  get toolResults() {\n    return this.finalStep.toolResults;\n  }\n  get staticToolResults() {\n    return this.finalStep.staticToolResults;\n  }\n  get dynamicToolResults() {\n    return this.finalStep.dynamicToolResults;\n  }\n  get sources() {\n    return this.finalStep.sources;\n  }\n  get finishReason() {\n    return this.finalStep.finishReason;\n  }\n  get warnings() {\n    return this.finalStep.warnings;\n  }\n  get providerMetadata() {\n    return this.finalStep.providerMetadata;\n  }\n  get response() {\n    return this.finalStep.response;\n  }\n  get request() {\n    return this.finalStep.request;\n  }\n  get usage() {\n    return this.finalStep.usage;\n  }\n  get totalUsage() {\n    return this.steps.reduce((totalUsage, step) => {\n      return addLanguageModelUsage(totalUsage, step.usage);\n    }, {\n      inputTokens: void 0,\n      outputTokens: void 0,\n      totalTokens: void 0,\n      reasoningTokens: void 0,\n      cachedInputTokens: void 0\n    });\n  }\n  get experimental_output() {\n    if (this.resolvedOutput == null) {\n      throw new NoOutputSpecifiedError();\n    }\n    return this.resolvedOutput;\n  }\n};\nfunction asToolCalls(content) {\n  const parts = content.filter(part => part.type === \"tool-call\");\n  if (parts.length === 0) {\n    return void 0;\n  }\n  return parts.map(toolCall => ({\n    toolCallId: toolCall.toolCallId,\n    toolName: toolCall.toolName,\n    input: toolCall.input\n  }));\n}\nfunction asContent({\n  content,\n  toolCalls,\n  toolOutputs\n}) {\n  return [...content.map(part => {\n    switch (part.type) {\n      case \"text\":\n      case \"reasoning\":\n      case \"source\":\n        return part;\n      case \"file\":\n        {\n          return {\n            type: \"file\",\n            file: new DefaultGeneratedFile(part)\n          };\n        }\n      case \"tool-call\":\n        {\n          return toolCalls.find(toolCall => toolCall.toolCallId === part.toolCallId);\n        }\n      case \"tool-result\":\n        {\n          const toolCall = toolCalls.find(toolCall2 => toolCall2.toolCallId === part.toolCallId);\n          if (toolCall == null) {\n            throw new Error(`Tool call ${part.toolCallId} not found.`);\n          }\n          if (part.isError) {\n            return {\n              type: \"tool-error\",\n              toolCallId: part.toolCallId,\n              toolName: part.toolName,\n              input: toolCall.input,\n              error: part.result,\n              providerExecuted: true,\n              dynamic: toolCall.dynamic\n            };\n          }\n          return {\n            type: \"tool-result\",\n            toolCallId: part.toolCallId,\n            toolName: part.toolName,\n            input: toolCall.input,\n            output: part.result,\n            providerExecuted: true,\n            dynamic: toolCall.dynamic\n          };\n        }\n    }\n  }), ...toolOutputs];\n}\nfunction prepareHeaders(headers, defaultHeaders) {\n  const responseHeaders = new Headers(headers != null ? headers : {});\n  for (const [key, value] of Object.entries(defaultHeaders)) {\n    if (!responseHeaders.has(key)) {\n      responseHeaders.set(key, value);\n    }\n  }\n  return responseHeaders;\n}\nfunction createTextStreamResponse({\n  status,\n  statusText,\n  headers,\n  textStream\n}) {\n  return new Response(textStream.pipeThrough(new TextEncoderStream()), {\n    status: status != null ? status : 200,\n    statusText,\n    headers: prepareHeaders(headers, {\n      \"content-type\": \"text/plain; charset=utf-8\"\n    })\n  });\n}\nfunction writeToServerResponse({\n  response,\n  status,\n  statusText,\n  headers,\n  stream\n}) {\n  response.writeHead(status != null ? status : 200, statusText, headers);\n  const reader = stream.getReader();\n  const read = async () => {\n    try {\n      while (true) {\n        const {\n          done,\n          value\n        } = await reader.read();\n        if (done) break;\n        response.write(value);\n      }\n    } catch (error40) {\n      throw error40;\n    } finally {\n      response.end();\n    }\n  };\n  read();\n}\nfunction pipeTextStreamToResponse({\n  response,\n  status,\n  statusText,\n  headers,\n  textStream\n}) {\n  writeToServerResponse({\n    response,\n    status,\n    statusText,\n    headers: Object.fromEntries(prepareHeaders(headers, {\n      \"content-type\": \"text/plain; charset=utf-8\"\n    }).entries()),\n    stream: textStream.pipeThrough(new TextEncoderStream())\n  });\n}\nvar JsonToSseTransformStream = class extends TransformStream {\n  constructor() {\n    super({\n      transform(part, controller) {\n        controller.enqueue(`data: ${JSON.stringify(part)}\n\n`);\n      },\n      flush(controller) {\n        controller.enqueue(\"data: [DONE]\\n\\n\");\n      }\n    });\n  }\n};\nvar UI_MESSAGE_STREAM_HEADERS = {\n  \"content-type\": \"text/event-stream\",\n  \"cache-control\": \"no-cache\",\n  connection: \"keep-alive\",\n  \"x-vercel-ai-ui-message-stream\": \"v1\",\n  \"x-accel-buffering\": \"no\"\n  // disable nginx buffering\n};\nfunction createUIMessageStreamResponse({\n  status,\n  statusText,\n  headers,\n  stream,\n  consumeSseStream\n}) {\n  let sseStream = stream.pipeThrough(new JsonToSseTransformStream());\n  if (consumeSseStream) {\n    const [stream1, stream2] = sseStream.tee();\n    sseStream = stream1;\n    consumeSseStream({\n      stream: stream2\n    });\n  }\n  return new Response(sseStream.pipeThrough(new TextEncoderStream()), {\n    status,\n    statusText,\n    headers: prepareHeaders(headers, UI_MESSAGE_STREAM_HEADERS)\n  });\n}\nfunction getResponseUIMessageId({\n  originalMessages,\n  responseMessageId\n}) {\n  if (originalMessages == null) {\n    return void 0;\n  }\n  const lastMessage = originalMessages[originalMessages.length - 1];\n  return (lastMessage == null ? void 0 : lastMessage.role) === \"assistant\" ? lastMessage.id : typeof responseMessageId === \"function\" ? responseMessageId() : responseMessageId;\n}\nvar uiMessageChunkSchema = external_exports2.union([external_exports2.strictObject({\n  type: external_exports2.literal(\"text-start\"),\n  id: external_exports2.string(),\n  providerMetadata: providerMetadataSchema.optional()\n}), external_exports2.strictObject({\n  type: external_exports2.literal(\"text-delta\"),\n  id: external_exports2.string(),\n  delta: external_exports2.string(),\n  providerMetadata: providerMetadataSchema.optional()\n}), external_exports2.strictObject({\n  type: external_exports2.literal(\"text-end\"),\n  id: external_exports2.string(),\n  providerMetadata: providerMetadataSchema.optional()\n}), external_exports2.strictObject({\n  type: external_exports2.literal(\"error\"),\n  errorText: external_exports2.string()\n}), external_exports2.strictObject({\n  type: external_exports2.literal(\"tool-input-start\"),\n  toolCallId: external_exports2.string(),\n  toolName: external_exports2.string(),\n  providerExecuted: external_exports2.boolean().optional(),\n  dynamic: external_exports2.boolean().optional()\n}), external_exports2.strictObject({\n  type: external_exports2.literal(\"tool-input-delta\"),\n  toolCallId: external_exports2.string(),\n  inputTextDelta: external_exports2.string()\n}), external_exports2.strictObject({\n  type: external_exports2.literal(\"tool-input-available\"),\n  toolCallId: external_exports2.string(),\n  toolName: external_exports2.string(),\n  input: external_exports2.unknown(),\n  providerExecuted: external_exports2.boolean().optional(),\n  providerMetadata: providerMetadataSchema.optional(),\n  dynamic: external_exports2.boolean().optional()\n}), external_exports2.strictObject({\n  type: external_exports2.literal(\"tool-input-error\"),\n  toolCallId: external_exports2.string(),\n  toolName: external_exports2.string(),\n  input: external_exports2.unknown(),\n  providerExecuted: external_exports2.boolean().optional(),\n  providerMetadata: providerMetadataSchema.optional(),\n  dynamic: external_exports2.boolean().optional(),\n  errorText: external_exports2.string()\n}), external_exports2.strictObject({\n  type: external_exports2.literal(\"tool-output-available\"),\n  toolCallId: external_exports2.string(),\n  output: external_exports2.unknown(),\n  providerExecuted: external_exports2.boolean().optional(),\n  dynamic: external_exports2.boolean().optional(),\n  preliminary: external_exports2.boolean().optional()\n}), external_exports2.strictObject({\n  type: external_exports2.literal(\"tool-output-error\"),\n  toolCallId: external_exports2.string(),\n  errorText: external_exports2.string(),\n  providerExecuted: external_exports2.boolean().optional(),\n  dynamic: external_exports2.boolean().optional()\n}), external_exports2.strictObject({\n  type: external_exports2.literal(\"reasoning\"),\n  text: external_exports2.string(),\n  providerMetadata: providerMetadataSchema.optional()\n}), external_exports2.strictObject({\n  type: external_exports2.literal(\"reasoning-start\"),\n  id: external_exports2.string(),\n  providerMetadata: providerMetadataSchema.optional()\n}), external_exports2.strictObject({\n  type: external_exports2.literal(\"reasoning-delta\"),\n  id: external_exports2.string(),\n  delta: external_exports2.string(),\n  providerMetadata: providerMetadataSchema.optional()\n}), external_exports2.strictObject({\n  type: external_exports2.literal(\"reasoning-end\"),\n  id: external_exports2.string(),\n  providerMetadata: providerMetadataSchema.optional()\n}), external_exports2.strictObject({\n  type: external_exports2.literal(\"reasoning-part-finish\")\n}), external_exports2.strictObject({\n  type: external_exports2.literal(\"source-url\"),\n  sourceId: external_exports2.string(),\n  url: external_exports2.string(),\n  title: external_exports2.string().optional(),\n  providerMetadata: providerMetadataSchema.optional()\n}), external_exports2.strictObject({\n  type: external_exports2.literal(\"source-document\"),\n  sourceId: external_exports2.string(),\n  mediaType: external_exports2.string(),\n  title: external_exports2.string(),\n  filename: external_exports2.string().optional(),\n  providerMetadata: providerMetadataSchema.optional()\n}), external_exports2.strictObject({\n  type: external_exports2.literal(\"file\"),\n  url: external_exports2.string(),\n  mediaType: external_exports2.string(),\n  providerMetadata: providerMetadataSchema.optional()\n}), external_exports2.strictObject({\n  type: external_exports2.string().startsWith(\"data-\"),\n  id: external_exports2.string().optional(),\n  data: external_exports2.unknown(),\n  transient: external_exports2.boolean().optional()\n}), external_exports2.strictObject({\n  type: external_exports2.literal(\"start-step\")\n}), external_exports2.strictObject({\n  type: external_exports2.literal(\"finish-step\")\n}), external_exports2.strictObject({\n  type: external_exports2.literal(\"start\"),\n  messageId: external_exports2.string().optional(),\n  messageMetadata: external_exports2.unknown().optional()\n}), external_exports2.strictObject({\n  type: external_exports2.literal(\"finish\"),\n  messageMetadata: external_exports2.unknown().optional()\n}), external_exports2.strictObject({\n  type: external_exports2.literal(\"abort\")\n}), external_exports2.strictObject({\n  type: external_exports2.literal(\"message-metadata\"),\n  messageMetadata: external_exports2.unknown()\n})]);\nfunction isDataUIMessageChunk(chunk) {\n  return chunk.type.startsWith(\"data-\");\n}\nfunction mergeObjects(base, overrides) {\n  if (base === void 0 && overrides === void 0) {\n    return void 0;\n  }\n  if (base === void 0) {\n    return overrides;\n  }\n  if (overrides === void 0) {\n    return base;\n  }\n  const result = {\n    ...base\n  };\n  for (const key in overrides) {\n    if (Object.prototype.hasOwnProperty.call(overrides, key)) {\n      const overridesValue = overrides[key];\n      if (overridesValue === void 0) continue;\n      const baseValue = key in base ? base[key] : void 0;\n      const isSourceObject = overridesValue !== null && typeof overridesValue === \"object\" && !Array.isArray(overridesValue) && !(overridesValue instanceof Date) && !(overridesValue instanceof RegExp);\n      const isTargetObject = baseValue !== null && baseValue !== void 0 && typeof baseValue === \"object\" && !Array.isArray(baseValue) && !(baseValue instanceof Date) && !(baseValue instanceof RegExp);\n      if (isSourceObject && isTargetObject) {\n        result[key] = mergeObjects(baseValue, overridesValue);\n      } else {\n        result[key] = overridesValue;\n      }\n    }\n  }\n  return result;\n}\nfunction fixJson(input) {\n  const stack = [\"ROOT\"];\n  let lastValidIndex = -1;\n  let literalStart = null;\n  function processValueStart(char, i, swapState) {\n    {\n      switch (char) {\n        case '\"':\n          {\n            lastValidIndex = i;\n            stack.pop();\n            stack.push(swapState);\n            stack.push(\"INSIDE_STRING\");\n            break;\n          }\n        case \"f\":\n        case \"t\":\n        case \"n\":\n          {\n            lastValidIndex = i;\n            literalStart = i;\n            stack.pop();\n            stack.push(swapState);\n            stack.push(\"INSIDE_LITERAL\");\n            break;\n          }\n        case \"-\":\n          {\n            stack.pop();\n            stack.push(swapState);\n            stack.push(\"INSIDE_NUMBER\");\n            break;\n          }\n        case \"0\":\n        case \"1\":\n        case \"2\":\n        case \"3\":\n        case \"4\":\n        case \"5\":\n        case \"6\":\n        case \"7\":\n        case \"8\":\n        case \"9\":\n          {\n            lastValidIndex = i;\n            stack.pop();\n            stack.push(swapState);\n            stack.push(\"INSIDE_NUMBER\");\n            break;\n          }\n        case \"{\":\n          {\n            lastValidIndex = i;\n            stack.pop();\n            stack.push(swapState);\n            stack.push(\"INSIDE_OBJECT_START\");\n            break;\n          }\n        case \"[\":\n          {\n            lastValidIndex = i;\n            stack.pop();\n            stack.push(swapState);\n            stack.push(\"INSIDE_ARRAY_START\");\n            break;\n          }\n      }\n    }\n  }\n  function processAfterObjectValue(char, i) {\n    switch (char) {\n      case \",\":\n        {\n          stack.pop();\n          stack.push(\"INSIDE_OBJECT_AFTER_COMMA\");\n          break;\n        }\n      case \"}\":\n        {\n          lastValidIndex = i;\n          stack.pop();\n          break;\n        }\n    }\n  }\n  function processAfterArrayValue(char, i) {\n    switch (char) {\n      case \",\":\n        {\n          stack.pop();\n          stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n          break;\n        }\n      case \"]\":\n        {\n          lastValidIndex = i;\n          stack.pop();\n          break;\n        }\n    }\n  }\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n    const currentState = stack[stack.length - 1];\n    switch (currentState) {\n      case \"ROOT\":\n        processValueStart(char, i, \"FINISH\");\n        break;\n      case \"INSIDE_OBJECT_START\":\n        {\n          switch (char) {\n            case '\"':\n              {\n                stack.pop();\n                stack.push(\"INSIDE_OBJECT_KEY\");\n                break;\n              }\n            case \"}\":\n              {\n                lastValidIndex = i;\n                stack.pop();\n                break;\n              }\n          }\n          break;\n        }\n      case \"INSIDE_OBJECT_AFTER_COMMA\":\n        {\n          switch (char) {\n            case '\"':\n              {\n                stack.pop();\n                stack.push(\"INSIDE_OBJECT_KEY\");\n                break;\n              }\n          }\n          break;\n        }\n      case \"INSIDE_OBJECT_KEY\":\n        {\n          switch (char) {\n            case '\"':\n              {\n                stack.pop();\n                stack.push(\"INSIDE_OBJECT_AFTER_KEY\");\n                break;\n              }\n          }\n          break;\n        }\n      case \"INSIDE_OBJECT_AFTER_KEY\":\n        {\n          switch (char) {\n            case \":\":\n              {\n                stack.pop();\n                stack.push(\"INSIDE_OBJECT_BEFORE_VALUE\");\n                break;\n              }\n          }\n          break;\n        }\n      case \"INSIDE_OBJECT_BEFORE_VALUE\":\n        {\n          processValueStart(char, i, \"INSIDE_OBJECT_AFTER_VALUE\");\n          break;\n        }\n      case \"INSIDE_OBJECT_AFTER_VALUE\":\n        {\n          processAfterObjectValue(char, i);\n          break;\n        }\n      case \"INSIDE_STRING\":\n        {\n          switch (char) {\n            case '\"':\n              {\n                stack.pop();\n                lastValidIndex = i;\n                break;\n              }\n            case \"\\\\\":\n              {\n                stack.push(\"INSIDE_STRING_ESCAPE\");\n                break;\n              }\n            default:\n              {\n                lastValidIndex = i;\n              }\n          }\n          break;\n        }\n      case \"INSIDE_ARRAY_START\":\n        {\n          switch (char) {\n            case \"]\":\n              {\n                lastValidIndex = i;\n                stack.pop();\n                break;\n              }\n            default:\n              {\n                lastValidIndex = i;\n                processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n                break;\n              }\n          }\n          break;\n        }\n      case \"INSIDE_ARRAY_AFTER_VALUE\":\n        {\n          switch (char) {\n            case \",\":\n              {\n                stack.pop();\n                stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n                break;\n              }\n            case \"]\":\n              {\n                lastValidIndex = i;\n                stack.pop();\n                break;\n              }\n            default:\n              {\n                lastValidIndex = i;\n                break;\n              }\n          }\n          break;\n        }\n      case \"INSIDE_ARRAY_AFTER_COMMA\":\n        {\n          processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n          break;\n        }\n      case \"INSIDE_STRING_ESCAPE\":\n        {\n          stack.pop();\n          lastValidIndex = i;\n          break;\n        }\n      case \"INSIDE_NUMBER\":\n        {\n          switch (char) {\n            case \"0\":\n            case \"1\":\n            case \"2\":\n            case \"3\":\n            case \"4\":\n            case \"5\":\n            case \"6\":\n            case \"7\":\n            case \"8\":\n            case \"9\":\n              {\n                lastValidIndex = i;\n                break;\n              }\n            case \"e\":\n            case \"E\":\n            case \"-\":\n            case \".\":\n              {\n                break;\n              }\n            case \",\":\n              {\n                stack.pop();\n                if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n                  processAfterArrayValue(char, i);\n                }\n                if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n                  processAfterObjectValue(char, i);\n                }\n                break;\n              }\n            case \"}\":\n              {\n                stack.pop();\n                if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n                  processAfterObjectValue(char, i);\n                }\n                break;\n              }\n            case \"]\":\n              {\n                stack.pop();\n                if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n                  processAfterArrayValue(char, i);\n                }\n                break;\n              }\n            default:\n              {\n                stack.pop();\n                break;\n              }\n          }\n          break;\n        }\n      case \"INSIDE_LITERAL\":\n        {\n          const partialLiteral = input.substring(literalStart, i + 1);\n          if (!\"false\".startsWith(partialLiteral) && !\"true\".startsWith(partialLiteral) && !\"null\".startsWith(partialLiteral)) {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n              processAfterObjectValue(char, i);\n            } else if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n              processAfterArrayValue(char, i);\n            }\n          } else {\n            lastValidIndex = i;\n          }\n          break;\n        }\n    }\n  }\n  let result = input.slice(0, lastValidIndex + 1);\n  for (let i = stack.length - 1; i >= 0; i--) {\n    const state = stack[i];\n    switch (state) {\n      case \"INSIDE_STRING\":\n        {\n          result += '\"';\n          break;\n        }\n      case \"INSIDE_OBJECT_KEY\":\n      case \"INSIDE_OBJECT_AFTER_KEY\":\n      case \"INSIDE_OBJECT_AFTER_COMMA\":\n      case \"INSIDE_OBJECT_START\":\n      case \"INSIDE_OBJECT_BEFORE_VALUE\":\n      case \"INSIDE_OBJECT_AFTER_VALUE\":\n        {\n          result += \"}\";\n          break;\n        }\n      case \"INSIDE_ARRAY_START\":\n      case \"INSIDE_ARRAY_AFTER_COMMA\":\n      case \"INSIDE_ARRAY_AFTER_VALUE\":\n        {\n          result += \"]\";\n          break;\n        }\n      case \"INSIDE_LITERAL\":\n        {\n          const partialLiteral = input.substring(literalStart, input.length);\n          if (\"true\".startsWith(partialLiteral)) {\n            result += \"true\".slice(partialLiteral.length);\n          } else if (\"false\".startsWith(partialLiteral)) {\n            result += \"false\".slice(partialLiteral.length);\n          } else if (\"null\".startsWith(partialLiteral)) {\n            result += \"null\".slice(partialLiteral.length);\n          }\n        }\n    }\n  }\n  return result;\n}\nasync function parsePartialJson(jsonText) {\n  if (jsonText === void 0) {\n    return {\n      value: void 0,\n      state: \"undefined-input\"\n    };\n  }\n  let result = await safeParseJSON2({\n    text: jsonText\n  });\n  if (result.success) {\n    return {\n      value: result.value,\n      state: \"successful-parse\"\n    };\n  }\n  result = await safeParseJSON2({\n    text: fixJson(jsonText)\n  });\n  if (result.success) {\n    return {\n      value: result.value,\n      state: \"repaired-parse\"\n    };\n  }\n  return {\n    value: void 0,\n    state: \"failed-parse\"\n  };\n}\nfunction isToolUIPart(part) {\n  return part.type.startsWith(\"tool-\");\n}\nfunction getToolName(part) {\n  return part.type.split(\"-\").slice(1).join(\"-\");\n}\nfunction createStreamingUIMessageState({\n  lastMessage,\n  messageId\n}) {\n  return {\n    message: (lastMessage == null ? void 0 : lastMessage.role) === \"assistant\" ? lastMessage : {\n      id: messageId,\n      metadata: void 0,\n      role: \"assistant\",\n      parts: []\n    },\n    activeTextParts: {},\n    activeReasoningParts: {},\n    partialToolCalls: {}\n  };\n}\nfunction processUIMessageStream({\n  stream,\n  messageMetadataSchema,\n  dataPartSchemas,\n  runUpdateMessageJob,\n  onError,\n  onToolCall,\n  onData\n}) {\n  return stream.pipeThrough(new TransformStream({\n    async transform(chunk, controller) {\n      await runUpdateMessageJob(async ({\n        state,\n        write\n      }) => {\n        var _a172, _b8, _c, _d;\n        function getToolInvocation(toolCallId) {\n          const toolInvocations = state.message.parts.filter(isToolUIPart);\n          const toolInvocation = toolInvocations.find(invocation => invocation.toolCallId === toolCallId);\n          if (toolInvocation == null) {\n            throw new Error(\"tool-output-error must be preceded by a tool-input-available\");\n          }\n          return toolInvocation;\n        }\n        function getDynamicToolInvocation(toolCallId) {\n          const toolInvocations = state.message.parts.filter(part => part.type === \"dynamic-tool\");\n          const toolInvocation = toolInvocations.find(invocation => invocation.toolCallId === toolCallId);\n          if (toolInvocation == null) {\n            throw new Error(\"tool-output-error must be preceded by a tool-input-available\");\n          }\n          return toolInvocation;\n        }\n        function updateToolPart(options) {\n          var _a182;\n          const part = state.message.parts.find(part2 => isToolUIPart(part2) && part2.toolCallId === options.toolCallId);\n          const anyOptions = options;\n          const anyPart = part;\n          if (part != null) {\n            part.state = options.state;\n            anyPart.input = anyOptions.input;\n            anyPart.output = anyOptions.output;\n            anyPart.errorText = anyOptions.errorText;\n            anyPart.rawInput = anyOptions.rawInput;\n            anyPart.preliminary = anyOptions.preliminary;\n            anyPart.providerExecuted = (_a182 = anyOptions.providerExecuted) != null ? _a182 : part.providerExecuted;\n            if (anyOptions.providerMetadata != null && part.state === \"input-available\") {\n              part.callProviderMetadata = anyOptions.providerMetadata;\n            }\n          } else {\n            state.message.parts.push({\n              type: `tool-${options.toolName}`,\n              toolCallId: options.toolCallId,\n              state: options.state,\n              input: anyOptions.input,\n              output: anyOptions.output,\n              rawInput: anyOptions.rawInput,\n              errorText: anyOptions.errorText,\n              providerExecuted: anyOptions.providerExecuted,\n              preliminary: anyOptions.preliminary,\n              ...(anyOptions.providerMetadata != null ? {\n                callProviderMetadata: anyOptions.providerMetadata\n              } : {})\n            });\n          }\n        }\n        function updateDynamicToolPart(options) {\n          var _a182;\n          const part = state.message.parts.find(part2 => part2.type === \"dynamic-tool\" && part2.toolCallId === options.toolCallId);\n          const anyOptions = options;\n          const anyPart = part;\n          if (part != null) {\n            part.state = options.state;\n            anyPart.toolName = options.toolName;\n            anyPart.input = anyOptions.input;\n            anyPart.output = anyOptions.output;\n            anyPart.errorText = anyOptions.errorText;\n            anyPart.rawInput = (_a182 = anyOptions.rawInput) != null ? _a182 : anyPart.rawInput;\n            anyPart.preliminary = anyOptions.preliminary;\n            if (anyOptions.providerMetadata != null && part.state === \"input-available\") {\n              part.callProviderMetadata = anyOptions.providerMetadata;\n            }\n          } else {\n            state.message.parts.push({\n              type: \"dynamic-tool\",\n              toolName: options.toolName,\n              toolCallId: options.toolCallId,\n              state: options.state,\n              input: anyOptions.input,\n              output: anyOptions.output,\n              errorText: anyOptions.errorText,\n              preliminary: anyOptions.preliminary,\n              ...(anyOptions.providerMetadata != null ? {\n                callProviderMetadata: anyOptions.providerMetadata\n              } : {})\n            });\n          }\n        }\n        async function updateMessageMetadata(metadata) {\n          if (metadata != null) {\n            const mergedMetadata = state.message.metadata != null ? mergeObjects(state.message.metadata, metadata) : metadata;\n            if (messageMetadataSchema != null) {\n              await validateTypes2({\n                value: mergedMetadata,\n                schema: messageMetadataSchema\n              });\n            }\n            state.message.metadata = mergedMetadata;\n          }\n        }\n        switch (chunk.type) {\n          case \"text-start\":\n            {\n              const textPart = {\n                type: \"text\",\n                text: \"\",\n                providerMetadata: chunk.providerMetadata,\n                state: \"streaming\"\n              };\n              state.activeTextParts[chunk.id] = textPart;\n              state.message.parts.push(textPart);\n              write();\n              break;\n            }\n          case \"text-delta\":\n            {\n              const textPart = state.activeTextParts[chunk.id];\n              textPart.text += chunk.delta;\n              textPart.providerMetadata = (_a172 = chunk.providerMetadata) != null ? _a172 : textPart.providerMetadata;\n              write();\n              break;\n            }\n          case \"text-end\":\n            {\n              const textPart = state.activeTextParts[chunk.id];\n              textPart.state = \"done\";\n              textPart.providerMetadata = (_b8 = chunk.providerMetadata) != null ? _b8 : textPart.providerMetadata;\n              delete state.activeTextParts[chunk.id];\n              write();\n              break;\n            }\n          case \"reasoning-start\":\n            {\n              const reasoningPart = {\n                type: \"reasoning\",\n                text: \"\",\n                providerMetadata: chunk.providerMetadata,\n                state: \"streaming\"\n              };\n              state.activeReasoningParts[chunk.id] = reasoningPart;\n              state.message.parts.push(reasoningPart);\n              write();\n              break;\n            }\n          case \"reasoning-delta\":\n            {\n              const reasoningPart = state.activeReasoningParts[chunk.id];\n              reasoningPart.text += chunk.delta;\n              reasoningPart.providerMetadata = (_c = chunk.providerMetadata) != null ? _c : reasoningPart.providerMetadata;\n              write();\n              break;\n            }\n          case \"reasoning-end\":\n            {\n              const reasoningPart = state.activeReasoningParts[chunk.id];\n              reasoningPart.providerMetadata = (_d = chunk.providerMetadata) != null ? _d : reasoningPart.providerMetadata;\n              reasoningPart.state = \"done\";\n              delete state.activeReasoningParts[chunk.id];\n              write();\n              break;\n            }\n          case \"file\":\n            {\n              state.message.parts.push({\n                type: \"file\",\n                mediaType: chunk.mediaType,\n                url: chunk.url\n              });\n              write();\n              break;\n            }\n          case \"source-url\":\n            {\n              state.message.parts.push({\n                type: \"source-url\",\n                sourceId: chunk.sourceId,\n                url: chunk.url,\n                title: chunk.title,\n                providerMetadata: chunk.providerMetadata\n              });\n              write();\n              break;\n            }\n          case \"source-document\":\n            {\n              state.message.parts.push({\n                type: \"source-document\",\n                sourceId: chunk.sourceId,\n                mediaType: chunk.mediaType,\n                title: chunk.title,\n                filename: chunk.filename,\n                providerMetadata: chunk.providerMetadata\n              });\n              write();\n              break;\n            }\n          case \"tool-input-start\":\n            {\n              const toolInvocations = state.message.parts.filter(isToolUIPart);\n              state.partialToolCalls[chunk.toolCallId] = {\n                text: \"\",\n                toolName: chunk.toolName,\n                index: toolInvocations.length,\n                dynamic: chunk.dynamic\n              };\n              if (chunk.dynamic) {\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: \"input-streaming\",\n                  input: void 0\n                });\n              } else {\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: \"input-streaming\",\n                  input: void 0,\n                  providerExecuted: chunk.providerExecuted\n                });\n              }\n              write();\n              break;\n            }\n          case \"tool-input-delta\":\n            {\n              const partialToolCall = state.partialToolCalls[chunk.toolCallId];\n              partialToolCall.text += chunk.inputTextDelta;\n              const {\n                value: partialArgs\n              } = await parsePartialJson(partialToolCall.text);\n              if (partialToolCall.dynamic) {\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: partialToolCall.toolName,\n                  state: \"input-streaming\",\n                  input: partialArgs\n                });\n              } else {\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: partialToolCall.toolName,\n                  state: \"input-streaming\",\n                  input: partialArgs\n                });\n              }\n              write();\n              break;\n            }\n          case \"tool-input-available\":\n            {\n              if (chunk.dynamic) {\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: \"input-available\",\n                  input: chunk.input,\n                  providerMetadata: chunk.providerMetadata\n                });\n              } else {\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: \"input-available\",\n                  input: chunk.input,\n                  providerExecuted: chunk.providerExecuted,\n                  providerMetadata: chunk.providerMetadata\n                });\n              }\n              write();\n              if (onToolCall && !chunk.providerExecuted) {\n                await onToolCall({\n                  toolCall: chunk\n                });\n              }\n              break;\n            }\n          case \"tool-input-error\":\n            {\n              if (chunk.dynamic) {\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: \"output-error\",\n                  input: chunk.input,\n                  errorText: chunk.errorText,\n                  providerMetadata: chunk.providerMetadata\n                });\n              } else {\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: \"output-error\",\n                  input: void 0,\n                  rawInput: chunk.input,\n                  errorText: chunk.errorText,\n                  providerExecuted: chunk.providerExecuted,\n                  providerMetadata: chunk.providerMetadata\n                });\n              }\n              write();\n              break;\n            }\n          case \"tool-output-available\":\n            {\n              if (chunk.dynamic) {\n                const toolInvocation = getDynamicToolInvocation(chunk.toolCallId);\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: toolInvocation.toolName,\n                  state: \"output-available\",\n                  input: toolInvocation.input,\n                  output: chunk.output,\n                  preliminary: chunk.preliminary\n                });\n              } else {\n                const toolInvocation = getToolInvocation(chunk.toolCallId);\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: getToolName(toolInvocation),\n                  state: \"output-available\",\n                  input: toolInvocation.input,\n                  output: chunk.output,\n                  providerExecuted: chunk.providerExecuted,\n                  preliminary: chunk.preliminary\n                });\n              }\n              write();\n              break;\n            }\n          case \"tool-output-error\":\n            {\n              if (chunk.dynamic) {\n                const toolInvocation = getDynamicToolInvocation(chunk.toolCallId);\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: toolInvocation.toolName,\n                  state: \"output-error\",\n                  input: toolInvocation.input,\n                  errorText: chunk.errorText\n                });\n              } else {\n                const toolInvocation = getToolInvocation(chunk.toolCallId);\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: getToolName(toolInvocation),\n                  state: \"output-error\",\n                  input: toolInvocation.input,\n                  rawInput: toolInvocation.rawInput,\n                  errorText: chunk.errorText\n                });\n              }\n              write();\n              break;\n            }\n          case \"start-step\":\n            {\n              state.message.parts.push({\n                type: \"step-start\"\n              });\n              break;\n            }\n          case \"finish-step\":\n            {\n              state.activeTextParts = {};\n              state.activeReasoningParts = {};\n              break;\n            }\n          case \"start\":\n            {\n              if (chunk.messageId != null) {\n                state.message.id = chunk.messageId;\n              }\n              await updateMessageMetadata(chunk.messageMetadata);\n              if (chunk.messageId != null || chunk.messageMetadata != null) {\n                write();\n              }\n              break;\n            }\n          case \"finish\":\n            {\n              await updateMessageMetadata(chunk.messageMetadata);\n              if (chunk.messageMetadata != null) {\n                write();\n              }\n              break;\n            }\n          case \"message-metadata\":\n            {\n              await updateMessageMetadata(chunk.messageMetadata);\n              if (chunk.messageMetadata != null) {\n                write();\n              }\n              break;\n            }\n          case \"error\":\n            {\n              onError == null ? void 0 : onError(new Error(chunk.errorText));\n              break;\n            }\n          default:\n            {\n              if (isDataUIMessageChunk(chunk)) {\n                if ((dataPartSchemas == null ? void 0 : dataPartSchemas[chunk.type]) != null) {\n                  await validateTypes2({\n                    value: chunk.data,\n                    schema: dataPartSchemas[chunk.type]\n                  });\n                }\n                const dataChunk = chunk;\n                if (dataChunk.transient) {\n                  onData == null ? void 0 : onData(dataChunk);\n                  break;\n                }\n                const existingUIPart = dataChunk.id != null ? state.message.parts.find(chunkArg => dataChunk.type === chunkArg.type && dataChunk.id === chunkArg.id) : void 0;\n                if (existingUIPart != null) {\n                  existingUIPart.data = dataChunk.data;\n                } else {\n                  state.message.parts.push(dataChunk);\n                }\n                onData == null ? void 0 : onData(dataChunk);\n                write();\n              }\n            }\n        }\n        controller.enqueue(chunk);\n      });\n    }\n  }));\n}\nfunction handleUIMessageStreamFinish({\n  messageId,\n  originalMessages = [],\n  onFinish,\n  onError,\n  stream\n}) {\n  let lastMessage = originalMessages == null ? void 0 : originalMessages[originalMessages.length - 1];\n  if ((lastMessage == null ? void 0 : lastMessage.role) !== \"assistant\") {\n    lastMessage = void 0;\n  } else {\n    messageId = lastMessage.id;\n  }\n  let isAborted2 = false;\n  const idInjectedStream = stream.pipeThrough(new TransformStream({\n    transform(chunk, controller) {\n      if (chunk.type === \"start\") {\n        const startChunk = chunk;\n        if (startChunk.messageId == null && messageId != null) {\n          startChunk.messageId = messageId;\n        }\n      }\n      if (chunk.type === \"abort\") {\n        isAborted2 = true;\n      }\n      controller.enqueue(chunk);\n    }\n  }));\n  if (onFinish == null) {\n    return idInjectedStream;\n  }\n  const state = createStreamingUIMessageState({\n    lastMessage: lastMessage ? structuredClone(lastMessage) : void 0,\n    messageId: messageId != null ? messageId : \"\"\n    // will be overridden by the stream\n  });\n  const runUpdateMessageJob = async job => {\n    await job({\n      state,\n      write: () => {}\n    });\n  };\n  let finishCalled = false;\n  const callOnFinish = async () => {\n    if (finishCalled || !onFinish) {\n      return;\n    }\n    finishCalled = true;\n    const isContinuation = state.message.id === (lastMessage == null ? void 0 : lastMessage.id);\n    await onFinish({\n      isAborted: isAborted2,\n      isContinuation,\n      responseMessage: state.message,\n      messages: [...(isContinuation ? originalMessages.slice(0, -1) : originalMessages), state.message]\n    });\n  };\n  return processUIMessageStream({\n    stream: idInjectedStream,\n    runUpdateMessageJob,\n    onError\n  }).pipeThrough(new TransformStream({\n    transform(chunk, controller) {\n      controller.enqueue(chunk);\n    },\n    // @ts-expect-error cancel is still new and missing from types https://developer.mozilla.org/en-US/docs/Web/API/TransformStream#browser_compatibility\n    async cancel() {\n      await callOnFinish();\n    },\n    async flush() {\n      await callOnFinish();\n    }\n  }));\n}\nfunction pipeUIMessageStreamToResponse({\n  response,\n  status,\n  statusText,\n  headers,\n  stream,\n  consumeSseStream\n}) {\n  let sseStream = stream.pipeThrough(new JsonToSseTransformStream());\n  if (consumeSseStream) {\n    const [stream1, stream2] = sseStream.tee();\n    sseStream = stream1;\n    consumeSseStream({\n      stream: stream2\n    });\n  }\n  writeToServerResponse({\n    response,\n    status,\n    statusText,\n    headers: Object.fromEntries(prepareHeaders(headers, UI_MESSAGE_STREAM_HEADERS).entries()),\n    stream: sseStream.pipeThrough(new TextEncoderStream())\n  });\n}\nfunction createAsyncIterableStream(source) {\n  const stream = source.pipeThrough(new TransformStream());\n  stream[Symbol.asyncIterator] = function () {\n    const reader = this.getReader();\n    let finished = false;\n    async function cleanup(cancelStream) {\n      var _a172;\n      finished = true;\n      try {\n        if (cancelStream) {\n          await ((_a172 = reader.cancel) == null ? void 0 : _a172.call(reader));\n        }\n      } finally {\n        try {\n          reader.releaseLock();\n        } catch (e) {}\n      }\n    }\n    return {\n      /**\n       * Reads the next chunk from the stream.\n       * @returns A promise resolving to the next IteratorResult.\n       */\n      async next() {\n        if (finished) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        const {\n          done,\n          value\n        } = await reader.read();\n        if (done) {\n          await cleanup(true);\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        return {\n          done: false,\n          value\n        };\n      },\n      /**\n       * Called on early exit (e.g., break from for-await).\n       * Ensures the stream is cancelled and resources are released.\n       * @returns A promise resolving to a completed IteratorResult.\n       */\n      async return() {\n        await cleanup(true);\n        return {\n          done: true,\n          value: void 0\n        };\n      },\n      /**\n       * Called on early exit with error.\n       * Ensures the stream is cancelled and resources are released, then rethrows the error.\n       * @param err The error to throw.\n       * @returns A promise that rejects with the provided error.\n       */\n      async throw(err) {\n        await cleanup(true);\n        throw err;\n      }\n    };\n  };\n  return stream;\n}\nasync function consumeStream({\n  stream,\n  onError\n}) {\n  const reader = stream.getReader();\n  try {\n    while (true) {\n      const {\n        done\n      } = await reader.read();\n      if (done) break;\n    }\n  } catch (error40) {\n    onError == null ? void 0 : onError(error40);\n  } finally {\n    reader.releaseLock();\n  }\n}\nfunction createResolvablePromise() {\n  let resolve22;\n  let reject;\n  const promise2 = new Promise((res, rej) => {\n    resolve22 = res;\n    reject = rej;\n  });\n  return {\n    promise: promise2,\n    resolve: resolve22,\n    reject\n  };\n}\nfunction createStitchableStream() {\n  let innerStreamReaders = [];\n  let controller = null;\n  let isClosed = false;\n  let waitForNewStream = createResolvablePromise();\n  const terminate = () => {\n    isClosed = true;\n    waitForNewStream.resolve();\n    innerStreamReaders.forEach(reader => reader.cancel());\n    innerStreamReaders = [];\n    controller == null ? void 0 : controller.close();\n  };\n  const processPull = async () => {\n    if (isClosed && innerStreamReaders.length === 0) {\n      controller == null ? void 0 : controller.close();\n      return;\n    }\n    if (innerStreamReaders.length === 0) {\n      waitForNewStream = createResolvablePromise();\n      await waitForNewStream.promise;\n      return processPull();\n    }\n    try {\n      const {\n        value,\n        done\n      } = await innerStreamReaders[0].read();\n      if (done) {\n        innerStreamReaders.shift();\n        if (innerStreamReaders.length > 0) {\n          await processPull();\n        } else if (isClosed) {\n          controller == null ? void 0 : controller.close();\n        }\n      } else {\n        controller == null ? void 0 : controller.enqueue(value);\n      }\n    } catch (error40) {\n      controller == null ? void 0 : controller.error(error40);\n      innerStreamReaders.shift();\n      terminate();\n    }\n  };\n  return {\n    stream: new ReadableStream({\n      start(controllerParam) {\n        controller = controllerParam;\n      },\n      pull: processPull,\n      async cancel() {\n        for (const reader of innerStreamReaders) {\n          await reader.cancel();\n        }\n        innerStreamReaders = [];\n        isClosed = true;\n      }\n    }),\n    addStream: innerStream => {\n      if (isClosed) {\n        throw new Error(\"Cannot add inner stream: outer stream is closed\");\n      }\n      innerStreamReaders.push(innerStream.getReader());\n      waitForNewStream.resolve();\n    },\n    /**\n     * Gracefully close the outer stream. This will let the inner streams\n     * finish processing and then close the outer stream.\n     */\n    close: () => {\n      isClosed = true;\n      waitForNewStream.resolve();\n      if (innerStreamReaders.length === 0) {\n        controller == null ? void 0 : controller.close();\n      }\n    },\n    /**\n     * Immediately close the outer stream. This will cancel all inner streams\n     * and close the outer stream.\n     */\n    terminate\n  };\n}\nvar DelayedPromise = class {\n  constructor() {\n    this.status = {\n      type: \"pending\"\n    };\n    this._resolve = void 0;\n    this._reject = void 0;\n  }\n  get promise() {\n    if (this._promise) {\n      return this._promise;\n    }\n    this._promise = new Promise((resolve22, reject) => {\n      if (this.status.type === \"resolved\") {\n        resolve22(this.status.value);\n      } else if (this.status.type === \"rejected\") {\n        reject(this.status.error);\n      }\n      this._resolve = resolve22;\n      this._reject = reject;\n    });\n    return this._promise;\n  }\n  resolve(value) {\n    var _a172;\n    this.status = {\n      type: \"resolved\",\n      value\n    };\n    if (this._promise) {\n      (_a172 = this._resolve) == null ? void 0 : _a172.call(this, value);\n    }\n  }\n  reject(error40) {\n    var _a172;\n    this.status = {\n      type: \"rejected\",\n      error: error40\n    };\n    if (this._promise) {\n      (_a172 = this._reject) == null ? void 0 : _a172.call(this, error40);\n    }\n  }\n};\nfunction now() {\n  var _a172, _b8;\n  return (_b8 = (_a172 = globalThis == null ? void 0 : globalThis.performance) == null ? void 0 : _a172.now()) != null ? _b8 : Date.now();\n}\nfunction runToolsTransformation({\n  tools,\n  generatorStream,\n  tracer,\n  telemetry,\n  system,\n  messages,\n  abortSignal,\n  repairToolCall,\n  experimental_context\n}) {\n  let toolResultsStreamController = null;\n  const toolResultsStream = new ReadableStream({\n    start(controller) {\n      toolResultsStreamController = controller;\n    }\n  });\n  const outstandingToolResults = /* @__PURE__ */new Set();\n  const toolInputs = /* @__PURE__ */new Map();\n  let canClose = false;\n  let finishChunk = void 0;\n  function attemptClose() {\n    if (canClose && outstandingToolResults.size === 0) {\n      if (finishChunk != null) {\n        toolResultsStreamController.enqueue(finishChunk);\n      }\n      toolResultsStreamController.close();\n    }\n  }\n  const forwardStream = new TransformStream({\n    async transform(chunk, controller) {\n      const chunkType = chunk.type;\n      switch (chunkType) {\n        case \"stream-start\":\n        case \"text-start\":\n        case \"text-delta\":\n        case \"text-end\":\n        case \"reasoning-start\":\n        case \"reasoning-delta\":\n        case \"reasoning-end\":\n        case \"tool-input-start\":\n        case \"tool-input-delta\":\n        case \"tool-input-end\":\n        case \"source\":\n        case \"response-metadata\":\n        case \"error\":\n        case \"raw\":\n          {\n            controller.enqueue(chunk);\n            break;\n          }\n        case \"file\":\n          {\n            controller.enqueue({\n              type: \"file\",\n              file: new DefaultGeneratedFileWithType({\n                data: chunk.data,\n                mediaType: chunk.mediaType\n              })\n            });\n            break;\n          }\n        case \"finish\":\n          {\n            finishChunk = {\n              type: \"finish\",\n              finishReason: chunk.finishReason,\n              usage: chunk.usage,\n              providerMetadata: chunk.providerMetadata\n            };\n            break;\n          }\n        case \"tool-call\":\n          {\n            try {\n              const toolCall = await parseToolCall({\n                toolCall: chunk,\n                tools,\n                repairToolCall,\n                system,\n                messages\n              });\n              controller.enqueue(toolCall);\n              if (toolCall.invalid) {\n                toolResultsStreamController.enqueue({\n                  type: \"tool-error\",\n                  toolCallId: toolCall.toolCallId,\n                  toolName: toolCall.toolName,\n                  input: toolCall.input,\n                  error: getErrorMessage3(toolCall.error),\n                  dynamic: true\n                });\n                break;\n              }\n              const tool3 = tools[toolCall.toolName];\n              toolInputs.set(toolCall.toolCallId, toolCall.input);\n              if (tool3.onInputAvailable != null) {\n                await tool3.onInputAvailable({\n                  input: toolCall.input,\n                  toolCallId: toolCall.toolCallId,\n                  messages,\n                  abortSignal,\n                  experimental_context\n                });\n              }\n              if (tool3.execute != null && toolCall.providerExecuted !== true) {\n                const toolExecutionId = generateId2();\n                outstandingToolResults.add(toolExecutionId);\n                recordSpan({\n                  name: \"ai.toolCall\",\n                  attributes: selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      ...assembleOperationName({\n                        operationId: \"ai.toolCall\",\n                        telemetry\n                      }),\n                      \"ai.toolCall.name\": toolCall.toolName,\n                      \"ai.toolCall.id\": toolCall.toolCallId,\n                      \"ai.toolCall.args\": {\n                        output: () => JSON.stringify(toolCall.input)\n                      }\n                    }\n                  }),\n                  tracer,\n                  fn: async span => {\n                    let output;\n                    try {\n                      const stream = executeTool({\n                        execute: tool3.execute.bind(tool3),\n                        input: toolCall.input,\n                        options: {\n                          toolCallId: toolCall.toolCallId,\n                          messages,\n                          abortSignal,\n                          experimental_context\n                        }\n                      });\n                      for await (const part of stream) {\n                        toolResultsStreamController.enqueue({\n                          ...toolCall,\n                          type: \"tool-result\",\n                          output: part.output,\n                          ...(part.type === \"preliminary\" && {\n                            preliminary: true\n                          })\n                        });\n                        if (part.type === \"final\") {\n                          output = part.output;\n                        }\n                      }\n                    } catch (error40) {\n                      recordErrorOnSpan(span, error40);\n                      toolResultsStreamController.enqueue({\n                        ...toolCall,\n                        type: \"tool-error\",\n                        error: error40\n                      });\n                      outstandingToolResults.delete(toolExecutionId);\n                      attemptClose();\n                      return;\n                    }\n                    outstandingToolResults.delete(toolExecutionId);\n                    attemptClose();\n                    try {\n                      span.setAttributes(selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                          \"ai.toolCall.result\": {\n                            output: () => JSON.stringify(output)\n                          }\n                        }\n                      }));\n                    } catch (ignored) {}\n                  }\n                });\n              }\n            } catch (error40) {\n              toolResultsStreamController.enqueue({\n                type: \"error\",\n                error: error40\n              });\n            }\n            break;\n          }\n        case \"tool-result\":\n          {\n            const toolName = chunk.toolName;\n            if (chunk.isError) {\n              toolResultsStreamController.enqueue({\n                type: \"tool-error\",\n                toolCallId: chunk.toolCallId,\n                toolName,\n                input: toolInputs.get(chunk.toolCallId),\n                providerExecuted: chunk.providerExecuted,\n                error: chunk.result\n              });\n            } else {\n              controller.enqueue({\n                type: \"tool-result\",\n                toolCallId: chunk.toolCallId,\n                toolName,\n                input: toolInputs.get(chunk.toolCallId),\n                output: chunk.result,\n                providerExecuted: chunk.providerExecuted\n              });\n            }\n            break;\n          }\n        default:\n          {\n            const _exhaustiveCheck = chunkType;\n            throw new Error(`Unhandled chunk type: ${_exhaustiveCheck}`);\n          }\n      }\n    },\n    flush() {\n      canClose = true;\n      attemptClose();\n    }\n  });\n  return new ReadableStream({\n    async start(controller) {\n      return Promise.all([generatorStream.pipeThrough(forwardStream).pipeTo(new WritableStream({\n        write(chunk) {\n          controller.enqueue(chunk);\n        },\n        close() {}\n      })), toolResultsStream.pipeTo(new WritableStream({\n        write(chunk) {\n          controller.enqueue(chunk);\n        },\n        close() {\n          controller.close();\n        }\n      }))]);\n    }\n  });\n}\nvar originalGenerateId2 = createIdGenerator2({\n  prefix: \"aitxt\",\n  size: 24\n});\nfunction streamText({\n  model,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  stopWhen = stepCountIs(1),\n  experimental_output: output,\n  experimental_telemetry: telemetry,\n  prepareStep,\n  providerOptions,\n  experimental_activeTools,\n  activeTools = experimental_activeTools,\n  experimental_repairToolCall: repairToolCall,\n  experimental_transform: transform2,\n  experimental_download: download2,\n  includeRawChunks = false,\n  onChunk,\n  onError = ({\n    error: error40\n  }) => {\n    console.error(error40);\n  },\n  onFinish,\n  onAbort,\n  onStepFinish,\n  experimental_context,\n  _internal: {\n    now: now2 = now,\n    generateId: generateId32 = originalGenerateId2,\n    currentDate = () => /* @__PURE__ */new Date()\n  } = {},\n  ...settings\n}) {\n  return new DefaultStreamTextResult({\n    model: resolveLanguageModel(model),\n    telemetry,\n    headers,\n    settings,\n    maxRetries,\n    abortSignal,\n    system,\n    prompt,\n    messages,\n    tools,\n    toolChoice,\n    transforms: asArray(transform2),\n    activeTools,\n    repairToolCall,\n    stopConditions: asArray(stopWhen),\n    output,\n    providerOptions,\n    prepareStep,\n    includeRawChunks,\n    onChunk,\n    onError,\n    onFinish,\n    onAbort,\n    onStepFinish,\n    now: now2,\n    currentDate,\n    generateId: generateId32,\n    experimental_context,\n    download: download2\n  });\n}\nfunction createOutputTransformStream(output) {\n  if (!output) {\n    return new TransformStream({\n      transform(chunk, controller) {\n        controller.enqueue({\n          part: chunk,\n          partialOutput: void 0\n        });\n      }\n    });\n  }\n  let firstTextChunkId = void 0;\n  let text2 = \"\";\n  let textChunk = \"\";\n  let lastPublishedJson = \"\";\n  function publishTextChunk({\n    controller,\n    partialOutput = void 0\n  }) {\n    controller.enqueue({\n      part: {\n        type: \"text-delta\",\n        id: firstTextChunkId,\n        text: textChunk\n      },\n      partialOutput\n    });\n    textChunk = \"\";\n  }\n  return new TransformStream({\n    async transform(chunk, controller) {\n      if (chunk.type === \"finish-step\" && textChunk.length > 0) {\n        publishTextChunk({\n          controller\n        });\n      }\n      if (chunk.type !== \"text-delta\" && chunk.type !== \"text-start\" && chunk.type !== \"text-end\") {\n        controller.enqueue({\n          part: chunk,\n          partialOutput: void 0\n        });\n        return;\n      }\n      if (firstTextChunkId == null) {\n        firstTextChunkId = chunk.id;\n      } else if (chunk.id !== firstTextChunkId) {\n        controller.enqueue({\n          part: chunk,\n          partialOutput: void 0\n        });\n        return;\n      }\n      if (chunk.type === \"text-start\") {\n        controller.enqueue({\n          part: chunk,\n          partialOutput: void 0\n        });\n        return;\n      }\n      if (chunk.type === \"text-end\") {\n        if (textChunk.length > 0) {\n          publishTextChunk({\n            controller\n          });\n        }\n        controller.enqueue({\n          part: chunk,\n          partialOutput: void 0\n        });\n        return;\n      }\n      text2 += chunk.text;\n      textChunk += chunk.text;\n      const result = await output.parsePartial({\n        text: text2\n      });\n      if (result != null) {\n        const currentJson = JSON.stringify(result.partial);\n        if (currentJson !== lastPublishedJson) {\n          publishTextChunk({\n            controller,\n            partialOutput: result.partial\n          });\n          lastPublishedJson = currentJson;\n        }\n      }\n    }\n  });\n}\nvar DefaultStreamTextResult = class {\n  constructor({\n    model,\n    telemetry,\n    headers,\n    settings,\n    maxRetries: maxRetriesArg,\n    abortSignal,\n    system,\n    prompt,\n    messages,\n    tools,\n    toolChoice,\n    transforms,\n    activeTools,\n    repairToolCall,\n    stopConditions,\n    output,\n    providerOptions,\n    prepareStep,\n    includeRawChunks,\n    now: now2,\n    currentDate,\n    generateId: generateId32,\n    onChunk,\n    onError,\n    onFinish,\n    onAbort,\n    onStepFinish,\n    experimental_context,\n    download: download2\n  }) {\n    this._totalUsage = new DelayedPromise();\n    this._finishReason = new DelayedPromise();\n    this._steps = new DelayedPromise();\n    this.output = output;\n    this.includeRawChunks = includeRawChunks;\n    this.tools = tools;\n    let stepFinish;\n    let recordedContent = [];\n    const recordedResponseMessages = [];\n    let recordedFinishReason = void 0;\n    let recordedTotalUsage = void 0;\n    let recordedRequest = {};\n    let recordedWarnings = [];\n    const recordedSteps = [];\n    let rootSpan;\n    let activeTextContent = {};\n    let activeReasoningContent = {};\n    const eventProcessor = new TransformStream({\n      async transform(chunk, controller) {\n        var _a172, _b8, _c;\n        controller.enqueue(chunk);\n        const {\n          part\n        } = chunk;\n        if (part.type === \"text-delta\" || part.type === \"reasoning-delta\" || part.type === \"source\" || part.type === \"tool-call\" || part.type === \"tool-result\" || part.type === \"tool-input-start\" || part.type === \"tool-input-delta\" || part.type === \"raw\") {\n          await (onChunk == null ? void 0 : onChunk({\n            chunk: part\n          }));\n        }\n        if (part.type === \"error\") {\n          await onError({\n            error: wrapGatewayError(part.error)\n          });\n        }\n        if (part.type === \"text-start\") {\n          activeTextContent[part.id] = {\n            type: \"text\",\n            text: \"\",\n            providerMetadata: part.providerMetadata\n          };\n          recordedContent.push(activeTextContent[part.id]);\n        }\n        if (part.type === \"text-delta\") {\n          const activeText = activeTextContent[part.id];\n          if (activeText == null) {\n            controller.enqueue({\n              part: {\n                type: \"error\",\n                error: `text part ${part.id} not found`\n              },\n              partialOutput: void 0\n            });\n            return;\n          }\n          activeText.text += part.text;\n          activeText.providerMetadata = (_a172 = part.providerMetadata) != null ? _a172 : activeText.providerMetadata;\n        }\n        if (part.type === \"text-end\") {\n          delete activeTextContent[part.id];\n        }\n        if (part.type === \"reasoning-start\") {\n          activeReasoningContent[part.id] = {\n            type: \"reasoning\",\n            text: \"\",\n            providerMetadata: part.providerMetadata\n          };\n          recordedContent.push(activeReasoningContent[part.id]);\n        }\n        if (part.type === \"reasoning-delta\") {\n          const activeReasoning = activeReasoningContent[part.id];\n          if (activeReasoning == null) {\n            controller.enqueue({\n              part: {\n                type: \"error\",\n                error: `reasoning part ${part.id} not found`\n              },\n              partialOutput: void 0\n            });\n            return;\n          }\n          activeReasoning.text += part.text;\n          activeReasoning.providerMetadata = (_b8 = part.providerMetadata) != null ? _b8 : activeReasoning.providerMetadata;\n        }\n        if (part.type === \"reasoning-end\") {\n          const activeReasoning = activeReasoningContent[part.id];\n          if (activeReasoning == null) {\n            controller.enqueue({\n              part: {\n                type: \"error\",\n                error: `reasoning part ${part.id} not found`\n              },\n              partialOutput: void 0\n            });\n            return;\n          }\n          activeReasoning.providerMetadata = (_c = part.providerMetadata) != null ? _c : activeReasoning.providerMetadata;\n          delete activeReasoningContent[part.id];\n        }\n        if (part.type === \"file\") {\n          recordedContent.push({\n            type: \"file\",\n            file: part.file\n          });\n        }\n        if (part.type === \"source\") {\n          recordedContent.push(part);\n        }\n        if (part.type === \"tool-call\") {\n          recordedContent.push(part);\n        }\n        if (part.type === \"tool-result\" && !part.preliminary) {\n          recordedContent.push(part);\n        }\n        if (part.type === \"tool-error\") {\n          recordedContent.push(part);\n        }\n        if (part.type === \"start-step\") {\n          recordedRequest = part.request;\n          recordedWarnings = part.warnings;\n        }\n        if (part.type === \"finish-step\") {\n          const stepMessages = toResponseMessages({\n            content: recordedContent,\n            tools\n          });\n          const currentStepResult = new DefaultStepResult({\n            content: recordedContent,\n            finishReason: part.finishReason,\n            usage: part.usage,\n            warnings: recordedWarnings,\n            request: recordedRequest,\n            response: {\n              ...part.response,\n              messages: [...recordedResponseMessages, ...stepMessages]\n            },\n            providerMetadata: part.providerMetadata\n          });\n          await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));\n          logWarnings(recordedWarnings);\n          recordedSteps.push(currentStepResult);\n          recordedContent = [];\n          activeReasoningContent = {};\n          activeTextContent = {};\n          recordedResponseMessages.push(...stepMessages);\n          stepFinish.resolve();\n        }\n        if (part.type === \"finish\") {\n          recordedTotalUsage = part.totalUsage;\n          recordedFinishReason = part.finishReason;\n        }\n      },\n      async flush(controller) {\n        try {\n          if (recordedSteps.length === 0) {\n            const error40 = new NoOutputGeneratedError({\n              message: \"No output generated. Check the stream for errors.\"\n            });\n            self._finishReason.reject(error40);\n            self._totalUsage.reject(error40);\n            self._steps.reject(error40);\n            return;\n          }\n          const finishReason = recordedFinishReason != null ? recordedFinishReason : \"unknown\";\n          const totalUsage = recordedTotalUsage != null ? recordedTotalUsage : {\n            inputTokens: void 0,\n            outputTokens: void 0,\n            totalTokens: void 0\n          };\n          self._finishReason.resolve(finishReason);\n          self._totalUsage.resolve(totalUsage);\n          self._steps.resolve(recordedSteps);\n          const finalStep = recordedSteps[recordedSteps.length - 1];\n          await (onFinish == null ? void 0 : onFinish({\n            finishReason,\n            totalUsage,\n            usage: finalStep.usage,\n            content: finalStep.content,\n            text: finalStep.text,\n            reasoningText: finalStep.reasoningText,\n            reasoning: finalStep.reasoning,\n            files: finalStep.files,\n            sources: finalStep.sources,\n            toolCalls: finalStep.toolCalls,\n            staticToolCalls: finalStep.staticToolCalls,\n            dynamicToolCalls: finalStep.dynamicToolCalls,\n            toolResults: finalStep.toolResults,\n            staticToolResults: finalStep.staticToolResults,\n            dynamicToolResults: finalStep.dynamicToolResults,\n            request: finalStep.request,\n            response: finalStep.response,\n            warnings: finalStep.warnings,\n            providerMetadata: finalStep.providerMetadata,\n            steps: recordedSteps\n          }));\n          rootSpan.setAttributes(selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              \"ai.response.finishReason\": finishReason,\n              \"ai.response.text\": {\n                output: () => finalStep.text\n              },\n              \"ai.response.toolCalls\": {\n                output: () => {\n                  var _a172;\n                  return ((_a172 = finalStep.toolCalls) == null ? void 0 : _a172.length) ? JSON.stringify(finalStep.toolCalls) : void 0;\n                }\n              },\n              \"ai.response.providerMetadata\": JSON.stringify(finalStep.providerMetadata),\n              \"ai.usage.inputTokens\": totalUsage.inputTokens,\n              \"ai.usage.outputTokens\": totalUsage.outputTokens,\n              \"ai.usage.totalTokens\": totalUsage.totalTokens,\n              \"ai.usage.reasoningTokens\": totalUsage.reasoningTokens,\n              \"ai.usage.cachedInputTokens\": totalUsage.cachedInputTokens\n            }\n          }));\n        } catch (error40) {\n          controller.error(error40);\n        } finally {\n          rootSpan.end();\n        }\n      }\n    });\n    const stitchableStream = createStitchableStream();\n    this.addStream = stitchableStream.addStream;\n    this.closeStream = stitchableStream.close;\n    const reader = stitchableStream.stream.getReader();\n    let stream = new ReadableStream({\n      async start(controller) {\n        controller.enqueue({\n          type: \"start\"\n        });\n      },\n      async pull(controller) {\n        function abort() {\n          onAbort == null ? void 0 : onAbort({\n            steps: recordedSteps\n          });\n          controller.enqueue({\n            type: \"abort\"\n          });\n          controller.close();\n        }\n        try {\n          const {\n            done,\n            value\n          } = await reader.read();\n          if (done) {\n            controller.close();\n            return;\n          }\n          if (abortSignal == null ? void 0 : abortSignal.aborted) {\n            abort();\n            return;\n          }\n          controller.enqueue(value);\n        } catch (error40) {\n          if (isAbortError2(error40) && (abortSignal == null ? void 0 : abortSignal.aborted)) {\n            abort();\n          } else {\n            controller.error(error40);\n          }\n        }\n      },\n      cancel(reason) {\n        return stitchableStream.stream.cancel(reason);\n      }\n    });\n    for (const transform2 of transforms) {\n      stream = stream.pipeThrough(transform2({\n        tools,\n        stopStream() {\n          stitchableStream.terminate();\n        }\n      }));\n    }\n    this.baseStream = stream.pipeThrough(createOutputTransformStream(output)).pipeThrough(eventProcessor);\n    const {\n      maxRetries,\n      retry\n    } = prepareRetries({\n      maxRetries: maxRetriesArg,\n      abortSignal\n    });\n    const tracer = getTracer(telemetry);\n    const callSettings = prepareCallSettings(settings);\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n      model,\n      telemetry,\n      headers,\n      settings: {\n        ...callSettings,\n        maxRetries\n      }\n    });\n    const self = this;\n    recordSpan({\n      name: \"ai.streamText\",\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({\n            operationId: \"ai.streamText\",\n            telemetry\n          }),\n          ...baseTelemetryAttributes,\n          // specific settings that only make sense on the outer level:\n          \"ai.prompt\": {\n            input: () => JSON.stringify({\n              system,\n              prompt,\n              messages\n            })\n          }\n        }\n      }),\n      tracer,\n      endWhenDone: false,\n      fn: async rootSpanArg => {\n        rootSpan = rootSpanArg;\n        async function streamStep({\n          currentStep,\n          responseMessages,\n          usage\n        }) {\n          var _a172, _b8, _c, _d, _e;\n          const includeRawChunks2 = self.includeRawChunks;\n          stepFinish = new DelayedPromise();\n          const initialPrompt = await standardizePrompt({\n            system,\n            prompt,\n            messages\n          });\n          const stepInputMessages = [...initialPrompt.messages, ...responseMessages];\n          const prepareStepResult = await (prepareStep == null ? void 0 : prepareStep({\n            model,\n            steps: recordedSteps,\n            stepNumber: recordedSteps.length,\n            messages: stepInputMessages\n          }));\n          const promptMessages = await convertToLanguageModelPrompt({\n            prompt: {\n              system: (_a172 = prepareStepResult == null ? void 0 : prepareStepResult.system) != null ? _a172 : initialPrompt.system,\n              messages: (_b8 = prepareStepResult == null ? void 0 : prepareStepResult.messages) != null ? _b8 : stepInputMessages\n            },\n            supportedUrls: await model.supportedUrls,\n            download: download2\n          });\n          const stepModel = resolveLanguageModel((_c = prepareStepResult == null ? void 0 : prepareStepResult.model) != null ? _c : model);\n          const {\n            toolChoice: stepToolChoice,\n            tools: stepTools\n          } = prepareToolsAndToolChoice({\n            tools,\n            toolChoice: (_d = prepareStepResult == null ? void 0 : prepareStepResult.toolChoice) != null ? _d : toolChoice,\n            activeTools: (_e = prepareStepResult == null ? void 0 : prepareStepResult.activeTools) != null ? _e : activeTools\n          });\n          const {\n            result: {\n              stream: stream2,\n              response,\n              request\n            },\n            doStreamSpan,\n            startTimestampMs\n          } = await retry(() => recordSpan({\n            name: \"ai.streamText.doStream\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: \"ai.streamText.doStream\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // model:\n                \"ai.model.provider\": stepModel.provider,\n                \"ai.model.id\": stepModel.modelId,\n                // prompt:\n                \"ai.prompt.messages\": {\n                  input: () => stringifyForTelemetry(promptMessages)\n                },\n                \"ai.prompt.tools\": {\n                  // convert the language model level tools:\n                  input: () => stepTools == null ? void 0 : stepTools.map(tool3 => JSON.stringify(tool3))\n                },\n                \"ai.prompt.toolChoice\": {\n                  input: () => stepToolChoice != null ? JSON.stringify(stepToolChoice) : void 0\n                },\n                // standardized gen-ai llm span attributes:\n                \"gen_ai.system\": stepModel.provider,\n                \"gen_ai.request.model\": stepModel.modelId,\n                \"gen_ai.request.frequency_penalty\": callSettings.frequencyPenalty,\n                \"gen_ai.request.max_tokens\": callSettings.maxOutputTokens,\n                \"gen_ai.request.presence_penalty\": callSettings.presencePenalty,\n                \"gen_ai.request.stop_sequences\": callSettings.stopSequences,\n                \"gen_ai.request.temperature\": callSettings.temperature,\n                \"gen_ai.request.top_k\": callSettings.topK,\n                \"gen_ai.request.top_p\": callSettings.topP\n              }\n            }),\n            tracer,\n            endWhenDone: false,\n            fn: async doStreamSpan2 => {\n              return {\n                startTimestampMs: now2(),\n                // get before the call\n                doStreamSpan: doStreamSpan2,\n                result: await stepModel.doStream({\n                  ...callSettings,\n                  tools: stepTools,\n                  toolChoice: stepToolChoice,\n                  responseFormat: output == null ? void 0 : output.responseFormat,\n                  prompt: promptMessages,\n                  providerOptions,\n                  abortSignal,\n                  headers,\n                  includeRawChunks: includeRawChunks2\n                })\n              };\n            }\n          }));\n          const streamWithToolResults = runToolsTransformation({\n            tools,\n            generatorStream: stream2,\n            tracer,\n            telemetry,\n            system,\n            messages: stepInputMessages,\n            repairToolCall,\n            abortSignal,\n            experimental_context\n          });\n          const stepRequest = request != null ? request : {};\n          const stepToolCalls = [];\n          const stepToolOutputs = [];\n          let warnings;\n          const activeToolCallToolNames = {};\n          let stepFinishReason = \"unknown\";\n          let stepUsage = {\n            inputTokens: void 0,\n            outputTokens: void 0,\n            totalTokens: void 0\n          };\n          let stepProviderMetadata;\n          let stepFirstChunk = true;\n          let stepResponse = {\n            id: generateId32(),\n            timestamp: currentDate(),\n            modelId: model.modelId\n          };\n          let activeText = \"\";\n          self.addStream(streamWithToolResults.pipeThrough(new TransformStream({\n            async transform(chunk, controller) {\n              var _a182, _b22, _c2, _d2;\n              if (chunk.type === \"stream-start\") {\n                warnings = chunk.warnings;\n                return;\n              }\n              if (stepFirstChunk) {\n                const msToFirstChunk = now2() - startTimestampMs;\n                stepFirstChunk = false;\n                doStreamSpan.addEvent(\"ai.stream.firstChunk\", {\n                  \"ai.response.msToFirstChunk\": msToFirstChunk\n                });\n                doStreamSpan.setAttributes({\n                  \"ai.response.msToFirstChunk\": msToFirstChunk\n                });\n                controller.enqueue({\n                  type: \"start-step\",\n                  request: stepRequest,\n                  warnings: warnings != null ? warnings : []\n                });\n              }\n              const chunkType = chunk.type;\n              switch (chunkType) {\n                case \"text-start\":\n                case \"text-end\":\n                  {\n                    controller.enqueue(chunk);\n                    break;\n                  }\n                case \"text-delta\":\n                  {\n                    if (chunk.delta.length > 0) {\n                      controller.enqueue({\n                        type: \"text-delta\",\n                        id: chunk.id,\n                        text: chunk.delta,\n                        providerMetadata: chunk.providerMetadata\n                      });\n                      activeText += chunk.delta;\n                    }\n                    break;\n                  }\n                case \"reasoning-start\":\n                case \"reasoning-end\":\n                  {\n                    controller.enqueue(chunk);\n                    break;\n                  }\n                case \"reasoning-delta\":\n                  {\n                    controller.enqueue({\n                      type: \"reasoning-delta\",\n                      id: chunk.id,\n                      text: chunk.delta,\n                      providerMetadata: chunk.providerMetadata\n                    });\n                    break;\n                  }\n                case \"tool-call\":\n                  {\n                    controller.enqueue(chunk);\n                    stepToolCalls.push(chunk);\n                    break;\n                  }\n                case \"tool-result\":\n                  {\n                    controller.enqueue(chunk);\n                    if (!chunk.preliminary) {\n                      stepToolOutputs.push(chunk);\n                    }\n                    break;\n                  }\n                case \"tool-error\":\n                  {\n                    controller.enqueue(chunk);\n                    stepToolOutputs.push(chunk);\n                    break;\n                  }\n                case \"response-metadata\":\n                  {\n                    stepResponse = {\n                      id: (_a182 = chunk.id) != null ? _a182 : stepResponse.id,\n                      timestamp: (_b22 = chunk.timestamp) != null ? _b22 : stepResponse.timestamp,\n                      modelId: (_c2 = chunk.modelId) != null ? _c2 : stepResponse.modelId\n                    };\n                    break;\n                  }\n                case \"finish\":\n                  {\n                    stepUsage = chunk.usage;\n                    stepFinishReason = chunk.finishReason;\n                    stepProviderMetadata = chunk.providerMetadata;\n                    const msToFinish = now2() - startTimestampMs;\n                    doStreamSpan.addEvent(\"ai.stream.finish\");\n                    doStreamSpan.setAttributes({\n                      \"ai.response.msToFinish\": msToFinish,\n                      \"ai.response.avgOutputTokensPerSecond\": 1e3 * ((_d2 = stepUsage.outputTokens) != null ? _d2 : 0) / msToFinish\n                    });\n                    break;\n                  }\n                case \"file\":\n                  {\n                    controller.enqueue(chunk);\n                    break;\n                  }\n                case \"source\":\n                  {\n                    controller.enqueue(chunk);\n                    break;\n                  }\n                case \"tool-input-start\":\n                  {\n                    activeToolCallToolNames[chunk.id] = chunk.toolName;\n                    const tool3 = tools == null ? void 0 : tools[chunk.toolName];\n                    if ((tool3 == null ? void 0 : tool3.onInputStart) != null) {\n                      await tool3.onInputStart({\n                        toolCallId: chunk.id,\n                        messages: stepInputMessages,\n                        abortSignal,\n                        experimental_context\n                      });\n                    }\n                    controller.enqueue({\n                      ...chunk,\n                      dynamic: (tool3 == null ? void 0 : tool3.type) === \"dynamic\"\n                    });\n                    break;\n                  }\n                case \"tool-input-end\":\n                  {\n                    delete activeToolCallToolNames[chunk.id];\n                    controller.enqueue(chunk);\n                    break;\n                  }\n                case \"tool-input-delta\":\n                  {\n                    const toolName = activeToolCallToolNames[chunk.id];\n                    const tool3 = tools == null ? void 0 : tools[toolName];\n                    if ((tool3 == null ? void 0 : tool3.onInputDelta) != null) {\n                      await tool3.onInputDelta({\n                        inputTextDelta: chunk.delta,\n                        toolCallId: chunk.id,\n                        messages: stepInputMessages,\n                        abortSignal,\n                        experimental_context\n                      });\n                    }\n                    controller.enqueue(chunk);\n                    break;\n                  }\n                case \"error\":\n                  {\n                    controller.enqueue(chunk);\n                    stepFinishReason = \"error\";\n                    break;\n                  }\n                case \"raw\":\n                  {\n                    if (includeRawChunks2) {\n                      controller.enqueue(chunk);\n                    }\n                    break;\n                  }\n                default:\n                  {\n                    const exhaustiveCheck = chunkType;\n                    throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n                  }\n              }\n            },\n            // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n            async flush(controller) {\n              const stepToolCallsJson = stepToolCalls.length > 0 ? JSON.stringify(stepToolCalls) : void 0;\n              try {\n                doStreamSpan.setAttributes(selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.response.finishReason\": stepFinishReason,\n                    \"ai.response.text\": {\n                      output: () => activeText\n                    },\n                    \"ai.response.toolCalls\": {\n                      output: () => stepToolCallsJson\n                    },\n                    \"ai.response.id\": stepResponse.id,\n                    \"ai.response.model\": stepResponse.modelId,\n                    \"ai.response.timestamp\": stepResponse.timestamp.toISOString(),\n                    \"ai.response.providerMetadata\": JSON.stringify(stepProviderMetadata),\n                    \"ai.usage.inputTokens\": stepUsage.inputTokens,\n                    \"ai.usage.outputTokens\": stepUsage.outputTokens,\n                    \"ai.usage.totalTokens\": stepUsage.totalTokens,\n                    \"ai.usage.reasoningTokens\": stepUsage.reasoningTokens,\n                    \"ai.usage.cachedInputTokens\": stepUsage.cachedInputTokens,\n                    // standardized gen-ai llm span attributes:\n                    \"gen_ai.response.finish_reasons\": [stepFinishReason],\n                    \"gen_ai.response.id\": stepResponse.id,\n                    \"gen_ai.response.model\": stepResponse.modelId,\n                    \"gen_ai.usage.input_tokens\": stepUsage.inputTokens,\n                    \"gen_ai.usage.output_tokens\": stepUsage.outputTokens\n                  }\n                }));\n              } catch (error40) {} finally {\n                doStreamSpan.end();\n              }\n              controller.enqueue({\n                type: \"finish-step\",\n                finishReason: stepFinishReason,\n                usage: stepUsage,\n                providerMetadata: stepProviderMetadata,\n                response: {\n                  ...stepResponse,\n                  headers: response == null ? void 0 : response.headers\n                }\n              });\n              const combinedUsage = addLanguageModelUsage(usage, stepUsage);\n              await stepFinish.promise;\n              const clientToolCalls = stepToolCalls.filter(toolCall => toolCall.providerExecuted !== true);\n              const clientToolOutputs = stepToolOutputs.filter(toolOutput => toolOutput.providerExecuted !== true);\n              if (clientToolCalls.length > 0 &&\n              // all current tool calls have outputs (incl. execution errors):\n              clientToolOutputs.length === clientToolCalls.length &&\n              // continue until a stop condition is met:\n              !(await isStopConditionMet({\n                stopConditions,\n                steps: recordedSteps\n              }))) {\n                responseMessages.push(...toResponseMessages({\n                  content:\n                  // use transformed content to create the messages for the next step:\n                  recordedSteps[recordedSteps.length - 1].content,\n                  tools\n                }));\n                try {\n                  await streamStep({\n                    currentStep: currentStep + 1,\n                    responseMessages,\n                    usage: combinedUsage\n                  });\n                } catch (error40) {\n                  controller.enqueue({\n                    type: \"error\",\n                    error: error40\n                  });\n                  self.closeStream();\n                }\n              } else {\n                controller.enqueue({\n                  type: \"finish\",\n                  finishReason: stepFinishReason,\n                  totalUsage: combinedUsage\n                });\n                self.closeStream();\n              }\n            }\n          })));\n        }\n        await streamStep({\n          currentStep: 0,\n          responseMessages: [],\n          usage: {\n            inputTokens: void 0,\n            outputTokens: void 0,\n            totalTokens: void 0\n          }\n        });\n      }\n    }).catch(error40 => {\n      self.addStream(new ReadableStream({\n        start(controller) {\n          controller.enqueue({\n            type: \"error\",\n            error: error40\n          });\n          controller.close();\n        }\n      }));\n      self.closeStream();\n    });\n  }\n  get steps() {\n    this.consumeStream();\n    return this._steps.promise;\n  }\n  get finalStep() {\n    return this.steps.then(steps => steps[steps.length - 1]);\n  }\n  get content() {\n    return this.finalStep.then(step => step.content);\n  }\n  get warnings() {\n    return this.finalStep.then(step => step.warnings);\n  }\n  get providerMetadata() {\n    return this.finalStep.then(step => step.providerMetadata);\n  }\n  get text() {\n    return this.finalStep.then(step => step.text);\n  }\n  get reasoningText() {\n    return this.finalStep.then(step => step.reasoningText);\n  }\n  get reasoning() {\n    return this.finalStep.then(step => step.reasoning);\n  }\n  get sources() {\n    return this.finalStep.then(step => step.sources);\n  }\n  get files() {\n    return this.finalStep.then(step => step.files);\n  }\n  get toolCalls() {\n    return this.finalStep.then(step => step.toolCalls);\n  }\n  get staticToolCalls() {\n    return this.finalStep.then(step => step.staticToolCalls);\n  }\n  get dynamicToolCalls() {\n    return this.finalStep.then(step => step.dynamicToolCalls);\n  }\n  get toolResults() {\n    return this.finalStep.then(step => step.toolResults);\n  }\n  get staticToolResults() {\n    return this.finalStep.then(step => step.staticToolResults);\n  }\n  get dynamicToolResults() {\n    return this.finalStep.then(step => step.dynamicToolResults);\n  }\n  get usage() {\n    return this.finalStep.then(step => step.usage);\n  }\n  get request() {\n    return this.finalStep.then(step => step.request);\n  }\n  get response() {\n    return this.finalStep.then(step => step.response);\n  }\n  get totalUsage() {\n    this.consumeStream();\n    return this._totalUsage.promise;\n  }\n  get finishReason() {\n    this.consumeStream();\n    return this._finishReason.promise;\n  }\n  /**\n  Split out a new stream from the original stream.\n  The original stream is replaced to allow for further splitting,\n  since we do not know how many times the stream will be split.\n  \n  Note: this leads to buffering the stream content on the server.\n  However, the LLM results are expected to be small enough to not cause issues.\n     */\n  teeStream() {\n    const [stream1, stream2] = this.baseStream.tee();\n    this.baseStream = stream2;\n    return stream1;\n  }\n  get textStream() {\n    return createAsyncIterableStream(this.teeStream().pipeThrough(new TransformStream({\n      transform({\n        part\n      }, controller) {\n        if (part.type === \"text-delta\") {\n          controller.enqueue(part.text);\n        }\n      }\n    })));\n  }\n  get fullStream() {\n    return createAsyncIterableStream(this.teeStream().pipeThrough(new TransformStream({\n      transform({\n        part\n      }, controller) {\n        controller.enqueue(part);\n      }\n    })));\n  }\n  async consumeStream(options) {\n    var _a172;\n    try {\n      await consumeStream({\n        stream: this.fullStream,\n        onError: options == null ? void 0 : options.onError\n      });\n    } catch (error40) {\n      (_a172 = options == null ? void 0 : options.onError) == null ? void 0 : _a172.call(options, error40);\n    }\n  }\n  get experimental_partialOutputStream() {\n    if (this.output == null) {\n      throw new NoOutputSpecifiedError();\n    }\n    return createAsyncIterableStream(this.teeStream().pipeThrough(new TransformStream({\n      transform({\n        partialOutput\n      }, controller) {\n        if (partialOutput != null) {\n          controller.enqueue(partialOutput);\n        }\n      }\n    })));\n  }\n  toUIMessageStream({\n    originalMessages,\n    generateMessageId,\n    onFinish,\n    messageMetadata,\n    sendReasoning = true,\n    sendSources = false,\n    sendStart = true,\n    sendFinish = true,\n    onError = getErrorMessage2\n  } = {}) {\n    const responseMessageId = generateMessageId != null ? getResponseUIMessageId({\n      originalMessages,\n      responseMessageId: generateMessageId\n    }) : void 0;\n    const toolNamesByCallId = {};\n    const isDynamic = toolCallId => {\n      var _a172, _b8;\n      const toolName = toolNamesByCallId[toolCallId];\n      const dynamic = ((_b8 = (_a172 = this.tools) == null ? void 0 : _a172[toolName]) == null ? void 0 : _b8.type) === \"dynamic\";\n      return dynamic ? true : void 0;\n    };\n    const baseStream = this.fullStream.pipeThrough(new TransformStream({\n      transform: async (part, controller) => {\n        const messageMetadataValue = messageMetadata == null ? void 0 : messageMetadata({\n          part\n        });\n        const partType = part.type;\n        switch (partType) {\n          case \"text-start\":\n            {\n              controller.enqueue({\n                type: \"text-start\",\n                id: part.id,\n                ...(part.providerMetadata != null ? {\n                  providerMetadata: part.providerMetadata\n                } : {})\n              });\n              break;\n            }\n          case \"text-delta\":\n            {\n              controller.enqueue({\n                type: \"text-delta\",\n                id: part.id,\n                delta: part.text,\n                ...(part.providerMetadata != null ? {\n                  providerMetadata: part.providerMetadata\n                } : {})\n              });\n              break;\n            }\n          case \"text-end\":\n            {\n              controller.enqueue({\n                type: \"text-end\",\n                id: part.id,\n                ...(part.providerMetadata != null ? {\n                  providerMetadata: part.providerMetadata\n                } : {})\n              });\n              break;\n            }\n          case \"reasoning-start\":\n            {\n              controller.enqueue({\n                type: \"reasoning-start\",\n                id: part.id,\n                ...(part.providerMetadata != null ? {\n                  providerMetadata: part.providerMetadata\n                } : {})\n              });\n              break;\n            }\n          case \"reasoning-delta\":\n            {\n              if (sendReasoning) {\n                controller.enqueue({\n                  type: \"reasoning-delta\",\n                  id: part.id,\n                  delta: part.text,\n                  ...(part.providerMetadata != null ? {\n                    providerMetadata: part.providerMetadata\n                  } : {})\n                });\n              }\n              break;\n            }\n          case \"reasoning-end\":\n            {\n              controller.enqueue({\n                type: \"reasoning-end\",\n                id: part.id,\n                ...(part.providerMetadata != null ? {\n                  providerMetadata: part.providerMetadata\n                } : {})\n              });\n              break;\n            }\n          case \"file\":\n            {\n              controller.enqueue({\n                type: \"file\",\n                mediaType: part.file.mediaType,\n                url: `data:${part.file.mediaType};base64,${part.file.base64}`\n              });\n              break;\n            }\n          case \"source\":\n            {\n              if (sendSources && part.sourceType === \"url\") {\n                controller.enqueue({\n                  type: \"source-url\",\n                  sourceId: part.id,\n                  url: part.url,\n                  title: part.title,\n                  ...(part.providerMetadata != null ? {\n                    providerMetadata: part.providerMetadata\n                  } : {})\n                });\n              }\n              if (sendSources && part.sourceType === \"document\") {\n                controller.enqueue({\n                  type: \"source-document\",\n                  sourceId: part.id,\n                  mediaType: part.mediaType,\n                  title: part.title,\n                  filename: part.filename,\n                  ...(part.providerMetadata != null ? {\n                    providerMetadata: part.providerMetadata\n                  } : {})\n                });\n              }\n              break;\n            }\n          case \"tool-input-start\":\n            {\n              toolNamesByCallId[part.id] = part.toolName;\n              const dynamic = isDynamic(part.id);\n              controller.enqueue({\n                type: \"tool-input-start\",\n                toolCallId: part.id,\n                toolName: part.toolName,\n                ...(part.providerExecuted != null ? {\n                  providerExecuted: part.providerExecuted\n                } : {}),\n                ...(dynamic != null ? {\n                  dynamic\n                } : {})\n              });\n              break;\n            }\n          case \"tool-input-delta\":\n            {\n              controller.enqueue({\n                type: \"tool-input-delta\",\n                toolCallId: part.id,\n                inputTextDelta: part.delta\n              });\n              break;\n            }\n          case \"tool-call\":\n            {\n              toolNamesByCallId[part.toolCallId] = part.toolName;\n              const dynamic = isDynamic(part.toolCallId);\n              if (part.invalid) {\n                controller.enqueue({\n                  type: \"tool-input-error\",\n                  toolCallId: part.toolCallId,\n                  toolName: part.toolName,\n                  input: part.input,\n                  ...(part.providerExecuted != null ? {\n                    providerExecuted: part.providerExecuted\n                  } : {}),\n                  ...(part.providerMetadata != null ? {\n                    providerMetadata: part.providerMetadata\n                  } : {}),\n                  ...(dynamic != null ? {\n                    dynamic\n                  } : {}),\n                  errorText: onError(part.error)\n                });\n              } else {\n                controller.enqueue({\n                  type: \"tool-input-available\",\n                  toolCallId: part.toolCallId,\n                  toolName: part.toolName,\n                  input: part.input,\n                  ...(part.providerExecuted != null ? {\n                    providerExecuted: part.providerExecuted\n                  } : {}),\n                  ...(part.providerMetadata != null ? {\n                    providerMetadata: part.providerMetadata\n                  } : {}),\n                  ...(dynamic != null ? {\n                    dynamic\n                  } : {})\n                });\n              }\n              break;\n            }\n          case \"tool-result\":\n            {\n              const dynamic = isDynamic(part.toolCallId);\n              controller.enqueue({\n                type: \"tool-output-available\",\n                toolCallId: part.toolCallId,\n                output: part.output,\n                ...(part.providerExecuted != null ? {\n                  providerExecuted: part.providerExecuted\n                } : {}),\n                ...(part.preliminary != null ? {\n                  preliminary: part.preliminary\n                } : {}),\n                ...(dynamic != null ? {\n                  dynamic\n                } : {})\n              });\n              break;\n            }\n          case \"tool-error\":\n            {\n              const dynamic = isDynamic(part.toolCallId);\n              controller.enqueue({\n                type: \"tool-output-error\",\n                toolCallId: part.toolCallId,\n                errorText: onError(part.error),\n                ...(part.providerExecuted != null ? {\n                  providerExecuted: part.providerExecuted\n                } : {}),\n                ...(dynamic != null ? {\n                  dynamic\n                } : {})\n              });\n              break;\n            }\n          case \"error\":\n            {\n              controller.enqueue({\n                type: \"error\",\n                errorText: onError(part.error)\n              });\n              break;\n            }\n          case \"start-step\":\n            {\n              controller.enqueue({\n                type: \"start-step\"\n              });\n              break;\n            }\n          case \"finish-step\":\n            {\n              controller.enqueue({\n                type: \"finish-step\"\n              });\n              break;\n            }\n          case \"start\":\n            {\n              if (sendStart) {\n                controller.enqueue({\n                  type: \"start\",\n                  ...(messageMetadataValue != null ? {\n                    messageMetadata: messageMetadataValue\n                  } : {}),\n                  ...(responseMessageId != null ? {\n                    messageId: responseMessageId\n                  } : {})\n                });\n              }\n              break;\n            }\n          case \"finish\":\n            {\n              if (sendFinish) {\n                controller.enqueue({\n                  type: \"finish\",\n                  ...(messageMetadataValue != null ? {\n                    messageMetadata: messageMetadataValue\n                  } : {})\n                });\n              }\n              break;\n            }\n          case \"abort\":\n            {\n              controller.enqueue(part);\n              break;\n            }\n          case \"tool-input-end\":\n            {\n              break;\n            }\n          case \"raw\":\n            {\n              break;\n            }\n          default:\n            {\n              const exhaustiveCheck = partType;\n              throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n            }\n        }\n        if (messageMetadataValue != null && partType !== \"start\" && partType !== \"finish\") {\n          controller.enqueue({\n            type: \"message-metadata\",\n            messageMetadata: messageMetadataValue\n          });\n        }\n      }\n    }));\n    return createAsyncIterableStream(handleUIMessageStreamFinish({\n      stream: baseStream,\n      messageId: responseMessageId != null ? responseMessageId : generateMessageId == null ? void 0 : generateMessageId(),\n      originalMessages,\n      onFinish,\n      onError\n    }));\n  }\n  pipeUIMessageStreamToResponse(response, {\n    originalMessages,\n    generateMessageId,\n    onFinish,\n    messageMetadata,\n    sendReasoning,\n    sendSources,\n    sendFinish,\n    sendStart,\n    onError,\n    ...init\n  } = {}) {\n    pipeUIMessageStreamToResponse({\n      response,\n      stream: this.toUIMessageStream({\n        originalMessages,\n        generateMessageId,\n        onFinish,\n        messageMetadata,\n        sendReasoning,\n        sendSources,\n        sendFinish,\n        sendStart,\n        onError\n      }),\n      ...init\n    });\n  }\n  pipeTextStreamToResponse(response, init) {\n    pipeTextStreamToResponse({\n      response,\n      textStream: this.textStream,\n      ...init\n    });\n  }\n  toUIMessageStreamResponse({\n    originalMessages,\n    generateMessageId,\n    onFinish,\n    messageMetadata,\n    sendReasoning,\n    sendSources,\n    sendFinish,\n    sendStart,\n    onError,\n    ...init\n  } = {}) {\n    return createUIMessageStreamResponse({\n      stream: this.toUIMessageStream({\n        originalMessages,\n        generateMessageId,\n        onFinish,\n        messageMetadata,\n        sendReasoning,\n        sendSources,\n        sendFinish,\n        sendStart,\n        onError\n      }),\n      ...init\n    });\n  }\n  toTextStreamResponse(init) {\n    return createTextStreamResponse({\n      textStream: this.textStream,\n      ...init\n    });\n  }\n};\nfunction extractReasoningContent(content) {\n  const parts = content.filter(content2 => content2.type === \"reasoning\");\n  return parts.length === 0 ? void 0 : parts.map(content2 => content2.text).join(\"\\n\");\n}\nvar noSchemaOutputStrategy = {\n  type: \"no-schema\",\n  jsonSchema: void 0,\n  async validatePartialResult({\n    value,\n    textDelta\n  }) {\n    return {\n      success: true,\n      value: {\n        partial: value,\n        textDelta\n      }\n    };\n  },\n  async validateFinalResult(value, context) {\n    return value === void 0 ? {\n      success: false,\n      error: new NoObjectGeneratedError({\n        message: \"No object generated: response did not match schema.\",\n        text: context.text,\n        response: context.response,\n        usage: context.usage,\n        finishReason: context.finishReason\n      })\n    } : {\n      success: true,\n      value\n    };\n  },\n  createElementStream() {\n    throw new UnsupportedFunctionalityError({\n      functionality: \"element streams in no-schema mode\"\n    });\n  }\n};\nvar objectOutputStrategy = schema => ({\n  type: \"object\",\n  jsonSchema: schema.jsonSchema,\n  async validatePartialResult({\n    value,\n    textDelta\n  }) {\n    return {\n      success: true,\n      value: {\n        // Note: currently no validation of partial results:\n        partial: value,\n        textDelta\n      }\n    };\n  },\n  async validateFinalResult(value) {\n    return safeValidateTypes2({\n      value,\n      schema\n    });\n  },\n  createElementStream() {\n    throw new UnsupportedFunctionalityError({\n      functionality: \"element streams in object mode\"\n    });\n  }\n});\nvar arrayOutputStrategy = schema => {\n  const {\n    $schema,\n    ...itemSchema\n  } = schema.jsonSchema;\n  return {\n    type: \"enum\",\n    // wrap in object that contains array of elements, since most LLMs will not\n    // be able to generate an array directly:\n    // possible future optimization: use arrays directly when model supports grammar-guided generation\n    jsonSchema: {\n      $schema: \"http://json-schema.org/draft-07/schema#\",\n      type: \"object\",\n      properties: {\n        elements: {\n          type: \"array\",\n          items: itemSchema\n        }\n      },\n      required: [\"elements\"],\n      additionalProperties: false\n    },\n    async validatePartialResult({\n      value,\n      latestObject,\n      isFirstDelta,\n      isFinalDelta\n    }) {\n      var _a172;\n      if (!isJSONObject(value) || !isJSONArray(value.elements)) {\n        return {\n          success: false,\n          error: new TypeValidationError2({\n            value,\n            cause: \"value must be an object that contains an array of elements\"\n          })\n        };\n      }\n      const inputArray = value.elements;\n      const resultArray = [];\n      for (let i = 0; i < inputArray.length; i++) {\n        const element = inputArray[i];\n        const result = await safeValidateTypes2({\n          value: element,\n          schema\n        });\n        if (i === inputArray.length - 1 && !isFinalDelta) {\n          continue;\n        }\n        if (!result.success) {\n          return result;\n        }\n        resultArray.push(result.value);\n      }\n      const publishedElementCount = (_a172 = latestObject == null ? void 0 : latestObject.length) != null ? _a172 : 0;\n      let textDelta = \"\";\n      if (isFirstDelta) {\n        textDelta += \"[\";\n      }\n      if (publishedElementCount > 0) {\n        textDelta += \",\";\n      }\n      textDelta += resultArray.slice(publishedElementCount).map(element => JSON.stringify(element)).join(\",\");\n      if (isFinalDelta) {\n        textDelta += \"]\";\n      }\n      return {\n        success: true,\n        value: {\n          partial: resultArray,\n          textDelta\n        }\n      };\n    },\n    async validateFinalResult(value) {\n      if (!isJSONObject(value) || !isJSONArray(value.elements)) {\n        return {\n          success: false,\n          error: new TypeValidationError2({\n            value,\n            cause: \"value must be an object that contains an array of elements\"\n          })\n        };\n      }\n      const inputArray = value.elements;\n      for (const element of inputArray) {\n        const result = await safeValidateTypes2({\n          value: element,\n          schema\n        });\n        if (!result.success) {\n          return result;\n        }\n      }\n      return {\n        success: true,\n        value: inputArray\n      };\n    },\n    createElementStream(originalStream) {\n      let publishedElements = 0;\n      return createAsyncIterableStream(originalStream.pipeThrough(new TransformStream({\n        transform(chunk, controller) {\n          switch (chunk.type) {\n            case \"object\":\n              {\n                const array2 = chunk.object;\n                for (; publishedElements < array2.length; publishedElements++) {\n                  controller.enqueue(array2[publishedElements]);\n                }\n                break;\n              }\n            case \"text-delta\":\n            case \"finish\":\n            case \"error\":\n              break;\n            default:\n              {\n                const _exhaustiveCheck = chunk;\n                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n              }\n          }\n        }\n      })));\n    }\n  };\n};\nvar enumOutputStrategy = enumValues => {\n  return {\n    type: \"enum\",\n    // wrap in object that contains result, since most LLMs will not\n    // be able to generate an enum value directly:\n    // possible future optimization: use enums directly when model supports top-level enums\n    jsonSchema: {\n      $schema: \"http://json-schema.org/draft-07/schema#\",\n      type: \"object\",\n      properties: {\n        result: {\n          type: \"string\",\n          enum: enumValues\n        }\n      },\n      required: [\"result\"],\n      additionalProperties: false\n    },\n    async validateFinalResult(value) {\n      if (!isJSONObject(value) || typeof value.result !== \"string\") {\n        return {\n          success: false,\n          error: new TypeValidationError2({\n            value,\n            cause: 'value must be an object that contains a string in the \"result\" property.'\n          })\n        };\n      }\n      const result = value.result;\n      return enumValues.includes(result) ? {\n        success: true,\n        value: result\n      } : {\n        success: false,\n        error: new TypeValidationError2({\n          value,\n          cause: \"value must be a string in the enum\"\n        })\n      };\n    },\n    async validatePartialResult({\n      value,\n      textDelta\n    }) {\n      if (!isJSONObject(value) || typeof value.result !== \"string\") {\n        return {\n          success: false,\n          error: new TypeValidationError2({\n            value,\n            cause: 'value must be an object that contains a string in the \"result\" property.'\n          })\n        };\n      }\n      const result = value.result;\n      const possibleEnumValues = enumValues.filter(enumValue => enumValue.startsWith(result));\n      if (value.result.length === 0 || possibleEnumValues.length === 0) {\n        return {\n          success: false,\n          error: new TypeValidationError2({\n            value,\n            cause: \"value must be a string in the enum\"\n          })\n        };\n      }\n      return {\n        success: true,\n        value: {\n          partial: possibleEnumValues.length > 1 ? result : possibleEnumValues[0],\n          textDelta\n        }\n      };\n    },\n    createElementStream() {\n      throw new UnsupportedFunctionalityError({\n        functionality: \"element streams in enum mode\"\n      });\n    }\n  };\n};\nfunction getOutputStrategy({\n  output,\n  schema,\n  enumValues\n}) {\n  switch (output) {\n    case \"object\":\n      return objectOutputStrategy(asSchema(schema));\n    case \"array\":\n      return arrayOutputStrategy(asSchema(schema));\n    case \"enum\":\n      return enumOutputStrategy(enumValues);\n    case \"no-schema\":\n      return noSchemaOutputStrategy;\n    default:\n      {\n        const _exhaustiveCheck = output;\n        throw new Error(`Unsupported output: ${_exhaustiveCheck}`);\n      }\n  }\n}\nasync function parseAndValidateObjectResult(result, outputStrategy, context) {\n  const parseResult = await safeParseJSON2({\n    text: result\n  });\n  if (!parseResult.success) {\n    throw new NoObjectGeneratedError({\n      message: \"No object generated: could not parse the response.\",\n      cause: parseResult.error,\n      text: result,\n      response: context.response,\n      usage: context.usage,\n      finishReason: context.finishReason\n    });\n  }\n  const validationResult = await outputStrategy.validateFinalResult(parseResult.value, {\n    text: result,\n    response: context.response,\n    usage: context.usage\n  });\n  if (!validationResult.success) {\n    throw new NoObjectGeneratedError({\n      message: \"No object generated: response did not match schema.\",\n      cause: validationResult.error,\n      text: result,\n      response: context.response,\n      usage: context.usage,\n      finishReason: context.finishReason\n    });\n  }\n  return validationResult.value;\n}\nasync function parseAndValidateObjectResultWithRepair(result, outputStrategy, repairText, context) {\n  try {\n    return await parseAndValidateObjectResult(result, outputStrategy, context);\n  } catch (error40) {\n    if (repairText != null && NoObjectGeneratedError.isInstance(error40) && (JSONParseError2.isInstance(error40.cause) || TypeValidationError2.isInstance(error40.cause))) {\n      const repairedText = await repairText({\n        text: result,\n        error: error40.cause\n      });\n      if (repairedText === null) {\n        throw error40;\n      }\n      return await parseAndValidateObjectResult(repairedText, outputStrategy, context);\n    }\n    throw error40;\n  }\n}\nfunction validateObjectGenerationInput({\n  output,\n  schema,\n  schemaName,\n  schemaDescription,\n  enumValues\n}) {\n  if (output != null && output !== \"object\" && output !== \"array\" && output !== \"enum\" && output !== \"no-schema\") {\n    throw new InvalidArgumentError3({\n      parameter: \"output\",\n      value: output,\n      message: \"Invalid output type.\"\n    });\n  }\n  if (output === \"no-schema\") {\n    if (schema != null) {\n      throw new InvalidArgumentError3({\n        parameter: \"schema\",\n        value: schema,\n        message: \"Schema is not supported for no-schema output.\"\n      });\n    }\n    if (schemaDescription != null) {\n      throw new InvalidArgumentError3({\n        parameter: \"schemaDescription\",\n        value: schemaDescription,\n        message: \"Schema description is not supported for no-schema output.\"\n      });\n    }\n    if (schemaName != null) {\n      throw new InvalidArgumentError3({\n        parameter: \"schemaName\",\n        value: schemaName,\n        message: \"Schema name is not supported for no-schema output.\"\n      });\n    }\n    if (enumValues != null) {\n      throw new InvalidArgumentError3({\n        parameter: \"enumValues\",\n        value: enumValues,\n        message: \"Enum values are not supported for no-schema output.\"\n      });\n    }\n  }\n  if (output === \"object\") {\n    if (schema == null) {\n      throw new InvalidArgumentError3({\n        parameter: \"schema\",\n        value: schema,\n        message: \"Schema is required for object output.\"\n      });\n    }\n    if (enumValues != null) {\n      throw new InvalidArgumentError3({\n        parameter: \"enumValues\",\n        value: enumValues,\n        message: \"Enum values are not supported for object output.\"\n      });\n    }\n  }\n  if (output === \"array\") {\n    if (schema == null) {\n      throw new InvalidArgumentError3({\n        parameter: \"schema\",\n        value: schema,\n        message: \"Element schema is required for array output.\"\n      });\n    }\n    if (enumValues != null) {\n      throw new InvalidArgumentError3({\n        parameter: \"enumValues\",\n        value: enumValues,\n        message: \"Enum values are not supported for array output.\"\n      });\n    }\n  }\n  if (output === \"enum\") {\n    if (schema != null) {\n      throw new InvalidArgumentError3({\n        parameter: \"schema\",\n        value: schema,\n        message: \"Schema is not supported for enum output.\"\n      });\n    }\n    if (schemaDescription != null) {\n      throw new InvalidArgumentError3({\n        parameter: \"schemaDescription\",\n        value: schemaDescription,\n        message: \"Schema description is not supported for enum output.\"\n      });\n    }\n    if (schemaName != null) {\n      throw new InvalidArgumentError3({\n        parameter: \"schemaName\",\n        value: schemaName,\n        message: \"Schema name is not supported for enum output.\"\n      });\n    }\n    if (enumValues == null) {\n      throw new InvalidArgumentError3({\n        parameter: \"enumValues\",\n        value: enumValues,\n        message: \"Enum values are required for enum output.\"\n      });\n    }\n    for (const value of enumValues) {\n      if (typeof value !== \"string\") {\n        throw new InvalidArgumentError3({\n          parameter: \"enumValues\",\n          value,\n          message: \"Enum values must be strings.\"\n        });\n      }\n    }\n  }\n}\nvar originalGenerateId3 = createIdGenerator2({\n  prefix: \"aiobj\",\n  size: 24\n});\nasync function generateObject(options) {\n  const {\n    model: modelArg,\n    output = \"object\",\n    system,\n    prompt,\n    messages,\n    maxRetries: maxRetriesArg,\n    abortSignal,\n    headers,\n    experimental_repairText: repairText,\n    experimental_telemetry: telemetry,\n    experimental_download: download2,\n    providerOptions,\n    _internal: {\n      generateId: generateId32 = originalGenerateId3,\n      currentDate = () => /* @__PURE__ */new Date()\n    } = {},\n    ...settings\n  } = options;\n  const model = resolveLanguageModel(modelArg);\n  const enumValues = \"enum\" in options ? options.enum : void 0;\n  const {\n    schema: inputSchema,\n    schemaDescription,\n    schemaName\n  } = \"schema\" in options ? options : {};\n  validateObjectGenerationInput({\n    output,\n    schema: inputSchema,\n    schemaName,\n    schemaDescription,\n    enumValues\n  });\n  const {\n    maxRetries,\n    retry\n  } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const outputStrategy = getOutputStrategy({\n    output,\n    schema: inputSchema,\n    enumValues\n  });\n  const callSettings = prepareCallSettings(settings);\n  const headersWithUserAgent = withUserAgentSuffix2(headers != null ? headers : {}, `ai/${VERSION3}`);\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers: headersWithUserAgent,\n    settings: {\n      ...callSettings,\n      maxRetries\n    }\n  });\n  const tracer = getTracer(telemetry);\n  try {\n    return await recordSpan({\n      name: \"ai.generateObject\",\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({\n            operationId: \"ai.generateObject\",\n            telemetry\n          }),\n          ...baseTelemetryAttributes,\n          // specific settings that only make sense on the outer level:\n          \"ai.prompt\": {\n            input: () => JSON.stringify({\n              system,\n              prompt,\n              messages\n            })\n          },\n          \"ai.schema\": outputStrategy.jsonSchema != null ? {\n            input: () => JSON.stringify(outputStrategy.jsonSchema)\n          } : void 0,\n          \"ai.schema.name\": schemaName,\n          \"ai.schema.description\": schemaDescription,\n          \"ai.settings.output\": outputStrategy.type\n        }\n      }),\n      tracer,\n      fn: async span => {\n        var _a172;\n        let result;\n        let finishReason;\n        let usage;\n        let warnings;\n        let response;\n        let request;\n        let resultProviderMetadata;\n        let reasoning;\n        const standardizedPrompt = await standardizePrompt({\n          system,\n          prompt,\n          messages\n        });\n        const promptMessages = await convertToLanguageModelPrompt({\n          prompt: standardizedPrompt,\n          supportedUrls: await model.supportedUrls,\n          download: download2\n        });\n        const generateResult = await retry(() => recordSpan({\n          name: \"ai.generateObject.doGenerate\",\n          attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              ...assembleOperationName({\n                operationId: \"ai.generateObject.doGenerate\",\n                telemetry\n              }),\n              ...baseTelemetryAttributes,\n              \"ai.prompt.messages\": {\n                input: () => stringifyForTelemetry(promptMessages)\n              },\n              // standardized gen-ai llm span attributes:\n              \"gen_ai.system\": model.provider,\n              \"gen_ai.request.model\": model.modelId,\n              \"gen_ai.request.frequency_penalty\": callSettings.frequencyPenalty,\n              \"gen_ai.request.max_tokens\": callSettings.maxOutputTokens,\n              \"gen_ai.request.presence_penalty\": callSettings.presencePenalty,\n              \"gen_ai.request.temperature\": callSettings.temperature,\n              \"gen_ai.request.top_k\": callSettings.topK,\n              \"gen_ai.request.top_p\": callSettings.topP\n            }\n          }),\n          tracer,\n          fn: async span2 => {\n            var _a182, _b8, _c, _d, _e, _f, _g, _h;\n            const result2 = await model.doGenerate({\n              responseFormat: {\n                type: \"json\",\n                schema: outputStrategy.jsonSchema,\n                name: schemaName,\n                description: schemaDescription\n              },\n              ...prepareCallSettings(settings),\n              prompt: promptMessages,\n              providerOptions,\n              abortSignal,\n              headers: headersWithUserAgent\n            });\n            const responseData = {\n              id: (_b8 = (_a182 = result2.response) == null ? void 0 : _a182.id) != null ? _b8 : generateId32(),\n              timestamp: (_d = (_c = result2.response) == null ? void 0 : _c.timestamp) != null ? _d : currentDate(),\n              modelId: (_f = (_e = result2.response) == null ? void 0 : _e.modelId) != null ? _f : model.modelId,\n              headers: (_g = result2.response) == null ? void 0 : _g.headers,\n              body: (_h = result2.response) == null ? void 0 : _h.body\n            };\n            const text2 = extractTextContent(result2.content);\n            const reasoning2 = extractReasoningContent(result2.content);\n            if (text2 === void 0) {\n              throw new NoObjectGeneratedError({\n                message: \"No object generated: the model did not return a response.\",\n                response: responseData,\n                usage: result2.usage,\n                finishReason: result2.finishReason\n              });\n            }\n            span2.setAttributes(selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                \"ai.response.finishReason\": result2.finishReason,\n                \"ai.response.object\": {\n                  output: () => text2\n                },\n                \"ai.response.id\": responseData.id,\n                \"ai.response.model\": responseData.modelId,\n                \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                \"ai.response.providerMetadata\": JSON.stringify(result2.providerMetadata),\n                // TODO rename telemetry attributes to inputTokens and outputTokens\n                \"ai.usage.promptTokens\": result2.usage.inputTokens,\n                \"ai.usage.completionTokens\": result2.usage.outputTokens,\n                // standardized gen-ai llm span attributes:\n                \"gen_ai.response.finish_reasons\": [result2.finishReason],\n                \"gen_ai.response.id\": responseData.id,\n                \"gen_ai.response.model\": responseData.modelId,\n                \"gen_ai.usage.input_tokens\": result2.usage.inputTokens,\n                \"gen_ai.usage.output_tokens\": result2.usage.outputTokens\n              }\n            }));\n            return {\n              ...result2,\n              objectText: text2,\n              reasoning: reasoning2,\n              responseData\n            };\n          }\n        }));\n        result = generateResult.objectText;\n        finishReason = generateResult.finishReason;\n        usage = generateResult.usage;\n        warnings = generateResult.warnings;\n        resultProviderMetadata = generateResult.providerMetadata;\n        request = (_a172 = generateResult.request) != null ? _a172 : {};\n        response = generateResult.responseData;\n        reasoning = generateResult.reasoning;\n        logWarnings(warnings);\n        const object22 = await parseAndValidateObjectResultWithRepair(result, outputStrategy, repairText, {\n          response,\n          usage,\n          finishReason\n        });\n        span.setAttributes(selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            \"ai.response.finishReason\": finishReason,\n            \"ai.response.object\": {\n              output: () => JSON.stringify(object22)\n            },\n            \"ai.response.providerMetadata\": JSON.stringify(resultProviderMetadata),\n            // TODO rename telemetry attributes to inputTokens and outputTokens\n            \"ai.usage.promptTokens\": usage.inputTokens,\n            \"ai.usage.completionTokens\": usage.outputTokens\n          }\n        }));\n        return new DefaultGenerateObjectResult({\n          object: object22,\n          reasoning,\n          finishReason,\n          usage,\n          warnings,\n          request,\n          response,\n          providerMetadata: resultProviderMetadata\n        });\n      }\n    });\n  } catch (error40) {\n    throw wrapGatewayError(error40);\n  }\n}\nvar DefaultGenerateObjectResult = class {\n  constructor(options) {\n    this.object = options.object;\n    this.finishReason = options.finishReason;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.providerMetadata = options.providerMetadata;\n    this.response = options.response;\n    this.request = options.request;\n    this.reasoning = options.reasoning;\n  }\n  toJsonResponse(init) {\n    var _a172;\n    return new Response(JSON.stringify(this.object), {\n      status: (_a172 = init == null ? void 0 : init.status) != null ? _a172 : 200,\n      headers: prepareHeaders(init == null ? void 0 : init.headers, {\n        \"content-type\": \"application/json; charset=utf-8\"\n      })\n    });\n  }\n};\nvar originalGenerateId4 = createIdGenerator2({\n  prefix: \"aiobj\",\n  size: 24\n});\nvar NoSpeechGeneratedError = class extends AISDKError2 {\n  constructor(options) {\n    super({\n      name: \"AI_NoSpeechGeneratedError\",\n      message: \"No speech audio generated.\"\n    });\n    this.responses = options.responses;\n  }\n};\nvar DefaultGeneratedAudioFile = class extends DefaultGeneratedFile {\n  constructor({\n    data,\n    mediaType\n  }) {\n    super({\n      data,\n      mediaType\n    });\n    let format = \"mp3\";\n    if (mediaType) {\n      const mediaTypeParts = mediaType.split(\"/\");\n      if (mediaTypeParts.length === 2) {\n        if (mediaType !== \"audio/mpeg\") {\n          format = mediaTypeParts[1];\n        }\n      }\n    }\n    if (!format) {\n      throw new Error(\"Audio format must be provided or determinable from media type\");\n    }\n    this.format = format;\n  }\n};\nasync function generateSpeech({\n  model,\n  text: text2,\n  voice,\n  outputFormat,\n  instructions,\n  speed,\n  language,\n  providerOptions = {},\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers\n}) {\n  var _a172;\n  if (model.specificationVersion !== \"v2\") {\n    throw new UnsupportedModelVersionError({\n      version: model.specificationVersion,\n      provider: model.provider,\n      modelId: model.modelId\n    });\n  }\n  const headersWithUserAgent = withUserAgentSuffix2(headers != null ? headers : {}, `ai/${VERSION3}`);\n  const {\n    retry\n  } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const result = await retry(() => model.doGenerate({\n    text: text2,\n    voice,\n    outputFormat,\n    instructions,\n    speed,\n    language,\n    abortSignal,\n    headers: headersWithUserAgent,\n    providerOptions\n  }));\n  if (!result.audio || result.audio.length === 0) {\n    throw new NoSpeechGeneratedError({\n      responses: [result.response]\n    });\n  }\n  logWarnings(result.warnings);\n  return new DefaultSpeechResult({\n    audio: new DefaultGeneratedAudioFile({\n      data: result.audio,\n      mediaType: (_a172 = detectMediaType({\n        data: result.audio,\n        signatures: audioMediaTypeSignatures\n      })) != null ? _a172 : \"audio/mp3\"\n    }),\n    warnings: result.warnings,\n    responses: [result.response],\n    providerMetadata: result.providerMetadata\n  });\n}\nvar DefaultSpeechResult = class {\n  constructor(options) {\n    var _a172;\n    this.audio = options.audio;\n    this.warnings = options.warnings;\n    this.responses = options.responses;\n    this.providerMetadata = (_a172 = options.providerMetadata) != null ? _a172 : {};\n  }\n};\nvar output_exports = {};\n__export2(output_exports, {\n  object: () => object2,\n  text: () => text\n});\nvar text = () => ({\n  type: \"text\",\n  responseFormat: {\n    type: \"text\"\n  },\n  async parsePartial({\n    text: text2\n  }) {\n    return {\n      partial: text2\n    };\n  },\n  async parseOutput({\n    text: text2\n  }) {\n    return text2;\n  }\n});\nvar object2 = ({\n  schema: inputSchema\n}) => {\n  const schema = asSchema(inputSchema);\n  return {\n    type: \"object\",\n    responseFormat: {\n      type: \"json\",\n      schema: schema.jsonSchema\n    },\n    async parsePartial({\n      text: text2\n    }) {\n      const result = await parsePartialJson(text2);\n      switch (result.state) {\n        case \"failed-parse\":\n        case \"undefined-input\":\n          return void 0;\n        case \"repaired-parse\":\n        case \"successful-parse\":\n          return {\n            // Note: currently no validation of partial results:\n            partial: result.value\n          };\n        default:\n          {\n            const _exhaustiveCheck = result.state;\n            throw new Error(`Unsupported parse state: ${_exhaustiveCheck}`);\n          }\n      }\n    },\n    async parseOutput({\n      text: text2\n    }, context) {\n      const parseResult = await safeParseJSON2({\n        text: text2\n      });\n      if (!parseResult.success) {\n        throw new NoObjectGeneratedError({\n          message: \"No object generated: could not parse the response.\",\n          cause: parseResult.error,\n          text: text2,\n          response: context.response,\n          usage: context.usage,\n          finishReason: context.finishReason\n        });\n      }\n      const validationResult = await safeValidateTypes2({\n        value: parseResult.value,\n        schema\n      });\n      if (!validationResult.success) {\n        throw new NoObjectGeneratedError({\n          message: \"No object generated: response did not match schema.\",\n          cause: validationResult.error,\n          text: text2,\n          response: context.response,\n          usage: context.usage,\n          finishReason: context.finishReason\n        });\n      }\n      return validationResult.value;\n    }\n  };\n};\nvar name162 = \"AI_NoSuchProviderError\";\nvar marker162 = `vercel.ai.error.${name162}`;\nvar symbol162 = Symbol.for(marker162);\nvar _a162;\n_a162 = symbol162;\nvar ClientOrServerImplementationSchema = external_exports2.looseObject({\n  name: external_exports2.string(),\n  version: external_exports2.string()\n});\nvar BaseParamsSchema = external_exports2.looseObject({\n  _meta: external_exports2.optional(external_exports2.object({}).loose())\n});\nvar ResultSchema = BaseParamsSchema;\nvar RequestSchema = external_exports2.object({\n  method: external_exports2.string(),\n  params: external_exports2.optional(BaseParamsSchema)\n});\nvar ServerCapabilitiesSchema = external_exports2.looseObject({\n  experimental: external_exports2.optional(external_exports2.object({}).loose()),\n  logging: external_exports2.optional(external_exports2.object({}).loose()),\n  prompts: external_exports2.optional(external_exports2.looseObject({\n    listChanged: external_exports2.optional(external_exports2.boolean())\n  })),\n  resources: external_exports2.optional(external_exports2.looseObject({\n    subscribe: external_exports2.optional(external_exports2.boolean()),\n    listChanged: external_exports2.optional(external_exports2.boolean())\n  })),\n  tools: external_exports2.optional(external_exports2.looseObject({\n    listChanged: external_exports2.optional(external_exports2.boolean())\n  }))\n});\nvar InitializeResultSchema = ResultSchema.extend({\n  protocolVersion: external_exports2.string(),\n  capabilities: ServerCapabilitiesSchema,\n  serverInfo: ClientOrServerImplementationSchema,\n  instructions: external_exports2.optional(external_exports2.string())\n});\nvar PaginatedResultSchema = ResultSchema.extend({\n  nextCursor: external_exports2.optional(external_exports2.string())\n});\nvar ToolSchema = external_exports2.object({\n  name: external_exports2.string(),\n  description: external_exports2.optional(external_exports2.string()),\n  inputSchema: external_exports2.object({\n    type: external_exports2.literal(\"object\"),\n    properties: external_exports2.optional(external_exports2.object({}).loose())\n  }).loose()\n}).loose();\nvar ListToolsResultSchema = PaginatedResultSchema.extend({\n  tools: external_exports2.array(ToolSchema)\n});\nvar TextContentSchema = external_exports2.object({\n  type: external_exports2.literal(\"text\"),\n  text: external_exports2.string()\n}).loose();\nvar ImageContentSchema = external_exports2.object({\n  type: external_exports2.literal(\"image\"),\n  data: external_exports2.base64(),\n  mimeType: external_exports2.string()\n}).loose();\nvar ResourceContentsSchema = external_exports2.object({\n  /**\n   * The URI of this resource.\n   */\n  uri: external_exports2.string(),\n  /**\n   * The MIME type of this resource, if known.\n   */\n  mimeType: external_exports2.optional(external_exports2.string())\n}).loose();\nvar TextResourceContentsSchema = ResourceContentsSchema.extend({\n  text: external_exports2.string()\n});\nvar BlobResourceContentsSchema = ResourceContentsSchema.extend({\n  blob: external_exports2.base64()\n});\nvar EmbeddedResourceSchema = external_exports2.object({\n  type: external_exports2.literal(\"resource\"),\n  resource: external_exports2.union([TextResourceContentsSchema, BlobResourceContentsSchema])\n}).loose();\nvar CallToolResultSchema = ResultSchema.extend({\n  content: external_exports2.array(external_exports2.union([TextContentSchema, ImageContentSchema, EmbeddedResourceSchema])),\n  isError: external_exports2.boolean().default(false).optional()\n}).or(ResultSchema.extend({\n  toolResult: external_exports2.unknown()\n}));\nvar JSONRPC_VERSION = \"2.0\";\nvar JSONRPCRequestSchema = external_exports2.object({\n  jsonrpc: external_exports2.literal(JSONRPC_VERSION),\n  id: external_exports2.union([external_exports2.string(), external_exports2.number().int()])\n}).merge(RequestSchema).strict();\nvar JSONRPCResponseSchema = external_exports2.object({\n  jsonrpc: external_exports2.literal(JSONRPC_VERSION),\n  id: external_exports2.union([external_exports2.string(), external_exports2.number().int()]),\n  result: ResultSchema\n}).strict();\nvar JSONRPCErrorSchema = external_exports2.object({\n  jsonrpc: external_exports2.literal(JSONRPC_VERSION),\n  id: external_exports2.union([external_exports2.string(), external_exports2.number().int()]),\n  error: external_exports2.object({\n    code: external_exports2.number().int(),\n    message: external_exports2.string(),\n    data: external_exports2.optional(external_exports2.unknown())\n  })\n}).strict();\nvar JSONRPCNotificationSchema = external_exports2.object({\n  jsonrpc: external_exports2.literal(JSONRPC_VERSION)\n}).merge(external_exports2.object({\n  method: external_exports2.string(),\n  params: external_exports2.optional(BaseParamsSchema)\n})).strict();\nvar JSONRPCMessageSchema = external_exports2.union([JSONRPCRequestSchema, JSONRPCNotificationSchema, JSONRPCResponseSchema, JSONRPCErrorSchema]);\nvar NoTranscriptGeneratedError = class extends AISDKError2 {\n  constructor(options) {\n    super({\n      name: \"AI_NoTranscriptGeneratedError\",\n      message: \"No transcript generated.\"\n    });\n    this.responses = options.responses;\n  }\n};\nasync function transcribe({\n  model,\n  audio,\n  providerOptions = {},\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers\n}) {\n  if (model.specificationVersion !== \"v2\") {\n    throw new UnsupportedModelVersionError({\n      version: model.specificationVersion,\n      provider: model.provider,\n      modelId: model.modelId\n    });\n  }\n  const {\n    retry\n  } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const headersWithUserAgent = withUserAgentSuffix2(headers != null ? headers : {}, `ai/${VERSION3}`);\n  const audioData = audio instanceof URL ? (await download({\n    url: audio\n  })).data : convertDataContentToUint8Array(audio);\n  const result = await retry(() => {\n    var _a172;\n    return model.doGenerate({\n      audio: audioData,\n      abortSignal,\n      headers: headersWithUserAgent,\n      providerOptions,\n      mediaType: (_a172 = detectMediaType({\n        data: audioData,\n        signatures: audioMediaTypeSignatures\n      })) != null ? _a172 : \"audio/wav\"\n    });\n  });\n  logWarnings(result.warnings);\n  if (!result.text) {\n    throw new NoTranscriptGeneratedError({\n      responses: [result.response]\n    });\n  }\n  return new DefaultTranscriptionResult({\n    text: result.text,\n    segments: result.segments,\n    language: result.language,\n    durationInSeconds: result.durationInSeconds,\n    warnings: result.warnings,\n    responses: [result.response],\n    providerMetadata: result.providerMetadata\n  });\n}\nvar DefaultTranscriptionResult = class {\n  constructor(options) {\n    var _a172;\n    this.text = options.text;\n    this.segments = options.segments;\n    this.language = options.language;\n    this.durationInSeconds = options.durationInSeconds;\n    this.warnings = options.warnings;\n    this.responses = options.responses;\n    this.providerMetadata = (_a172 = options.providerMetadata) != null ? _a172 : {};\n  }\n};\nvar textUIPartSchema = external_exports2.object({\n  type: external_exports2.literal(\"text\"),\n  text: external_exports2.string(),\n  state: external_exports2.enum([\"streaming\", \"done\"]).optional(),\n  providerMetadata: providerMetadataSchema.optional()\n});\nvar reasoningUIPartSchema = external_exports2.object({\n  type: external_exports2.literal(\"reasoning\"),\n  text: external_exports2.string(),\n  state: external_exports2.enum([\"streaming\", \"done\"]).optional(),\n  providerMetadata: providerMetadataSchema.optional()\n});\nvar sourceUrlUIPartSchema = external_exports2.object({\n  type: external_exports2.literal(\"source-url\"),\n  sourceId: external_exports2.string(),\n  url: external_exports2.string(),\n  title: external_exports2.string().optional(),\n  providerMetadata: providerMetadataSchema.optional()\n});\nvar sourceDocumentUIPartSchema = external_exports2.object({\n  type: external_exports2.literal(\"source-document\"),\n  sourceId: external_exports2.string(),\n  mediaType: external_exports2.string(),\n  title: external_exports2.string(),\n  filename: external_exports2.string().optional(),\n  providerMetadata: providerMetadataSchema.optional()\n});\nvar fileUIPartSchema = external_exports2.object({\n  type: external_exports2.literal(\"file\"),\n  mediaType: external_exports2.string(),\n  filename: external_exports2.string().optional(),\n  url: external_exports2.string(),\n  providerMetadata: providerMetadataSchema.optional()\n});\nvar stepStartUIPartSchema = external_exports2.object({\n  type: external_exports2.literal(\"step-start\")\n});\nvar dataUIPartSchema = external_exports2.object({\n  type: external_exports2.string().startsWith(\"data-\"),\n  id: external_exports2.string().optional(),\n  data: external_exports2.unknown()\n});\nvar dynamicToolUIPartSchemas = [external_exports2.object({\n  type: external_exports2.literal(\"dynamic-tool\"),\n  toolName: external_exports2.string(),\n  toolCallId: external_exports2.string(),\n  state: external_exports2.literal(\"input-streaming\"),\n  input: external_exports2.unknown().optional(),\n  output: external_exports2.never().optional(),\n  errorText: external_exports2.never().optional()\n}), external_exports2.object({\n  type: external_exports2.literal(\"dynamic-tool\"),\n  toolName: external_exports2.string(),\n  toolCallId: external_exports2.string(),\n  state: external_exports2.literal(\"input-available\"),\n  input: external_exports2.unknown(),\n  output: external_exports2.never().optional(),\n  errorText: external_exports2.never().optional(),\n  callProviderMetadata: providerMetadataSchema.optional()\n}), external_exports2.object({\n  type: external_exports2.literal(\"dynamic-tool\"),\n  toolName: external_exports2.string(),\n  toolCallId: external_exports2.string(),\n  state: external_exports2.literal(\"output-available\"),\n  input: external_exports2.unknown(),\n  output: external_exports2.unknown(),\n  errorText: external_exports2.never().optional(),\n  callProviderMetadata: providerMetadataSchema.optional(),\n  preliminary: external_exports2.boolean().optional()\n}), external_exports2.object({\n  type: external_exports2.literal(\"dynamic-tool\"),\n  toolName: external_exports2.string(),\n  toolCallId: external_exports2.string(),\n  state: external_exports2.literal(\"output-error\"),\n  input: external_exports2.unknown(),\n  output: external_exports2.never().optional(),\n  errorText: external_exports2.string(),\n  callProviderMetadata: providerMetadataSchema.optional()\n})];\nvar toolUIPartSchemas = [external_exports2.object({\n  type: external_exports2.string().startsWith(\"tool-\"),\n  toolCallId: external_exports2.string(),\n  state: external_exports2.literal(\"input-streaming\"),\n  providerExecuted: external_exports2.boolean().optional(),\n  input: external_exports2.unknown().optional(),\n  output: external_exports2.never().optional(),\n  errorText: external_exports2.never().optional()\n}), external_exports2.object({\n  type: external_exports2.string().startsWith(\"tool-\"),\n  toolCallId: external_exports2.string(),\n  state: external_exports2.literal(\"input-available\"),\n  providerExecuted: external_exports2.boolean().optional(),\n  input: external_exports2.unknown(),\n  output: external_exports2.never().optional(),\n  errorText: external_exports2.never().optional(),\n  callProviderMetadata: providerMetadataSchema.optional()\n}), external_exports2.object({\n  type: external_exports2.string().startsWith(\"tool-\"),\n  toolCallId: external_exports2.string(),\n  state: external_exports2.literal(\"output-available\"),\n  providerExecuted: external_exports2.boolean().optional(),\n  input: external_exports2.unknown(),\n  output: external_exports2.unknown(),\n  errorText: external_exports2.never().optional(),\n  callProviderMetadata: providerMetadataSchema.optional(),\n  preliminary: external_exports2.boolean().optional()\n}), external_exports2.object({\n  type: external_exports2.string().startsWith(\"tool-\"),\n  toolCallId: external_exports2.string(),\n  state: external_exports2.literal(\"output-error\"),\n  providerExecuted: external_exports2.boolean().optional(),\n  input: external_exports2.unknown(),\n  output: external_exports2.never().optional(),\n  errorText: external_exports2.string(),\n  callProviderMetadata: providerMetadataSchema.optional()\n})];\nvar uiMessageSchema = external_exports2.object({\n  id: external_exports2.string(),\n  role: external_exports2.enum([\"system\", \"user\", \"assistant\"]),\n  metadata: external_exports2.unknown().optional(),\n  parts: external_exports2.array(external_exports2.union([textUIPartSchema, reasoningUIPartSchema, sourceUrlUIPartSchema, sourceDocumentUIPartSchema, fileUIPartSchema, stepStartUIPartSchema, dataUIPartSchema, ...dynamicToolUIPartSchemas, ...toolUIPartSchemas]))\n});\n\n// ../../node_modules/@ai-sdk/openai/node_modules/@ai-sdk/provider/dist/index.mjs\nvar marker18 = \"vercel.ai.error\";\nvar symbol19 = Symbol.for(marker18);\nvar _a18;\nvar _AISDKError5 = class _AISDKError6 extends Error {\n  /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */\n  constructor({\n    name: name143,\n    message,\n    cause\n  }) {\n    super(message);\n    this[_a18] = true;\n    this.name = name143;\n    this.cause = cause;\n  }\n  /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */\n  static isInstance(error40) {\n    return _AISDKError6.hasMarker(error40, marker18);\n  }\n  static hasMarker(error40, marker153) {\n    const markerSymbol = Symbol.for(marker153);\n    return error40 != null && typeof error40 === \"object\" && markerSymbol in error40 && typeof error40[markerSymbol] === \"boolean\" && error40[markerSymbol] === true;\n  }\n};\n_a18 = symbol19;\nvar AISDKError3 = _AISDKError5;\nvar name17 = \"AI_APICallError\";\nvar marker25 = `vercel.ai.error.${name17}`;\nvar symbol25 = Symbol.for(marker25);\nvar _a25;\nvar APICallError3 = class extends AISDKError3 {\n  constructor({\n    message,\n    url: url2,\n    requestBodyValues,\n    statusCode,\n    responseHeaders,\n    responseBody,\n    cause,\n    isRetryable = statusCode != null && (statusCode === 408 ||\n    // request timeout\n    statusCode === 409 ||\n    // conflict\n    statusCode === 429 ||\n    // too many requests\n    statusCode >= 500),\n    // server error\n    data\n  }) {\n    super({\n      name: name17,\n      message,\n      cause\n    });\n    this[_a25] = true;\n    this.url = url2;\n    this.requestBodyValues = requestBodyValues;\n    this.statusCode = statusCode;\n    this.responseHeaders = responseHeaders;\n    this.responseBody = responseBody;\n    this.isRetryable = isRetryable;\n    this.data = data;\n  }\n  static isInstance(error40) {\n    return AISDKError3.hasMarker(error40, marker25);\n  }\n};\n_a25 = symbol25;\nvar name25 = \"AI_EmptyResponseBodyError\";\nvar marker35 = `vercel.ai.error.${name25}`;\nvar symbol35 = Symbol.for(marker35);\nvar _a35;\nvar EmptyResponseBodyError2 = class extends AISDKError3 {\n  // used in isInstance\n  constructor({\n    message = \"Empty response body\"\n  } = {}) {\n    super({\n      name: name25,\n      message\n    });\n    this[_a35] = true;\n  }\n  static isInstance(error40) {\n    return AISDKError3.hasMarker(error40, marker35);\n  }\n};\n_a35 = symbol35;\nfunction getErrorMessage4(error40) {\n  if (error40 == null) {\n    return \"unknown error\";\n  }\n  if (typeof error40 === \"string\") {\n    return error40;\n  }\n  if (error40 instanceof Error) {\n    return error40.message;\n  }\n  return JSON.stringify(error40);\n}\nvar name35 = \"AI_InvalidArgumentError\";\nvar marker45 = `vercel.ai.error.${name35}`;\nvar symbol45 = Symbol.for(marker45);\nvar _a45;\nvar InvalidArgumentError4 = class extends AISDKError3 {\n  constructor({\n    message,\n    cause,\n    argument\n  }) {\n    super({\n      name: name35,\n      message,\n      cause\n    });\n    this[_a45] = true;\n    this.argument = argument;\n  }\n  static isInstance(error40) {\n    return AISDKError3.hasMarker(error40, marker45);\n  }\n};\n_a45 = symbol45;\nvar name45 = \"AI_InvalidPromptError\";\nvar marker55 = `vercel.ai.error.${name45}`;\nvar symbol55 = Symbol.for(marker55);\nvar _a55;\nvar InvalidPromptError2 = class extends AISDKError3 {\n  constructor({\n    prompt,\n    message,\n    cause\n  }) {\n    super({\n      name: name45,\n      message: `Invalid prompt: ${message}`,\n      cause\n    });\n    this[_a55] = true;\n    this.prompt = prompt;\n  }\n  static isInstance(error40) {\n    return AISDKError3.hasMarker(error40, marker55);\n  }\n};\n_a55 = symbol55;\nvar name55 = \"AI_InvalidResponseDataError\";\nvar marker65 = `vercel.ai.error.${name55}`;\nvar symbol65 = Symbol.for(marker65);\nvar _a65;\nvar InvalidResponseDataError = class extends AISDKError3 {\n  constructor({\n    data,\n    message = `Invalid response data: ${JSON.stringify(data)}.`\n  }) {\n    super({\n      name: name55,\n      message\n    });\n    this[_a65] = true;\n    this.data = data;\n  }\n  static isInstance(error40) {\n    return AISDKError3.hasMarker(error40, marker65);\n  }\n};\n_a65 = symbol65;\nvar name65 = \"AI_JSONParseError\";\nvar marker75 = `vercel.ai.error.${name65}`;\nvar symbol75 = Symbol.for(marker75);\nvar _a75;\nvar JSONParseError3 = class extends AISDKError3 {\n  constructor({\n    text: text2,\n    cause\n  }) {\n    super({\n      name: name65,\n      message: `JSON parsing failed: Text: ${text2}.\nError message: ${getErrorMessage4(cause)}`,\n      cause\n    });\n    this[_a75] = true;\n    this.text = text2;\n  }\n  static isInstance(error40) {\n    return AISDKError3.hasMarker(error40, marker75);\n  }\n};\n_a75 = symbol75;\nvar name74 = \"AI_LoadAPIKeyError\";\nvar marker84 = `vercel.ai.error.${name74}`;\nvar symbol84 = Symbol.for(marker84);\nvar _a84;\nvar LoadAPIKeyError = class extends AISDKError3 {\n  // used in isInstance\n  constructor({\n    message\n  }) {\n    super({\n      name: name74,\n      message\n    });\n    this[_a84] = true;\n  }\n  static isInstance(error40) {\n    return AISDKError3.hasMarker(error40, marker84);\n  }\n};\n_a84 = symbol84;\nvar name84 = \"AI_LoadSettingError\";\nvar marker94 = `vercel.ai.error.${name84}`;\nvar symbol94 = Symbol.for(marker94);\nvar _a94;\n_a94 = symbol94;\nvar name94 = \"AI_NoContentGeneratedError\";\nvar marker104 = `vercel.ai.error.${name94}`;\nvar symbol104 = Symbol.for(marker104);\nvar _a104;\n_a104 = symbol104;\nvar name104 = \"AI_NoSuchModelError\";\nvar marker114 = `vercel.ai.error.${name104}`;\nvar symbol114 = Symbol.for(marker114);\nvar _a114;\n_a114 = symbol114;\nvar name114 = \"AI_TooManyEmbeddingValuesForCallError\";\nvar marker124 = `vercel.ai.error.${name114}`;\nvar symbol124 = Symbol.for(marker124);\nvar _a124;\nvar TooManyEmbeddingValuesForCallError = class extends AISDKError3 {\n  constructor(options) {\n    super({\n      name: name114,\n      message: `Too many values for a single embedding call. The ${options.provider} model \"${options.modelId}\" can only embed up to ${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`\n    });\n    this[_a124] = true;\n    this.provider = options.provider;\n    this.modelId = options.modelId;\n    this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;\n    this.values = options.values;\n  }\n  static isInstance(error40) {\n    return AISDKError3.hasMarker(error40, marker124);\n  }\n};\n_a124 = symbol124;\nvar name124 = \"AI_TypeValidationError\";\nvar marker134 = `vercel.ai.error.${name124}`;\nvar symbol134 = Symbol.for(marker134);\nvar _a134;\nvar _TypeValidationError5 = class _TypeValidationError6 extends AISDKError3 {\n  constructor({\n    value,\n    cause\n  }) {\n    super({\n      name: name124,\n      message: `Type validation failed: Value: ${JSON.stringify(value)}.\nError message: ${getErrorMessage4(cause)}`,\n      cause\n    });\n    this[_a134] = true;\n    this.value = value;\n  }\n  static isInstance(error40) {\n    return AISDKError3.hasMarker(error40, marker134);\n  }\n  /**\n   * Wraps an error into a TypeValidationError.\n   * If the cause is already a TypeValidationError with the same value, it returns the cause.\n   * Otherwise, it creates a new TypeValidationError.\n   *\n   * @param {Object} params - The parameters for wrapping the error.\n   * @param {unknown} params.value - The value that failed validation.\n   * @param {unknown} params.cause - The original error or cause of the validation failure.\n   * @returns {TypeValidationError} A TypeValidationError instance.\n   */\n  static wrap({\n    value,\n    cause\n  }) {\n    return _TypeValidationError6.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError6({\n      value,\n      cause\n    });\n  }\n};\n_a134 = symbol134;\nvar TypeValidationError3 = _TypeValidationError5;\nvar name134 = \"AI_UnsupportedFunctionalityError\";\nvar marker144 = `vercel.ai.error.${name134}`;\nvar symbol144 = Symbol.for(marker144);\nvar _a144;\nvar UnsupportedFunctionalityError2 = class extends AISDKError3 {\n  constructor({\n    functionality,\n    message = `'${functionality}' functionality not supported.`\n  }) {\n    super({\n      name: name134,\n      message\n    });\n    this[_a144] = true;\n    this.functionality = functionality;\n  }\n  static isInstance(error40) {\n    return AISDKError3.hasMarker(error40, marker144);\n  }\n};\n_a144 = symbol144;\n\n// ../../node_modules/@ai-sdk/openai/node_modules/@ai-sdk/provider-utils/dist/index.mjs\nfunction combineHeaders2(...headers) {\n  return headers.reduce((combinedHeaders, currentHeaders) => ({\n    ...combinedHeaders,\n    ...(currentHeaders != null ? currentHeaders : {})\n  }), {});\n}\nfunction extractResponseHeaders2(response) {\n  return Object.fromEntries([...response.headers]);\n}\nfunction getRuntimeEnvironmentUserAgent2(globalThisAny = globalThis) {\n  var _a20, _b8, _c;\n  if (globalThisAny.window) {\n    return `runtime/browser`;\n  }\n  if ((_a20 = globalThisAny.navigator) == null ? void 0 : _a20.userAgent) {\n    return `runtime/${globalThisAny.navigator.userAgent.toLowerCase()}`;\n  }\n  if ((_c = (_b8 = globalThisAny.process) == null ? void 0 : _b8.versions) == null ? void 0 : _c.node) {\n    return `runtime/node.js/${globalThisAny.process.version.substring(0)}`;\n  }\n  if (globalThisAny.EdgeRuntime) {\n    return `runtime/vercel-edge`;\n  }\n  return \"runtime/unknown\";\n}\nfunction removeUndefinedEntries3(record2) {\n  return Object.fromEntries(Object.entries(record2).filter(([_key, value]) => value != null));\n}\nfunction withUserAgentSuffix3(headers, ...userAgentSuffixParts) {\n  const cleanedHeaders = removeUndefinedEntries3(headers != null ? headers : {});\n  const normalizedHeaders = new Headers(cleanedHeaders);\n  const currentUserAgentHeader = normalizedHeaders.get(\"user-agent\") || \"\";\n  normalizedHeaders.set(\"user-agent\", [currentUserAgentHeader, ...userAgentSuffixParts].filter(Boolean).join(\" \"));\n  return Object.fromEntries(normalizedHeaders);\n}\nvar createIdGenerator3 = ({\n  prefix,\n  size = 16,\n  alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n  separator = \"-\"\n} = {}) => {\n  const generator = () => {\n    const alphabetLength = alphabet.length;\n    const chars = new Array(size);\n    for (let i = 0; i < size; i++) {\n      chars[i] = alphabet[Math.random() * alphabetLength | 0];\n    }\n    return chars.join(\"\");\n  };\n  if (prefix == null) {\n    return generator;\n  }\n  if (alphabet.includes(separator)) {\n    throw new InvalidArgumentError4({\n      argument: \"separator\",\n      message: `The separator \"${separator}\" must not be part of the alphabet \"${alphabet}\".`\n    });\n  }\n  return () => `${prefix}${separator}${generator()}`;\n};\nvar generateId3 = createIdGenerator3();\nfunction isAbortError3(error40) {\n  return (error40 instanceof Error || error40 instanceof DOMException) && (error40.name === \"AbortError\" || error40.name === \"ResponseAborted\" ||\n  // Next.js\n  error40.name === \"TimeoutError\");\n}\nvar FETCH_FAILED_ERROR_MESSAGES2 = [\"fetch failed\", \"failed to fetch\"];\nfunction handleFetchError2({\n  error: error40,\n  url: url2,\n  requestBodyValues\n}) {\n  if (isAbortError3(error40)) {\n    return error40;\n  }\n  if (error40 instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES2.includes(error40.message.toLowerCase())) {\n    const cause = error40.cause;\n    if (cause != null) {\n      return new APICallError3({\n        message: `Cannot connect to API: ${cause.message}`,\n        cause,\n        url: url2,\n        requestBodyValues,\n        isRetryable: true\n        // retry when network error\n      });\n    }\n  }\n  return error40;\n}\nvar VERSION4 = true ? \"3.0.9\" : \"0.0.0-test\";\nfunction loadApiKey({\n  apiKey,\n  environmentVariableName,\n  apiKeyParameterName = \"apiKey\",\n  description\n}) {\n  if (typeof apiKey === \"string\") {\n    return apiKey;\n  }\n  if (apiKey != null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string.`\n    });\n  }\n  if (typeof process === \"undefined\") {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`\n    });\n  }\n  apiKey = process.env[environmentVariableName];\n  if (apiKey == null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`\n    });\n  }\n  if (typeof apiKey !== \"string\") {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`\n    });\n  }\n  return apiKey;\n}\nfunction mediaTypeToExtension(mediaType) {\n  var _a20;\n  const [_type, subtype = \"\"] = mediaType.toLowerCase().split(\"/\");\n  return (_a20 = {\n    mpeg: \"mp3\",\n    \"x-wav\": \"wav\",\n    opus: \"ogg\",\n    mp4: \"m4a\",\n    \"x-m4a\": \"m4a\"\n  }[subtype]) != null ? _a20 : subtype;\n}\nvar suspectProtoRx3 = /\"__proto__\"\\s*:/;\nvar suspectConstructorRx3 = /\"constructor\"\\s*:/;\nfunction _parse4(text2) {\n  const obj = JSON.parse(text2);\n  if (obj === null || typeof obj !== \"object\") {\n    return obj;\n  }\n  if (suspectProtoRx3.test(text2) === false && suspectConstructorRx3.test(text2) === false) {\n    return obj;\n  }\n  return filter3(obj);\n}\nfunction filter3(obj) {\n  let next = [obj];\n  while (next.length) {\n    const nodes = next;\n    next = [];\n    for (const node of nodes) {\n      if (Object.prototype.hasOwnProperty.call(node, \"__proto__\")) {\n        throw new SyntaxError(\"Object contains forbidden prototype property\");\n      }\n      if (Object.prototype.hasOwnProperty.call(node, \"constructor\") && Object.prototype.hasOwnProperty.call(node.constructor, \"prototype\")) {\n        throw new SyntaxError(\"Object contains forbidden prototype property\");\n      }\n      for (const key in node) {\n        const value = node[key];\n        if (value && typeof value === \"object\") {\n          next.push(value);\n        }\n      }\n    }\n  }\n  return obj;\n}\nfunction secureJsonParse3(text2) {\n  const {\n    stackTraceLimit\n  } = Error;\n  Error.stackTraceLimit = 0;\n  try {\n    return _parse4(text2);\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit;\n  }\n}\nvar validatorSymbol3 = Symbol.for(\"vercel.ai.validator\");\nfunction validator3(validate) {\n  return {\n    [validatorSymbol3]: true,\n    validate\n  };\n}\nfunction isValidator3(value) {\n  return typeof value === \"object\" && value !== null && validatorSymbol3 in value && value[validatorSymbol3] === true && \"validate\" in value;\n}\nfunction asValidator3(value) {\n  return isValidator3(value) ? value : standardSchemaValidator3(value);\n}\nfunction standardSchemaValidator3(standardSchema) {\n  return validator3(async value => {\n    const result = await standardSchema[\"~standard\"].validate(value);\n    return result.issues == null ? {\n      success: true,\n      value: result.value\n    } : {\n      success: false,\n      error: new TypeValidationError3({\n        value,\n        cause: result.issues\n      })\n    };\n  });\n}\nasync function validateTypes3({\n  value,\n  schema\n}) {\n  const result = await safeValidateTypes3({\n    value,\n    schema\n  });\n  if (!result.success) {\n    throw TypeValidationError3.wrap({\n      value,\n      cause: result.error\n    });\n  }\n  return result.value;\n}\nasync function safeValidateTypes3({\n  value,\n  schema\n}) {\n  const validator22 = asValidator3(schema);\n  try {\n    if (validator22.validate == null) {\n      return {\n        success: true,\n        value,\n        rawValue: value\n      };\n    }\n    const result = await validator22.validate(value);\n    if (result.success) {\n      return {\n        success: true,\n        value: result.value,\n        rawValue: value\n      };\n    }\n    return {\n      success: false,\n      error: TypeValidationError3.wrap({\n        value,\n        cause: result.error\n      }),\n      rawValue: value\n    };\n  } catch (error40) {\n    return {\n      success: false,\n      error: TypeValidationError3.wrap({\n        value,\n        cause: error40\n      }),\n      rawValue: value\n    };\n  }\n}\nasync function parseJSON2({\n  text: text2,\n  schema\n}) {\n  try {\n    const value = secureJsonParse3(text2);\n    if (schema == null) {\n      return value;\n    }\n    return validateTypes3({\n      value,\n      schema\n    });\n  } catch (error40) {\n    if (JSONParseError3.isInstance(error40) || TypeValidationError3.isInstance(error40)) {\n      throw error40;\n    }\n    throw new JSONParseError3({\n      text: text2,\n      cause: error40\n    });\n  }\n}\nasync function safeParseJSON3({\n  text: text2,\n  schema\n}) {\n  try {\n    const value = secureJsonParse3(text2);\n    if (schema == null) {\n      return {\n        success: true,\n        value,\n        rawValue: value\n      };\n    }\n    return await safeValidateTypes3({\n      value,\n      schema\n    });\n  } catch (error40) {\n    return {\n      success: false,\n      error: JSONParseError3.isInstance(error40) ? error40 : new JSONParseError3({\n        text: text2,\n        cause: error40\n      }),\n      rawValue: void 0\n    };\n  }\n}\nfunction isParsableJson(input) {\n  try {\n    secureJsonParse3(input);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction parseJsonEventStream2({\n  stream,\n  schema\n}) {\n  return stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream()).pipeThrough(new TransformStream({\n    async transform({\n      data\n    }, controller) {\n      if (data === \"[DONE]\") {\n        return;\n      }\n      controller.enqueue(await safeParseJSON3({\n        text: data,\n        schema\n      }));\n    }\n  }));\n}\nasync function parseProviderOptions({\n  provider,\n  providerOptions,\n  schema\n}) {\n  if ((providerOptions == null ? void 0 : providerOptions[provider]) == null) {\n    return void 0;\n  }\n  const parsedProviderOptions = await safeValidateTypes3({\n    value: providerOptions[provider],\n    schema\n  });\n  if (!parsedProviderOptions.success) {\n    throw new InvalidArgumentError4({\n      argument: \"providerOptions\",\n      message: `invalid ${provider} provider options`,\n      cause: parsedProviderOptions.error\n    });\n  }\n  return parsedProviderOptions.value;\n}\nvar getOriginalFetch22 = () => globalThis.fetch;\nvar postJsonToApi2 = async ({\n  url: url2,\n  headers,\n  body,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch: fetch2\n}) => postToApi2({\n  url: url2,\n  headers: {\n    \"Content-Type\": \"application/json\",\n    ...headers\n  },\n  body: {\n    content: JSON.stringify(body),\n    values: body\n  },\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch: fetch2\n});\nvar postFormDataToApi = async ({\n  url: url2,\n  headers,\n  formData,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch: fetch2\n}) => postToApi2({\n  url: url2,\n  headers,\n  body: {\n    content: formData,\n    values: Object.fromEntries(formData.entries())\n  },\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch: fetch2\n});\nvar postToApi2 = async ({\n  url: url2,\n  headers = {},\n  body,\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch: fetch2 = getOriginalFetch22()\n}) => {\n  try {\n    const response = await fetch2(url2, {\n      method: \"POST\",\n      headers: withUserAgentSuffix3(headers, `ai-sdk/provider-utils/${VERSION4}`, getRuntimeEnvironmentUserAgent2()),\n      body: body.content,\n      signal: abortSignal\n    });\n    const responseHeaders = extractResponseHeaders2(response);\n    if (!response.ok) {\n      let errorInformation;\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url: url2,\n          requestBodyValues: body.values\n        });\n      } catch (error40) {\n        if (isAbortError3(error40) || APICallError3.isInstance(error40)) {\n          throw error40;\n        }\n        throw new APICallError3({\n          message: \"Failed to process error response\",\n          cause: error40,\n          statusCode: response.status,\n          url: url2,\n          responseHeaders,\n          requestBodyValues: body.values\n        });\n      }\n      throw errorInformation.value;\n    }\n    try {\n      return await successfulResponseHandler({\n        response,\n        url: url2,\n        requestBodyValues: body.values\n      });\n    } catch (error40) {\n      if (error40 instanceof Error) {\n        if (isAbortError3(error40) || APICallError3.isInstance(error40)) {\n          throw error40;\n        }\n      }\n      throw new APICallError3({\n        message: \"Failed to process successful response\",\n        cause: error40,\n        statusCode: response.status,\n        url: url2,\n        responseHeaders,\n        requestBodyValues: body.values\n      });\n    }\n  } catch (error40) {\n    throw handleFetchError2({\n      error: error40,\n      url: url2,\n      requestBodyValues: body.values\n    });\n  }\n};\nfunction tool(tool2) {\n  return tool2;\n}\nfunction createProviderDefinedToolFactory({\n  id,\n  name: name19,\n  inputSchema\n}) {\n  return ({\n    execute,\n    outputSchema: outputSchema2,\n    toModelOutput,\n    onInputStart,\n    onInputDelta,\n    onInputAvailable,\n    ...args\n  }) => tool({\n    type: \"provider-defined\",\n    id,\n    name: name19,\n    args,\n    inputSchema,\n    outputSchema: outputSchema2,\n    execute,\n    toModelOutput,\n    onInputStart,\n    onInputDelta,\n    onInputAvailable\n  });\n}\nfunction createProviderDefinedToolFactoryWithOutputSchema({\n  id,\n  name: name19,\n  inputSchema,\n  outputSchema: outputSchema2\n}) {\n  return ({\n    execute,\n    toModelOutput,\n    onInputStart,\n    onInputDelta,\n    onInputAvailable,\n    ...args\n  }) => tool({\n    type: \"provider-defined\",\n    id,\n    name: name19,\n    args,\n    inputSchema,\n    outputSchema: outputSchema2,\n    execute,\n    toModelOutput,\n    onInputStart,\n    onInputDelta,\n    onInputAvailable\n  });\n}\nvar createJsonErrorResponseHandler2 = ({\n  errorSchema,\n  errorToMessage,\n  isRetryable\n}) => async ({\n  response,\n  url: url2,\n  requestBodyValues\n}) => {\n  const responseBody = await response.text();\n  const responseHeaders = extractResponseHeaders2(response);\n  if (responseBody.trim() === \"\") {\n    return {\n      responseHeaders,\n      value: new APICallError3({\n        message: response.statusText,\n        url: url2,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n  try {\n    const parsedError = await parseJSON2({\n      text: responseBody,\n      schema: errorSchema\n    });\n    return {\n      responseHeaders,\n      value: new APICallError3({\n        message: errorToMessage(parsedError),\n        url: url2,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        data: parsedError,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)\n      })\n    };\n  } catch (parseError) {\n    return {\n      responseHeaders,\n      value: new APICallError3({\n        message: response.statusText,\n        url: url2,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n};\nvar createEventSourceResponseHandler2 = chunkSchema2 => async ({\n  response\n}) => {\n  const responseHeaders = extractResponseHeaders2(response);\n  if (response.body == null) {\n    throw new EmptyResponseBodyError2({});\n  }\n  return {\n    responseHeaders,\n    value: parseJsonEventStream2({\n      stream: response.body,\n      schema: chunkSchema2\n    })\n  };\n};\nvar createJsonResponseHandler2 = responseSchema2 => async ({\n  response,\n  url: url2,\n  requestBodyValues\n}) => {\n  const responseBody = await response.text();\n  const parsedResult = await safeParseJSON3({\n    text: responseBody,\n    schema: responseSchema2\n  });\n  const responseHeaders = extractResponseHeaders2(response);\n  if (!parsedResult.success) {\n    throw new APICallError3({\n      message: \"Invalid JSON response\",\n      cause: parsedResult.error,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody,\n      url: url2,\n      requestBodyValues\n    });\n  }\n  return {\n    responseHeaders,\n    value: parsedResult.value,\n    rawValue: parsedResult.rawValue\n  };\n};\nvar createBinaryResponseHandler = () => async ({\n  response,\n  url: url2,\n  requestBodyValues\n}) => {\n  const responseHeaders = extractResponseHeaders2(response);\n  if (!response.body) {\n    throw new APICallError3({\n      message: \"Response body is empty\",\n      url: url2,\n      requestBodyValues,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody: void 0\n    });\n  }\n  try {\n    const buffer = await response.arrayBuffer();\n    return {\n      responseHeaders,\n      value: new Uint8Array(buffer)\n    };\n  } catch (error40) {\n    throw new APICallError3({\n      message: \"Failed to read response as array buffer\",\n      url: url2,\n      requestBodyValues,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody: void 0,\n      cause: error40\n    });\n  }\n};\nvar ignoreOverride4 = Symbol(\"Let zodToJsonSchema decide on which parser to use\");\nvar ALPHA_NUMERIC4 = new Set(\"ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789\");\nvar schemaSymbol3 = Symbol.for(\"vercel.ai.schema\");\nvar {\n  btoa: btoa4,\n  atob: atob4\n} = globalThis;\nfunction convertBase64ToUint8Array2(base64String) {\n  const base64Url = base64String.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  const latin1string = atob4(base64Url);\n  return Uint8Array.from(latin1string, byte => byte.codePointAt(0));\n}\nfunction convertUint8ArrayToBase642(array2) {\n  let latin1string = \"\";\n  for (let i = 0; i < array2.length; i++) {\n    latin1string += String.fromCodePoint(array2[i]);\n  }\n  return btoa4(latin1string);\n}\nfunction convertToBase64(value) {\n  return value instanceof Uint8Array ? convertUint8ArrayToBase642(value) : value;\n}\nfunction withoutTrailingSlash2(url2) {\n  return url2 == null ? void 0 : url2.replace(/\\/$/, \"\");\n}\n\n// ../../node_modules/@ai-sdk/openai/dist/index.mjs\nvar openaiErrorDataSchema = external_exports2.object({\n  error: external_exports2.object({\n    message: external_exports2.string(),\n    // The additional information below is handled loosely to support\n    // OpenAI-compatible providers that have slightly different error\n    // responses:\n    type: external_exports2.string().nullish(),\n    param: external_exports2.any().nullish(),\n    code: external_exports2.union([external_exports2.string(), external_exports2.number()]).nullish()\n  })\n});\nvar openaiFailedResponseHandler = createJsonErrorResponseHandler2({\n  errorSchema: openaiErrorDataSchema,\n  errorToMessage: data => data.error.message\n});\nfunction convertToOpenAIChatMessages({\n  prompt,\n  systemMessageMode = \"system\"\n}) {\n  const messages = [];\n  const warnings = [];\n  for (const {\n    role,\n    content\n  } of prompt) {\n    switch (role) {\n      case \"system\":\n        {\n          switch (systemMessageMode) {\n            case \"system\":\n              {\n                messages.push({\n                  role: \"system\",\n                  content\n                });\n                break;\n              }\n            case \"developer\":\n              {\n                messages.push({\n                  role: \"developer\",\n                  content\n                });\n                break;\n              }\n            case \"remove\":\n              {\n                warnings.push({\n                  type: \"other\",\n                  message: \"system messages are removed for this model\"\n                });\n                break;\n              }\n            default:\n              {\n                const _exhaustiveCheck = systemMessageMode;\n                throw new Error(`Unsupported system message mode: ${_exhaustiveCheck}`);\n              }\n          }\n          break;\n        }\n      case \"user\":\n        {\n          if (content.length === 1 && content[0].type === \"text\") {\n            messages.push({\n              role: \"user\",\n              content: content[0].text\n            });\n            break;\n          }\n          messages.push({\n            role: \"user\",\n            content: content.map((part, index) => {\n              var _a20, _b8, _c;\n              switch (part.type) {\n                case \"text\":\n                  {\n                    return {\n                      type: \"text\",\n                      text: part.text\n                    };\n                  }\n                case \"file\":\n                  {\n                    if (part.mediaType.startsWith(\"image/\")) {\n                      const mediaType = part.mediaType === \"image/*\" ? \"image/jpeg\" : part.mediaType;\n                      return {\n                        type: \"image_url\",\n                        image_url: {\n                          url: part.data instanceof URL ? part.data.toString() : `data:${mediaType};base64,${convertToBase64(part.data)}`,\n                          // OpenAI specific extension: image detail\n                          detail: (_b8 = (_a20 = part.providerOptions) == null ? void 0 : _a20.openai) == null ? void 0 : _b8.imageDetail\n                        }\n                      };\n                    } else if (part.mediaType.startsWith(\"audio/\")) {\n                      if (part.data instanceof URL) {\n                        throw new UnsupportedFunctionalityError2({\n                          functionality: \"audio file parts with URLs\"\n                        });\n                      }\n                      switch (part.mediaType) {\n                        case \"audio/wav\":\n                          {\n                            return {\n                              type: \"input_audio\",\n                              input_audio: {\n                                data: convertToBase64(part.data),\n                                format: \"wav\"\n                              }\n                            };\n                          }\n                        case \"audio/mp3\":\n                        case \"audio/mpeg\":\n                          {\n                            return {\n                              type: \"input_audio\",\n                              input_audio: {\n                                data: convertToBase64(part.data),\n                                format: \"mp3\"\n                              }\n                            };\n                          }\n                        default:\n                          {\n                            throw new UnsupportedFunctionalityError2({\n                              functionality: `audio content parts with media type ${part.mediaType}`\n                            });\n                          }\n                      }\n                    } else if (part.mediaType === \"application/pdf\") {\n                      if (part.data instanceof URL) {\n                        throw new UnsupportedFunctionalityError2({\n                          functionality: \"PDF file parts with URLs\"\n                        });\n                      }\n                      return {\n                        type: \"file\",\n                        file: typeof part.data === \"string\" && part.data.startsWith(\"file-\") ? {\n                          file_id: part.data\n                        } : {\n                          filename: (_c = part.filename) != null ? _c : `part-${index}.pdf`,\n                          file_data: `data:application/pdf;base64,${convertToBase64(part.data)}`\n                        }\n                      };\n                    } else {\n                      throw new UnsupportedFunctionalityError2({\n                        functionality: `file part media type ${part.mediaType}`\n                      });\n                    }\n                  }\n              }\n            })\n          });\n          break;\n        }\n      case \"assistant\":\n        {\n          let text2 = \"\";\n          const toolCalls = [];\n          for (const part of content) {\n            switch (part.type) {\n              case \"text\":\n                {\n                  text2 += part.text;\n                  break;\n                }\n              case \"tool-call\":\n                {\n                  toolCalls.push({\n                    id: part.toolCallId,\n                    type: \"function\",\n                    function: {\n                      name: part.toolName,\n                      arguments: JSON.stringify(part.input)\n                    }\n                  });\n                  break;\n                }\n            }\n          }\n          messages.push({\n            role: \"assistant\",\n            content: text2,\n            tool_calls: toolCalls.length > 0 ? toolCalls : void 0\n          });\n          break;\n        }\n      case \"tool\":\n        {\n          for (const toolResponse of content) {\n            const output = toolResponse.output;\n            let contentValue;\n            switch (output.type) {\n              case \"text\":\n              case \"error-text\":\n                contentValue = output.value;\n                break;\n              case \"content\":\n              case \"json\":\n              case \"error-json\":\n                contentValue = JSON.stringify(output.value);\n                break;\n            }\n            messages.push({\n              role: \"tool\",\n              tool_call_id: toolResponse.toolCallId,\n              content: contentValue\n            });\n          }\n          break;\n        }\n      default:\n        {\n          const _exhaustiveCheck = role;\n          throw new Error(`Unsupported role: ${_exhaustiveCheck}`);\n        }\n    }\n  }\n  return {\n    messages,\n    warnings\n  };\n}\nfunction getResponseMetadata({\n  id,\n  model,\n  created\n}) {\n  return {\n    id: id != null ? id : void 0,\n    modelId: model != null ? model : void 0,\n    timestamp: created != null ? new Date(created * 1e3) : void 0\n  };\n}\nfunction mapOpenAIFinishReason(finishReason) {\n  switch (finishReason) {\n    case \"stop\":\n      return \"stop\";\n    case \"length\":\n      return \"length\";\n    case \"content_filter\":\n      return \"content-filter\";\n    case \"function_call\":\n    case \"tool_calls\":\n      return \"tool-calls\";\n    default:\n      return \"unknown\";\n  }\n}\nvar openaiProviderOptions = external_exports2.object({\n  /**\n   * Modify the likelihood of specified tokens appearing in the completion.\n   *\n   * Accepts a JSON object that maps tokens (specified by their token ID in\n   * the GPT tokenizer) to an associated bias value from -100 to 100.\n   */\n  logitBias: external_exports2.record(external_exports2.coerce.number(), external_exports2.number()).optional(),\n  /**\n   * Return the log probabilities of the tokens.\n   *\n   * Setting to true will return the log probabilities of the tokens that\n   * were generated.\n   *\n   * Setting to a number will return the log probabilities of the top n\n   * tokens that were generated.\n   */\n  logprobs: external_exports2.union([external_exports2.boolean(), external_exports2.number()]).optional(),\n  /**\n   * Whether to enable parallel function calling during tool use. Default to true.\n   */\n  parallelToolCalls: external_exports2.boolean().optional(),\n  /**\n   * A unique identifier representing your end-user, which can help OpenAI to\n   * monitor and detect abuse.\n   */\n  user: external_exports2.string().optional(),\n  /**\n   * Reasoning effort for reasoning models. Defaults to `medium`.\n   */\n  reasoningEffort: external_exports2.enum([\"minimal\", \"low\", \"medium\", \"high\"]).optional(),\n  /**\n   * Maximum number of completion tokens to generate. Useful for reasoning models.\n   */\n  maxCompletionTokens: external_exports2.number().optional(),\n  /**\n   * Whether to enable persistence in responses API.\n   */\n  store: external_exports2.boolean().optional(),\n  /**\n   * Metadata to associate with the request.\n   */\n  metadata: external_exports2.record(external_exports2.string().max(64), external_exports2.string().max(512)).optional(),\n  /**\n   * Parameters for prediction mode.\n   */\n  prediction: external_exports2.record(external_exports2.string(), external_exports2.any()).optional(),\n  /**\n   * Whether to use structured outputs.\n   *\n   * @default true\n   */\n  structuredOutputs: external_exports2.boolean().optional(),\n  /**\n   * Service tier for the request.\n   * - 'auto': Default service tier\n   * - 'flex': 50% cheaper processing at the cost of increased latency. Only available for o3 and o4-mini models.\n   * - 'priority': Higher-speed processing with predictably low latency at premium cost. Available for Enterprise customers.\n   *\n   * @default 'auto'\n   */\n  serviceTier: external_exports2.enum([\"auto\", \"flex\", \"priority\"]).optional(),\n  /**\n   * Whether to use strict JSON schema validation.\n   *\n   * @default false\n   */\n  strictJsonSchema: external_exports2.boolean().optional(),\n  /**\n   * Controls the verbosity of the model's responses.\n   * Lower values will result in more concise responses, while higher values will result in more verbose responses.\n   */\n  textVerbosity: external_exports2.enum([\"low\", \"medium\", \"high\"]).optional(),\n  /**\n   * A cache key for prompt caching. Allows manual control over prompt caching behavior.\n   * Useful for improving cache hit rates and working around automatic caching issues.\n   */\n  promptCacheKey: external_exports2.string().optional(),\n  /**\n   * A stable identifier used to help detect users of your application\n   * that may be violating OpenAI's usage policies. The IDs should be a\n   * string that uniquely identifies each user. We recommend hashing their\n   * username or email address, in order to avoid sending us any identifying\n   * information.\n   */\n  safetyIdentifier: external_exports2.string().optional()\n});\nvar comparisonFilterSchema = external_exports2.object({\n  key: external_exports2.string(),\n  type: external_exports2.enum([\"eq\", \"ne\", \"gt\", \"gte\", \"lt\", \"lte\"]),\n  value: external_exports2.union([external_exports2.string(), external_exports2.number(), external_exports2.boolean()])\n});\nvar compoundFilterSchema = external_exports2.object({\n  type: external_exports2.enum([\"and\", \"or\"]),\n  filters: external_exports2.array(external_exports2.union([comparisonFilterSchema, external_exports2.lazy(() => compoundFilterSchema)]))\n});\nvar filtersSchema = external_exports2.union([comparisonFilterSchema, compoundFilterSchema]);\nvar fileSearchArgsSchema = external_exports2.object({\n  vectorStoreIds: external_exports2.array(external_exports2.string()).optional(),\n  maxNumResults: external_exports2.number().optional(),\n  ranking: external_exports2.object({\n    ranker: external_exports2.enum([\"auto\", \"default-2024-08-21\"]).optional()\n  }).optional(),\n  filters: filtersSchema.optional()\n});\nvar fileSearch = createProviderDefinedToolFactory({\n  id: \"openai.file_search\",\n  name: \"file_search\",\n  inputSchema: external_exports2.object({\n    query: external_exports2.string()\n  })\n});\nvar webSearchPreviewArgsSchema = external_exports2.object({\n  /**\n   * Search context size to use for the web search.\n   * - high: Most comprehensive context, highest cost, slower response\n   * - medium: Balanced context, cost, and latency (default)\n   * - low: Least context, lowest cost, fastest response\n   */\n  searchContextSize: external_exports2.enum([\"low\", \"medium\", \"high\"]).optional(),\n  /**\n   * User location information to provide geographically relevant search results.\n   */\n  userLocation: external_exports2.object({\n    /**\n     * Type of location (always 'approximate')\n     */\n    type: external_exports2.literal(\"approximate\"),\n    /**\n     * Two-letter ISO country code (e.g., 'US', 'GB')\n     */\n    country: external_exports2.string().optional(),\n    /**\n     * City name (free text, e.g., 'Minneapolis')\n     */\n    city: external_exports2.string().optional(),\n    /**\n     * Region name (free text, e.g., 'Minnesota')\n     */\n    region: external_exports2.string().optional(),\n    /**\n     * IANA timezone (e.g., 'America/Chicago')\n     */\n    timezone: external_exports2.string().optional()\n  }).optional()\n});\nvar webSearchPreview = createProviderDefinedToolFactory({\n  id: \"openai.web_search_preview\",\n  name: \"web_search_preview\",\n  inputSchema: external_exports2.object({\n    action: external_exports2.discriminatedUnion(\"type\", [external_exports2.object({\n      type: external_exports2.literal(\"search\"),\n      query: external_exports2.string().nullish()\n    }), external_exports2.object({\n      type: external_exports2.literal(\"open_page\"),\n      url: external_exports2.string()\n    }), external_exports2.object({\n      type: external_exports2.literal(\"find\"),\n      url: external_exports2.string(),\n      pattern: external_exports2.string()\n    })]).nullish()\n  })\n});\nfunction prepareChatTools({\n  tools,\n  toolChoice,\n  structuredOutputs,\n  strictJsonSchema\n}) {\n  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;\n  const toolWarnings = [];\n  if (tools == null) {\n    return {\n      tools: void 0,\n      toolChoice: void 0,\n      toolWarnings\n    };\n  }\n  const openaiTools2 = [];\n  for (const tool2 of tools) {\n    switch (tool2.type) {\n      case \"function\":\n        openaiTools2.push({\n          type: \"function\",\n          function: {\n            name: tool2.name,\n            description: tool2.description,\n            parameters: tool2.inputSchema,\n            strict: structuredOutputs ? strictJsonSchema : void 0\n          }\n        });\n        break;\n      case \"provider-defined\":\n        switch (tool2.id) {\n          case \"openai.file_search\":\n            {\n              const args = fileSearchArgsSchema.parse(tool2.args);\n              openaiTools2.push({\n                type: \"file_search\",\n                vector_store_ids: args.vectorStoreIds,\n                max_num_results: args.maxNumResults,\n                ranking_options: args.ranking ? {\n                  ranker: args.ranking.ranker\n                } : void 0,\n                filters: args.filters\n              });\n              break;\n            }\n          case \"openai.web_search_preview\":\n            {\n              const args = webSearchPreviewArgsSchema.parse(tool2.args);\n              openaiTools2.push({\n                type: \"web_search_preview\",\n                search_context_size: args.searchContextSize,\n                user_location: args.userLocation\n              });\n              break;\n            }\n          default:\n            toolWarnings.push({\n              type: \"unsupported-tool\",\n              tool: tool2\n            });\n            break;\n        }\n        break;\n      default:\n        toolWarnings.push({\n          type: \"unsupported-tool\",\n          tool: tool2\n        });\n        break;\n    }\n  }\n  if (toolChoice == null) {\n    return {\n      tools: openaiTools2,\n      toolChoice: void 0,\n      toolWarnings\n    };\n  }\n  const type = toolChoice.type;\n  switch (type) {\n    case \"auto\":\n    case \"none\":\n    case \"required\":\n      return {\n        tools: openaiTools2,\n        toolChoice: type,\n        toolWarnings\n      };\n    case \"tool\":\n      return {\n        tools: openaiTools2,\n        toolChoice: {\n          type: \"function\",\n          function: {\n            name: toolChoice.toolName\n          }\n        },\n        toolWarnings\n      };\n    default:\n      {\n        const _exhaustiveCheck = type;\n        throw new UnsupportedFunctionalityError2({\n          functionality: `tool choice type: ${_exhaustiveCheck}`\n        });\n      }\n  }\n}\nvar OpenAIChatLanguageModel = class {\n  constructor(modelId, config2) {\n    this.specificationVersion = \"v2\";\n    this.supportedUrls = {\n      \"image/*\": [/^https?:\\/\\/.*$/]\n    };\n    this.modelId = modelId;\n    this.config = config2;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  async getArgs({\n    prompt,\n    maxOutputTokens,\n    temperature,\n    topP,\n    topK,\n    frequencyPenalty,\n    presencePenalty,\n    stopSequences,\n    responseFormat,\n    seed,\n    tools,\n    toolChoice,\n    providerOptions\n  }) {\n    var _a20, _b8, _c, _d;\n    const warnings = [];\n    const openaiOptions = (_a20 = await parseProviderOptions({\n      provider: \"openai\",\n      providerOptions,\n      schema: openaiProviderOptions\n    })) != null ? _a20 : {};\n    const structuredOutputs = (_b8 = openaiOptions.structuredOutputs) != null ? _b8 : true;\n    if (topK != null) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"topK\"\n      });\n    }\n    if ((responseFormat == null ? void 0 : responseFormat.type) === \"json\" && responseFormat.schema != null && !structuredOutputs) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"responseFormat\",\n        details: \"JSON response format schema is only supported with structuredOutputs\"\n      });\n    }\n    const {\n      messages,\n      warnings: messageWarnings\n    } = convertToOpenAIChatMessages({\n      prompt,\n      systemMessageMode: getSystemMessageMode(this.modelId)\n    });\n    warnings.push(...messageWarnings);\n    const strictJsonSchema = (_c = openaiOptions.strictJsonSchema) != null ? _c : false;\n    const baseArgs = {\n      // model id:\n      model: this.modelId,\n      // model specific settings:\n      logit_bias: openaiOptions.logitBias,\n      logprobs: openaiOptions.logprobs === true || typeof openaiOptions.logprobs === \"number\" ? true : void 0,\n      top_logprobs: typeof openaiOptions.logprobs === \"number\" ? openaiOptions.logprobs : typeof openaiOptions.logprobs === \"boolean\" ? openaiOptions.logprobs ? 0 : void 0 : void 0,\n      user: openaiOptions.user,\n      parallel_tool_calls: openaiOptions.parallelToolCalls,\n      // standardized settings:\n      max_tokens: maxOutputTokens,\n      temperature,\n      top_p: topP,\n      frequency_penalty: frequencyPenalty,\n      presence_penalty: presencePenalty,\n      response_format: (responseFormat == null ? void 0 : responseFormat.type) === \"json\" ? structuredOutputs && responseFormat.schema != null ? {\n        type: \"json_schema\",\n        json_schema: {\n          schema: responseFormat.schema,\n          strict: strictJsonSchema,\n          name: (_d = responseFormat.name) != null ? _d : \"response\",\n          description: responseFormat.description\n        }\n      } : {\n        type: \"json_object\"\n      } : void 0,\n      stop: stopSequences,\n      seed,\n      verbosity: openaiOptions.textVerbosity,\n      // openai specific settings:\n      // TODO AI SDK 6: remove, we auto-map maxOutputTokens now\n      max_completion_tokens: openaiOptions.maxCompletionTokens,\n      store: openaiOptions.store,\n      metadata: openaiOptions.metadata,\n      prediction: openaiOptions.prediction,\n      reasoning_effort: openaiOptions.reasoningEffort,\n      service_tier: openaiOptions.serviceTier,\n      prompt_cache_key: openaiOptions.promptCacheKey,\n      safety_identifier: openaiOptions.safetyIdentifier,\n      // messages:\n      messages\n    };\n    if (isReasoningModel(this.modelId)) {\n      if (baseArgs.temperature != null) {\n        baseArgs.temperature = void 0;\n        warnings.push({\n          type: \"unsupported-setting\",\n          setting: \"temperature\",\n          details: \"temperature is not supported for reasoning models\"\n        });\n      }\n      if (baseArgs.top_p != null) {\n        baseArgs.top_p = void 0;\n        warnings.push({\n          type: \"unsupported-setting\",\n          setting: \"topP\",\n          details: \"topP is not supported for reasoning models\"\n        });\n      }\n      if (baseArgs.frequency_penalty != null) {\n        baseArgs.frequency_penalty = void 0;\n        warnings.push({\n          type: \"unsupported-setting\",\n          setting: \"frequencyPenalty\",\n          details: \"frequencyPenalty is not supported for reasoning models\"\n        });\n      }\n      if (baseArgs.presence_penalty != null) {\n        baseArgs.presence_penalty = void 0;\n        warnings.push({\n          type: \"unsupported-setting\",\n          setting: \"presencePenalty\",\n          details: \"presencePenalty is not supported for reasoning models\"\n        });\n      }\n      if (baseArgs.logit_bias != null) {\n        baseArgs.logit_bias = void 0;\n        warnings.push({\n          type: \"other\",\n          message: \"logitBias is not supported for reasoning models\"\n        });\n      }\n      if (baseArgs.logprobs != null) {\n        baseArgs.logprobs = void 0;\n        warnings.push({\n          type: \"other\",\n          message: \"logprobs is not supported for reasoning models\"\n        });\n      }\n      if (baseArgs.top_logprobs != null) {\n        baseArgs.top_logprobs = void 0;\n        warnings.push({\n          type: \"other\",\n          message: \"topLogprobs is not supported for reasoning models\"\n        });\n      }\n      if (baseArgs.max_tokens != null) {\n        if (baseArgs.max_completion_tokens == null) {\n          baseArgs.max_completion_tokens = baseArgs.max_tokens;\n        }\n        baseArgs.max_tokens = void 0;\n      }\n    } else if (this.modelId.startsWith(\"gpt-4o-search-preview\") || this.modelId.startsWith(\"gpt-4o-mini-search-preview\")) {\n      if (baseArgs.temperature != null) {\n        baseArgs.temperature = void 0;\n        warnings.push({\n          type: \"unsupported-setting\",\n          setting: \"temperature\",\n          details: \"temperature is not supported for the search preview models and has been removed.\"\n        });\n      }\n    }\n    if (openaiOptions.serviceTier === \"flex\" && !supportsFlexProcessing(this.modelId)) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"serviceTier\",\n        details: \"flex processing is only available for o3, o4-mini, and gpt-5 models\"\n      });\n      baseArgs.service_tier = void 0;\n    }\n    if (openaiOptions.serviceTier === \"priority\" && !supportsPriorityProcessing(this.modelId)) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"serviceTier\",\n        details: \"priority processing is only available for supported models (gpt-4, gpt-5, gpt-5-mini, o3, o4-mini) and requires Enterprise access. gpt-5-nano is not supported\"\n      });\n      baseArgs.service_tier = void 0;\n    }\n    const {\n      tools: openaiTools2,\n      toolChoice: openaiToolChoice,\n      toolWarnings\n    } = prepareChatTools({\n      tools,\n      toolChoice,\n      structuredOutputs,\n      strictJsonSchema\n    });\n    return {\n      args: {\n        ...baseArgs,\n        tools: openaiTools2,\n        tool_choice: openaiToolChoice\n      },\n      warnings: [...warnings, ...toolWarnings]\n    };\n  }\n  async doGenerate(options) {\n    var _a20, _b8, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;\n    const {\n      args: body,\n      warnings\n    } = await this.getArgs(options);\n    const {\n      responseHeaders,\n      value: response,\n      rawValue: rawResponse\n    } = await postJsonToApi2({\n      url: this.config.url({\n        path: \"/chat/completions\",\n        modelId: this.modelId\n      }),\n      headers: combineHeaders2(this.config.headers(), options.headers),\n      body,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler2(openaiChatResponseSchema),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    const choice = response.choices[0];\n    const content = [];\n    const text2 = choice.message.content;\n    if (text2 != null && text2.length > 0) {\n      content.push({\n        type: \"text\",\n        text: text2\n      });\n    }\n    for (const toolCall of (_a20 = choice.message.tool_calls) != null ? _a20 : []) {\n      content.push({\n        type: \"tool-call\",\n        toolCallId: (_b8 = toolCall.id) != null ? _b8 : generateId3(),\n        toolName: toolCall.function.name,\n        input: toolCall.function.arguments\n      });\n    }\n    for (const annotation of (_c = choice.message.annotations) != null ? _c : []) {\n      content.push({\n        type: \"source\",\n        sourceType: \"url\",\n        id: generateId3(),\n        url: annotation.url,\n        title: annotation.title\n      });\n    }\n    const completionTokenDetails = (_d = response.usage) == null ? void 0 : _d.completion_tokens_details;\n    const promptTokenDetails = (_e = response.usage) == null ? void 0 : _e.prompt_tokens_details;\n    const providerMetadata = {\n      openai: {}\n    };\n    if ((completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens) != null) {\n      providerMetadata.openai.acceptedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens;\n    }\n    if ((completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens) != null) {\n      providerMetadata.openai.rejectedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens;\n    }\n    if (((_f = choice.logprobs) == null ? void 0 : _f.content) != null) {\n      providerMetadata.openai.logprobs = choice.logprobs.content;\n    }\n    return {\n      content,\n      finishReason: mapOpenAIFinishReason(choice.finish_reason),\n      usage: {\n        inputTokens: (_h = (_g = response.usage) == null ? void 0 : _g.prompt_tokens) != null ? _h : void 0,\n        outputTokens: (_j = (_i = response.usage) == null ? void 0 : _i.completion_tokens) != null ? _j : void 0,\n        totalTokens: (_l = (_k = response.usage) == null ? void 0 : _k.total_tokens) != null ? _l : void 0,\n        reasoningTokens: (_m = completionTokenDetails == null ? void 0 : completionTokenDetails.reasoning_tokens) != null ? _m : void 0,\n        cachedInputTokens: (_n = promptTokenDetails == null ? void 0 : promptTokenDetails.cached_tokens) != null ? _n : void 0\n      },\n      request: {\n        body\n      },\n      response: {\n        ...getResponseMetadata(response),\n        headers: responseHeaders,\n        body: rawResponse\n      },\n      warnings,\n      providerMetadata\n    };\n  }\n  async doStream(options) {\n    const {\n      args,\n      warnings\n    } = await this.getArgs(options);\n    const body = {\n      ...args,\n      stream: true,\n      stream_options: {\n        include_usage: true\n      }\n    };\n    const {\n      responseHeaders,\n      value: response\n    } = await postJsonToApi2({\n      url: this.config.url({\n        path: \"/chat/completions\",\n        modelId: this.modelId\n      }),\n      headers: combineHeaders2(this.config.headers(), options.headers),\n      body,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createEventSourceResponseHandler2(openaiChatChunkSchema),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    const toolCalls = [];\n    let finishReason = \"unknown\";\n    const usage = {\n      inputTokens: void 0,\n      outputTokens: void 0,\n      totalTokens: void 0\n    };\n    let isFirstChunk = true;\n    let isActiveText = false;\n    const providerMetadata = {\n      openai: {}\n    };\n    return {\n      stream: response.pipeThrough(new TransformStream({\n        start(controller) {\n          controller.enqueue({\n            type: \"stream-start\",\n            warnings\n          });\n        },\n        transform(chunk, controller) {\n          var _a20, _b8, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;\n          if (options.includeRawChunks) {\n            controller.enqueue({\n              type: \"raw\",\n              rawValue: chunk.rawValue\n            });\n          }\n          if (!chunk.success) {\n            finishReason = \"error\";\n            controller.enqueue({\n              type: \"error\",\n              error: chunk.error\n            });\n            return;\n          }\n          const value = chunk.value;\n          if (\"error\" in value) {\n            finishReason = \"error\";\n            controller.enqueue({\n              type: \"error\",\n              error: value.error\n            });\n            return;\n          }\n          if (isFirstChunk) {\n            isFirstChunk = false;\n            controller.enqueue({\n              type: \"response-metadata\",\n              ...getResponseMetadata(value)\n            });\n          }\n          if (value.usage != null) {\n            usage.inputTokens = (_a20 = value.usage.prompt_tokens) != null ? _a20 : void 0;\n            usage.outputTokens = (_b8 = value.usage.completion_tokens) != null ? _b8 : void 0;\n            usage.totalTokens = (_c = value.usage.total_tokens) != null ? _c : void 0;\n            usage.reasoningTokens = (_e = (_d = value.usage.completion_tokens_details) == null ? void 0 : _d.reasoning_tokens) != null ? _e : void 0;\n            usage.cachedInputTokens = (_g = (_f = value.usage.prompt_tokens_details) == null ? void 0 : _f.cached_tokens) != null ? _g : void 0;\n            if (((_h = value.usage.completion_tokens_details) == null ? void 0 : _h.accepted_prediction_tokens) != null) {\n              providerMetadata.openai.acceptedPredictionTokens = (_i = value.usage.completion_tokens_details) == null ? void 0 : _i.accepted_prediction_tokens;\n            }\n            if (((_j = value.usage.completion_tokens_details) == null ? void 0 : _j.rejected_prediction_tokens) != null) {\n              providerMetadata.openai.rejectedPredictionTokens = (_k = value.usage.completion_tokens_details) == null ? void 0 : _k.rejected_prediction_tokens;\n            }\n          }\n          const choice = value.choices[0];\n          if ((choice == null ? void 0 : choice.finish_reason) != null) {\n            finishReason = mapOpenAIFinishReason(choice.finish_reason);\n          }\n          if (((_l = choice == null ? void 0 : choice.logprobs) == null ? void 0 : _l.content) != null) {\n            providerMetadata.openai.logprobs = choice.logprobs.content;\n          }\n          if ((choice == null ? void 0 : choice.delta) == null) {\n            return;\n          }\n          const delta = choice.delta;\n          if (delta.content != null) {\n            if (!isActiveText) {\n              controller.enqueue({\n                type: \"text-start\",\n                id: \"0\"\n              });\n              isActiveText = true;\n            }\n            controller.enqueue({\n              type: \"text-delta\",\n              id: \"0\",\n              delta: delta.content\n            });\n          }\n          if (delta.tool_calls != null) {\n            for (const toolCallDelta of delta.tool_calls) {\n              const index = toolCallDelta.index;\n              if (toolCalls[index] == null) {\n                if (toolCallDelta.type !== \"function\") {\n                  throw new InvalidResponseDataError({\n                    data: toolCallDelta,\n                    message: `Expected 'function' type.`\n                  });\n                }\n                if (toolCallDelta.id == null) {\n                  throw new InvalidResponseDataError({\n                    data: toolCallDelta,\n                    message: `Expected 'id' to be a string.`\n                  });\n                }\n                if (((_m = toolCallDelta.function) == null ? void 0 : _m.name) == null) {\n                  throw new InvalidResponseDataError({\n                    data: toolCallDelta,\n                    message: `Expected 'function.name' to be a string.`\n                  });\n                }\n                controller.enqueue({\n                  type: \"tool-input-start\",\n                  id: toolCallDelta.id,\n                  toolName: toolCallDelta.function.name\n                });\n                toolCalls[index] = {\n                  id: toolCallDelta.id,\n                  type: \"function\",\n                  function: {\n                    name: toolCallDelta.function.name,\n                    arguments: (_n = toolCallDelta.function.arguments) != null ? _n : \"\"\n                  },\n                  hasFinished: false\n                };\n                const toolCall2 = toolCalls[index];\n                if (((_o = toolCall2.function) == null ? void 0 : _o.name) != null && ((_p = toolCall2.function) == null ? void 0 : _p.arguments) != null) {\n                  if (toolCall2.function.arguments.length > 0) {\n                    controller.enqueue({\n                      type: \"tool-input-delta\",\n                      id: toolCall2.id,\n                      delta: toolCall2.function.arguments\n                    });\n                  }\n                  if (isParsableJson(toolCall2.function.arguments)) {\n                    controller.enqueue({\n                      type: \"tool-input-end\",\n                      id: toolCall2.id\n                    });\n                    controller.enqueue({\n                      type: \"tool-call\",\n                      toolCallId: (_q = toolCall2.id) != null ? _q : generateId3(),\n                      toolName: toolCall2.function.name,\n                      input: toolCall2.function.arguments\n                    });\n                    toolCall2.hasFinished = true;\n                  }\n                }\n                continue;\n              }\n              const toolCall = toolCalls[index];\n              if (toolCall.hasFinished) {\n                continue;\n              }\n              if (((_r = toolCallDelta.function) == null ? void 0 : _r.arguments) != null) {\n                toolCall.function.arguments += (_t = (_s = toolCallDelta.function) == null ? void 0 : _s.arguments) != null ? _t : \"\";\n              }\n              controller.enqueue({\n                type: \"tool-input-delta\",\n                id: toolCall.id,\n                delta: (_u = toolCallDelta.function.arguments) != null ? _u : \"\"\n              });\n              if (((_v = toolCall.function) == null ? void 0 : _v.name) != null && ((_w = toolCall.function) == null ? void 0 : _w.arguments) != null && isParsableJson(toolCall.function.arguments)) {\n                controller.enqueue({\n                  type: \"tool-input-end\",\n                  id: toolCall.id\n                });\n                controller.enqueue({\n                  type: \"tool-call\",\n                  toolCallId: (_x = toolCall.id) != null ? _x : generateId3(),\n                  toolName: toolCall.function.name,\n                  input: toolCall.function.arguments\n                });\n                toolCall.hasFinished = true;\n              }\n            }\n          }\n          if (delta.annotations != null) {\n            for (const annotation of delta.annotations) {\n              controller.enqueue({\n                type: \"source\",\n                sourceType: \"url\",\n                id: generateId3(),\n                url: annotation.url,\n                title: annotation.title\n              });\n            }\n          }\n        },\n        flush(controller) {\n          if (isActiveText) {\n            controller.enqueue({\n              type: \"text-end\",\n              id: \"0\"\n            });\n          }\n          controller.enqueue({\n            type: \"finish\",\n            finishReason,\n            usage,\n            ...(providerMetadata != null ? {\n              providerMetadata\n            } : {})\n          });\n        }\n      })),\n      request: {\n        body\n      },\n      response: {\n        headers: responseHeaders\n      }\n    };\n  }\n};\nvar openaiTokenUsageSchema = external_exports2.object({\n  prompt_tokens: external_exports2.number().nullish(),\n  completion_tokens: external_exports2.number().nullish(),\n  total_tokens: external_exports2.number().nullish(),\n  prompt_tokens_details: external_exports2.object({\n    cached_tokens: external_exports2.number().nullish()\n  }).nullish(),\n  completion_tokens_details: external_exports2.object({\n    reasoning_tokens: external_exports2.number().nullish(),\n    accepted_prediction_tokens: external_exports2.number().nullish(),\n    rejected_prediction_tokens: external_exports2.number().nullish()\n  }).nullish()\n}).nullish();\nvar openaiChatResponseSchema = external_exports2.object({\n  id: external_exports2.string().nullish(),\n  created: external_exports2.number().nullish(),\n  model: external_exports2.string().nullish(),\n  choices: external_exports2.array(external_exports2.object({\n    message: external_exports2.object({\n      role: external_exports2.literal(\"assistant\").nullish(),\n      content: external_exports2.string().nullish(),\n      tool_calls: external_exports2.array(external_exports2.object({\n        id: external_exports2.string().nullish(),\n        type: external_exports2.literal(\"function\"),\n        function: external_exports2.object({\n          name: external_exports2.string(),\n          arguments: external_exports2.string()\n        })\n      })).nullish(),\n      annotations: external_exports2.array(external_exports2.object({\n        type: external_exports2.literal(\"url_citation\"),\n        start_index: external_exports2.number(),\n        end_index: external_exports2.number(),\n        url: external_exports2.string(),\n        title: external_exports2.string()\n      })).nullish()\n    }),\n    index: external_exports2.number(),\n    logprobs: external_exports2.object({\n      content: external_exports2.array(external_exports2.object({\n        token: external_exports2.string(),\n        logprob: external_exports2.number(),\n        top_logprobs: external_exports2.array(external_exports2.object({\n          token: external_exports2.string(),\n          logprob: external_exports2.number()\n        }))\n      })).nullish()\n    }).nullish(),\n    finish_reason: external_exports2.string().nullish()\n  })),\n  usage: openaiTokenUsageSchema\n});\nvar openaiChatChunkSchema = external_exports2.union([external_exports2.object({\n  id: external_exports2.string().nullish(),\n  created: external_exports2.number().nullish(),\n  model: external_exports2.string().nullish(),\n  choices: external_exports2.array(external_exports2.object({\n    delta: external_exports2.object({\n      role: external_exports2.enum([\"assistant\"]).nullish(),\n      content: external_exports2.string().nullish(),\n      tool_calls: external_exports2.array(external_exports2.object({\n        index: external_exports2.number(),\n        id: external_exports2.string().nullish(),\n        type: external_exports2.literal(\"function\").nullish(),\n        function: external_exports2.object({\n          name: external_exports2.string().nullish(),\n          arguments: external_exports2.string().nullish()\n        })\n      })).nullish(),\n      annotations: external_exports2.array(external_exports2.object({\n        type: external_exports2.literal(\"url_citation\"),\n        start_index: external_exports2.number(),\n        end_index: external_exports2.number(),\n        url: external_exports2.string(),\n        title: external_exports2.string()\n      })).nullish()\n    }).nullish(),\n    logprobs: external_exports2.object({\n      content: external_exports2.array(external_exports2.object({\n        token: external_exports2.string(),\n        logprob: external_exports2.number(),\n        top_logprobs: external_exports2.array(external_exports2.object({\n          token: external_exports2.string(),\n          logprob: external_exports2.number()\n        }))\n      })).nullish()\n    }).nullish(),\n    finish_reason: external_exports2.string().nullish(),\n    index: external_exports2.number()\n  })),\n  usage: openaiTokenUsageSchema\n}), openaiErrorDataSchema]);\nfunction isReasoningModel(modelId) {\n  return (modelId.startsWith(\"o\") || modelId.startsWith(\"gpt-5\")) && !modelId.startsWith(\"gpt-5-chat\");\n}\nfunction supportsFlexProcessing(modelId) {\n  return modelId.startsWith(\"o3\") || modelId.startsWith(\"o4-mini\") || modelId.startsWith(\"gpt-5\") && !modelId.startsWith(\"gpt-5-chat\");\n}\nfunction supportsPriorityProcessing(modelId) {\n  return modelId.startsWith(\"gpt-4\") || modelId.startsWith(\"gpt-5-mini\") || modelId.startsWith(\"gpt-5\") && !modelId.startsWith(\"gpt-5-nano\") && !modelId.startsWith(\"gpt-5-chat\") || modelId.startsWith(\"o3\") || modelId.startsWith(\"o4-mini\");\n}\nfunction getSystemMessageMode(modelId) {\n  var _a20, _b8;\n  if (!isReasoningModel(modelId)) {\n    return \"system\";\n  }\n  return (_b8 = (_a20 = reasoningModels[modelId]) == null ? void 0 : _a20.systemMessageMode) != null ? _b8 : \"developer\";\n}\nvar reasoningModels = {\n  \"o1-mini\": {\n    systemMessageMode: \"remove\"\n  },\n  \"o1-mini-2024-09-12\": {\n    systemMessageMode: \"remove\"\n  },\n  \"o1-preview\": {\n    systemMessageMode: \"remove\"\n  },\n  \"o1-preview-2024-09-12\": {\n    systemMessageMode: \"remove\"\n  },\n  o3: {\n    systemMessageMode: \"developer\"\n  },\n  \"o3-2025-04-16\": {\n    systemMessageMode: \"developer\"\n  },\n  \"o3-mini\": {\n    systemMessageMode: \"developer\"\n  },\n  \"o3-mini-2025-01-31\": {\n    systemMessageMode: \"developer\"\n  },\n  \"o4-mini\": {\n    systemMessageMode: \"developer\"\n  },\n  \"o4-mini-2025-04-16\": {\n    systemMessageMode: \"developer\"\n  }\n};\nfunction convertToOpenAICompletionPrompt({\n  prompt,\n  user = \"user\",\n  assistant = \"assistant\"\n}) {\n  let text2 = \"\";\n  if (prompt[0].role === \"system\") {\n    text2 += `${prompt[0].content}\n\n`;\n    prompt = prompt.slice(1);\n  }\n  for (const {\n    role,\n    content\n  } of prompt) {\n    switch (role) {\n      case \"system\":\n        {\n          throw new InvalidPromptError2({\n            message: \"Unexpected system message in prompt: ${content}\",\n            prompt\n          });\n        }\n      case \"user\":\n        {\n          const userMessage = content.map(part => {\n            switch (part.type) {\n              case \"text\":\n                {\n                  return part.text;\n                }\n            }\n          }).filter(Boolean).join(\"\");\n          text2 += `${user}:\n${userMessage}\n\n`;\n          break;\n        }\n      case \"assistant\":\n        {\n          const assistantMessage = content.map(part => {\n            switch (part.type) {\n              case \"text\":\n                {\n                  return part.text;\n                }\n              case \"tool-call\":\n                {\n                  throw new UnsupportedFunctionalityError2({\n                    functionality: \"tool-call messages\"\n                  });\n                }\n            }\n          }).join(\"\");\n          text2 += `${assistant}:\n${assistantMessage}\n\n`;\n          break;\n        }\n      case \"tool\":\n        {\n          throw new UnsupportedFunctionalityError2({\n            functionality: \"tool messages\"\n          });\n        }\n      default:\n        {\n          const _exhaustiveCheck = role;\n          throw new Error(`Unsupported role: ${_exhaustiveCheck}`);\n        }\n    }\n  }\n  text2 += `${assistant}:\n`;\n  return {\n    prompt: text2,\n    stopSequences: [`\n${user}:`]\n  };\n}\nfunction getResponseMetadata2({\n  id,\n  model,\n  created\n}) {\n  return {\n    id: id != null ? id : void 0,\n    modelId: model != null ? model : void 0,\n    timestamp: created != null ? new Date(created * 1e3) : void 0\n  };\n}\nfunction mapOpenAIFinishReason2(finishReason) {\n  switch (finishReason) {\n    case \"stop\":\n      return \"stop\";\n    case \"length\":\n      return \"length\";\n    case \"content_filter\":\n      return \"content-filter\";\n    case \"function_call\":\n    case \"tool_calls\":\n      return \"tool-calls\";\n    default:\n      return \"unknown\";\n  }\n}\nvar openaiCompletionProviderOptions = external_exports2.object({\n  /**\n  Echo back the prompt in addition to the completion.\n     */\n  echo: external_exports2.boolean().optional(),\n  /**\n  Modify the likelihood of specified tokens appearing in the completion.\n  \n  Accepts a JSON object that maps tokens (specified by their token ID in\n  the GPT tokenizer) to an associated bias value from -100 to 100. You\n  can use this tokenizer tool to convert text to token IDs. Mathematically,\n  the bias is added to the logits generated by the model prior to sampling.\n  The exact effect will vary per model, but values between -1 and 1 should\n  decrease or increase likelihood of selection; values like -100 or 100\n  should result in a ban or exclusive selection of the relevant token.\n  \n  As an example, you can pass {\"50256\": -100} to prevent the <|endoftext|>\n  token from being generated.\n   */\n  logitBias: external_exports2.record(external_exports2.string(), external_exports2.number()).optional(),\n  /**\n  The suffix that comes after a completion of inserted text.\n   */\n  suffix: external_exports2.string().optional(),\n  /**\n  A unique identifier representing your end-user, which can help OpenAI to\n  monitor and detect abuse. Learn more.\n   */\n  user: external_exports2.string().optional(),\n  /**\n  Return the log probabilities of the tokens. Including logprobs will increase\n  the response size and can slow down response times. However, it can\n  be useful to better understand how the model is behaving.\n  Setting to true will return the log probabilities of the tokens that\n  were generated.\n  Setting to a number will return the log probabilities of the top n\n  tokens that were generated.\n     */\n  logprobs: external_exports2.union([external_exports2.boolean(), external_exports2.number()]).optional()\n});\nvar OpenAICompletionLanguageModel = class {\n  constructor(modelId, config2) {\n    this.specificationVersion = \"v2\";\n    this.supportedUrls = {\n      // No URLs are supported for completion models.\n    };\n    this.modelId = modelId;\n    this.config = config2;\n  }\n  get providerOptionsName() {\n    return this.config.provider.split(\".\")[0].trim();\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  async getArgs({\n    prompt,\n    maxOutputTokens,\n    temperature,\n    topP,\n    topK,\n    frequencyPenalty,\n    presencePenalty,\n    stopSequences: userStopSequences,\n    responseFormat,\n    tools,\n    toolChoice,\n    seed,\n    providerOptions\n  }) {\n    const warnings = [];\n    const openaiOptions = {\n      ...(await parseProviderOptions({\n        provider: \"openai\",\n        providerOptions,\n        schema: openaiCompletionProviderOptions\n      })),\n      ...(await parseProviderOptions({\n        provider: this.providerOptionsName,\n        providerOptions,\n        schema: openaiCompletionProviderOptions\n      }))\n    };\n    if (topK != null) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"topK\"\n      });\n    }\n    if (tools == null ? void 0 : tools.length) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"tools\"\n      });\n    }\n    if (toolChoice != null) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"toolChoice\"\n      });\n    }\n    if (responseFormat != null && responseFormat.type !== \"text\") {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"responseFormat\",\n        details: \"JSON response format is not supported.\"\n      });\n    }\n    const {\n      prompt: completionPrompt,\n      stopSequences\n    } = convertToOpenAICompletionPrompt({\n      prompt\n    });\n    const stop = [...(stopSequences != null ? stopSequences : []), ...(userStopSequences != null ? userStopSequences : [])];\n    return {\n      args: {\n        // model id:\n        model: this.modelId,\n        // model specific settings:\n        echo: openaiOptions.echo,\n        logit_bias: openaiOptions.logitBias,\n        logprobs: (openaiOptions == null ? void 0 : openaiOptions.logprobs) === true ? 0 : (openaiOptions == null ? void 0 : openaiOptions.logprobs) === false ? void 0 : openaiOptions == null ? void 0 : openaiOptions.logprobs,\n        suffix: openaiOptions.suffix,\n        user: openaiOptions.user,\n        // standardized settings:\n        max_tokens: maxOutputTokens,\n        temperature,\n        top_p: topP,\n        frequency_penalty: frequencyPenalty,\n        presence_penalty: presencePenalty,\n        seed,\n        // prompt:\n        prompt: completionPrompt,\n        // stop sequences:\n        stop: stop.length > 0 ? stop : void 0\n      },\n      warnings\n    };\n  }\n  async doGenerate(options) {\n    var _a20, _b8, _c;\n    const {\n      args,\n      warnings\n    } = await this.getArgs(options);\n    const {\n      responseHeaders,\n      value: response,\n      rawValue: rawResponse\n    } = await postJsonToApi2({\n      url: this.config.url({\n        path: \"/completions\",\n        modelId: this.modelId\n      }),\n      headers: combineHeaders2(this.config.headers(), options.headers),\n      body: args,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler2(openaiCompletionResponseSchema),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    const choice = response.choices[0];\n    const providerMetadata = {\n      openai: {}\n    };\n    if (choice.logprobs != null) {\n      providerMetadata.openai.logprobs = choice.logprobs;\n    }\n    return {\n      content: [{\n        type: \"text\",\n        text: choice.text\n      }],\n      usage: {\n        inputTokens: (_a20 = response.usage) == null ? void 0 : _a20.prompt_tokens,\n        outputTokens: (_b8 = response.usage) == null ? void 0 : _b8.completion_tokens,\n        totalTokens: (_c = response.usage) == null ? void 0 : _c.total_tokens\n      },\n      finishReason: mapOpenAIFinishReason2(choice.finish_reason),\n      request: {\n        body: args\n      },\n      response: {\n        ...getResponseMetadata2(response),\n        headers: responseHeaders,\n        body: rawResponse\n      },\n      providerMetadata,\n      warnings\n    };\n  }\n  async doStream(options) {\n    const {\n      args,\n      warnings\n    } = await this.getArgs(options);\n    const body = {\n      ...args,\n      stream: true,\n      stream_options: {\n        include_usage: true\n      }\n    };\n    const {\n      responseHeaders,\n      value: response\n    } = await postJsonToApi2({\n      url: this.config.url({\n        path: \"/completions\",\n        modelId: this.modelId\n      }),\n      headers: combineHeaders2(this.config.headers(), options.headers),\n      body,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createEventSourceResponseHandler2(openaiCompletionChunkSchema),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    let finishReason = \"unknown\";\n    const providerMetadata = {\n      openai: {}\n    };\n    const usage = {\n      inputTokens: void 0,\n      outputTokens: void 0,\n      totalTokens: void 0\n    };\n    let isFirstChunk = true;\n    return {\n      stream: response.pipeThrough(new TransformStream({\n        start(controller) {\n          controller.enqueue({\n            type: \"stream-start\",\n            warnings\n          });\n        },\n        transform(chunk, controller) {\n          if (options.includeRawChunks) {\n            controller.enqueue({\n              type: \"raw\",\n              rawValue: chunk.rawValue\n            });\n          }\n          if (!chunk.success) {\n            finishReason = \"error\";\n            controller.enqueue({\n              type: \"error\",\n              error: chunk.error\n            });\n            return;\n          }\n          const value = chunk.value;\n          if (\"error\" in value) {\n            finishReason = \"error\";\n            controller.enqueue({\n              type: \"error\",\n              error: value.error\n            });\n            return;\n          }\n          if (isFirstChunk) {\n            isFirstChunk = false;\n            controller.enqueue({\n              type: \"response-metadata\",\n              ...getResponseMetadata2(value)\n            });\n            controller.enqueue({\n              type: \"text-start\",\n              id: \"0\"\n            });\n          }\n          if (value.usage != null) {\n            usage.inputTokens = value.usage.prompt_tokens;\n            usage.outputTokens = value.usage.completion_tokens;\n            usage.totalTokens = value.usage.total_tokens;\n          }\n          const choice = value.choices[0];\n          if ((choice == null ? void 0 : choice.finish_reason) != null) {\n            finishReason = mapOpenAIFinishReason2(choice.finish_reason);\n          }\n          if ((choice == null ? void 0 : choice.logprobs) != null) {\n            providerMetadata.openai.logprobs = choice.logprobs;\n          }\n          if ((choice == null ? void 0 : choice.text) != null && choice.text.length > 0) {\n            controller.enqueue({\n              type: \"text-delta\",\n              id: \"0\",\n              delta: choice.text\n            });\n          }\n        },\n        flush(controller) {\n          if (!isFirstChunk) {\n            controller.enqueue({\n              type: \"text-end\",\n              id: \"0\"\n            });\n          }\n          controller.enqueue({\n            type: \"finish\",\n            finishReason,\n            providerMetadata,\n            usage\n          });\n        }\n      })),\n      request: {\n        body\n      },\n      response: {\n        headers: responseHeaders\n      }\n    };\n  }\n};\nvar usageSchema = external_exports2.object({\n  prompt_tokens: external_exports2.number(),\n  completion_tokens: external_exports2.number(),\n  total_tokens: external_exports2.number()\n});\nvar openaiCompletionResponseSchema = external_exports2.object({\n  id: external_exports2.string().nullish(),\n  created: external_exports2.number().nullish(),\n  model: external_exports2.string().nullish(),\n  choices: external_exports2.array(external_exports2.object({\n    text: external_exports2.string(),\n    finish_reason: external_exports2.string(),\n    logprobs: external_exports2.object({\n      tokens: external_exports2.array(external_exports2.string()),\n      token_logprobs: external_exports2.array(external_exports2.number()),\n      top_logprobs: external_exports2.array(external_exports2.record(external_exports2.string(), external_exports2.number())).nullish()\n    }).nullish()\n  })),\n  usage: usageSchema.nullish()\n});\nvar openaiCompletionChunkSchema = external_exports2.union([external_exports2.object({\n  id: external_exports2.string().nullish(),\n  created: external_exports2.number().nullish(),\n  model: external_exports2.string().nullish(),\n  choices: external_exports2.array(external_exports2.object({\n    text: external_exports2.string(),\n    finish_reason: external_exports2.string().nullish(),\n    index: external_exports2.number(),\n    logprobs: external_exports2.object({\n      tokens: external_exports2.array(external_exports2.string()),\n      token_logprobs: external_exports2.array(external_exports2.number()),\n      top_logprobs: external_exports2.array(external_exports2.record(external_exports2.string(), external_exports2.number())).nullish()\n    }).nullish()\n  })),\n  usage: usageSchema.nullish()\n}), openaiErrorDataSchema]);\nvar openaiEmbeddingProviderOptions = external_exports2.object({\n  /**\n  The number of dimensions the resulting output embeddings should have.\n  Only supported in text-embedding-3 and later models.\n     */\n  dimensions: external_exports2.number().optional(),\n  /**\n  A unique identifier representing your end-user, which can help OpenAI to\n  monitor and detect abuse. Learn more.\n  */\n  user: external_exports2.string().optional()\n});\nvar OpenAIEmbeddingModel = class {\n  constructor(modelId, config2) {\n    this.specificationVersion = \"v2\";\n    this.maxEmbeddingsPerCall = 2048;\n    this.supportsParallelCalls = true;\n    this.modelId = modelId;\n    this.config = config2;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  async doEmbed({\n    values,\n    headers,\n    abortSignal,\n    providerOptions\n  }) {\n    var _a20;\n    if (values.length > this.maxEmbeddingsPerCall) {\n      throw new TooManyEmbeddingValuesForCallError({\n        provider: this.provider,\n        modelId: this.modelId,\n        maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,\n        values\n      });\n    }\n    const openaiOptions = (_a20 = await parseProviderOptions({\n      provider: \"openai\",\n      providerOptions,\n      schema: openaiEmbeddingProviderOptions\n    })) != null ? _a20 : {};\n    const {\n      responseHeaders,\n      value: response,\n      rawValue\n    } = await postJsonToApi2({\n      url: this.config.url({\n        path: \"/embeddings\",\n        modelId: this.modelId\n      }),\n      headers: combineHeaders2(this.config.headers(), headers),\n      body: {\n        model: this.modelId,\n        input: values,\n        encoding_format: \"float\",\n        dimensions: openaiOptions.dimensions,\n        user: openaiOptions.user\n      },\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler2(openaiTextEmbeddingResponseSchema),\n      abortSignal,\n      fetch: this.config.fetch\n    });\n    return {\n      embeddings: response.data.map(item => item.embedding),\n      usage: response.usage ? {\n        tokens: response.usage.prompt_tokens\n      } : void 0,\n      response: {\n        headers: responseHeaders,\n        body: rawValue\n      }\n    };\n  }\n};\nvar openaiTextEmbeddingResponseSchema = external_exports2.object({\n  data: external_exports2.array(external_exports2.object({\n    embedding: external_exports2.array(external_exports2.number())\n  })),\n  usage: external_exports2.object({\n    prompt_tokens: external_exports2.number()\n  }).nullish()\n});\nvar modelMaxImagesPerCall = {\n  \"dall-e-3\": 1,\n  \"dall-e-2\": 10,\n  \"gpt-image-1\": 10\n};\nvar hasDefaultResponseFormat = /* @__PURE__ */new Set([\"gpt-image-1\"]);\nvar OpenAIImageModel = class {\n  constructor(modelId, config2) {\n    this.modelId = modelId;\n    this.config = config2;\n    this.specificationVersion = \"v2\";\n  }\n  get maxImagesPerCall() {\n    var _a20;\n    return (_a20 = modelMaxImagesPerCall[this.modelId]) != null ? _a20 : 1;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  async doGenerate({\n    prompt,\n    n,\n    size,\n    aspectRatio,\n    seed,\n    providerOptions,\n    headers,\n    abortSignal\n  }) {\n    var _a20, _b8, _c, _d;\n    const warnings = [];\n    if (aspectRatio != null) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"aspectRatio\",\n        details: \"This model does not support aspect ratio. Use `size` instead.\"\n      });\n    }\n    if (seed != null) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"seed\"\n      });\n    }\n    const currentDate = (_c = (_b8 = (_a20 = this.config._internal) == null ? void 0 : _a20.currentDate) == null ? void 0 : _b8.call(_a20)) != null ? _c : /* @__PURE__ */new Date();\n    const {\n      value: response,\n      responseHeaders\n    } = await postJsonToApi2({\n      url: this.config.url({\n        path: \"/images/generations\",\n        modelId: this.modelId\n      }),\n      headers: combineHeaders2(this.config.headers(), headers),\n      body: {\n        model: this.modelId,\n        prompt,\n        n,\n        size,\n        ...((_d = providerOptions.openai) != null ? _d : {}),\n        ...(!hasDefaultResponseFormat.has(this.modelId) ? {\n          response_format: \"b64_json\"\n        } : {})\n      },\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler2(openaiImageResponseSchema),\n      abortSignal,\n      fetch: this.config.fetch\n    });\n    return {\n      images: response.data.map(item => item.b64_json),\n      warnings,\n      response: {\n        timestamp: currentDate,\n        modelId: this.modelId,\n        headers: responseHeaders\n      },\n      providerMetadata: {\n        openai: {\n          images: response.data.map(item => item.revised_prompt ? {\n            revisedPrompt: item.revised_prompt\n          } : null)\n        }\n      }\n    };\n  }\n};\nvar openaiImageResponseSchema = external_exports2.object({\n  data: external_exports2.array(external_exports2.object({\n    b64_json: external_exports2.string(),\n    revised_prompt: external_exports2.string().optional()\n  }))\n});\nvar codeInterpreterInputSchema = external_exports2.object({\n  code: external_exports2.string().nullish(),\n  containerId: external_exports2.string()\n});\nvar codeInterpreterOutputSchema = external_exports2.object({\n  outputs: external_exports2.array(external_exports2.discriminatedUnion(\"type\", [external_exports2.object({\n    type: external_exports2.literal(\"logs\"),\n    logs: external_exports2.string()\n  }), external_exports2.object({\n    type: external_exports2.literal(\"image\"),\n    url: external_exports2.string()\n  })])).nullish()\n});\nvar codeInterpreterArgsSchema = external_exports2.object({\n  container: external_exports2.union([external_exports2.string(), external_exports2.object({\n    fileIds: external_exports2.array(external_exports2.string()).optional()\n  })]).optional()\n});\nvar codeInterpreterToolFactory = createProviderDefinedToolFactoryWithOutputSchema({\n  id: \"openai.code_interpreter\",\n  name: \"code_interpreter\",\n  inputSchema: codeInterpreterInputSchema,\n  outputSchema: codeInterpreterOutputSchema\n});\nvar codeInterpreter = (args = {}) => {\n  return codeInterpreterToolFactory(args);\n};\nvar webSearchArgsSchema = external_exports2.object({\n  filters: external_exports2.object({\n    allowedDomains: external_exports2.array(external_exports2.string()).optional()\n  }).optional(),\n  searchContextSize: external_exports2.enum([\"low\", \"medium\", \"high\"]).optional(),\n  userLocation: external_exports2.object({\n    type: external_exports2.literal(\"approximate\"),\n    country: external_exports2.string().optional(),\n    city: external_exports2.string().optional(),\n    region: external_exports2.string().optional(),\n    timezone: external_exports2.string().optional()\n  }).optional()\n});\nvar webSearchToolFactory = createProviderDefinedToolFactory({\n  id: \"openai.web_search\",\n  name: \"web_search\",\n  inputSchema: external_exports2.object({\n    action: external_exports2.discriminatedUnion(\"type\", [external_exports2.object({\n      type: external_exports2.literal(\"search\"),\n      query: external_exports2.string().nullish()\n    }), external_exports2.object({\n      type: external_exports2.literal(\"open_page\"),\n      url: external_exports2.string()\n    }), external_exports2.object({\n      type: external_exports2.literal(\"find\"),\n      url: external_exports2.string(),\n      pattern: external_exports2.string()\n    })]).nullish()\n  })\n});\nvar webSearch = (args = {}) => {\n  return webSearchToolFactory(args);\n};\nvar openaiTools = {\n  /**\n   * The Code Interpreter tool allows models to write and run Python code in a\n   * sandboxed environment to solve complex problems in domains like data analysis,\n   * coding, and math.\n   *\n   * @param container - The container to use for the code interpreter.\n   *\n   * Must have name `code_interpreter`.\n   */\n  codeInterpreter,\n  /**\n   * File search is a tool available in the Responses API. It enables models to\n   * retrieve information in a knowledge base of previously uploaded files through\n   * semantic and keyword search.\n   *\n   * Must have name `file_search`.\n   *\n   * @param vectorStoreIds - The vector store IDs to use for the file search.\n   * @param maxNumResults - The maximum number of results to return.\n   * @param ranking - The ranking options to use for the file search.\n   * @param filters - The filters to use for the file search.\n   */\n  fileSearch,\n  /**\n   * Web search allows models to access up-to-date information from the internet\n   * and provide answers with sourced citations.\n   *\n   * Must have name `web_search_preview`.\n   *\n   * @param searchContextSize - The search context size to use for the web search.\n   * @param userLocation - The user location to use for the web search.\n   *\n   * @deprecated Use `webSearch` instead.\n   */\n  webSearchPreview,\n  /**\n   * Web search allows models to access up-to-date information from the internet\n   * and provide answers with sourced citations.\n   *\n   * Must have name `web_search`.\n   *\n   * @param filters - The filters to use for the web search.\n   * @param searchContextSize - The search context size to use for the web search.\n   * @param userLocation - The user location to use for the web search.\n   */\n  webSearch\n};\nfunction isFileId(data, prefixes) {\n  if (!prefixes) return false;\n  return prefixes.some(prefix => data.startsWith(prefix));\n}\nasync function convertToOpenAIResponsesInput({\n  prompt,\n  systemMessageMode,\n  fileIdPrefixes\n}) {\n  var _a20, _b8, _c, _d, _e, _f;\n  const input = [];\n  const warnings = [];\n  for (const {\n    role,\n    content\n  } of prompt) {\n    switch (role) {\n      case \"system\":\n        {\n          switch (systemMessageMode) {\n            case \"system\":\n              {\n                input.push({\n                  role: \"system\",\n                  content\n                });\n                break;\n              }\n            case \"developer\":\n              {\n                input.push({\n                  role: \"developer\",\n                  content\n                });\n                break;\n              }\n            case \"remove\":\n              {\n                warnings.push({\n                  type: \"other\",\n                  message: \"system messages are removed for this model\"\n                });\n                break;\n              }\n            default:\n              {\n                const _exhaustiveCheck = systemMessageMode;\n                throw new Error(`Unsupported system message mode: ${_exhaustiveCheck}`);\n              }\n          }\n          break;\n        }\n      case \"user\":\n        {\n          input.push({\n            role: \"user\",\n            content: content.map((part, index) => {\n              var _a27, _b22, _c2;\n              switch (part.type) {\n                case \"text\":\n                  {\n                    return {\n                      type: \"input_text\",\n                      text: part.text\n                    };\n                  }\n                case \"file\":\n                  {\n                    if (part.mediaType.startsWith(\"image/\")) {\n                      const mediaType = part.mediaType === \"image/*\" ? \"image/jpeg\" : part.mediaType;\n                      return {\n                        type: \"input_image\",\n                        ...(part.data instanceof URL ? {\n                          image_url: part.data.toString()\n                        } : typeof part.data === \"string\" && isFileId(part.data, fileIdPrefixes) ? {\n                          file_id: part.data\n                        } : {\n                          image_url: `data:${mediaType};base64,${convertToBase64(part.data)}`\n                        }),\n                        detail: (_b22 = (_a27 = part.providerOptions) == null ? void 0 : _a27.openai) == null ? void 0 : _b22.imageDetail\n                      };\n                    } else if (part.mediaType === \"application/pdf\") {\n                      if (part.data instanceof URL) {\n                        return {\n                          type: \"input_file\",\n                          file_url: part.data.toString()\n                        };\n                      }\n                      return {\n                        type: \"input_file\",\n                        ...(typeof part.data === \"string\" && isFileId(part.data, fileIdPrefixes) ? {\n                          file_id: part.data\n                        } : {\n                          filename: (_c2 = part.filename) != null ? _c2 : `part-${index}.pdf`,\n                          file_data: `data:application/pdf;base64,${convertToBase64(part.data)}`\n                        })\n                      };\n                    } else {\n                      throw new UnsupportedFunctionalityError2({\n                        functionality: `file part media type ${part.mediaType}`\n                      });\n                    }\n                  }\n              }\n            })\n          });\n          break;\n        }\n      case \"assistant\":\n        {\n          const reasoningMessages = {};\n          const toolCallParts = {};\n          for (const part of content) {\n            switch (part.type) {\n              case \"text\":\n                {\n                  input.push({\n                    role: \"assistant\",\n                    content: [{\n                      type: \"output_text\",\n                      text: part.text\n                    }],\n                    id: (_c = (_b8 = (_a20 = part.providerOptions) == null ? void 0 : _a20.openai) == null ? void 0 : _b8.itemId) != null ? _c : void 0\n                  });\n                  break;\n                }\n              case \"tool-call\":\n                {\n                  toolCallParts[part.toolCallId] = part;\n                  if (part.providerExecuted) {\n                    break;\n                  }\n                  input.push({\n                    type: \"function_call\",\n                    call_id: part.toolCallId,\n                    name: part.toolName,\n                    arguments: JSON.stringify(part.input),\n                    id: (_f = (_e = (_d = part.providerOptions) == null ? void 0 : _d.openai) == null ? void 0 : _e.itemId) != null ? _f : void 0\n                  });\n                  break;\n                }\n              case \"tool-result\":\n                {\n                  warnings.push({\n                    type: \"other\",\n                    message: `tool result parts in assistant messages are not supported for OpenAI responses`\n                  });\n                  break;\n                }\n              case \"reasoning\":\n                {\n                  const providerOptions = await parseProviderOptions({\n                    provider: \"openai\",\n                    providerOptions: part.providerOptions,\n                    schema: openaiResponsesReasoningProviderOptionsSchema\n                  });\n                  const reasoningId = providerOptions == null ? void 0 : providerOptions.itemId;\n                  if (reasoningId != null) {\n                    const existingReasoningMessage = reasoningMessages[reasoningId];\n                    const summaryParts = [];\n                    if (part.text.length > 0) {\n                      summaryParts.push({\n                        type: \"summary_text\",\n                        text: part.text\n                      });\n                    } else if (existingReasoningMessage !== void 0) {\n                      warnings.push({\n                        type: \"other\",\n                        message: `Cannot append empty reasoning part to existing reasoning sequence. Skipping reasoning part: ${JSON.stringify(part)}.`\n                      });\n                    }\n                    if (existingReasoningMessage === void 0) {\n                      reasoningMessages[reasoningId] = {\n                        type: \"reasoning\",\n                        id: reasoningId,\n                        encrypted_content: providerOptions == null ? void 0 : providerOptions.reasoningEncryptedContent,\n                        summary: summaryParts\n                      };\n                      input.push(reasoningMessages[reasoningId]);\n                    } else {\n                      existingReasoningMessage.summary.push(...summaryParts);\n                    }\n                  } else {\n                    warnings.push({\n                      type: \"other\",\n                      message: `Non-OpenAI reasoning parts are not supported. Skipping reasoning part: ${JSON.stringify(part)}.`\n                    });\n                  }\n                  break;\n                }\n            }\n          }\n          break;\n        }\n      case \"tool\":\n        {\n          for (const part of content) {\n            const output = part.output;\n            let contentValue;\n            switch (output.type) {\n              case \"text\":\n              case \"error-text\":\n                contentValue = output.value;\n                break;\n              case \"content\":\n              case \"json\":\n              case \"error-json\":\n                contentValue = JSON.stringify(output.value);\n                break;\n            }\n            input.push({\n              type: \"function_call_output\",\n              call_id: part.toolCallId,\n              output: contentValue\n            });\n          }\n          break;\n        }\n      default:\n        {\n          const _exhaustiveCheck = role;\n          throw new Error(`Unsupported role: ${_exhaustiveCheck}`);\n        }\n    }\n  }\n  return {\n    input,\n    warnings\n  };\n}\nvar openaiResponsesReasoningProviderOptionsSchema = external_exports2.object({\n  itemId: external_exports2.string().nullish(),\n  reasoningEncryptedContent: external_exports2.string().nullish()\n});\nfunction mapOpenAIResponseFinishReason({\n  finishReason,\n  hasFunctionCall\n}) {\n  switch (finishReason) {\n    case void 0:\n    case null:\n      return hasFunctionCall ? \"tool-calls\" : \"stop\";\n    case \"max_output_tokens\":\n      return \"length\";\n    case \"content_filter\":\n      return \"content-filter\";\n    default:\n      return hasFunctionCall ? \"tool-calls\" : \"unknown\";\n  }\n}\nfunction prepareResponsesTools({\n  tools,\n  toolChoice,\n  strictJsonSchema\n}) {\n  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;\n  const toolWarnings = [];\n  if (tools == null) {\n    return {\n      tools: void 0,\n      toolChoice: void 0,\n      toolWarnings\n    };\n  }\n  const openaiTools2 = [];\n  for (const tool2 of tools) {\n    switch (tool2.type) {\n      case \"function\":\n        openaiTools2.push({\n          type: \"function\",\n          name: tool2.name,\n          description: tool2.description,\n          parameters: tool2.inputSchema,\n          strict: strictJsonSchema\n        });\n        break;\n      case \"provider-defined\":\n        {\n          switch (tool2.id) {\n            case \"openai.file_search\":\n              {\n                const args = fileSearchArgsSchema.parse(tool2.args);\n                openaiTools2.push({\n                  type: \"file_search\",\n                  vector_store_ids: args.vectorStoreIds,\n                  max_num_results: args.maxNumResults,\n                  ranking_options: args.ranking ? {\n                    ranker: args.ranking.ranker\n                  } : void 0,\n                  filters: args.filters\n                });\n                break;\n              }\n            case \"openai.web_search_preview\":\n              {\n                const args = webSearchPreviewArgsSchema.parse(tool2.args);\n                openaiTools2.push({\n                  type: \"web_search_preview\",\n                  search_context_size: args.searchContextSize,\n                  user_location: args.userLocation\n                });\n                break;\n              }\n            case \"openai.web_search\":\n              {\n                const args = webSearchArgsSchema.parse(tool2.args);\n                openaiTools2.push({\n                  type: \"web_search\",\n                  filters: args.filters != null ? {\n                    allowed_domains: args.filters.allowedDomains\n                  } : void 0,\n                  search_context_size: args.searchContextSize,\n                  user_location: args.userLocation\n                });\n                break;\n              }\n            case \"openai.code_interpreter\":\n              {\n                const args = codeInterpreterArgsSchema.parse(tool2.args);\n                openaiTools2.push({\n                  type: \"code_interpreter\",\n                  container: args.container == null ? {\n                    type: \"auto\",\n                    file_ids: void 0\n                  } : typeof args.container === \"string\" ? args.container : {\n                    type: \"auto\",\n                    file_ids: args.container.fileIds\n                  }\n                });\n                break;\n              }\n            default:\n              {\n                toolWarnings.push({\n                  type: \"unsupported-tool\",\n                  tool: tool2\n                });\n                break;\n              }\n          }\n          break;\n        }\n      default:\n        toolWarnings.push({\n          type: \"unsupported-tool\",\n          tool: tool2\n        });\n        break;\n    }\n  }\n  if (toolChoice == null) {\n    return {\n      tools: openaiTools2,\n      toolChoice: void 0,\n      toolWarnings\n    };\n  }\n  const type = toolChoice.type;\n  switch (type) {\n    case \"auto\":\n    case \"none\":\n    case \"required\":\n      return {\n        tools: openaiTools2,\n        toolChoice: type,\n        toolWarnings\n      };\n    case \"tool\":\n      return {\n        tools: openaiTools2,\n        toolChoice: toolChoice.toolName === \"code_interpreter\" || toolChoice.toolName === \"file_search\" || toolChoice.toolName === \"web_search_preview\" || toolChoice.toolName === \"web_search\" ? {\n          type: toolChoice.toolName\n        } : {\n          type: \"function\",\n          name: toolChoice.toolName\n        },\n        toolWarnings\n      };\n    default:\n      {\n        const _exhaustiveCheck = type;\n        throw new UnsupportedFunctionalityError2({\n          functionality: `tool choice type: ${_exhaustiveCheck}`\n        });\n      }\n  }\n}\nvar webSearchCallItem = external_exports2.object({\n  type: external_exports2.literal(\"web_search_call\"),\n  id: external_exports2.string(),\n  status: external_exports2.string(),\n  action: external_exports2.discriminatedUnion(\"type\", [external_exports2.object({\n    type: external_exports2.literal(\"search\"),\n    query: external_exports2.string().nullish()\n  }), external_exports2.object({\n    type: external_exports2.literal(\"open_page\"),\n    url: external_exports2.string()\n  }), external_exports2.object({\n    type: external_exports2.literal(\"find\"),\n    url: external_exports2.string(),\n    pattern: external_exports2.string()\n  })]).nullish()\n});\nvar codeInterpreterCallItem = external_exports2.object({\n  type: external_exports2.literal(\"code_interpreter_call\"),\n  id: external_exports2.string(),\n  code: external_exports2.string().nullable(),\n  container_id: external_exports2.string(),\n  outputs: external_exports2.array(external_exports2.discriminatedUnion(\"type\", [external_exports2.object({\n    type: external_exports2.literal(\"logs\"),\n    logs: external_exports2.string()\n  }), external_exports2.object({\n    type: external_exports2.literal(\"image\"),\n    url: external_exports2.string()\n  })])).nullable()\n});\nvar TOP_LOGPROBS_MAX = 20;\nvar LOGPROBS_SCHEMA = external_exports2.array(external_exports2.object({\n  token: external_exports2.string(),\n  logprob: external_exports2.number(),\n  top_logprobs: external_exports2.array(external_exports2.object({\n    token: external_exports2.string(),\n    logprob: external_exports2.number()\n  }))\n}));\nvar OpenAIResponsesLanguageModel = class {\n  constructor(modelId, config2) {\n    this.specificationVersion = \"v2\";\n    this.supportedUrls = {\n      \"image/*\": [/^https?:\\/\\/.*$/],\n      \"application/pdf\": [/^https?:\\/\\/.*$/]\n    };\n    this.modelId = modelId;\n    this.config = config2;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  async getArgs({\n    maxOutputTokens,\n    temperature,\n    stopSequences,\n    topP,\n    topK,\n    presencePenalty,\n    frequencyPenalty,\n    seed,\n    prompt,\n    providerOptions,\n    tools,\n    toolChoice,\n    responseFormat\n  }) {\n    var _a20, _b8, _c, _d;\n    const warnings = [];\n    const modelConfig = getResponsesModelConfig(this.modelId);\n    if (topK != null) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"topK\"\n      });\n    }\n    if (seed != null) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"seed\"\n      });\n    }\n    if (presencePenalty != null) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"presencePenalty\"\n      });\n    }\n    if (frequencyPenalty != null) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"frequencyPenalty\"\n      });\n    }\n    if (stopSequences != null) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"stopSequences\"\n      });\n    }\n    const {\n      input,\n      warnings: inputWarnings\n    } = await convertToOpenAIResponsesInput({\n      prompt,\n      systemMessageMode: modelConfig.systemMessageMode,\n      fileIdPrefixes: this.config.fileIdPrefixes\n    });\n    warnings.push(...inputWarnings);\n    const openaiOptions = await parseProviderOptions({\n      provider: \"openai\",\n      providerOptions,\n      schema: openaiResponsesProviderOptionsSchema\n    });\n    const strictJsonSchema = (_a20 = openaiOptions == null ? void 0 : openaiOptions.strictJsonSchema) != null ? _a20 : false;\n    let include = openaiOptions == null ? void 0 : openaiOptions.include;\n    const topLogprobs = typeof (openaiOptions == null ? void 0 : openaiOptions.logprobs) === \"number\" ? openaiOptions == null ? void 0 : openaiOptions.logprobs : (openaiOptions == null ? void 0 : openaiOptions.logprobs) === true ? TOP_LOGPROBS_MAX : void 0;\n    include = topLogprobs ? Array.isArray(include) ? [...include, \"message.output_text.logprobs\"] : [\"message.output_text.logprobs\"] : include;\n    const webSearchToolName = (_b8 = tools == null ? void 0 : tools.find(tool2 => tool2.type === \"provider-defined\" && (tool2.id === \"openai.web_search\" || tool2.id === \"openai.web_search_preview\"))) == null ? void 0 : _b8.name;\n    include = webSearchToolName ? Array.isArray(include) ? [...include, \"web_search_call.action.sources\"] : [\"web_search_call.action.sources\"] : include;\n    const codeInterpreterToolName = (_c = tools == null ? void 0 : tools.find(tool2 => tool2.type === \"provider-defined\" && tool2.id === \"openai.code_interpreter\")) == null ? void 0 : _c.name;\n    include = codeInterpreterToolName ? Array.isArray(include) ? [...include, \"code_interpreter_call.outputs\"] : [\"code_interpreter_call.outputs\"] : include;\n    const baseArgs = {\n      model: this.modelId,\n      input,\n      temperature,\n      top_p: topP,\n      max_output_tokens: maxOutputTokens,\n      ...(((responseFormat == null ? void 0 : responseFormat.type) === \"json\" || (openaiOptions == null ? void 0 : openaiOptions.textVerbosity)) && {\n        text: {\n          ...((responseFormat == null ? void 0 : responseFormat.type) === \"json\" && {\n            format: responseFormat.schema != null ? {\n              type: \"json_schema\",\n              strict: strictJsonSchema,\n              name: (_d = responseFormat.name) != null ? _d : \"response\",\n              description: responseFormat.description,\n              schema: responseFormat.schema\n            } : {\n              type: \"json_object\"\n            }\n          }),\n          ...((openaiOptions == null ? void 0 : openaiOptions.textVerbosity) && {\n            verbosity: openaiOptions.textVerbosity\n          })\n        }\n      }),\n      // provider options:\n      metadata: openaiOptions == null ? void 0 : openaiOptions.metadata,\n      parallel_tool_calls: openaiOptions == null ? void 0 : openaiOptions.parallelToolCalls,\n      previous_response_id: openaiOptions == null ? void 0 : openaiOptions.previousResponseId,\n      store: openaiOptions == null ? void 0 : openaiOptions.store,\n      user: openaiOptions == null ? void 0 : openaiOptions.user,\n      instructions: openaiOptions == null ? void 0 : openaiOptions.instructions,\n      service_tier: openaiOptions == null ? void 0 : openaiOptions.serviceTier,\n      include,\n      prompt_cache_key: openaiOptions == null ? void 0 : openaiOptions.promptCacheKey,\n      safety_identifier: openaiOptions == null ? void 0 : openaiOptions.safetyIdentifier,\n      top_logprobs: topLogprobs,\n      // model-specific settings:\n      ...(modelConfig.isReasoningModel && ((openaiOptions == null ? void 0 : openaiOptions.reasoningEffort) != null || (openaiOptions == null ? void 0 : openaiOptions.reasoningSummary) != null) && {\n        reasoning: {\n          ...((openaiOptions == null ? void 0 : openaiOptions.reasoningEffort) != null && {\n            effort: openaiOptions.reasoningEffort\n          }),\n          ...((openaiOptions == null ? void 0 : openaiOptions.reasoningSummary) != null && {\n            summary: openaiOptions.reasoningSummary\n          })\n        }\n      }),\n      ...(modelConfig.requiredAutoTruncation && {\n        truncation: \"auto\"\n      })\n    };\n    if (modelConfig.isReasoningModel) {\n      if (baseArgs.temperature != null) {\n        baseArgs.temperature = void 0;\n        warnings.push({\n          type: \"unsupported-setting\",\n          setting: \"temperature\",\n          details: \"temperature is not supported for reasoning models\"\n        });\n      }\n      if (baseArgs.top_p != null) {\n        baseArgs.top_p = void 0;\n        warnings.push({\n          type: \"unsupported-setting\",\n          setting: \"topP\",\n          details: \"topP is not supported for reasoning models\"\n        });\n      }\n    } else {\n      if ((openaiOptions == null ? void 0 : openaiOptions.reasoningEffort) != null) {\n        warnings.push({\n          type: \"unsupported-setting\",\n          setting: \"reasoningEffort\",\n          details: \"reasoningEffort is not supported for non-reasoning models\"\n        });\n      }\n      if ((openaiOptions == null ? void 0 : openaiOptions.reasoningSummary) != null) {\n        warnings.push({\n          type: \"unsupported-setting\",\n          setting: \"reasoningSummary\",\n          details: \"reasoningSummary is not supported for non-reasoning models\"\n        });\n      }\n    }\n    if ((openaiOptions == null ? void 0 : openaiOptions.serviceTier) === \"flex\" && !modelConfig.supportsFlexProcessing) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"serviceTier\",\n        details: \"flex processing is only available for o3, o4-mini, and gpt-5 models\"\n      });\n      delete baseArgs.service_tier;\n    }\n    if ((openaiOptions == null ? void 0 : openaiOptions.serviceTier) === \"priority\" && !modelConfig.supportsPriorityProcessing) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"serviceTier\",\n        details: \"priority processing is only available for supported models (gpt-4, gpt-5, gpt-5-mini, o3, o4-mini) and requires Enterprise access. gpt-5-nano is not supported\"\n      });\n      delete baseArgs.service_tier;\n    }\n    const {\n      tools: openaiTools2,\n      toolChoice: openaiToolChoice,\n      toolWarnings\n    } = prepareResponsesTools({\n      tools,\n      toolChoice,\n      strictJsonSchema\n    });\n    return {\n      webSearchToolName,\n      args: {\n        ...baseArgs,\n        tools: openaiTools2,\n        tool_choice: openaiToolChoice\n      },\n      warnings: [...warnings, ...toolWarnings]\n    };\n  }\n  async doGenerate(options) {\n    var _a20, _b8, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q;\n    const {\n      args: body,\n      warnings,\n      webSearchToolName\n    } = await this.getArgs(options);\n    const url2 = this.config.url({\n      path: \"/responses\",\n      modelId: this.modelId\n    });\n    const {\n      responseHeaders,\n      value: response,\n      rawValue: rawResponse\n    } = await postJsonToApi2({\n      url: url2,\n      headers: combineHeaders2(this.config.headers(), options.headers),\n      body,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler2(external_exports2.object({\n        id: external_exports2.string(),\n        created_at: external_exports2.number(),\n        error: external_exports2.object({\n          code: external_exports2.string(),\n          message: external_exports2.string()\n        }).nullish(),\n        model: external_exports2.string(),\n        output: external_exports2.array(external_exports2.discriminatedUnion(\"type\", [external_exports2.object({\n          type: external_exports2.literal(\"message\"),\n          role: external_exports2.literal(\"assistant\"),\n          id: external_exports2.string(),\n          content: external_exports2.array(external_exports2.object({\n            type: external_exports2.literal(\"output_text\"),\n            text: external_exports2.string(),\n            logprobs: LOGPROBS_SCHEMA.nullish(),\n            annotations: external_exports2.array(external_exports2.discriminatedUnion(\"type\", [external_exports2.object({\n              type: external_exports2.literal(\"url_citation\"),\n              start_index: external_exports2.number(),\n              end_index: external_exports2.number(),\n              url: external_exports2.string(),\n              title: external_exports2.string()\n            }), external_exports2.object({\n              type: external_exports2.literal(\"file_citation\"),\n              file_id: external_exports2.string(),\n              filename: external_exports2.string().nullish(),\n              index: external_exports2.number().nullish(),\n              start_index: external_exports2.number().nullish(),\n              end_index: external_exports2.number().nullish(),\n              quote: external_exports2.string().nullish()\n            }), external_exports2.object({\n              type: external_exports2.literal(\"container_file_citation\")\n            })]))\n          }))\n        }), codeInterpreterCallItem, external_exports2.object({\n          type: external_exports2.literal(\"function_call\"),\n          call_id: external_exports2.string(),\n          name: external_exports2.string(),\n          arguments: external_exports2.string(),\n          id: external_exports2.string()\n        }), webSearchCallItem, external_exports2.object({\n          type: external_exports2.literal(\"computer_call\"),\n          id: external_exports2.string(),\n          status: external_exports2.string().optional()\n        }), external_exports2.object({\n          type: external_exports2.literal(\"file_search_call\"),\n          id: external_exports2.string(),\n          status: external_exports2.string().optional(),\n          queries: external_exports2.array(external_exports2.string()).nullish(),\n          results: external_exports2.array(external_exports2.object({\n            attributes: external_exports2.object({\n              file_id: external_exports2.string(),\n              filename: external_exports2.string(),\n              score: external_exports2.number(),\n              text: external_exports2.string()\n            })\n          })).nullish()\n        }), external_exports2.object({\n          type: external_exports2.literal(\"reasoning\"),\n          id: external_exports2.string(),\n          encrypted_content: external_exports2.string().nullish(),\n          summary: external_exports2.array(external_exports2.object({\n            type: external_exports2.literal(\"summary_text\"),\n            text: external_exports2.string()\n          }))\n        })])),\n        service_tier: external_exports2.string().nullish(),\n        incomplete_details: external_exports2.object({\n          reason: external_exports2.string()\n        }).nullable(),\n        usage: usageSchema2\n      })),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    if (response.error) {\n      throw new APICallError3({\n        message: response.error.message,\n        url: url2,\n        requestBodyValues: body,\n        statusCode: 400,\n        responseHeaders,\n        responseBody: rawResponse,\n        isRetryable: false\n      });\n    }\n    const content = [];\n    const logprobs = [];\n    let hasFunctionCall = false;\n    for (const part of response.output) {\n      switch (part.type) {\n        case \"reasoning\":\n          {\n            if (part.summary.length === 0) {\n              part.summary.push({\n                type: \"summary_text\",\n                text: \"\"\n              });\n            }\n            for (const summary of part.summary) {\n              content.push({\n                type: \"reasoning\",\n                text: summary.text,\n                providerMetadata: {\n                  openai: {\n                    itemId: part.id,\n                    reasoningEncryptedContent: (_a20 = part.encrypted_content) != null ? _a20 : null\n                  }\n                }\n              });\n            }\n            break;\n          }\n        case \"message\":\n          {\n            for (const contentPart of part.content) {\n              if (((_c = (_b8 = options.providerOptions) == null ? void 0 : _b8.openai) == null ? void 0 : _c.logprobs) && contentPart.logprobs) {\n                logprobs.push(contentPart.logprobs);\n              }\n              content.push({\n                type: \"text\",\n                text: contentPart.text,\n                providerMetadata: {\n                  openai: {\n                    itemId: part.id\n                  }\n                }\n              });\n              for (const annotation of contentPart.annotations) {\n                if (annotation.type === \"url_citation\") {\n                  content.push({\n                    type: \"source\",\n                    sourceType: \"url\",\n                    id: (_f = (_e = (_d = this.config).generateId) == null ? void 0 : _e.call(_d)) != null ? _f : generateId3(),\n                    url: annotation.url,\n                    title: annotation.title\n                  });\n                } else if (annotation.type === \"file_citation\") {\n                  content.push({\n                    type: \"source\",\n                    sourceType: \"document\",\n                    id: (_i = (_h = (_g = this.config).generateId) == null ? void 0 : _h.call(_g)) != null ? _i : generateId3(),\n                    mediaType: \"text/plain\",\n                    title: (_k = (_j = annotation.quote) != null ? _j : annotation.filename) != null ? _k : \"Document\",\n                    filename: (_l = annotation.filename) != null ? _l : annotation.file_id\n                  });\n                }\n              }\n            }\n            break;\n          }\n        case \"function_call\":\n          {\n            hasFunctionCall = true;\n            content.push({\n              type: \"tool-call\",\n              toolCallId: part.call_id,\n              toolName: part.name,\n              input: part.arguments,\n              providerMetadata: {\n                openai: {\n                  itemId: part.id\n                }\n              }\n            });\n            break;\n          }\n        case \"web_search_call\":\n          {\n            content.push({\n              type: \"tool-call\",\n              toolCallId: part.id,\n              toolName: webSearchToolName != null ? webSearchToolName : \"web_search\",\n              input: JSON.stringify({\n                action: part.action\n              }),\n              providerExecuted: true\n            });\n            content.push({\n              type: \"tool-result\",\n              toolCallId: part.id,\n              toolName: webSearchToolName != null ? webSearchToolName : \"web_search\",\n              result: {\n                status: part.status\n              },\n              providerExecuted: true\n            });\n            break;\n          }\n        case \"computer_call\":\n          {\n            content.push({\n              type: \"tool-call\",\n              toolCallId: part.id,\n              toolName: \"computer_use\",\n              input: \"\",\n              providerExecuted: true\n            });\n            content.push({\n              type: \"tool-result\",\n              toolCallId: part.id,\n              toolName: \"computer_use\",\n              result: {\n                type: \"computer_use_tool_result\",\n                status: part.status || \"completed\"\n              },\n              providerExecuted: true\n            });\n            break;\n          }\n        case \"file_search_call\":\n          {\n            content.push({\n              type: \"tool-call\",\n              toolCallId: part.id,\n              toolName: \"file_search\",\n              input: \"\",\n              providerExecuted: true\n            });\n            content.push({\n              type: \"tool-result\",\n              toolCallId: part.id,\n              toolName: \"file_search\",\n              result: {\n                type: \"file_search_tool_result\",\n                status: part.status || \"completed\",\n                ...(part.queries && {\n                  queries: part.queries\n                }),\n                ...(part.results && {\n                  results: part.results\n                })\n              },\n              providerExecuted: true\n            });\n            break;\n          }\n        case \"code_interpreter_call\":\n          {\n            content.push({\n              type: \"tool-call\",\n              toolCallId: part.id,\n              toolName: \"code_interpreter\",\n              input: JSON.stringify({\n                code: part.code,\n                containerId: part.container_id\n              }),\n              providerExecuted: true\n            });\n            content.push({\n              type: \"tool-result\",\n              toolCallId: part.id,\n              toolName: \"code_interpreter\",\n              result: {\n                outputs: part.outputs\n              },\n              providerExecuted: true\n            });\n            break;\n          }\n      }\n    }\n    const providerMetadata = {\n      openai: {\n        responseId: response.id\n      }\n    };\n    if (logprobs.length > 0) {\n      providerMetadata.openai.logprobs = logprobs;\n    }\n    if (typeof response.service_tier === \"string\") {\n      providerMetadata.openai.serviceTier = response.service_tier;\n    }\n    return {\n      content,\n      finishReason: mapOpenAIResponseFinishReason({\n        finishReason: (_m = response.incomplete_details) == null ? void 0 : _m.reason,\n        hasFunctionCall\n      }),\n      usage: {\n        inputTokens: response.usage.input_tokens,\n        outputTokens: response.usage.output_tokens,\n        totalTokens: response.usage.input_tokens + response.usage.output_tokens,\n        reasoningTokens: (_o = (_n = response.usage.output_tokens_details) == null ? void 0 : _n.reasoning_tokens) != null ? _o : void 0,\n        cachedInputTokens: (_q = (_p = response.usage.input_tokens_details) == null ? void 0 : _p.cached_tokens) != null ? _q : void 0\n      },\n      request: {\n        body\n      },\n      response: {\n        id: response.id,\n        timestamp: new Date(response.created_at * 1e3),\n        modelId: response.model,\n        headers: responseHeaders,\n        body: rawResponse\n      },\n      providerMetadata,\n      warnings\n    };\n  }\n  async doStream(options) {\n    const {\n      args: body,\n      warnings,\n      webSearchToolName\n    } = await this.getArgs(options);\n    const {\n      responseHeaders,\n      value: response\n    } = await postJsonToApi2({\n      url: this.config.url({\n        path: \"/responses\",\n        modelId: this.modelId\n      }),\n      headers: combineHeaders2(this.config.headers(), options.headers),\n      body: {\n        ...body,\n        stream: true\n      },\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createEventSourceResponseHandler2(openaiResponsesChunkSchema),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    const self = this;\n    let finishReason = \"unknown\";\n    const usage = {\n      inputTokens: void 0,\n      outputTokens: void 0,\n      totalTokens: void 0\n    };\n    const logprobs = [];\n    let responseId = null;\n    const ongoingToolCalls = {};\n    let hasFunctionCall = false;\n    const activeReasoning = {};\n    let serviceTier;\n    return {\n      stream: response.pipeThrough(new TransformStream({\n        start(controller) {\n          controller.enqueue({\n            type: \"stream-start\",\n            warnings\n          });\n        },\n        transform(chunk, controller) {\n          var _a20, _b8, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u;\n          if (options.includeRawChunks) {\n            controller.enqueue({\n              type: \"raw\",\n              rawValue: chunk.rawValue\n            });\n          }\n          if (!chunk.success) {\n            finishReason = \"error\";\n            controller.enqueue({\n              type: \"error\",\n              error: chunk.error\n            });\n            return;\n          }\n          const value = chunk.value;\n          if (isResponseOutputItemAddedChunk(value)) {\n            if (value.item.type === \"function_call\") {\n              ongoingToolCalls[value.output_index] = {\n                toolName: value.item.name,\n                toolCallId: value.item.call_id\n              };\n              controller.enqueue({\n                type: \"tool-input-start\",\n                id: value.item.call_id,\n                toolName: value.item.name\n              });\n            } else if (value.item.type === \"web_search_call\") {\n              ongoingToolCalls[value.output_index] = {\n                toolName: webSearchToolName != null ? webSearchToolName : \"web_search\",\n                toolCallId: value.item.id\n              };\n              controller.enqueue({\n                type: \"tool-input-start\",\n                id: value.item.id,\n                toolName: webSearchToolName != null ? webSearchToolName : \"web_search\"\n              });\n            } else if (value.item.type === \"computer_call\") {\n              ongoingToolCalls[value.output_index] = {\n                toolName: \"computer_use\",\n                toolCallId: value.item.id\n              };\n              controller.enqueue({\n                type: \"tool-input-start\",\n                id: value.item.id,\n                toolName: \"computer_use\"\n              });\n            } else if (value.item.type === \"file_search_call\") {\n              ongoingToolCalls[value.output_index] = {\n                toolName: \"file_search\",\n                toolCallId: value.item.id\n              };\n              controller.enqueue({\n                type: \"tool-input-start\",\n                id: value.item.id,\n                toolName: \"file_search\"\n              });\n            } else if (value.item.type === \"message\") {\n              controller.enqueue({\n                type: \"text-start\",\n                id: value.item.id,\n                providerMetadata: {\n                  openai: {\n                    itemId: value.item.id\n                  }\n                }\n              });\n            } else if (isResponseOutputItemAddedReasoningChunk(value)) {\n              activeReasoning[value.item.id] = {\n                encryptedContent: value.item.encrypted_content,\n                summaryParts: [0]\n              };\n              controller.enqueue({\n                type: \"reasoning-start\",\n                id: `${value.item.id}:0`,\n                providerMetadata: {\n                  openai: {\n                    itemId: value.item.id,\n                    reasoningEncryptedContent: (_a20 = value.item.encrypted_content) != null ? _a20 : null\n                  }\n                }\n              });\n            }\n          } else if (isResponseOutputItemDoneChunk(value)) {\n            if (value.item.type === \"function_call\") {\n              ongoingToolCalls[value.output_index] = void 0;\n              hasFunctionCall = true;\n              controller.enqueue({\n                type: \"tool-input-end\",\n                id: value.item.call_id\n              });\n              controller.enqueue({\n                type: \"tool-call\",\n                toolCallId: value.item.call_id,\n                toolName: value.item.name,\n                input: value.item.arguments,\n                providerMetadata: {\n                  openai: {\n                    itemId: value.item.id\n                  }\n                }\n              });\n            } else if (value.item.type === \"web_search_call\") {\n              ongoingToolCalls[value.output_index] = void 0;\n              controller.enqueue({\n                type: \"tool-input-end\",\n                id: value.item.id\n              });\n              controller.enqueue({\n                type: \"tool-call\",\n                toolCallId: value.item.id,\n                toolName: \"web_search\",\n                input: JSON.stringify({\n                  action: value.item.action\n                }),\n                providerExecuted: true\n              });\n              controller.enqueue({\n                type: \"tool-result\",\n                toolCallId: value.item.id,\n                toolName: \"web_search\",\n                result: {\n                  status: value.item.status\n                },\n                providerExecuted: true\n              });\n            } else if (value.item.type === \"computer_call\") {\n              ongoingToolCalls[value.output_index] = void 0;\n              controller.enqueue({\n                type: \"tool-input-end\",\n                id: value.item.id\n              });\n              controller.enqueue({\n                type: \"tool-call\",\n                toolCallId: value.item.id,\n                toolName: \"computer_use\",\n                input: \"\",\n                providerExecuted: true\n              });\n              controller.enqueue({\n                type: \"tool-result\",\n                toolCallId: value.item.id,\n                toolName: \"computer_use\",\n                result: {\n                  type: \"computer_use_tool_result\",\n                  status: value.item.status || \"completed\"\n                },\n                providerExecuted: true\n              });\n            } else if (value.item.type === \"file_search_call\") {\n              ongoingToolCalls[value.output_index] = void 0;\n              controller.enqueue({\n                type: \"tool-input-end\",\n                id: value.item.id\n              });\n              controller.enqueue({\n                type: \"tool-call\",\n                toolCallId: value.item.id,\n                toolName: \"file_search\",\n                input: \"\",\n                providerExecuted: true\n              });\n              controller.enqueue({\n                type: \"tool-result\",\n                toolCallId: value.item.id,\n                toolName: \"file_search\",\n                result: {\n                  type: \"file_search_tool_result\",\n                  status: value.item.status || \"completed\",\n                  ...(value.item.queries && {\n                    queries: value.item.queries\n                  }),\n                  ...(value.item.results && {\n                    results: value.item.results\n                  })\n                },\n                providerExecuted: true\n              });\n            } else if (value.item.type === \"code_interpreter_call\") {\n              controller.enqueue({\n                type: \"tool-call\",\n                toolCallId: value.item.id,\n                toolName: \"code_interpreter\",\n                input: JSON.stringify({\n                  code: value.item.code,\n                  containerId: value.item.container_id\n                }),\n                providerExecuted: true\n              });\n              controller.enqueue({\n                type: \"tool-result\",\n                toolCallId: value.item.id,\n                toolName: \"code_interpreter\",\n                result: {\n                  outputs: value.item.outputs\n                },\n                providerExecuted: true\n              });\n            } else if (value.item.type === \"message\") {\n              controller.enqueue({\n                type: \"text-end\",\n                id: value.item.id\n              });\n            } else if (isResponseOutputItemDoneReasoningChunk(value)) {\n              const activeReasoningPart = activeReasoning[value.item.id];\n              for (const summaryIndex of activeReasoningPart.summaryParts) {\n                controller.enqueue({\n                  type: \"reasoning-end\",\n                  id: `${value.item.id}:${summaryIndex}`,\n                  providerMetadata: {\n                    openai: {\n                      itemId: value.item.id,\n                      reasoningEncryptedContent: (_b8 = value.item.encrypted_content) != null ? _b8 : null\n                    }\n                  }\n                });\n              }\n              delete activeReasoning[value.item.id];\n            }\n          } else if (isResponseFunctionCallArgumentsDeltaChunk(value)) {\n            const toolCall = ongoingToolCalls[value.output_index];\n            if (toolCall != null) {\n              controller.enqueue({\n                type: \"tool-input-delta\",\n                id: toolCall.toolCallId,\n                delta: value.delta\n              });\n            }\n          } else if (isResponseCreatedChunk(value)) {\n            responseId = value.response.id;\n            controller.enqueue({\n              type: \"response-metadata\",\n              id: value.response.id,\n              timestamp: new Date(value.response.created_at * 1e3),\n              modelId: value.response.model\n            });\n          } else if (isTextDeltaChunk(value)) {\n            controller.enqueue({\n              type: \"text-delta\",\n              id: value.item_id,\n              delta: value.delta\n            });\n            if (((_d = (_c = options.providerOptions) == null ? void 0 : _c.openai) == null ? void 0 : _d.logprobs) && value.logprobs) {\n              logprobs.push(value.logprobs);\n            }\n          } else if (isResponseReasoningSummaryPartAddedChunk(value)) {\n            if (value.summary_index > 0) {\n              (_e = activeReasoning[value.item_id]) == null ? void 0 : _e.summaryParts.push(value.summary_index);\n              controller.enqueue({\n                type: \"reasoning-start\",\n                id: `${value.item_id}:${value.summary_index}`,\n                providerMetadata: {\n                  openai: {\n                    itemId: value.item_id,\n                    reasoningEncryptedContent: (_g = (_f = activeReasoning[value.item_id]) == null ? void 0 : _f.encryptedContent) != null ? _g : null\n                  }\n                }\n              });\n            }\n          } else if (isResponseReasoningSummaryTextDeltaChunk(value)) {\n            controller.enqueue({\n              type: \"reasoning-delta\",\n              id: `${value.item_id}:${value.summary_index}`,\n              delta: value.delta,\n              providerMetadata: {\n                openai: {\n                  itemId: value.item_id\n                }\n              }\n            });\n          } else if (isResponseFinishedChunk(value)) {\n            finishReason = mapOpenAIResponseFinishReason({\n              finishReason: (_h = value.response.incomplete_details) == null ? void 0 : _h.reason,\n              hasFunctionCall\n            });\n            usage.inputTokens = value.response.usage.input_tokens;\n            usage.outputTokens = value.response.usage.output_tokens;\n            usage.totalTokens = value.response.usage.input_tokens + value.response.usage.output_tokens;\n            usage.reasoningTokens = (_j = (_i = value.response.usage.output_tokens_details) == null ? void 0 : _i.reasoning_tokens) != null ? _j : void 0;\n            usage.cachedInputTokens = (_l = (_k = value.response.usage.input_tokens_details) == null ? void 0 : _k.cached_tokens) != null ? _l : void 0;\n            if (typeof value.response.service_tier === \"string\") {\n              serviceTier = value.response.service_tier;\n            }\n          } else if (isResponseAnnotationAddedChunk(value)) {\n            if (value.annotation.type === \"url_citation\") {\n              controller.enqueue({\n                type: \"source\",\n                sourceType: \"url\",\n                id: (_o = (_n = (_m = self.config).generateId) == null ? void 0 : _n.call(_m)) != null ? _o : generateId3(),\n                url: value.annotation.url,\n                title: value.annotation.title\n              });\n            } else if (value.annotation.type === \"file_citation\") {\n              controller.enqueue({\n                type: \"source\",\n                sourceType: \"document\",\n                id: (_r = (_q = (_p = self.config).generateId) == null ? void 0 : _q.call(_p)) != null ? _r : generateId3(),\n                mediaType: \"text/plain\",\n                title: (_t = (_s = value.annotation.quote) != null ? _s : value.annotation.filename) != null ? _t : \"Document\",\n                filename: (_u = value.annotation.filename) != null ? _u : value.annotation.file_id\n              });\n            }\n          } else if (isErrorChunk(value)) {\n            controller.enqueue({\n              type: \"error\",\n              error: value\n            });\n          }\n        },\n        flush(controller) {\n          const providerMetadata = {\n            openai: {\n              responseId\n            }\n          };\n          if (logprobs.length > 0) {\n            providerMetadata.openai.logprobs = logprobs;\n          }\n          if (serviceTier !== void 0) {\n            providerMetadata.openai.serviceTier = serviceTier;\n          }\n          controller.enqueue({\n            type: \"finish\",\n            finishReason,\n            usage,\n            providerMetadata\n          });\n        }\n      })),\n      request: {\n        body\n      },\n      response: {\n        headers: responseHeaders\n      }\n    };\n  }\n};\nvar usageSchema2 = external_exports2.object({\n  input_tokens: external_exports2.number(),\n  input_tokens_details: external_exports2.object({\n    cached_tokens: external_exports2.number().nullish()\n  }).nullish(),\n  output_tokens: external_exports2.number(),\n  output_tokens_details: external_exports2.object({\n    reasoning_tokens: external_exports2.number().nullish()\n  }).nullish()\n});\nvar textDeltaChunkSchema = external_exports2.object({\n  type: external_exports2.literal(\"response.output_text.delta\"),\n  item_id: external_exports2.string(),\n  delta: external_exports2.string(),\n  logprobs: LOGPROBS_SCHEMA.nullish()\n});\nvar errorChunkSchema = external_exports2.object({\n  type: external_exports2.literal(\"error\"),\n  code: external_exports2.string(),\n  message: external_exports2.string(),\n  param: external_exports2.string().nullish(),\n  sequence_number: external_exports2.number()\n});\nvar responseFinishedChunkSchema = external_exports2.object({\n  type: external_exports2.enum([\"response.completed\", \"response.incomplete\"]),\n  response: external_exports2.object({\n    incomplete_details: external_exports2.object({\n      reason: external_exports2.string()\n    }).nullish(),\n    usage: usageSchema2,\n    service_tier: external_exports2.string().nullish()\n  })\n});\nvar responseCreatedChunkSchema = external_exports2.object({\n  type: external_exports2.literal(\"response.created\"),\n  response: external_exports2.object({\n    id: external_exports2.string(),\n    created_at: external_exports2.number(),\n    model: external_exports2.string(),\n    service_tier: external_exports2.string().nullish()\n  })\n});\nvar responseOutputItemAddedSchema = external_exports2.object({\n  type: external_exports2.literal(\"response.output_item.added\"),\n  output_index: external_exports2.number(),\n  item: external_exports2.discriminatedUnion(\"type\", [external_exports2.object({\n    type: external_exports2.literal(\"message\"),\n    id: external_exports2.string()\n  }), external_exports2.object({\n    type: external_exports2.literal(\"reasoning\"),\n    id: external_exports2.string(),\n    encrypted_content: external_exports2.string().nullish()\n  }), external_exports2.object({\n    type: external_exports2.literal(\"function_call\"),\n    id: external_exports2.string(),\n    call_id: external_exports2.string(),\n    name: external_exports2.string(),\n    arguments: external_exports2.string()\n  }), external_exports2.object({\n    type: external_exports2.literal(\"web_search_call\"),\n    id: external_exports2.string(),\n    status: external_exports2.string(),\n    action: external_exports2.object({\n      type: external_exports2.literal(\"search\"),\n      query: external_exports2.string().optional()\n    }).nullish()\n  }), external_exports2.object({\n    type: external_exports2.literal(\"computer_call\"),\n    id: external_exports2.string(),\n    status: external_exports2.string()\n  }), external_exports2.object({\n    type: external_exports2.literal(\"file_search_call\"),\n    id: external_exports2.string(),\n    status: external_exports2.string(),\n    queries: external_exports2.array(external_exports2.string()).nullish(),\n    results: external_exports2.array(external_exports2.object({\n      attributes: external_exports2.object({\n        file_id: external_exports2.string(),\n        filename: external_exports2.string(),\n        score: external_exports2.number(),\n        text: external_exports2.string()\n      })\n    })).optional()\n  })])\n});\nvar responseOutputItemDoneSchema = external_exports2.object({\n  type: external_exports2.literal(\"response.output_item.done\"),\n  output_index: external_exports2.number(),\n  item: external_exports2.discriminatedUnion(\"type\", [external_exports2.object({\n    type: external_exports2.literal(\"message\"),\n    id: external_exports2.string()\n  }), external_exports2.object({\n    type: external_exports2.literal(\"reasoning\"),\n    id: external_exports2.string(),\n    encrypted_content: external_exports2.string().nullish()\n  }), external_exports2.object({\n    type: external_exports2.literal(\"function_call\"),\n    id: external_exports2.string(),\n    call_id: external_exports2.string(),\n    name: external_exports2.string(),\n    arguments: external_exports2.string(),\n    status: external_exports2.literal(\"completed\")\n  }), codeInterpreterCallItem, webSearchCallItem, external_exports2.object({\n    type: external_exports2.literal(\"computer_call\"),\n    id: external_exports2.string(),\n    status: external_exports2.literal(\"completed\")\n  }), external_exports2.object({\n    type: external_exports2.literal(\"file_search_call\"),\n    id: external_exports2.string(),\n    status: external_exports2.literal(\"completed\"),\n    queries: external_exports2.array(external_exports2.string()).nullish(),\n    results: external_exports2.array(external_exports2.object({\n      attributes: external_exports2.object({\n        file_id: external_exports2.string(),\n        filename: external_exports2.string(),\n        score: external_exports2.number(),\n        text: external_exports2.string()\n      })\n    })).nullish()\n  })])\n});\nvar responseFunctionCallArgumentsDeltaSchema = external_exports2.object({\n  type: external_exports2.literal(\"response.function_call_arguments.delta\"),\n  item_id: external_exports2.string(),\n  output_index: external_exports2.number(),\n  delta: external_exports2.string()\n});\nvar responseAnnotationAddedSchema = external_exports2.object({\n  type: external_exports2.literal(\"response.output_text.annotation.added\"),\n  annotation: external_exports2.discriminatedUnion(\"type\", [external_exports2.object({\n    type: external_exports2.literal(\"url_citation\"),\n    url: external_exports2.string(),\n    title: external_exports2.string()\n  }), external_exports2.object({\n    type: external_exports2.literal(\"file_citation\"),\n    file_id: external_exports2.string(),\n    filename: external_exports2.string().nullish(),\n    index: external_exports2.number().nullish(),\n    start_index: external_exports2.number().nullish(),\n    end_index: external_exports2.number().nullish(),\n    quote: external_exports2.string().nullish()\n  })])\n});\nvar responseReasoningSummaryPartAddedSchema = external_exports2.object({\n  type: external_exports2.literal(\"response.reasoning_summary_part.added\"),\n  item_id: external_exports2.string(),\n  summary_index: external_exports2.number()\n});\nvar responseReasoningSummaryTextDeltaSchema = external_exports2.object({\n  type: external_exports2.literal(\"response.reasoning_summary_text.delta\"),\n  item_id: external_exports2.string(),\n  summary_index: external_exports2.number(),\n  delta: external_exports2.string()\n});\nvar openaiResponsesChunkSchema = external_exports2.union([textDeltaChunkSchema, responseFinishedChunkSchema, responseCreatedChunkSchema, responseOutputItemAddedSchema, responseOutputItemDoneSchema, responseFunctionCallArgumentsDeltaSchema, responseAnnotationAddedSchema, responseReasoningSummaryPartAddedSchema, responseReasoningSummaryTextDeltaSchema, errorChunkSchema, external_exports2.object({\n  type: external_exports2.string()\n}).loose()\n// fallback for unknown chunks\n]);\nfunction isTextDeltaChunk(chunk) {\n  return chunk.type === \"response.output_text.delta\";\n}\nfunction isResponseOutputItemDoneChunk(chunk) {\n  return chunk.type === \"response.output_item.done\";\n}\nfunction isResponseOutputItemDoneReasoningChunk(chunk) {\n  return isResponseOutputItemDoneChunk(chunk) && chunk.item.type === \"reasoning\";\n}\nfunction isResponseFinishedChunk(chunk) {\n  return chunk.type === \"response.completed\" || chunk.type === \"response.incomplete\";\n}\nfunction isResponseCreatedChunk(chunk) {\n  return chunk.type === \"response.created\";\n}\nfunction isResponseFunctionCallArgumentsDeltaChunk(chunk) {\n  return chunk.type === \"response.function_call_arguments.delta\";\n}\nfunction isResponseOutputItemAddedChunk(chunk) {\n  return chunk.type === \"response.output_item.added\";\n}\nfunction isResponseOutputItemAddedReasoningChunk(chunk) {\n  return isResponseOutputItemAddedChunk(chunk) && chunk.item.type === \"reasoning\";\n}\nfunction isResponseAnnotationAddedChunk(chunk) {\n  return chunk.type === \"response.output_text.annotation.added\";\n}\nfunction isResponseReasoningSummaryPartAddedChunk(chunk) {\n  return chunk.type === \"response.reasoning_summary_part.added\";\n}\nfunction isResponseReasoningSummaryTextDeltaChunk(chunk) {\n  return chunk.type === \"response.reasoning_summary_text.delta\";\n}\nfunction isErrorChunk(chunk) {\n  return chunk.type === \"error\";\n}\nfunction getResponsesModelConfig(modelId) {\n  const supportsFlexProcessing2 = modelId.startsWith(\"o3\") || modelId.startsWith(\"o4-mini\") || modelId.startsWith(\"gpt-5\") && !modelId.startsWith(\"gpt-5-chat\");\n  const supportsPriorityProcessing2 = modelId.startsWith(\"gpt-4\") || modelId.startsWith(\"gpt-5-mini\") || modelId.startsWith(\"gpt-5\") && !modelId.startsWith(\"gpt-5-nano\") && !modelId.startsWith(\"gpt-5-chat\") || modelId.startsWith(\"o3\") || modelId.startsWith(\"o4-mini\");\n  const defaults = {\n    requiredAutoTruncation: false,\n    systemMessageMode: \"system\",\n    supportsFlexProcessing: supportsFlexProcessing2,\n    supportsPriorityProcessing: supportsPriorityProcessing2\n  };\n  if (modelId.startsWith(\"gpt-5-chat\")) {\n    return {\n      ...defaults,\n      isReasoningModel: false\n    };\n  }\n  if (modelId.startsWith(\"o\") || modelId.startsWith(\"gpt-5\") || modelId.startsWith(\"codex-\") || modelId.startsWith(\"computer-use\")) {\n    if (modelId.startsWith(\"o1-mini\") || modelId.startsWith(\"o1-preview\")) {\n      return {\n        ...defaults,\n        isReasoningModel: true,\n        systemMessageMode: \"remove\"\n      };\n    }\n    return {\n      ...defaults,\n      isReasoningModel: true,\n      systemMessageMode: \"developer\"\n    };\n  }\n  return {\n    ...defaults,\n    isReasoningModel: false\n  };\n}\nvar openaiResponsesProviderOptionsSchema = external_exports2.object({\n  metadata: external_exports2.any().nullish(),\n  parallelToolCalls: external_exports2.boolean().nullish(),\n  previousResponseId: external_exports2.string().nullish(),\n  store: external_exports2.boolean().nullish(),\n  user: external_exports2.string().nullish(),\n  reasoningEffort: external_exports2.string().nullish(),\n  strictJsonSchema: external_exports2.boolean().nullish(),\n  instructions: external_exports2.string().nullish(),\n  reasoningSummary: external_exports2.string().nullish(),\n  serviceTier: external_exports2.enum([\"auto\", \"flex\", \"priority\"]).nullish(),\n  include: external_exports2.array(external_exports2.enum([\"reasoning.encrypted_content\", \"file_search_call.results\", \"message.output_text.logprobs\"])).nullish(),\n  textVerbosity: external_exports2.enum([\"low\", \"medium\", \"high\"]).nullish(),\n  promptCacheKey: external_exports2.string().nullish(),\n  safetyIdentifier: external_exports2.string().nullish(),\n  /**\n   * Return the log probabilities of the tokens.\n   *\n   * Setting to true will return the log probabilities of the tokens that\n   * were generated.\n   *\n   * Setting to a number will return the log probabilities of the top n\n   * tokens that were generated.\n   *\n   * @see https://platform.openai.com/docs/api-reference/responses/create\n   * @see https://cookbook.openai.com/examples/using_logprobs\n   */\n  logprobs: external_exports2.union([external_exports2.boolean(), external_exports2.number().min(1).max(TOP_LOGPROBS_MAX)]).optional()\n});\nvar OpenAIProviderOptionsSchema = external_exports2.object({\n  instructions: external_exports2.string().nullish(),\n  speed: external_exports2.number().min(0.25).max(4).default(1).nullish()\n});\nvar OpenAISpeechModel = class {\n  constructor(modelId, config2) {\n    this.modelId = modelId;\n    this.config = config2;\n    this.specificationVersion = \"v2\";\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  async getArgs({\n    text: text2,\n    voice = \"alloy\",\n    outputFormat = \"mp3\",\n    speed,\n    instructions,\n    language,\n    providerOptions\n  }) {\n    const warnings = [];\n    const openAIOptions = await parseProviderOptions({\n      provider: \"openai\",\n      providerOptions,\n      schema: OpenAIProviderOptionsSchema\n    });\n    const requestBody = {\n      model: this.modelId,\n      input: text2,\n      voice,\n      response_format: \"mp3\",\n      speed,\n      instructions\n    };\n    if (outputFormat) {\n      if ([\"mp3\", \"opus\", \"aac\", \"flac\", \"wav\", \"pcm\"].includes(outputFormat)) {\n        requestBody.response_format = outputFormat;\n      } else {\n        warnings.push({\n          type: \"unsupported-setting\",\n          setting: \"outputFormat\",\n          details: `Unsupported output format: ${outputFormat}. Using mp3 instead.`\n        });\n      }\n    }\n    if (openAIOptions) {\n      const speechModelOptions = {};\n      for (const key in speechModelOptions) {\n        const value = speechModelOptions[key];\n        if (value !== void 0) {\n          requestBody[key] = value;\n        }\n      }\n    }\n    if (language) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"language\",\n        details: `OpenAI speech models do not support language selection. Language parameter \"${language}\" was ignored.`\n      });\n    }\n    return {\n      requestBody,\n      warnings\n    };\n  }\n  async doGenerate(options) {\n    var _a20, _b8, _c;\n    const currentDate = (_c = (_b8 = (_a20 = this.config._internal) == null ? void 0 : _a20.currentDate) == null ? void 0 : _b8.call(_a20)) != null ? _c : /* @__PURE__ */new Date();\n    const {\n      requestBody,\n      warnings\n    } = await this.getArgs(options);\n    const {\n      value: audio,\n      responseHeaders,\n      rawValue: rawResponse\n    } = await postJsonToApi2({\n      url: this.config.url({\n        path: \"/audio/speech\",\n        modelId: this.modelId\n      }),\n      headers: combineHeaders2(this.config.headers(), options.headers),\n      body: requestBody,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createBinaryResponseHandler(),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    return {\n      audio,\n      warnings,\n      request: {\n        body: JSON.stringify(requestBody)\n      },\n      response: {\n        timestamp: currentDate,\n        modelId: this.modelId,\n        headers: responseHeaders,\n        body: rawResponse\n      }\n    };\n  }\n};\nvar openAITranscriptionProviderOptions = external_exports2.object({\n  /**\n   * Additional information to include in the transcription response.\n   */\n  include: external_exports2.array(external_exports2.string()).optional(),\n  /**\n   * The language of the input audio in ISO-639-1 format.\n   */\n  language: external_exports2.string().optional(),\n  /**\n   * An optional text to guide the model's style or continue a previous audio segment.\n   */\n  prompt: external_exports2.string().optional(),\n  /**\n   * The sampling temperature, between 0 and 1.\n   * @default 0\n   */\n  temperature: external_exports2.number().min(0).max(1).default(0).optional(),\n  /**\n   * The timestamp granularities to populate for this transcription.\n   * @default ['segment']\n   */\n  timestampGranularities: external_exports2.array(external_exports2.enum([\"word\", \"segment\"])).default([\"segment\"]).optional()\n});\nvar languageMap = {\n  afrikaans: \"af\",\n  arabic: \"ar\",\n  armenian: \"hy\",\n  azerbaijani: \"az\",\n  belarusian: \"be\",\n  bosnian: \"bs\",\n  bulgarian: \"bg\",\n  catalan: \"ca\",\n  chinese: \"zh\",\n  croatian: \"hr\",\n  czech: \"cs\",\n  danish: \"da\",\n  dutch: \"nl\",\n  english: \"en\",\n  estonian: \"et\",\n  finnish: \"fi\",\n  french: \"fr\",\n  galician: \"gl\",\n  german: \"de\",\n  greek: \"el\",\n  hebrew: \"he\",\n  hindi: \"hi\",\n  hungarian: \"hu\",\n  icelandic: \"is\",\n  indonesian: \"id\",\n  italian: \"it\",\n  japanese: \"ja\",\n  kannada: \"kn\",\n  kazakh: \"kk\",\n  korean: \"ko\",\n  latvian: \"lv\",\n  lithuanian: \"lt\",\n  macedonian: \"mk\",\n  malay: \"ms\",\n  marathi: \"mr\",\n  maori: \"mi\",\n  nepali: \"ne\",\n  norwegian: \"no\",\n  persian: \"fa\",\n  polish: \"pl\",\n  portuguese: \"pt\",\n  romanian: \"ro\",\n  russian: \"ru\",\n  serbian: \"sr\",\n  slovak: \"sk\",\n  slovenian: \"sl\",\n  spanish: \"es\",\n  swahili: \"sw\",\n  swedish: \"sv\",\n  tagalog: \"tl\",\n  tamil: \"ta\",\n  thai: \"th\",\n  turkish: \"tr\",\n  ukrainian: \"uk\",\n  urdu: \"ur\",\n  vietnamese: \"vi\",\n  welsh: \"cy\"\n};\nvar OpenAITranscriptionModel = class {\n  constructor(modelId, config2) {\n    this.modelId = modelId;\n    this.config = config2;\n    this.specificationVersion = \"v2\";\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  async getArgs({\n    audio,\n    mediaType,\n    providerOptions\n  }) {\n    const warnings = [];\n    const openAIOptions = await parseProviderOptions({\n      provider: \"openai\",\n      providerOptions,\n      schema: openAITranscriptionProviderOptions\n    });\n    const formData = new FormData();\n    const blob = audio instanceof Uint8Array ? new Blob([audio]) : new Blob([convertBase64ToUint8Array2(audio)]);\n    formData.append(\"model\", this.modelId);\n    const fileExtension = mediaTypeToExtension(mediaType);\n    formData.append(\"file\", new File([blob], \"audio\", {\n      type: mediaType\n    }), `audio.${fileExtension}`);\n    if (openAIOptions) {\n      const transcriptionModelOptions = {\n        include: openAIOptions.include,\n        language: openAIOptions.language,\n        prompt: openAIOptions.prompt,\n        // https://platform.openai.com/docs/api-reference/audio/createTranscription#audio_createtranscription-response_format\n        // prefer verbose_json to get segments for models that support it\n        response_format: [\"gpt-4o-transcribe\", \"gpt-4o-mini-transcribe\"].includes(this.modelId) ? \"json\" : \"verbose_json\",\n        temperature: openAIOptions.temperature,\n        timestamp_granularities: openAIOptions.timestampGranularities\n      };\n      for (const [key, value] of Object.entries(transcriptionModelOptions)) {\n        if (value != null) {\n          if (Array.isArray(value)) {\n            for (const item of value) {\n              formData.append(`${key}[]`, String(item));\n            }\n          } else {\n            formData.append(key, String(value));\n          }\n        }\n      }\n    }\n    return {\n      formData,\n      warnings\n    };\n  }\n  async doGenerate(options) {\n    var _a20, _b8, _c, _d, _e, _f, _g, _h;\n    const currentDate = (_c = (_b8 = (_a20 = this.config._internal) == null ? void 0 : _a20.currentDate) == null ? void 0 : _b8.call(_a20)) != null ? _c : /* @__PURE__ */new Date();\n    const {\n      formData,\n      warnings\n    } = await this.getArgs(options);\n    const {\n      value: response,\n      responseHeaders,\n      rawValue: rawResponse\n    } = await postFormDataToApi({\n      url: this.config.url({\n        path: \"/audio/transcriptions\",\n        modelId: this.modelId\n      }),\n      headers: combineHeaders2(this.config.headers(), options.headers),\n      formData,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler2(openaiTranscriptionResponseSchema),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    const language = response.language != null && response.language in languageMap ? languageMap[response.language] : void 0;\n    return {\n      text: response.text,\n      segments: (_g = (_f = (_d = response.segments) == null ? void 0 : _d.map(segment => ({\n        text: segment.text,\n        startSecond: segment.start,\n        endSecond: segment.end\n      }))) != null ? _f : (_e = response.words) == null ? void 0 : _e.map(word => ({\n        text: word.word,\n        startSecond: word.start,\n        endSecond: word.end\n      }))) != null ? _g : [],\n      language,\n      durationInSeconds: (_h = response.duration) != null ? _h : void 0,\n      warnings,\n      response: {\n        timestamp: currentDate,\n        modelId: this.modelId,\n        headers: responseHeaders,\n        body: rawResponse\n      }\n    };\n  }\n};\nvar openaiTranscriptionResponseSchema = external_exports2.object({\n  text: external_exports2.string(),\n  language: external_exports2.string().nullish(),\n  duration: external_exports2.number().nullish(),\n  words: external_exports2.array(external_exports2.object({\n    word: external_exports2.string(),\n    start: external_exports2.number(),\n    end: external_exports2.number()\n  })).nullish(),\n  segments: external_exports2.array(external_exports2.object({\n    id: external_exports2.number(),\n    seek: external_exports2.number(),\n    start: external_exports2.number(),\n    end: external_exports2.number(),\n    text: external_exports2.string(),\n    tokens: external_exports2.array(external_exports2.number()),\n    temperature: external_exports2.number(),\n    avg_logprob: external_exports2.number(),\n    compression_ratio: external_exports2.number(),\n    no_speech_prob: external_exports2.number()\n  })).nullish()\n});\nfunction createOpenAI(options = {}) {\n  var _a20, _b8;\n  const baseURL = (_a20 = withoutTrailingSlash2(options.baseURL)) != null ? _a20 : \"https://api.openai.com/v1\";\n  const providerName = (_b8 = options.name) != null ? _b8 : \"openai\";\n  const getHeaders = () => ({\n    Authorization: `Bearer ${loadApiKey({\n      apiKey: options.apiKey,\n      environmentVariableName: \"OPENAI_API_KEY\",\n      description: \"OpenAI\"\n    })}`,\n    \"OpenAI-Organization\": options.organization,\n    \"OpenAI-Project\": options.project,\n    ...options.headers\n  });\n  const createChatModel = modelId => new OpenAIChatLanguageModel(modelId, {\n    provider: `${providerName}.chat`,\n    url: ({\n      path\n    }) => `${baseURL}${path}`,\n    headers: getHeaders,\n    fetch: options.fetch\n  });\n  const createCompletionModel = modelId => new OpenAICompletionLanguageModel(modelId, {\n    provider: `${providerName}.completion`,\n    url: ({\n      path\n    }) => `${baseURL}${path}`,\n    headers: getHeaders,\n    fetch: options.fetch\n  });\n  const createEmbeddingModel = modelId => new OpenAIEmbeddingModel(modelId, {\n    provider: `${providerName}.embedding`,\n    url: ({\n      path\n    }) => `${baseURL}${path}`,\n    headers: getHeaders,\n    fetch: options.fetch\n  });\n  const createImageModel = modelId => new OpenAIImageModel(modelId, {\n    provider: `${providerName}.image`,\n    url: ({\n      path\n    }) => `${baseURL}${path}`,\n    headers: getHeaders,\n    fetch: options.fetch\n  });\n  const createTranscriptionModel = modelId => new OpenAITranscriptionModel(modelId, {\n    provider: `${providerName}.transcription`,\n    url: ({\n      path\n    }) => `${baseURL}${path}`,\n    headers: getHeaders,\n    fetch: options.fetch\n  });\n  const createSpeechModel = modelId => new OpenAISpeechModel(modelId, {\n    provider: `${providerName}.speech`,\n    url: ({\n      path\n    }) => `${baseURL}${path}`,\n    headers: getHeaders,\n    fetch: options.fetch\n  });\n  const createLanguageModel = modelId => {\n    if (new.target) {\n      throw new Error(\"The OpenAI model function cannot be called with the new keyword.\");\n    }\n    return createResponsesModel(modelId);\n  };\n  const createResponsesModel = modelId => {\n    return new OpenAIResponsesLanguageModel(modelId, {\n      provider: `${providerName}.responses`,\n      url: ({\n        path\n      }) => `${baseURL}${path}`,\n      headers: getHeaders,\n      fetch: options.fetch,\n      fileIdPrefixes: [\"file-\"]\n    });\n  };\n  const provider = function (modelId) {\n    return createLanguageModel(modelId);\n  };\n  provider.languageModel = createLanguageModel;\n  provider.chat = createChatModel;\n  provider.completion = createCompletionModel;\n  provider.responses = createResponsesModel;\n  provider.embedding = createEmbeddingModel;\n  provider.textEmbedding = createEmbeddingModel;\n  provider.textEmbeddingModel = createEmbeddingModel;\n  provider.image = createImageModel;\n  provider.imageModel = createImageModel;\n  provider.transcription = createTranscriptionModel;\n  provider.transcriptionModel = createTranscriptionModel;\n  provider.speech = createSpeechModel;\n  provider.speechModel = createSpeechModel;\n  provider.tools = openaiTools;\n  return provider;\n}\nvar openai = createOpenAI();\n\n// ../../node_modules/@ai-sdk/provider/dist/index.mjs\nvar marker19 = \"vercel.ai.error\";\nvar symbol20 = Symbol.for(marker19);\nvar _a19;\nvar _AISDKError7 = class _AISDKError8 extends Error {\n  /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */\n  constructor({\n    name: name143,\n    message,\n    cause\n  }) {\n    super(message);\n    this[_a19] = true;\n    this.name = name143;\n    this.cause = cause;\n  }\n  /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */\n  static isInstance(error40) {\n    return _AISDKError8.hasMarker(error40, marker19);\n  }\n  static hasMarker(error40, marker153) {\n    const markerSymbol = Symbol.for(marker153);\n    return error40 != null && typeof error40 === \"object\" && markerSymbol in error40 && typeof error40[markerSymbol] === \"boolean\" && error40[markerSymbol] === true;\n  }\n};\n_a19 = symbol20;\nvar AISDKError4 = _AISDKError7;\nvar name18 = \"AI_APICallError\";\nvar marker26 = `vercel.ai.error.${name18}`;\nvar symbol26 = Symbol.for(marker26);\nvar _a26;\nvar APICallError4 = class extends AISDKError4 {\n  constructor({\n    message,\n    url: url2,\n    requestBodyValues,\n    statusCode,\n    responseHeaders,\n    responseBody,\n    cause,\n    isRetryable = statusCode != null && (statusCode === 408 ||\n    // request timeout\n    statusCode === 409 ||\n    // conflict\n    statusCode === 429 ||\n    // too many requests\n    statusCode >= 500),\n    // server error\n    data\n  }) {\n    super({\n      name: name18,\n      message,\n      cause\n    });\n    this[_a26] = true;\n    this.url = url2;\n    this.requestBodyValues = requestBodyValues;\n    this.statusCode = statusCode;\n    this.responseHeaders = responseHeaders;\n    this.responseBody = responseBody;\n    this.isRetryable = isRetryable;\n    this.data = data;\n  }\n  static isInstance(error40) {\n    return AISDKError4.hasMarker(error40, marker26);\n  }\n};\n_a26 = symbol26;\nvar name26 = \"AI_EmptyResponseBodyError\";\nvar marker36 = `vercel.ai.error.${name26}`;\nvar symbol36 = Symbol.for(marker36);\nvar _a36;\nvar EmptyResponseBodyError3 = class extends AISDKError4 {\n  // used in isInstance\n  constructor({\n    message = \"Empty response body\"\n  } = {}) {\n    super({\n      name: name26,\n      message\n    });\n    this[_a36] = true;\n  }\n  static isInstance(error40) {\n    return AISDKError4.hasMarker(error40, marker36);\n  }\n};\n_a36 = symbol36;\nfunction getErrorMessage5(error40) {\n  if (error40 == null) {\n    return \"unknown error\";\n  }\n  if (typeof error40 === \"string\") {\n    return error40;\n  }\n  if (error40 instanceof Error) {\n    return error40.message;\n  }\n  return JSON.stringify(error40);\n}\nvar name36 = \"AI_InvalidArgumentError\";\nvar marker46 = `vercel.ai.error.${name36}`;\nvar symbol46 = Symbol.for(marker46);\nvar _a46;\nvar InvalidArgumentError5 = class extends AISDKError4 {\n  constructor({\n    message,\n    cause,\n    argument\n  }) {\n    super({\n      name: name36,\n      message,\n      cause\n    });\n    this[_a46] = true;\n    this.argument = argument;\n  }\n  static isInstance(error40) {\n    return AISDKError4.hasMarker(error40, marker46);\n  }\n};\n_a46 = symbol46;\nvar name46 = \"AI_InvalidPromptError\";\nvar marker56 = `vercel.ai.error.${name46}`;\nvar symbol56 = Symbol.for(marker56);\nvar _a56;\n_a56 = symbol56;\nvar name56 = \"AI_InvalidResponseDataError\";\nvar marker66 = `vercel.ai.error.${name56}`;\nvar symbol66 = Symbol.for(marker66);\nvar _a66;\nvar InvalidResponseDataError2 = class extends AISDKError4 {\n  constructor({\n    data,\n    message = `Invalid response data: ${JSON.stringify(data)}.`\n  }) {\n    super({\n      name: name56,\n      message\n    });\n    this[_a66] = true;\n    this.data = data;\n  }\n  static isInstance(error40) {\n    return AISDKError4.hasMarker(error40, marker66);\n  }\n};\n_a66 = symbol66;\nvar name66 = \"AI_JSONParseError\";\nvar marker76 = `vercel.ai.error.${name66}`;\nvar symbol76 = Symbol.for(marker76);\nvar _a76;\nvar JSONParseError4 = class extends AISDKError4 {\n  constructor({\n    text: text2,\n    cause\n  }) {\n    super({\n      name: name66,\n      message: `JSON parsing failed: Text: ${text2}.\nError message: ${getErrorMessage5(cause)}`,\n      cause\n    });\n    this[_a76] = true;\n    this.text = text2;\n  }\n  static isInstance(error40) {\n    return AISDKError4.hasMarker(error40, marker76);\n  }\n};\n_a76 = symbol76;\nvar name75 = \"AI_LoadAPIKeyError\";\nvar marker85 = `vercel.ai.error.${name75}`;\nvar symbol85 = Symbol.for(marker85);\nvar _a85;\nvar LoadAPIKeyError2 = class extends AISDKError4 {\n  // used in isInstance\n  constructor({\n    message\n  }) {\n    super({\n      name: name75,\n      message\n    });\n    this[_a85] = true;\n  }\n  static isInstance(error40) {\n    return AISDKError4.hasMarker(error40, marker85);\n  }\n};\n_a85 = symbol85;\nvar name85 = \"AI_LoadSettingError\";\nvar marker95 = `vercel.ai.error.${name85}`;\nvar symbol95 = Symbol.for(marker95);\nvar _a95;\n_a95 = symbol95;\nvar name95 = \"AI_NoContentGeneratedError\";\nvar marker105 = `vercel.ai.error.${name95}`;\nvar symbol105 = Symbol.for(marker105);\nvar _a105;\n_a105 = symbol105;\nvar name105 = \"AI_NoSuchModelError\";\nvar marker115 = `vercel.ai.error.${name105}`;\nvar symbol115 = Symbol.for(marker115);\nvar _a115;\nvar NoSuchModelError2 = class extends AISDKError4 {\n  constructor({\n    errorName = name105,\n    modelId,\n    modelType,\n    message = `No such ${modelType}: ${modelId}`\n  }) {\n    super({\n      name: errorName,\n      message\n    });\n    this[_a115] = true;\n    this.modelId = modelId;\n    this.modelType = modelType;\n  }\n  static isInstance(error40) {\n    return AISDKError4.hasMarker(error40, marker115);\n  }\n};\n_a115 = symbol115;\nvar name115 = \"AI_TooManyEmbeddingValuesForCallError\";\nvar marker125 = `vercel.ai.error.${name115}`;\nvar symbol125 = Symbol.for(marker125);\nvar _a125;\nvar TooManyEmbeddingValuesForCallError2 = class extends AISDKError4 {\n  constructor(options) {\n    super({\n      name: name115,\n      message: `Too many values for a single embedding call. The ${options.provider} model \"${options.modelId}\" can only embed up to ${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`\n    });\n    this[_a125] = true;\n    this.provider = options.provider;\n    this.modelId = options.modelId;\n    this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;\n    this.values = options.values;\n  }\n  static isInstance(error40) {\n    return AISDKError4.hasMarker(error40, marker125);\n  }\n};\n_a125 = symbol125;\nvar name125 = \"AI_TypeValidationError\";\nvar marker135 = `vercel.ai.error.${name125}`;\nvar symbol135 = Symbol.for(marker135);\nvar _a135;\nvar _TypeValidationError7 = class _TypeValidationError8 extends AISDKError4 {\n  constructor({\n    value,\n    cause\n  }) {\n    super({\n      name: name125,\n      message: `Type validation failed: Value: ${JSON.stringify(value)}.\nError message: ${getErrorMessage5(cause)}`,\n      cause\n    });\n    this[_a135] = true;\n    this.value = value;\n  }\n  static isInstance(error40) {\n    return AISDKError4.hasMarker(error40, marker135);\n  }\n  /**\n   * Wraps an error into a TypeValidationError.\n   * If the cause is already a TypeValidationError with the same value, it returns the cause.\n   * Otherwise, it creates a new TypeValidationError.\n   *\n   * @param {Object} params - The parameters for wrapping the error.\n   * @param {unknown} params.value - The value that failed validation.\n   * @param {unknown} params.cause - The original error or cause of the validation failure.\n   * @returns {TypeValidationError} A TypeValidationError instance.\n   */\n  static wrap({\n    value,\n    cause\n  }) {\n    return _TypeValidationError8.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError8({\n      value,\n      cause\n    });\n  }\n};\n_a135 = symbol135;\nvar TypeValidationError4 = _TypeValidationError7;\nvar name135 = \"AI_UnsupportedFunctionalityError\";\nvar marker145 = `vercel.ai.error.${name135}`;\nvar symbol145 = Symbol.for(marker145);\nvar _a145;\nvar UnsupportedFunctionalityError3 = class extends AISDKError4 {\n  constructor({\n    functionality,\n    message = `'${functionality}' functionality not supported.`\n  }) {\n    super({\n      name: name135,\n      message\n    });\n    this[_a145] = true;\n    this.functionality = functionality;\n  }\n  static isInstance(error40) {\n    return AISDKError4.hasMarker(error40, marker145);\n  }\n};\n_a145 = symbol145;\n\n// ../../node_modules/nanoid/non-secure/index.js\nvar customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = \"\";\n    let i = size | 0;\n    while (i--) {\n      id += alphabet[Math.random() * alphabet.length | 0];\n    }\n    return id;\n  };\n};\n\n// ../../node_modules/@ai-sdk/provider-utils/dist/index.mjs\nvar import_secure_json_parse = __toESM(require_secure_json_parse(), 1);\nfunction combineHeaders3(...headers) {\n  return headers.reduce((combinedHeaders, currentHeaders) => ({\n    ...combinedHeaders,\n    ...(currentHeaders != null ? currentHeaders : {})\n  }), {});\n}\nfunction createEventSourceParserStream() {\n  let buffer = \"\";\n  let event = void 0;\n  let data = [];\n  let lastEventId = void 0;\n  let retry = void 0;\n  function parseLine(line, controller) {\n    if (line === \"\") {\n      dispatchEvent(controller);\n      return;\n    }\n    if (line.startsWith(\":\")) {\n      return;\n    }\n    const colonIndex = line.indexOf(\":\");\n    if (colonIndex === -1) {\n      handleField(line, \"\");\n      return;\n    }\n    const field = line.slice(0, colonIndex);\n    const valueStart = colonIndex + 1;\n    const value = valueStart < line.length && line[valueStart] === \" \" ? line.slice(valueStart + 1) : line.slice(valueStart);\n    handleField(field, value);\n  }\n  function dispatchEvent(controller) {\n    if (data.length > 0) {\n      controller.enqueue({\n        event,\n        data: data.join(\"\\n\"),\n        id: lastEventId,\n        retry\n      });\n      data = [];\n      event = void 0;\n      retry = void 0;\n    }\n  }\n  function handleField(field, value) {\n    switch (field) {\n      case \"event\":\n        event = value;\n        break;\n      case \"data\":\n        data.push(value);\n        break;\n      case \"id\":\n        lastEventId = value;\n        break;\n      case \"retry\":\n        const parsedRetry = parseInt(value, 10);\n        if (!isNaN(parsedRetry)) {\n          retry = parsedRetry;\n        }\n        break;\n    }\n  }\n  return new TransformStream({\n    transform(chunk, controller) {\n      const {\n        lines,\n        incompleteLine\n      } = splitLines2(buffer, chunk);\n      buffer = incompleteLine;\n      for (let i = 0; i < lines.length; i++) {\n        parseLine(lines[i], controller);\n      }\n    },\n    flush(controller) {\n      parseLine(buffer, controller);\n      dispatchEvent(controller);\n    }\n  });\n}\nfunction splitLines2(buffer, chunk) {\n  const lines = [];\n  let currentLine = buffer;\n  for (let i = 0; i < chunk.length;) {\n    const char = chunk[i++];\n    if (char === \"\\n\") {\n      lines.push(currentLine);\n      currentLine = \"\";\n    } else if (char === \"\\r\") {\n      lines.push(currentLine);\n      currentLine = \"\";\n      if (chunk[i] === \"\\n\") {\n        i++;\n      }\n    } else {\n      currentLine += char;\n    }\n  }\n  return {\n    lines,\n    incompleteLine: currentLine\n  };\n}\nfunction extractResponseHeaders3(response) {\n  const headers = {};\n  response.headers.forEach((value, key) => {\n    headers[key] = value;\n  });\n  return headers;\n}\nvar createIdGenerator4 = ({\n  prefix,\n  size: defaultSize = 16,\n  alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n  separator = \"-\"\n} = {}) => {\n  const generator = customAlphabet(alphabet, defaultSize);\n  if (prefix == null) {\n    return generator;\n  }\n  if (alphabet.includes(separator)) {\n    throw new InvalidArgumentError5({\n      argument: \"separator\",\n      message: `The separator \"${separator}\" must not be part of the alphabet \"${alphabet}\".`\n    });\n  }\n  return size => `${prefix}${separator}${generator(size)}`;\n};\nvar generateId4 = createIdGenerator4();\nfunction removeUndefinedEntries4(record2) {\n  return Object.fromEntries(Object.entries(record2).filter(([_key, value]) => value != null));\n}\nfunction isAbortError4(error40) {\n  return error40 instanceof Error && (error40.name === \"AbortError\" || error40.name === \"TimeoutError\");\n}\nfunction loadApiKey2({\n  apiKey,\n  environmentVariableName,\n  apiKeyParameterName = \"apiKey\",\n  description\n}) {\n  if (typeof apiKey === \"string\") {\n    return apiKey;\n  }\n  if (apiKey != null) {\n    throw new LoadAPIKeyError2({\n      message: `${description} API key must be a string.`\n    });\n  }\n  if (typeof process === \"undefined\") {\n    throw new LoadAPIKeyError2({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`\n    });\n  }\n  apiKey = process.env[environmentVariableName];\n  if (apiKey == null) {\n    throw new LoadAPIKeyError2({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`\n    });\n  }\n  if (typeof apiKey !== \"string\") {\n    throw new LoadAPIKeyError2({\n      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`\n    });\n  }\n  return apiKey;\n}\nvar validatorSymbol4 = Symbol.for(\"vercel.ai.validator\");\nfunction validator4(validate) {\n  return {\n    [validatorSymbol4]: true,\n    validate\n  };\n}\nfunction isValidator4(value) {\n  return typeof value === \"object\" && value !== null && validatorSymbol4 in value && value[validatorSymbol4] === true && \"validate\" in value;\n}\nfunction asValidator4(value) {\n  return isValidator4(value) ? value : zodValidator(value);\n}\nfunction zodValidator(zodSchema2) {\n  return validator4(value => {\n    const result = zodSchema2.safeParse(value);\n    return result.success ? {\n      success: true,\n      value: result.data\n    } : {\n      success: false,\n      error: result.error\n    };\n  });\n}\nfunction validateTypes4({\n  value,\n  schema: inputSchema\n}) {\n  const result = safeValidateTypes4({\n    value,\n    schema: inputSchema\n  });\n  if (!result.success) {\n    throw TypeValidationError4.wrap({\n      value,\n      cause: result.error\n    });\n  }\n  return result.value;\n}\nfunction safeValidateTypes4({\n  value,\n  schema\n}) {\n  const validator22 = asValidator4(schema);\n  try {\n    if (validator22.validate == null) {\n      return {\n        success: true,\n        value\n      };\n    }\n    const result = validator22.validate(value);\n    if (result.success) {\n      return result;\n    }\n    return {\n      success: false,\n      error: TypeValidationError4.wrap({\n        value,\n        cause: result.error\n      })\n    };\n  } catch (error40) {\n    return {\n      success: false,\n      error: TypeValidationError4.wrap({\n        value,\n        cause: error40\n      })\n    };\n  }\n}\nfunction parseJSON3({\n  text: text2,\n  schema\n}) {\n  try {\n    const value = import_secure_json_parse.default.parse(text2);\n    if (schema == null) {\n      return value;\n    }\n    return validateTypes4({\n      value,\n      schema\n    });\n  } catch (error40) {\n    if (JSONParseError4.isInstance(error40) || TypeValidationError4.isInstance(error40)) {\n      throw error40;\n    }\n    throw new JSONParseError4({\n      text: text2,\n      cause: error40\n    });\n  }\n}\nfunction safeParseJSON4({\n  text: text2,\n  schema\n}) {\n  try {\n    const value = import_secure_json_parse.default.parse(text2);\n    if (schema == null) {\n      return {\n        success: true,\n        value,\n        rawValue: value\n      };\n    }\n    const validationResult = safeValidateTypes4({\n      value,\n      schema\n    });\n    return validationResult.success ? {\n      ...validationResult,\n      rawValue: value\n    } : validationResult;\n  } catch (error40) {\n    return {\n      success: false,\n      error: JSONParseError4.isInstance(error40) ? error40 : new JSONParseError4({\n        text: text2,\n        cause: error40\n      })\n    };\n  }\n}\nfunction isParsableJson2(input) {\n  try {\n    import_secure_json_parse.default.parse(input);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction parseProviderOptions2({\n  provider,\n  providerOptions,\n  schema\n}) {\n  if ((providerOptions == null ? void 0 : providerOptions[provider]) == null) {\n    return void 0;\n  }\n  const parsedProviderOptions = safeValidateTypes4({\n    value: providerOptions[provider],\n    schema\n  });\n  if (!parsedProviderOptions.success) {\n    throw new InvalidArgumentError5({\n      argument: \"providerOptions\",\n      message: `invalid ${provider} provider options`,\n      cause: parsedProviderOptions.error\n    });\n  }\n  return parsedProviderOptions.value;\n}\nvar getOriginalFetch23 = () => globalThis.fetch;\nvar postJsonToApi3 = async ({\n  url: url2,\n  headers,\n  body,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch: fetch2\n}) => postToApi3({\n  url: url2,\n  headers: {\n    \"Content-Type\": \"application/json\",\n    ...headers\n  },\n  body: {\n    content: JSON.stringify(body),\n    values: body\n  },\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch: fetch2\n});\nvar postFormDataToApi2 = async ({\n  url: url2,\n  headers,\n  formData,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch: fetch2\n}) => postToApi3({\n  url: url2,\n  headers,\n  body: {\n    content: formData,\n    values: Object.fromEntries(formData.entries())\n  },\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch: fetch2\n});\nvar postToApi3 = async ({\n  url: url2,\n  headers = {},\n  body,\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch: fetch2 = getOriginalFetch23()\n}) => {\n  try {\n    const response = await fetch2(url2, {\n      method: \"POST\",\n      headers: removeUndefinedEntries4(headers),\n      body: body.content,\n      signal: abortSignal\n    });\n    const responseHeaders = extractResponseHeaders3(response);\n    if (!response.ok) {\n      let errorInformation;\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url: url2,\n          requestBodyValues: body.values\n        });\n      } catch (error40) {\n        if (isAbortError4(error40) || APICallError4.isInstance(error40)) {\n          throw error40;\n        }\n        throw new APICallError4({\n          message: \"Failed to process error response\",\n          cause: error40,\n          statusCode: response.status,\n          url: url2,\n          responseHeaders,\n          requestBodyValues: body.values\n        });\n      }\n      throw errorInformation.value;\n    }\n    try {\n      return await successfulResponseHandler({\n        response,\n        url: url2,\n        requestBodyValues: body.values\n      });\n    } catch (error40) {\n      if (error40 instanceof Error) {\n        if (isAbortError4(error40) || APICallError4.isInstance(error40)) {\n          throw error40;\n        }\n      }\n      throw new APICallError4({\n        message: \"Failed to process successful response\",\n        cause: error40,\n        statusCode: response.status,\n        url: url2,\n        responseHeaders,\n        requestBodyValues: body.values\n      });\n    }\n  } catch (error40) {\n    if (isAbortError4(error40)) {\n      throw error40;\n    }\n    if (error40 instanceof TypeError && error40.message === \"fetch failed\") {\n      const cause = error40.cause;\n      if (cause != null) {\n        throw new APICallError4({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url: url2,\n          requestBodyValues: body.values,\n          isRetryable: true\n          // retry when network error\n        });\n      }\n    }\n    throw error40;\n  }\n};\nasync function resolve2(value) {\n  if (typeof value === \"function\") {\n    value = value();\n  }\n  return Promise.resolve(value);\n}\nvar createJsonErrorResponseHandler3 = ({\n  errorSchema,\n  errorToMessage,\n  isRetryable\n}) => async ({\n  response,\n  url: url2,\n  requestBodyValues\n}) => {\n  const responseBody = await response.text();\n  const responseHeaders = extractResponseHeaders3(response);\n  if (responseBody.trim() === \"\") {\n    return {\n      responseHeaders,\n      value: new APICallError4({\n        message: response.statusText,\n        url: url2,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n  try {\n    const parsedError = parseJSON3({\n      text: responseBody,\n      schema: errorSchema\n    });\n    return {\n      responseHeaders,\n      value: new APICallError4({\n        message: errorToMessage(parsedError),\n        url: url2,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        data: parsedError,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)\n      })\n    };\n  } catch (parseError) {\n    return {\n      responseHeaders,\n      value: new APICallError4({\n        message: response.statusText,\n        url: url2,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n};\nvar createEventSourceResponseHandler3 = chunkSchema2 => async ({\n  response\n}) => {\n  const responseHeaders = extractResponseHeaders3(response);\n  if (response.body == null) {\n    throw new EmptyResponseBodyError3({});\n  }\n  return {\n    responseHeaders,\n    value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(createEventSourceParserStream()).pipeThrough(new TransformStream({\n      transform({\n        data\n      }, controller) {\n        if (data === \"[DONE]\") {\n          return;\n        }\n        controller.enqueue(safeParseJSON4({\n          text: data,\n          schema: chunkSchema2\n        }));\n      }\n    }))\n  };\n};\nvar createJsonResponseHandler3 = responseSchema2 => async ({\n  response,\n  url: url2,\n  requestBodyValues\n}) => {\n  const responseBody = await response.text();\n  const parsedResult = safeParseJSON4({\n    text: responseBody,\n    schema: responseSchema2\n  });\n  const responseHeaders = extractResponseHeaders3(response);\n  if (!parsedResult.success) {\n    throw new APICallError4({\n      message: \"Invalid JSON response\",\n      cause: parsedResult.error,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody,\n      url: url2,\n      requestBodyValues\n    });\n  }\n  return {\n    responseHeaders,\n    value: parsedResult.value,\n    rawValue: parsedResult.rawValue\n  };\n};\nvar {\n  btoa: btoa5,\n  atob: atob5\n} = globalThis;\nfunction convertBase64ToUint8Array3(base64String) {\n  const base64Url = base64String.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  const latin1string = atob5(base64Url);\n  return Uint8Array.from(latin1string, byte => byte.codePointAt(0));\n}\nfunction convertUint8ArrayToBase643(array2) {\n  let latin1string = \"\";\n  for (let i = 0; i < array2.length; i++) {\n    latin1string += String.fromCodePoint(array2[i]);\n  }\n  return btoa5(latin1string);\n}\nfunction withoutTrailingSlash3(url2) {\n  return url2 == null ? void 0 : url2.replace(/\\/$/, \"\");\n}\n\n// ../../node_modules/@ai-sdk/anthropic/dist/index.mjs\nvar anthropicErrorDataSchema = external_exports.object({\n  type: external_exports.literal(\"error\"),\n  error: external_exports.object({\n    type: external_exports.string(),\n    message: external_exports.string()\n  })\n});\nvar anthropicFailedResponseHandler = createJsonErrorResponseHandler3({\n  errorSchema: anthropicErrorDataSchema,\n  errorToMessage: data => data.error.message\n});\nfunction prepareTools(mode) {\n  var _a20;\n  const tools = ((_a20 = mode.tools) == null ? void 0 : _a20.length) ? mode.tools : void 0;\n  const toolWarnings = [];\n  const betas = /* @__PURE__ */new Set();\n  if (tools == null) {\n    return {\n      tools: void 0,\n      tool_choice: void 0,\n      toolWarnings,\n      betas\n    };\n  }\n  const anthropicTools2 = [];\n  for (const tool2 of tools) {\n    switch (tool2.type) {\n      case \"function\":\n        anthropicTools2.push({\n          name: tool2.name,\n          description: tool2.description,\n          input_schema: tool2.parameters\n        });\n        break;\n      case \"provider-defined\":\n        switch (tool2.id) {\n          case \"anthropic.computer_20250124\":\n            betas.add(\"computer-use-2025-01-24\");\n            anthropicTools2.push({\n              name: tool2.name,\n              type: \"computer_20250124\",\n              display_width_px: tool2.args.displayWidthPx,\n              display_height_px: tool2.args.displayHeightPx,\n              display_number: tool2.args.displayNumber\n            });\n            break;\n          case \"anthropic.computer_20241022\":\n            betas.add(\"computer-use-2024-10-22\");\n            anthropicTools2.push({\n              name: tool2.name,\n              type: \"computer_20241022\",\n              display_width_px: tool2.args.displayWidthPx,\n              display_height_px: tool2.args.displayHeightPx,\n              display_number: tool2.args.displayNumber\n            });\n            break;\n          case \"anthropic.text_editor_20250124\":\n            betas.add(\"computer-use-2025-01-24\");\n            anthropicTools2.push({\n              name: tool2.name,\n              type: \"text_editor_20250124\"\n            });\n            break;\n          case \"anthropic.text_editor_20241022\":\n            betas.add(\"computer-use-2024-10-22\");\n            anthropicTools2.push({\n              name: tool2.name,\n              type: \"text_editor_20241022\"\n            });\n            break;\n          case \"anthropic.bash_20250124\":\n            betas.add(\"computer-use-2025-01-24\");\n            anthropicTools2.push({\n              name: tool2.name,\n              type: \"bash_20250124\"\n            });\n            break;\n          case \"anthropic.bash_20241022\":\n            betas.add(\"computer-use-2024-10-22\");\n            anthropicTools2.push({\n              name: tool2.name,\n              type: \"bash_20241022\"\n            });\n            break;\n          default:\n            toolWarnings.push({\n              type: \"unsupported-tool\",\n              tool: tool2\n            });\n            break;\n        }\n        break;\n      default:\n        toolWarnings.push({\n          type: \"unsupported-tool\",\n          tool: tool2\n        });\n        break;\n    }\n  }\n  const toolChoice = mode.toolChoice;\n  if (toolChoice == null) {\n    return {\n      tools: anthropicTools2,\n      tool_choice: void 0,\n      toolWarnings,\n      betas\n    };\n  }\n  const type = toolChoice.type;\n  switch (type) {\n    case \"auto\":\n      return {\n        tools: anthropicTools2,\n        tool_choice: {\n          type: \"auto\"\n        },\n        toolWarnings,\n        betas\n      };\n    case \"required\":\n      return {\n        tools: anthropicTools2,\n        tool_choice: {\n          type: \"any\"\n        },\n        toolWarnings,\n        betas\n      };\n    case \"none\":\n      return {\n        tools: void 0,\n        tool_choice: void 0,\n        toolWarnings,\n        betas\n      };\n    case \"tool\":\n      return {\n        tools: anthropicTools2,\n        tool_choice: {\n          type: \"tool\",\n          name: toolChoice.toolName\n        },\n        toolWarnings,\n        betas\n      };\n    default:\n      {\n        const _exhaustiveCheck = type;\n        throw new UnsupportedFunctionalityError3({\n          functionality: `Unsupported tool choice type: ${_exhaustiveCheck}`\n        });\n      }\n  }\n}\nfunction convertToAnthropicMessagesPrompt({\n  prompt,\n  sendReasoning,\n  warnings\n}) {\n  var _a20, _b8, _c, _d;\n  const betas = /* @__PURE__ */new Set();\n  const blocks = groupIntoBlocks(prompt);\n  let system = void 0;\n  const messages = [];\n  function getCacheControl(providerMetadata) {\n    var _a27;\n    const anthropic2 = providerMetadata == null ? void 0 : providerMetadata.anthropic;\n    const cacheControlValue = (_a27 = anthropic2 == null ? void 0 : anthropic2.cacheControl) != null ? _a27 : anthropic2 == null ? void 0 : anthropic2.cache_control;\n    return cacheControlValue;\n  }\n  for (let i = 0; i < blocks.length; i++) {\n    const block = blocks[i];\n    const isLastBlock = i === blocks.length - 1;\n    const type = block.type;\n    switch (type) {\n      case \"system\":\n        {\n          if (system != null) {\n            throw new UnsupportedFunctionalityError3({\n              functionality: \"Multiple system messages that are separated by user/assistant messages\"\n            });\n          }\n          system = block.messages.map(({\n            content,\n            providerMetadata\n          }) => ({\n            type: \"text\",\n            text: content,\n            cache_control: getCacheControl(providerMetadata)\n          }));\n          break;\n        }\n      case \"user\":\n        {\n          const anthropicContent = [];\n          for (const message of block.messages) {\n            const {\n              role,\n              content\n            } = message;\n            switch (role) {\n              case \"user\":\n                {\n                  for (let j = 0; j < content.length; j++) {\n                    const part = content[j];\n                    const isLastPart = j === content.length - 1;\n                    const cacheControl = (_a20 = getCacheControl(part.providerMetadata)) != null ? _a20 : isLastPart ? getCacheControl(message.providerMetadata) : void 0;\n                    switch (part.type) {\n                      case \"text\":\n                        {\n                          anthropicContent.push({\n                            type: \"text\",\n                            text: part.text,\n                            cache_control: cacheControl\n                          });\n                          break;\n                        }\n                      case \"image\":\n                        {\n                          anthropicContent.push({\n                            type: \"image\",\n                            source: part.image instanceof URL ? {\n                              type: \"url\",\n                              url: part.image.toString()\n                            } : {\n                              type: \"base64\",\n                              media_type: (_b8 = part.mimeType) != null ? _b8 : \"image/jpeg\",\n                              data: convertUint8ArrayToBase643(part.image)\n                            },\n                            cache_control: cacheControl\n                          });\n                          break;\n                        }\n                      case \"file\":\n                        {\n                          if (part.mimeType !== \"application/pdf\") {\n                            throw new UnsupportedFunctionalityError3({\n                              functionality: \"Non-PDF files in user messages\"\n                            });\n                          }\n                          betas.add(\"pdfs-2024-09-25\");\n                          anthropicContent.push({\n                            type: \"document\",\n                            source: part.data instanceof URL ? {\n                              type: \"url\",\n                              url: part.data.toString()\n                            } : {\n                              type: \"base64\",\n                              media_type: \"application/pdf\",\n                              data: part.data\n                            },\n                            cache_control: cacheControl\n                          });\n                          break;\n                        }\n                    }\n                  }\n                  break;\n                }\n              case \"tool\":\n                {\n                  for (let i2 = 0; i2 < content.length; i2++) {\n                    const part = content[i2];\n                    const isLastPart = i2 === content.length - 1;\n                    const cacheControl = (_c = getCacheControl(part.providerMetadata)) != null ? _c : isLastPart ? getCacheControl(message.providerMetadata) : void 0;\n                    const toolResultContent = part.content != null ? part.content.map(part2 => {\n                      var _a27;\n                      switch (part2.type) {\n                        case \"text\":\n                          return {\n                            type: \"text\",\n                            text: part2.text,\n                            cache_control: void 0\n                          };\n                        case \"image\":\n                          return {\n                            type: \"image\",\n                            source: {\n                              type: \"base64\",\n                              media_type: (_a27 = part2.mimeType) != null ? _a27 : \"image/jpeg\",\n                              data: part2.data\n                            },\n                            cache_control: void 0\n                          };\n                      }\n                    }) : JSON.stringify(part.result);\n                    anthropicContent.push({\n                      type: \"tool_result\",\n                      tool_use_id: part.toolCallId,\n                      content: toolResultContent,\n                      is_error: part.isError,\n                      cache_control: cacheControl\n                    });\n                  }\n                  break;\n                }\n              default:\n                {\n                  const _exhaustiveCheck = role;\n                  throw new Error(`Unsupported role: ${_exhaustiveCheck}`);\n                }\n            }\n          }\n          messages.push({\n            role: \"user\",\n            content: anthropicContent\n          });\n          break;\n        }\n      case \"assistant\":\n        {\n          const anthropicContent = [];\n          for (let j = 0; j < block.messages.length; j++) {\n            const message = block.messages[j];\n            const isLastMessage = j === block.messages.length - 1;\n            const {\n              content\n            } = message;\n            for (let k = 0; k < content.length; k++) {\n              const part = content[k];\n              const isLastContentPart = k === content.length - 1;\n              const cacheControl = (_d = getCacheControl(part.providerMetadata)) != null ? _d : isLastContentPart ? getCacheControl(message.providerMetadata) : void 0;\n              switch (part.type) {\n                case \"text\":\n                  {\n                    anthropicContent.push({\n                      type: \"text\",\n                      text:\n                      // trim the last text part if it's the last message in the block\n                      // because Anthropic does not allow trailing whitespace\n                      // in pre-filled assistant responses\n                      isLastBlock && isLastMessage && isLastContentPart ? part.text.trim() : part.text,\n                      cache_control: cacheControl\n                    });\n                    break;\n                  }\n                case \"reasoning\":\n                  {\n                    if (sendReasoning) {\n                      anthropicContent.push({\n                        type: \"thinking\",\n                        thinking: part.text,\n                        signature: part.signature,\n                        cache_control: cacheControl\n                      });\n                    } else {\n                      warnings.push({\n                        type: \"other\",\n                        message: \"sending reasoning content is disabled for this model\"\n                      });\n                    }\n                    break;\n                  }\n                case \"redacted-reasoning\":\n                  {\n                    anthropicContent.push({\n                      type: \"redacted_thinking\",\n                      data: part.data,\n                      cache_control: cacheControl\n                    });\n                    break;\n                  }\n                case \"tool-call\":\n                  {\n                    anthropicContent.push({\n                      type: \"tool_use\",\n                      id: part.toolCallId,\n                      name: part.toolName,\n                      input: part.args,\n                      cache_control: cacheControl\n                    });\n                    break;\n                  }\n              }\n            }\n          }\n          messages.push({\n            role: \"assistant\",\n            content: anthropicContent\n          });\n          break;\n        }\n      default:\n        {\n          const _exhaustiveCheck = type;\n          throw new Error(`Unsupported type: ${_exhaustiveCheck}`);\n        }\n    }\n  }\n  return {\n    prompt: {\n      system,\n      messages\n    },\n    betas\n  };\n}\nfunction groupIntoBlocks(prompt) {\n  const blocks = [];\n  let currentBlock = void 0;\n  for (const message of prompt) {\n    const {\n      role\n    } = message;\n    switch (role) {\n      case \"system\":\n        {\n          if ((currentBlock == null ? void 0 : currentBlock.type) !== \"system\") {\n            currentBlock = {\n              type: \"system\",\n              messages: []\n            };\n            blocks.push(currentBlock);\n          }\n          currentBlock.messages.push(message);\n          break;\n        }\n      case \"assistant\":\n        {\n          if ((currentBlock == null ? void 0 : currentBlock.type) !== \"assistant\") {\n            currentBlock = {\n              type: \"assistant\",\n              messages: []\n            };\n            blocks.push(currentBlock);\n          }\n          currentBlock.messages.push(message);\n          break;\n        }\n      case \"user\":\n        {\n          if ((currentBlock == null ? void 0 : currentBlock.type) !== \"user\") {\n            currentBlock = {\n              type: \"user\",\n              messages: []\n            };\n            blocks.push(currentBlock);\n          }\n          currentBlock.messages.push(message);\n          break;\n        }\n      case \"tool\":\n        {\n          if ((currentBlock == null ? void 0 : currentBlock.type) !== \"user\") {\n            currentBlock = {\n              type: \"user\",\n              messages: []\n            };\n            blocks.push(currentBlock);\n          }\n          currentBlock.messages.push(message);\n          break;\n        }\n      default:\n        {\n          const _exhaustiveCheck = role;\n          throw new Error(`Unsupported role: ${_exhaustiveCheck}`);\n        }\n    }\n  }\n  return blocks;\n}\nfunction mapAnthropicStopReason(finishReason) {\n  switch (finishReason) {\n    case \"end_turn\":\n    case \"stop_sequence\":\n      return \"stop\";\n    case \"tool_use\":\n      return \"tool-calls\";\n    case \"max_tokens\":\n      return \"length\";\n    default:\n      return \"unknown\";\n  }\n}\nvar AnthropicMessagesLanguageModel = class {\n  constructor(modelId, settings, config2) {\n    this.specificationVersion = \"v1\";\n    this.defaultObjectGenerationMode = \"tool\";\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config2;\n  }\n  supportsUrl(url2) {\n    return url2.protocol === \"https:\";\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  get supportsImageUrls() {\n    return this.config.supportsImageUrls;\n  }\n  async getArgs({\n    mode,\n    prompt,\n    maxTokens = 4096,\n    // 4096: max model output tokens TODO update default in v5\n    temperature,\n    topP,\n    topK,\n    frequencyPenalty,\n    presencePenalty,\n    stopSequences,\n    responseFormat,\n    seed,\n    providerMetadata: providerOptions\n  }) {\n    var _a20, _b8, _c;\n    const type = mode.type;\n    const warnings = [];\n    if (frequencyPenalty != null) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"frequencyPenalty\"\n      });\n    }\n    if (presencePenalty != null) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"presencePenalty\"\n      });\n    }\n    if (seed != null) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"seed\"\n      });\n    }\n    if (responseFormat != null && responseFormat.type !== \"text\") {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"responseFormat\",\n        details: \"JSON response format is not supported.\"\n      });\n    }\n    const {\n      prompt: messagesPrompt,\n      betas: messagesBetas\n    } = convertToAnthropicMessagesPrompt({\n      prompt,\n      sendReasoning: (_a20 = this.settings.sendReasoning) != null ? _a20 : true,\n      warnings\n    });\n    const anthropicOptions = parseProviderOptions2({\n      provider: \"anthropic\",\n      providerOptions,\n      schema: anthropicProviderOptionsSchema\n    });\n    const isThinking = ((_b8 = anthropicOptions == null ? void 0 : anthropicOptions.thinking) == null ? void 0 : _b8.type) === \"enabled\";\n    const thinkingBudget = (_c = anthropicOptions == null ? void 0 : anthropicOptions.thinking) == null ? void 0 : _c.budgetTokens;\n    const baseArgs = {\n      // model id:\n      model: this.modelId,\n      // standardized settings:\n      max_tokens: maxTokens,\n      temperature,\n      top_k: topK,\n      top_p: topP,\n      stop_sequences: stopSequences,\n      // provider specific settings:\n      ...(isThinking && {\n        thinking: {\n          type: \"enabled\",\n          budget_tokens: thinkingBudget\n        }\n      }),\n      // prompt:\n      system: messagesPrompt.system,\n      messages: messagesPrompt.messages\n    };\n    if (isThinking) {\n      if (thinkingBudget == null) {\n        throw new UnsupportedFunctionalityError3({\n          functionality: \"thinking requires a budget\"\n        });\n      }\n      if (baseArgs.temperature != null) {\n        baseArgs.temperature = void 0;\n        warnings.push({\n          type: \"unsupported-setting\",\n          setting: \"temperature\",\n          details: \"temperature is not supported when thinking is enabled\"\n        });\n      }\n      if (topK != null) {\n        baseArgs.top_k = void 0;\n        warnings.push({\n          type: \"unsupported-setting\",\n          setting: \"topK\",\n          details: \"topK is not supported when thinking is enabled\"\n        });\n      }\n      if (topP != null) {\n        baseArgs.top_p = void 0;\n        warnings.push({\n          type: \"unsupported-setting\",\n          setting: \"topP\",\n          details: \"topP is not supported when thinking is enabled\"\n        });\n      }\n      baseArgs.max_tokens = maxTokens + thinkingBudget;\n    }\n    switch (type) {\n      case \"regular\":\n        {\n          const {\n            tools,\n            tool_choice,\n            toolWarnings,\n            betas: toolsBetas\n          } = prepareTools(mode);\n          return {\n            args: {\n              ...baseArgs,\n              tools,\n              tool_choice\n            },\n            warnings: [...warnings, ...toolWarnings],\n            betas: /* @__PURE__ */new Set([...messagesBetas, ...toolsBetas])\n          };\n        }\n      case \"object-json\":\n        {\n          throw new UnsupportedFunctionalityError3({\n            functionality: \"json-mode object generation\"\n          });\n        }\n      case \"object-tool\":\n        {\n          const {\n            name: name19,\n            description,\n            parameters\n          } = mode.tool;\n          return {\n            args: {\n              ...baseArgs,\n              tools: [{\n                name: name19,\n                description,\n                input_schema: parameters\n              }],\n              tool_choice: {\n                type: \"tool\",\n                name: name19\n              }\n            },\n            warnings,\n            betas: messagesBetas\n          };\n        }\n      default:\n        {\n          const _exhaustiveCheck = type;\n          throw new Error(`Unsupported type: ${_exhaustiveCheck}`);\n        }\n    }\n  }\n  async getHeaders({\n    betas,\n    headers\n  }) {\n    return combineHeaders3(await resolve2(this.config.headers), betas.size > 0 ? {\n      \"anthropic-beta\": Array.from(betas).join(\",\")\n    } : {}, headers);\n  }\n  buildRequestUrl(isStreaming) {\n    var _a20, _b8, _c;\n    return (_c = (_b8 = (_a20 = this.config).buildRequestUrl) == null ? void 0 : _b8.call(_a20, this.config.baseURL, isStreaming)) != null ? _c : `${this.config.baseURL}/messages`;\n  }\n  transformRequestBody(args) {\n    var _a20, _b8, _c;\n    return (_c = (_b8 = (_a20 = this.config).transformRequestBody) == null ? void 0 : _b8.call(_a20, args)) != null ? _c : args;\n  }\n  async doGenerate(options) {\n    var _a20, _b8, _c, _d;\n    const {\n      args,\n      warnings,\n      betas\n    } = await this.getArgs(options);\n    const {\n      responseHeaders,\n      value: response,\n      rawValue: rawResponse\n    } = await postJsonToApi3({\n      url: this.buildRequestUrl(false),\n      headers: await this.getHeaders({\n        betas,\n        headers: options.headers\n      }),\n      body: this.transformRequestBody(args),\n      failedResponseHandler: anthropicFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler3(anthropicMessagesResponseSchema),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    const {\n      messages: rawPrompt,\n      ...rawSettings\n    } = args;\n    let text2 = \"\";\n    for (const content of response.content) {\n      if (content.type === \"text\") {\n        text2 += content.text;\n      }\n    }\n    let toolCalls = void 0;\n    if (response.content.some(content => content.type === \"tool_use\")) {\n      toolCalls = [];\n      for (const content of response.content) {\n        if (content.type === \"tool_use\") {\n          toolCalls.push({\n            toolCallType: \"function\",\n            toolCallId: content.id,\n            toolName: content.name,\n            args: JSON.stringify(content.input)\n          });\n        }\n      }\n    }\n    const reasoning = response.content.filter(content => content.type === \"redacted_thinking\" || content.type === \"thinking\").map(content => content.type === \"thinking\" ? {\n      type: \"text\",\n      text: content.thinking,\n      signature: content.signature\n    } : {\n      type: \"redacted\",\n      data: content.data\n    });\n    return {\n      text: text2,\n      reasoning: reasoning.length > 0 ? reasoning : void 0,\n      toolCalls,\n      finishReason: mapAnthropicStopReason(response.stop_reason),\n      usage: {\n        promptTokens: response.usage.input_tokens,\n        completionTokens: response.usage.output_tokens\n      },\n      rawCall: {\n        rawPrompt,\n        rawSettings\n      },\n      rawResponse: {\n        headers: responseHeaders,\n        body: rawResponse\n      },\n      response: {\n        id: (_a20 = response.id) != null ? _a20 : void 0,\n        modelId: (_b8 = response.model) != null ? _b8 : void 0\n      },\n      warnings,\n      providerMetadata: {\n        anthropic: {\n          cacheCreationInputTokens: (_c = response.usage.cache_creation_input_tokens) != null ? _c : null,\n          cacheReadInputTokens: (_d = response.usage.cache_read_input_tokens) != null ? _d : null\n        }\n      },\n      request: {\n        body: JSON.stringify(args)\n      }\n    };\n  }\n  async doStream(options) {\n    const {\n      args,\n      warnings,\n      betas\n    } = await this.getArgs(options);\n    const body = {\n      ...args,\n      stream: true\n    };\n    const {\n      responseHeaders,\n      value: response\n    } = await postJsonToApi3({\n      url: this.buildRequestUrl(true),\n      headers: await this.getHeaders({\n        betas,\n        headers: options.headers\n      }),\n      body: this.transformRequestBody(body),\n      failedResponseHandler: anthropicFailedResponseHandler,\n      successfulResponseHandler: createEventSourceResponseHandler3(anthropicMessagesChunkSchema),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    const {\n      messages: rawPrompt,\n      ...rawSettings\n    } = args;\n    let finishReason = \"unknown\";\n    const usage = {\n      promptTokens: Number.NaN,\n      completionTokens: Number.NaN\n    };\n    const toolCallContentBlocks = {};\n    let providerMetadata = void 0;\n    let blockType = void 0;\n    return {\n      stream: response.pipeThrough(new TransformStream({\n        transform(chunk, controller) {\n          var _a20, _b8, _c, _d;\n          if (!chunk.success) {\n            controller.enqueue({\n              type: \"error\",\n              error: chunk.error\n            });\n            return;\n          }\n          const value = chunk.value;\n          switch (value.type) {\n            case \"ping\":\n              {\n                return;\n              }\n            case \"content_block_start\":\n              {\n                const contentBlockType = value.content_block.type;\n                blockType = contentBlockType;\n                switch (contentBlockType) {\n                  case \"text\":\n                  case \"thinking\":\n                    {\n                      return;\n                    }\n                  case \"redacted_thinking\":\n                    {\n                      controller.enqueue({\n                        type: \"redacted-reasoning\",\n                        data: value.content_block.data\n                      });\n                      return;\n                    }\n                  case \"tool_use\":\n                    {\n                      toolCallContentBlocks[value.index] = {\n                        toolCallId: value.content_block.id,\n                        toolName: value.content_block.name,\n                        jsonText: \"\"\n                      };\n                      return;\n                    }\n                  default:\n                    {\n                      const _exhaustiveCheck = contentBlockType;\n                      throw new Error(`Unsupported content block type: ${_exhaustiveCheck}`);\n                    }\n                }\n              }\n            case \"content_block_stop\":\n              {\n                if (toolCallContentBlocks[value.index] != null) {\n                  const contentBlock = toolCallContentBlocks[value.index];\n                  controller.enqueue({\n                    type: \"tool-call\",\n                    toolCallType: \"function\",\n                    toolCallId: contentBlock.toolCallId,\n                    toolName: contentBlock.toolName,\n                    args: contentBlock.jsonText\n                  });\n                  delete toolCallContentBlocks[value.index];\n                }\n                blockType = void 0;\n                return;\n              }\n            case \"content_block_delta\":\n              {\n                const deltaType = value.delta.type;\n                switch (deltaType) {\n                  case \"text_delta\":\n                    {\n                      controller.enqueue({\n                        type: \"text-delta\",\n                        textDelta: value.delta.text\n                      });\n                      return;\n                    }\n                  case \"thinking_delta\":\n                    {\n                      controller.enqueue({\n                        type: \"reasoning\",\n                        textDelta: value.delta.thinking\n                      });\n                      return;\n                    }\n                  case \"signature_delta\":\n                    {\n                      if (blockType === \"thinking\") {\n                        controller.enqueue({\n                          type: \"reasoning-signature\",\n                          signature: value.delta.signature\n                        });\n                      }\n                      return;\n                    }\n                  case \"input_json_delta\":\n                    {\n                      const contentBlock = toolCallContentBlocks[value.index];\n                      controller.enqueue({\n                        type: \"tool-call-delta\",\n                        toolCallType: \"function\",\n                        toolCallId: contentBlock.toolCallId,\n                        toolName: contentBlock.toolName,\n                        argsTextDelta: value.delta.partial_json\n                      });\n                      contentBlock.jsonText += value.delta.partial_json;\n                      return;\n                    }\n                  default:\n                    {\n                      const _exhaustiveCheck = deltaType;\n                      throw new Error(`Unsupported delta type: ${_exhaustiveCheck}`);\n                    }\n                }\n              }\n            case \"message_start\":\n              {\n                usage.promptTokens = value.message.usage.input_tokens;\n                usage.completionTokens = value.message.usage.output_tokens;\n                providerMetadata = {\n                  anthropic: {\n                    cacheCreationInputTokens: (_a20 = value.message.usage.cache_creation_input_tokens) != null ? _a20 : null,\n                    cacheReadInputTokens: (_b8 = value.message.usage.cache_read_input_tokens) != null ? _b8 : null\n                  }\n                };\n                controller.enqueue({\n                  type: \"response-metadata\",\n                  id: (_c = value.message.id) != null ? _c : void 0,\n                  modelId: (_d = value.message.model) != null ? _d : void 0\n                });\n                return;\n              }\n            case \"message_delta\":\n              {\n                usage.completionTokens = value.usage.output_tokens;\n                finishReason = mapAnthropicStopReason(value.delta.stop_reason);\n                return;\n              }\n            case \"message_stop\":\n              {\n                controller.enqueue({\n                  type: \"finish\",\n                  finishReason,\n                  usage,\n                  providerMetadata\n                });\n                return;\n              }\n            case \"error\":\n              {\n                controller.enqueue({\n                  type: \"error\",\n                  error: value.error\n                });\n                return;\n              }\n            default:\n              {\n                const _exhaustiveCheck = value;\n                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n              }\n          }\n        }\n      })),\n      rawCall: {\n        rawPrompt,\n        rawSettings\n      },\n      rawResponse: {\n        headers: responseHeaders\n      },\n      warnings,\n      request: {\n        body: JSON.stringify(body)\n      }\n    };\n  }\n};\nvar anthropicMessagesResponseSchema = external_exports.object({\n  type: external_exports.literal(\"message\"),\n  id: external_exports.string().nullish(),\n  model: external_exports.string().nullish(),\n  content: external_exports.array(external_exports.discriminatedUnion(\"type\", [external_exports.object({\n    type: external_exports.literal(\"text\"),\n    text: external_exports.string()\n  }), external_exports.object({\n    type: external_exports.literal(\"thinking\"),\n    thinking: external_exports.string(),\n    signature: external_exports.string()\n  }), external_exports.object({\n    type: external_exports.literal(\"redacted_thinking\"),\n    data: external_exports.string()\n  }), external_exports.object({\n    type: external_exports.literal(\"tool_use\"),\n    id: external_exports.string(),\n    name: external_exports.string(),\n    input: external_exports.unknown()\n  })])),\n  stop_reason: external_exports.string().nullish(),\n  usage: external_exports.object({\n    input_tokens: external_exports.number(),\n    output_tokens: external_exports.number(),\n    cache_creation_input_tokens: external_exports.number().nullish(),\n    cache_read_input_tokens: external_exports.number().nullish()\n  })\n});\nvar anthropicMessagesChunkSchema = external_exports.discriminatedUnion(\"type\", [external_exports.object({\n  type: external_exports.literal(\"message_start\"),\n  message: external_exports.object({\n    id: external_exports.string().nullish(),\n    model: external_exports.string().nullish(),\n    usage: external_exports.object({\n      input_tokens: external_exports.number(),\n      output_tokens: external_exports.number(),\n      cache_creation_input_tokens: external_exports.number().nullish(),\n      cache_read_input_tokens: external_exports.number().nullish()\n    })\n  })\n}), external_exports.object({\n  type: external_exports.literal(\"content_block_start\"),\n  index: external_exports.number(),\n  content_block: external_exports.discriminatedUnion(\"type\", [external_exports.object({\n    type: external_exports.literal(\"text\"),\n    text: external_exports.string()\n  }), external_exports.object({\n    type: external_exports.literal(\"thinking\"),\n    thinking: external_exports.string()\n  }), external_exports.object({\n    type: external_exports.literal(\"tool_use\"),\n    id: external_exports.string(),\n    name: external_exports.string()\n  }), external_exports.object({\n    type: external_exports.literal(\"redacted_thinking\"),\n    data: external_exports.string()\n  })])\n}), external_exports.object({\n  type: external_exports.literal(\"content_block_delta\"),\n  index: external_exports.number(),\n  delta: external_exports.discriminatedUnion(\"type\", [external_exports.object({\n    type: external_exports.literal(\"input_json_delta\"),\n    partial_json: external_exports.string()\n  }), external_exports.object({\n    type: external_exports.literal(\"text_delta\"),\n    text: external_exports.string()\n  }), external_exports.object({\n    type: external_exports.literal(\"thinking_delta\"),\n    thinking: external_exports.string()\n  }), external_exports.object({\n    type: external_exports.literal(\"signature_delta\"),\n    signature: external_exports.string()\n  })])\n}), external_exports.object({\n  type: external_exports.literal(\"content_block_stop\"),\n  index: external_exports.number()\n}), external_exports.object({\n  type: external_exports.literal(\"error\"),\n  error: external_exports.object({\n    type: external_exports.string(),\n    message: external_exports.string()\n  })\n}), external_exports.object({\n  type: external_exports.literal(\"message_delta\"),\n  delta: external_exports.object({\n    stop_reason: external_exports.string().nullish()\n  }),\n  usage: external_exports.object({\n    output_tokens: external_exports.number()\n  })\n}), external_exports.object({\n  type: external_exports.literal(\"message_stop\")\n}), external_exports.object({\n  type: external_exports.literal(\"ping\")\n})]);\nvar anthropicProviderOptionsSchema = external_exports.object({\n  thinking: external_exports.object({\n    type: external_exports.union([external_exports.literal(\"enabled\"), external_exports.literal(\"disabled\")]),\n    budgetTokens: external_exports.number().optional()\n  }).optional()\n});\nvar Bash20241022Parameters = external_exports.object({\n  command: external_exports.string(),\n  restart: external_exports.boolean().optional()\n});\nfunction bashTool_20241022(options = {}) {\n  return {\n    type: \"provider-defined\",\n    id: \"anthropic.bash_20241022\",\n    args: {},\n    parameters: Bash20241022Parameters,\n    execute: options.execute,\n    experimental_toToolResultContent: options.experimental_toToolResultContent\n  };\n}\nvar Bash20250124Parameters = external_exports.object({\n  command: external_exports.string(),\n  restart: external_exports.boolean().optional()\n});\nfunction bashTool_20250124(options = {}) {\n  return {\n    type: \"provider-defined\",\n    id: \"anthropic.bash_20250124\",\n    args: {},\n    parameters: Bash20250124Parameters,\n    execute: options.execute,\n    experimental_toToolResultContent: options.experimental_toToolResultContent\n  };\n}\nvar TextEditor20241022Parameters = external_exports.object({\n  command: external_exports.enum([\"view\", \"create\", \"str_replace\", \"insert\", \"undo_edit\"]),\n  path: external_exports.string(),\n  file_text: external_exports.string().optional(),\n  insert_line: external_exports.number().int().optional(),\n  new_str: external_exports.string().optional(),\n  old_str: external_exports.string().optional(),\n  view_range: external_exports.array(external_exports.number().int()).optional()\n});\nfunction textEditorTool_20241022(options = {}) {\n  return {\n    type: \"provider-defined\",\n    id: \"anthropic.text_editor_20241022\",\n    args: {},\n    parameters: TextEditor20241022Parameters,\n    execute: options.execute,\n    experimental_toToolResultContent: options.experimental_toToolResultContent\n  };\n}\nvar TextEditor20250124Parameters = external_exports.object({\n  command: external_exports.enum([\"view\", \"create\", \"str_replace\", \"insert\", \"undo_edit\"]),\n  path: external_exports.string(),\n  file_text: external_exports.string().optional(),\n  insert_line: external_exports.number().int().optional(),\n  new_str: external_exports.string().optional(),\n  old_str: external_exports.string().optional(),\n  view_range: external_exports.array(external_exports.number().int()).optional()\n});\nfunction textEditorTool_20250124(options = {}) {\n  return {\n    type: \"provider-defined\",\n    id: \"anthropic.text_editor_20250124\",\n    args: {},\n    parameters: TextEditor20250124Parameters,\n    execute: options.execute,\n    experimental_toToolResultContent: options.experimental_toToolResultContent\n  };\n}\nvar Computer20241022Parameters = external_exports.object({\n  action: external_exports.enum([\"key\", \"type\", \"mouse_move\", \"left_click\", \"left_click_drag\", \"right_click\", \"middle_click\", \"double_click\", \"screenshot\", \"cursor_position\"]),\n  coordinate: external_exports.array(external_exports.number().int()).optional(),\n  text: external_exports.string().optional()\n});\nfunction computerTool_20241022(options) {\n  return {\n    type: \"provider-defined\",\n    id: \"anthropic.computer_20241022\",\n    args: {\n      displayWidthPx: options.displayWidthPx,\n      displayHeightPx: options.displayHeightPx,\n      displayNumber: options.displayNumber\n    },\n    parameters: Computer20241022Parameters,\n    execute: options.execute,\n    experimental_toToolResultContent: options.experimental_toToolResultContent\n  };\n}\nvar Computer20250124Parameters = external_exports.object({\n  action: external_exports.enum([\"key\", \"hold_key\", \"type\", \"cursor_position\", \"mouse_move\", \"left_mouse_down\", \"left_mouse_up\", \"left_click\", \"left_click_drag\", \"right_click\", \"middle_click\", \"double_click\", \"triple_click\", \"scroll\", \"wait\", \"screenshot\"]),\n  coordinate: external_exports.tuple([external_exports.number().int(), external_exports.number().int()]).optional(),\n  duration: external_exports.number().optional(),\n  scroll_amount: external_exports.number().optional(),\n  scroll_direction: external_exports.enum([\"up\", \"down\", \"left\", \"right\"]).optional(),\n  start_coordinate: external_exports.tuple([external_exports.number().int(), external_exports.number().int()]).optional(),\n  text: external_exports.string().optional()\n});\nfunction computerTool_20250124(options) {\n  return {\n    type: \"provider-defined\",\n    id: \"anthropic.computer_20250124\",\n    args: {\n      displayWidthPx: options.displayWidthPx,\n      displayHeightPx: options.displayHeightPx,\n      displayNumber: options.displayNumber\n    },\n    parameters: Computer20250124Parameters,\n    execute: options.execute,\n    experimental_toToolResultContent: options.experimental_toToolResultContent\n  };\n}\nvar anthropicTools = {\n  bash_20241022: bashTool_20241022,\n  bash_20250124: bashTool_20250124,\n  textEditor_20241022: textEditorTool_20241022,\n  textEditor_20250124: textEditorTool_20250124,\n  computer_20241022: computerTool_20241022,\n  computer_20250124: computerTool_20250124\n};\nfunction createAnthropic(options = {}) {\n  var _a20;\n  const baseURL = (_a20 = withoutTrailingSlash3(options.baseURL)) != null ? _a20 : \"https://api.anthropic.com/v1\";\n  const getHeaders = () => ({\n    \"anthropic-version\": \"2023-06-01\",\n    \"x-api-key\": loadApiKey2({\n      apiKey: options.apiKey,\n      environmentVariableName: \"ANTHROPIC_API_KEY\",\n      description: \"Anthropic\"\n    }),\n    ...options.headers\n  });\n  const createChatModel = (modelId, settings = {}) => new AnthropicMessagesLanguageModel(modelId, settings, {\n    provider: \"anthropic.messages\",\n    baseURL,\n    headers: getHeaders,\n    fetch: options.fetch,\n    supportsImageUrls: true\n  });\n  const provider = function (modelId, settings) {\n    if (new.target) {\n      throw new Error(\"The Anthropic model function cannot be called with the new keyword.\");\n    }\n    return createChatModel(modelId, settings);\n  };\n  provider.languageModel = createChatModel;\n  provider.chat = createChatModel;\n  provider.messages = createChatModel;\n  provider.textEmbeddingModel = modelId => {\n    throw new NoSuchModelError2({\n      modelId,\n      modelType: \"textEmbeddingModel\"\n    });\n  };\n  provider.tools = anthropicTools;\n  return provider;\n}\nvar anthropic = createAnthropic();\n\n// ../../node_modules/@ai-sdk/mistral/dist/index.mjs\nfunction convertToMistralChatMessages(prompt) {\n  const messages = [];\n  for (let i = 0; i < prompt.length; i++) {\n    const {\n      role,\n      content\n    } = prompt[i];\n    const isLastMessage = i === prompt.length - 1;\n    switch (role) {\n      case \"system\":\n        {\n          messages.push({\n            role: \"system\",\n            content\n          });\n          break;\n        }\n      case \"user\":\n        {\n          messages.push({\n            role: \"user\",\n            content: content.map(part => {\n              var _a20;\n              switch (part.type) {\n                case \"text\":\n                  {\n                    return {\n                      type: \"text\",\n                      text: part.text\n                    };\n                  }\n                case \"image\":\n                  {\n                    return {\n                      type: \"image_url\",\n                      image_url: part.image instanceof URL ? part.image.toString() : `data:${(_a20 = part.mimeType) != null ? _a20 : \"image/jpeg\"};base64,${convertUint8ArrayToBase643(part.image)}`\n                    };\n                  }\n                case \"file\":\n                  {\n                    if (!(part.data instanceof URL)) {\n                      throw new UnsupportedFunctionalityError3({\n                        functionality: \"File content parts in user messages\"\n                      });\n                    }\n                    switch (part.mimeType) {\n                      case \"application/pdf\":\n                        {\n                          return {\n                            type: \"document_url\",\n                            document_url: part.data.toString()\n                          };\n                        }\n                      default:\n                        {\n                          throw new UnsupportedFunctionalityError3({\n                            functionality: \"Only PDF files are supported in user messages\"\n                          });\n                        }\n                    }\n                  }\n              }\n            })\n          });\n          break;\n        }\n      case \"assistant\":\n        {\n          let text2 = \"\";\n          const toolCalls = [];\n          for (const part of content) {\n            switch (part.type) {\n              case \"text\":\n                {\n                  text2 += part.text;\n                  break;\n                }\n              case \"tool-call\":\n                {\n                  toolCalls.push({\n                    id: part.toolCallId,\n                    type: \"function\",\n                    function: {\n                      name: part.toolName,\n                      arguments: JSON.stringify(part.args)\n                    }\n                  });\n                  break;\n                }\n            }\n          }\n          messages.push({\n            role: \"assistant\",\n            content: text2,\n            prefix: isLastMessage ? true : void 0,\n            tool_calls: toolCalls.length > 0 ? toolCalls : void 0\n          });\n          break;\n        }\n      case \"tool\":\n        {\n          for (const toolResponse of content) {\n            messages.push({\n              role: \"tool\",\n              name: toolResponse.toolName,\n              content: JSON.stringify(toolResponse.result),\n              tool_call_id: toolResponse.toolCallId\n            });\n          }\n          break;\n        }\n      default:\n        {\n          const _exhaustiveCheck = role;\n          throw new Error(`Unsupported role: ${_exhaustiveCheck}`);\n        }\n    }\n  }\n  return messages;\n}\nfunction mapMistralFinishReason(finishReason) {\n  switch (finishReason) {\n    case \"stop\":\n      return \"stop\";\n    case \"length\":\n    case \"model_length\":\n      return \"length\";\n    case \"tool_calls\":\n      return \"tool-calls\";\n    default:\n      return \"unknown\";\n  }\n}\nvar mistralErrorDataSchema = external_exports.object({\n  object: external_exports.literal(\"error\"),\n  message: external_exports.string(),\n  type: external_exports.string(),\n  param: external_exports.string().nullable(),\n  code: external_exports.string().nullable()\n});\nvar mistralFailedResponseHandler = createJsonErrorResponseHandler3({\n  errorSchema: mistralErrorDataSchema,\n  errorToMessage: data => data.message\n});\nfunction getResponseMetadata3({\n  id,\n  model,\n  created\n}) {\n  return {\n    id: id != null ? id : void 0,\n    modelId: model != null ? model : void 0,\n    timestamp: created != null ? new Date(created * 1e3) : void 0\n  };\n}\nfunction prepareTools2(mode) {\n  var _a20;\n  const tools = ((_a20 = mode.tools) == null ? void 0 : _a20.length) ? mode.tools : void 0;\n  const toolWarnings = [];\n  if (tools == null) {\n    return {\n      tools: void 0,\n      tool_choice: void 0,\n      toolWarnings\n    };\n  }\n  const mistralTools = [];\n  for (const tool2 of tools) {\n    if (tool2.type === \"provider-defined\") {\n      toolWarnings.push({\n        type: \"unsupported-tool\",\n        tool: tool2\n      });\n    } else {\n      mistralTools.push({\n        type: \"function\",\n        function: {\n          name: tool2.name,\n          description: tool2.description,\n          parameters: tool2.parameters\n        }\n      });\n    }\n  }\n  const toolChoice = mode.toolChoice;\n  if (toolChoice == null) {\n    return {\n      tools: mistralTools,\n      tool_choice: void 0,\n      toolWarnings\n    };\n  }\n  const type = toolChoice.type;\n  switch (type) {\n    case \"auto\":\n    case \"none\":\n      return {\n        tools: mistralTools,\n        tool_choice: type,\n        toolWarnings\n      };\n    case \"required\":\n      return {\n        tools: mistralTools,\n        tool_choice: \"any\",\n        toolWarnings\n      };\n    case \"tool\":\n      return {\n        tools: mistralTools.filter(tool2 => tool2.function.name === toolChoice.toolName),\n        tool_choice: \"any\",\n        toolWarnings\n      };\n    default:\n      {\n        const _exhaustiveCheck = type;\n        throw new UnsupportedFunctionalityError3({\n          functionality: `Unsupported tool choice type: ${_exhaustiveCheck}`\n        });\n      }\n  }\n}\nvar MistralChatLanguageModel = class {\n  constructor(modelId, settings, config2) {\n    this.specificationVersion = \"v1\";\n    this.defaultObjectGenerationMode = \"json\";\n    this.supportsImageUrls = false;\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config2;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  supportsUrl(url2) {\n    return url2.protocol === \"https:\";\n  }\n  getArgs({\n    mode,\n    prompt,\n    maxTokens,\n    temperature,\n    topP,\n    topK,\n    frequencyPenalty,\n    presencePenalty,\n    stopSequences,\n    responseFormat,\n    seed,\n    providerMetadata\n  }) {\n    var _a20, _b8;\n    const type = mode.type;\n    const warnings = [];\n    if (topK != null) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"topK\"\n      });\n    }\n    if (frequencyPenalty != null) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"frequencyPenalty\"\n      });\n    }\n    if (presencePenalty != null) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"presencePenalty\"\n      });\n    }\n    if (stopSequences != null) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"stopSequences\"\n      });\n    }\n    if (responseFormat != null && responseFormat.type === \"json\" && responseFormat.schema != null) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"responseFormat\",\n        details: \"JSON response format schema is not supported\"\n      });\n    }\n    const baseArgs = {\n      // model id:\n      model: this.modelId,\n      // model specific settings:\n      safe_prompt: this.settings.safePrompt,\n      // standardized settings:\n      max_tokens: maxTokens,\n      temperature,\n      top_p: topP,\n      random_seed: seed,\n      // response format:\n      response_format: (responseFormat == null ? void 0 : responseFormat.type) === \"json\" ? {\n        type: \"json_object\"\n      } : void 0,\n      // mistral-specific provider options:\n      document_image_limit: (_a20 = providerMetadata == null ? void 0 : providerMetadata.mistral) == null ? void 0 : _a20.documentImageLimit,\n      document_page_limit: (_b8 = providerMetadata == null ? void 0 : providerMetadata.mistral) == null ? void 0 : _b8.documentPageLimit,\n      // messages:\n      messages: convertToMistralChatMessages(prompt)\n    };\n    switch (type) {\n      case \"regular\":\n        {\n          const {\n            tools,\n            tool_choice,\n            toolWarnings\n          } = prepareTools2(mode);\n          return {\n            args: {\n              ...baseArgs,\n              tools,\n              tool_choice\n            },\n            warnings: [...warnings, ...toolWarnings]\n          };\n        }\n      case \"object-json\":\n        {\n          return {\n            args: {\n              ...baseArgs,\n              response_format: {\n                type: \"json_object\"\n              }\n            },\n            warnings\n          };\n        }\n      case \"object-tool\":\n        {\n          return {\n            args: {\n              ...baseArgs,\n              tool_choice: \"any\",\n              tools: [{\n                type: \"function\",\n                function: mode.tool\n              }]\n            },\n            warnings\n          };\n        }\n      default:\n        {\n          const _exhaustiveCheck = type;\n          throw new Error(`Unsupported type: ${_exhaustiveCheck}`);\n        }\n    }\n  }\n  async doGenerate(options) {\n    var _a20;\n    const {\n      args,\n      warnings\n    } = this.getArgs(options);\n    const {\n      responseHeaders,\n      value: response,\n      rawValue: rawResponse\n    } = await postJsonToApi3({\n      url: `${this.config.baseURL}/chat/completions`,\n      headers: combineHeaders3(this.config.headers(), options.headers),\n      body: args,\n      failedResponseHandler: mistralFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler3(mistralChatResponseSchema),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    const {\n      messages: rawPrompt,\n      ...rawSettings\n    } = args;\n    const choice = response.choices[0];\n    let text2 = extractTextContent2(choice.message.content);\n    const lastMessage = rawPrompt[rawPrompt.length - 1];\n    if (lastMessage.role === \"assistant\" && (text2 == null ? void 0 : text2.startsWith(lastMessage.content))) {\n      text2 = text2.slice(lastMessage.content.length);\n    }\n    return {\n      text: text2,\n      toolCalls: (_a20 = choice.message.tool_calls) == null ? void 0 : _a20.map(toolCall => ({\n        toolCallType: \"function\",\n        toolCallId: toolCall.id,\n        toolName: toolCall.function.name,\n        args: toolCall.function.arguments\n      })),\n      finishReason: mapMistralFinishReason(choice.finish_reason),\n      usage: {\n        promptTokens: response.usage.prompt_tokens,\n        completionTokens: response.usage.completion_tokens\n      },\n      rawCall: {\n        rawPrompt,\n        rawSettings\n      },\n      rawResponse: {\n        headers: responseHeaders,\n        body: rawResponse\n      },\n      request: {\n        body: JSON.stringify(args)\n      },\n      response: getResponseMetadata3(response),\n      warnings\n    };\n  }\n  async doStream(options) {\n    const {\n      args,\n      warnings\n    } = this.getArgs(options);\n    const body = {\n      ...args,\n      stream: true\n    };\n    const {\n      responseHeaders,\n      value: response\n    } = await postJsonToApi3({\n      url: `${this.config.baseURL}/chat/completions`,\n      headers: combineHeaders3(this.config.headers(), options.headers),\n      body,\n      failedResponseHandler: mistralFailedResponseHandler,\n      successfulResponseHandler: createEventSourceResponseHandler3(mistralChatChunkSchema),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    const {\n      messages: rawPrompt,\n      ...rawSettings\n    } = args;\n    let finishReason = \"unknown\";\n    let usage = {\n      promptTokens: Number.NaN,\n      completionTokens: Number.NaN\n    };\n    let chunkNumber = 0;\n    let trimLeadingSpace = false;\n    return {\n      stream: response.pipeThrough(new TransformStream({\n        transform(chunk, controller) {\n          if (!chunk.success) {\n            controller.enqueue({\n              type: \"error\",\n              error: chunk.error\n            });\n            return;\n          }\n          chunkNumber++;\n          const value = chunk.value;\n          if (chunkNumber === 1) {\n            controller.enqueue({\n              type: \"response-metadata\",\n              ...getResponseMetadata3(value)\n            });\n          }\n          if (value.usage != null) {\n            usage = {\n              promptTokens: value.usage.prompt_tokens,\n              completionTokens: value.usage.completion_tokens\n            };\n          }\n          const choice = value.choices[0];\n          if ((choice == null ? void 0 : choice.finish_reason) != null) {\n            finishReason = mapMistralFinishReason(choice.finish_reason);\n          }\n          if ((choice == null ? void 0 : choice.delta) == null) {\n            return;\n          }\n          const delta = choice.delta;\n          const textContent = extractTextContent2(delta.content);\n          if (chunkNumber <= 2) {\n            const lastMessage = rawPrompt[rawPrompt.length - 1];\n            if (lastMessage.role === \"assistant\" && textContent === lastMessage.content.trimEnd()) {\n              if (textContent.length < lastMessage.content.length) {\n                trimLeadingSpace = true;\n              }\n              return;\n            }\n          }\n          if (textContent != null) {\n            controller.enqueue({\n              type: \"text-delta\",\n              textDelta: trimLeadingSpace ? textContent.trimStart() : textContent\n            });\n            trimLeadingSpace = false;\n          }\n          if (delta.tool_calls != null) {\n            for (const toolCall of delta.tool_calls) {\n              controller.enqueue({\n                type: \"tool-call-delta\",\n                toolCallType: \"function\",\n                toolCallId: toolCall.id,\n                toolName: toolCall.function.name,\n                argsTextDelta: toolCall.function.arguments\n              });\n              controller.enqueue({\n                type: \"tool-call\",\n                toolCallType: \"function\",\n                toolCallId: toolCall.id,\n                toolName: toolCall.function.name,\n                args: toolCall.function.arguments\n              });\n            }\n          }\n        },\n        flush(controller) {\n          controller.enqueue({\n            type: \"finish\",\n            finishReason,\n            usage\n          });\n        }\n      })),\n      rawCall: {\n        rawPrompt,\n        rawSettings\n      },\n      rawResponse: {\n        headers: responseHeaders\n      },\n      request: {\n        body: JSON.stringify(body)\n      },\n      warnings\n    };\n  }\n};\nfunction extractTextContent2(content) {\n  if (typeof content === \"string\") {\n    return content;\n  }\n  if (content == null) {\n    return void 0;\n  }\n  const textContent = [];\n  for (const chunk of content) {\n    const {\n      type\n    } = chunk;\n    switch (type) {\n      case \"text\":\n        textContent.push(chunk.text);\n        break;\n      case \"image_url\":\n      case \"reference\":\n        break;\n      default:\n        {\n          const _exhaustiveCheck = type;\n          throw new Error(`Unsupported type: ${_exhaustiveCheck}`);\n        }\n    }\n  }\n  return textContent.length ? textContent.join(\"\") : void 0;\n}\nvar mistralContentSchema = external_exports.union([external_exports.string(), external_exports.array(external_exports.discriminatedUnion(\"type\", [external_exports.object({\n  type: external_exports.literal(\"text\"),\n  text: external_exports.string()\n}), external_exports.object({\n  type: external_exports.literal(\"image_url\"),\n  image_url: external_exports.union([external_exports.string(), external_exports.object({\n    url: external_exports.string(),\n    detail: external_exports.string().nullable()\n  })])\n}), external_exports.object({\n  type: external_exports.literal(\"reference\"),\n  reference_ids: external_exports.array(external_exports.number())\n})]))]).nullish();\nvar mistralChatResponseSchema = external_exports.object({\n  id: external_exports.string().nullish(),\n  created: external_exports.number().nullish(),\n  model: external_exports.string().nullish(),\n  choices: external_exports.array(external_exports.object({\n    message: external_exports.object({\n      role: external_exports.literal(\"assistant\"),\n      content: mistralContentSchema,\n      tool_calls: external_exports.array(external_exports.object({\n        id: external_exports.string(),\n        function: external_exports.object({\n          name: external_exports.string(),\n          arguments: external_exports.string()\n        })\n      })).nullish()\n    }),\n    index: external_exports.number(),\n    finish_reason: external_exports.string().nullish()\n  })),\n  object: external_exports.literal(\"chat.completion\"),\n  usage: external_exports.object({\n    prompt_tokens: external_exports.number(),\n    completion_tokens: external_exports.number()\n  })\n});\nvar mistralChatChunkSchema = external_exports.object({\n  id: external_exports.string().nullish(),\n  created: external_exports.number().nullish(),\n  model: external_exports.string().nullish(),\n  choices: external_exports.array(external_exports.object({\n    delta: external_exports.object({\n      role: external_exports.enum([\"assistant\"]).optional(),\n      content: mistralContentSchema,\n      tool_calls: external_exports.array(external_exports.object({\n        id: external_exports.string(),\n        function: external_exports.object({\n          name: external_exports.string(),\n          arguments: external_exports.string()\n        })\n      })).nullish()\n    }),\n    finish_reason: external_exports.string().nullish(),\n    index: external_exports.number()\n  })),\n  usage: external_exports.object({\n    prompt_tokens: external_exports.number(),\n    completion_tokens: external_exports.number()\n  }).nullish()\n});\nvar MistralEmbeddingModel = class {\n  constructor(modelId, settings, config2) {\n    this.specificationVersion = \"v1\";\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config2;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  get maxEmbeddingsPerCall() {\n    var _a20;\n    return (_a20 = this.settings.maxEmbeddingsPerCall) != null ? _a20 : 32;\n  }\n  get supportsParallelCalls() {\n    var _a20;\n    return (_a20 = this.settings.supportsParallelCalls) != null ? _a20 : false;\n  }\n  async doEmbed({\n    values,\n    abortSignal,\n    headers\n  }) {\n    if (values.length > this.maxEmbeddingsPerCall) {\n      throw new TooManyEmbeddingValuesForCallError2({\n        provider: this.provider,\n        modelId: this.modelId,\n        maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,\n        values\n      });\n    }\n    const {\n      responseHeaders,\n      value: response\n    } = await postJsonToApi3({\n      url: `${this.config.baseURL}/embeddings`,\n      headers: combineHeaders3(this.config.headers(), headers),\n      body: {\n        model: this.modelId,\n        input: values,\n        encoding_format: \"float\"\n      },\n      failedResponseHandler: mistralFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler3(MistralTextEmbeddingResponseSchema),\n      abortSignal,\n      fetch: this.config.fetch\n    });\n    return {\n      embeddings: response.data.map(item => item.embedding),\n      usage: response.usage ? {\n        tokens: response.usage.prompt_tokens\n      } : void 0,\n      rawResponse: {\n        headers: responseHeaders\n      }\n    };\n  }\n};\nvar MistralTextEmbeddingResponseSchema = external_exports.object({\n  data: external_exports.array(external_exports.object({\n    embedding: external_exports.array(external_exports.number())\n  })),\n  usage: external_exports.object({\n    prompt_tokens: external_exports.number()\n  }).nullish()\n});\nfunction createMistral(options = {}) {\n  var _a20;\n  const baseURL = (_a20 = withoutTrailingSlash3(options.baseURL)) != null ? _a20 : \"https://api.mistral.ai/v1\";\n  const getHeaders = () => ({\n    Authorization: `Bearer ${loadApiKey2({\n      apiKey: options.apiKey,\n      environmentVariableName: \"MISTRAL_API_KEY\",\n      description: \"Mistral\"\n    })}`,\n    ...options.headers\n  });\n  const createChatModel = (modelId, settings = {}) => new MistralChatLanguageModel(modelId, settings, {\n    provider: \"mistral.chat\",\n    baseURL,\n    headers: getHeaders,\n    fetch: options.fetch\n  });\n  const createEmbeddingModel = (modelId, settings = {}) => new MistralEmbeddingModel(modelId, settings, {\n    provider: \"mistral.embedding\",\n    baseURL,\n    headers: getHeaders,\n    fetch: options.fetch\n  });\n  const provider = function (modelId, settings) {\n    if (new.target) {\n      throw new Error(\"The Mistral model function cannot be called with the new keyword.\");\n    }\n    return createChatModel(modelId, settings);\n  };\n  provider.languageModel = createChatModel;\n  provider.chat = createChatModel;\n  provider.embedding = createEmbeddingModel;\n  provider.textEmbedding = createEmbeddingModel;\n  provider.textEmbeddingModel = createEmbeddingModel;\n  return provider;\n}\nvar mistral = createMistral();\n\n// ../../node_modules/@ai-sdk/google/dist/index.mjs\nfunction convertJSONSchemaToOpenAPISchema(jsonSchema2) {\n  if (isEmptyObjectSchema(jsonSchema2)) {\n    return void 0;\n  }\n  if (typeof jsonSchema2 === \"boolean\") {\n    return {\n      type: \"boolean\",\n      properties: {}\n    };\n  }\n  const {\n    type,\n    description,\n    required: required2,\n    properties,\n    items,\n    allOf,\n    anyOf,\n    oneOf,\n    format,\n    const: constValue,\n    minLength,\n    enum: enumValues\n  } = jsonSchema2;\n  const result = {};\n  if (description) result.description = description;\n  if (required2) result.required = required2;\n  if (format) result.format = format;\n  if (constValue !== void 0) {\n    result.enum = [constValue];\n  }\n  if (type) {\n    if (Array.isArray(type)) {\n      if (type.includes(\"null\")) {\n        result.type = type.filter(t => t !== \"null\")[0];\n        result.nullable = true;\n      } else {\n        result.type = type;\n      }\n    } else if (type === \"null\") {\n      result.type = \"null\";\n    } else {\n      result.type = type;\n    }\n  }\n  if (enumValues !== void 0) {\n    result.enum = enumValues;\n  }\n  if (properties != null) {\n    result.properties = Object.entries(properties).reduce((acc, [key, value]) => {\n      acc[key] = convertJSONSchemaToOpenAPISchema(value);\n      return acc;\n    }, {});\n  }\n  if (items) {\n    result.items = Array.isArray(items) ? items.map(convertJSONSchemaToOpenAPISchema) : convertJSONSchemaToOpenAPISchema(items);\n  }\n  if (allOf) {\n    result.allOf = allOf.map(convertJSONSchemaToOpenAPISchema);\n  }\n  if (anyOf) {\n    if (anyOf.some(schema => typeof schema === \"object\" && (schema == null ? void 0 : schema.type) === \"null\")) {\n      const nonNullSchemas = anyOf.filter(schema => !(typeof schema === \"object\" && (schema == null ? void 0 : schema.type) === \"null\"));\n      if (nonNullSchemas.length === 1) {\n        const converted = convertJSONSchemaToOpenAPISchema(nonNullSchemas[0]);\n        if (typeof converted === \"object\") {\n          result.nullable = true;\n          Object.assign(result, converted);\n        }\n      } else {\n        result.anyOf = nonNullSchemas.map(convertJSONSchemaToOpenAPISchema);\n        result.nullable = true;\n      }\n    } else {\n      result.anyOf = anyOf.map(convertJSONSchemaToOpenAPISchema);\n    }\n  }\n  if (oneOf) {\n    result.oneOf = oneOf.map(convertJSONSchemaToOpenAPISchema);\n  }\n  if (minLength !== void 0) {\n    result.minLength = minLength;\n  }\n  return result;\n}\nfunction isEmptyObjectSchema(jsonSchema2) {\n  return jsonSchema2 != null && typeof jsonSchema2 === \"object\" && jsonSchema2.type === \"object\" && (jsonSchema2.properties == null || Object.keys(jsonSchema2.properties).length === 0) && !jsonSchema2.additionalProperties;\n}\nfunction convertToGoogleGenerativeAIMessages(prompt) {\n  var _a20, _b8;\n  const systemInstructionParts = [];\n  const contents = [];\n  let systemMessagesAllowed = true;\n  for (const {\n    role,\n    content\n  } of prompt) {\n    switch (role) {\n      case \"system\":\n        {\n          if (!systemMessagesAllowed) {\n            throw new UnsupportedFunctionalityError3({\n              functionality: \"system messages are only supported at the beginning of the conversation\"\n            });\n          }\n          systemInstructionParts.push({\n            text: content\n          });\n          break;\n        }\n      case \"user\":\n        {\n          systemMessagesAllowed = false;\n          const parts = [];\n          for (const part of content) {\n            switch (part.type) {\n              case \"text\":\n                {\n                  parts.push({\n                    text: part.text\n                  });\n                  break;\n                }\n              case \"image\":\n                {\n                  parts.push(part.image instanceof URL ? {\n                    fileData: {\n                      mimeType: (_a20 = part.mimeType) != null ? _a20 : \"image/jpeg\",\n                      fileUri: part.image.toString()\n                    }\n                  } : {\n                    inlineData: {\n                      mimeType: (_b8 = part.mimeType) != null ? _b8 : \"image/jpeg\",\n                      data: convertUint8ArrayToBase643(part.image)\n                    }\n                  });\n                  break;\n                }\n              case \"file\":\n                {\n                  parts.push(part.data instanceof URL ? {\n                    fileData: {\n                      mimeType: part.mimeType,\n                      fileUri: part.data.toString()\n                    }\n                  } : {\n                    inlineData: {\n                      mimeType: part.mimeType,\n                      data: part.data\n                    }\n                  });\n                  break;\n                }\n            }\n          }\n          contents.push({\n            role: \"user\",\n            parts\n          });\n          break;\n        }\n      case \"assistant\":\n        {\n          systemMessagesAllowed = false;\n          contents.push({\n            role: \"model\",\n            parts: content.map(part => {\n              switch (part.type) {\n                case \"text\":\n                  {\n                    return part.text.length === 0 ? void 0 : {\n                      text: part.text\n                    };\n                  }\n                case \"file\":\n                  {\n                    if (part.mimeType !== \"image/png\") {\n                      throw new UnsupportedFunctionalityError3({\n                        functionality: \"Only PNG images are supported in assistant messages\"\n                      });\n                    }\n                    if (part.data instanceof URL) {\n                      throw new UnsupportedFunctionalityError3({\n                        functionality: \"File data URLs in assistant messages are not supported\"\n                      });\n                    }\n                    return {\n                      inlineData: {\n                        mimeType: part.mimeType,\n                        data: part.data\n                      }\n                    };\n                  }\n                case \"tool-call\":\n                  {\n                    return {\n                      functionCall: {\n                        name: part.toolName,\n                        args: part.args\n                      }\n                    };\n                  }\n              }\n            }).filter(part => part !== void 0)\n          });\n          break;\n        }\n      case \"tool\":\n        {\n          systemMessagesAllowed = false;\n          contents.push({\n            role: \"user\",\n            parts: content.map(part => ({\n              functionResponse: {\n                name: part.toolName,\n                response: {\n                  name: part.toolName,\n                  content: part.result\n                }\n              }\n            }))\n          });\n          break;\n        }\n    }\n  }\n  return {\n    systemInstruction: systemInstructionParts.length > 0 ? {\n      parts: systemInstructionParts\n    } : void 0,\n    contents\n  };\n}\nfunction getModelPath(modelId) {\n  return modelId.includes(\"/\") ? modelId : `models/${modelId}`;\n}\nvar googleErrorDataSchema = external_exports.object({\n  error: external_exports.object({\n    code: external_exports.number().nullable(),\n    message: external_exports.string(),\n    status: external_exports.string()\n  })\n});\nvar googleFailedResponseHandler = createJsonErrorResponseHandler3({\n  errorSchema: googleErrorDataSchema,\n  errorToMessage: data => data.error.message\n});\nfunction prepareTools3(mode, useSearchGrounding, dynamicRetrievalConfig, modelId) {\n  var _a20, _b8;\n  const tools = ((_a20 = mode.tools) == null ? void 0 : _a20.length) ? mode.tools : void 0;\n  const toolWarnings = [];\n  const isGemini2 = modelId.includes(\"gemini-2\");\n  const supportsDynamicRetrieval = modelId.includes(\"gemini-1.5-flash\") && !modelId.includes(\"-8b\");\n  if (useSearchGrounding) {\n    return {\n      tools: isGemini2 ? {\n        googleSearch: {}\n      } : {\n        googleSearchRetrieval: !supportsDynamicRetrieval || !dynamicRetrievalConfig ? {} : {\n          dynamicRetrievalConfig\n        }\n      },\n      toolConfig: void 0,\n      toolWarnings\n    };\n  }\n  if (tools == null) {\n    return {\n      tools: void 0,\n      toolConfig: void 0,\n      toolWarnings\n    };\n  }\n  const functionDeclarations = [];\n  for (const tool2 of tools) {\n    if (tool2.type === \"provider-defined\") {\n      toolWarnings.push({\n        type: \"unsupported-tool\",\n        tool: tool2\n      });\n    } else {\n      functionDeclarations.push({\n        name: tool2.name,\n        description: (_b8 = tool2.description) != null ? _b8 : \"\",\n        parameters: convertJSONSchemaToOpenAPISchema(tool2.parameters)\n      });\n    }\n  }\n  const toolChoice = mode.toolChoice;\n  if (toolChoice == null) {\n    return {\n      tools: {\n        functionDeclarations\n      },\n      toolConfig: void 0,\n      toolWarnings\n    };\n  }\n  const type = toolChoice.type;\n  switch (type) {\n    case \"auto\":\n      return {\n        tools: {\n          functionDeclarations\n        },\n        toolConfig: {\n          functionCallingConfig: {\n            mode: \"AUTO\"\n          }\n        },\n        toolWarnings\n      };\n    case \"none\":\n      return {\n        tools: {\n          functionDeclarations\n        },\n        toolConfig: {\n          functionCallingConfig: {\n            mode: \"NONE\"\n          }\n        },\n        toolWarnings\n      };\n    case \"required\":\n      return {\n        tools: {\n          functionDeclarations\n        },\n        toolConfig: {\n          functionCallingConfig: {\n            mode: \"ANY\"\n          }\n        },\n        toolWarnings\n      };\n    case \"tool\":\n      return {\n        tools: {\n          functionDeclarations\n        },\n        toolConfig: {\n          functionCallingConfig: {\n            mode: \"ANY\",\n            allowedFunctionNames: [toolChoice.toolName]\n          }\n        },\n        toolWarnings\n      };\n    default:\n      {\n        const _exhaustiveCheck = type;\n        throw new UnsupportedFunctionalityError3({\n          functionality: `Unsupported tool choice type: ${_exhaustiveCheck}`\n        });\n      }\n  }\n}\nfunction mapGoogleGenerativeAIFinishReason({\n  finishReason,\n  hasToolCalls\n}) {\n  switch (finishReason) {\n    case \"STOP\":\n      return hasToolCalls ? \"tool-calls\" : \"stop\";\n    case \"MAX_TOKENS\":\n      return \"length\";\n    case \"IMAGE_SAFETY\":\n    case \"RECITATION\":\n    case \"SAFETY\":\n    case \"BLOCKLIST\":\n    case \"PROHIBITED_CONTENT\":\n    case \"SPII\":\n      return \"content-filter\";\n    case \"FINISH_REASON_UNSPECIFIED\":\n    case \"OTHER\":\n      return \"other\";\n    case \"MALFORMED_FUNCTION_CALL\":\n      return \"error\";\n    default:\n      return \"unknown\";\n  }\n}\nvar GoogleGenerativeAILanguageModel = class {\n  constructor(modelId, settings, config2) {\n    this.specificationVersion = \"v1\";\n    this.defaultObjectGenerationMode = \"json\";\n    this.supportsImageUrls = false;\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config2;\n  }\n  get supportsStructuredOutputs() {\n    var _a20;\n    return (_a20 = this.settings.structuredOutputs) != null ? _a20 : true;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  async getArgs({\n    mode,\n    prompt,\n    maxTokens,\n    temperature,\n    topP,\n    topK,\n    frequencyPenalty,\n    presencePenalty,\n    stopSequences,\n    responseFormat,\n    seed,\n    providerMetadata\n  }) {\n    var _a20, _b8, _c;\n    const type = mode.type;\n    const warnings = [];\n    const googleOptions = parseProviderOptions2({\n      provider: \"google\",\n      providerOptions: providerMetadata,\n      schema: googleGenerativeAIProviderOptionsSchema\n    });\n    if (((_a20 = googleOptions == null ? void 0 : googleOptions.thinkingConfig) == null ? void 0 : _a20.includeThoughts) === true && !this.config.provider.startsWith(\"google.vertex.\")) {\n      warnings.push({\n        type: \"other\",\n        message: `The 'includeThoughts' option is only supported with the Google Vertex provider and might not be supported or could behave unexpectedly with the current Google provider (${this.config.provider}).`\n      });\n    }\n    const generationConfig = {\n      // standardized settings:\n      maxOutputTokens: maxTokens,\n      temperature,\n      topK,\n      topP,\n      frequencyPenalty,\n      presencePenalty,\n      stopSequences,\n      seed,\n      // response format:\n      responseMimeType: (responseFormat == null ? void 0 : responseFormat.type) === \"json\" ? \"application/json\" : void 0,\n      responseSchema: (responseFormat == null ? void 0 : responseFormat.type) === \"json\" && responseFormat.schema != null &&\n      // Google GenAI does not support all OpenAPI Schema features,\n      // so this is needed as an escape hatch:\n      this.supportsStructuredOutputs ? convertJSONSchemaToOpenAPISchema(responseFormat.schema) : void 0,\n      ...(this.settings.audioTimestamp && {\n        audioTimestamp: this.settings.audioTimestamp\n      }),\n      // provider options:\n      responseModalities: googleOptions == null ? void 0 : googleOptions.responseModalities,\n      thinkingConfig: googleOptions == null ? void 0 : googleOptions.thinkingConfig\n    };\n    const {\n      contents,\n      systemInstruction\n    } = convertToGoogleGenerativeAIMessages(prompt);\n    switch (type) {\n      case \"regular\":\n        {\n          const {\n            tools,\n            toolConfig,\n            toolWarnings\n          } = prepareTools3(mode, (_b8 = this.settings.useSearchGrounding) != null ? _b8 : false, this.settings.dynamicRetrievalConfig, this.modelId);\n          return {\n            args: {\n              generationConfig,\n              contents,\n              systemInstruction,\n              safetySettings: this.settings.safetySettings,\n              tools,\n              toolConfig,\n              cachedContent: this.settings.cachedContent\n            },\n            warnings: [...warnings, ...toolWarnings]\n          };\n        }\n      case \"object-json\":\n        {\n          return {\n            args: {\n              generationConfig: {\n                ...generationConfig,\n                responseMimeType: \"application/json\",\n                responseSchema: mode.schema != null &&\n                // Google GenAI does not support all OpenAPI Schema features,\n                // so this is needed as an escape hatch:\n                this.supportsStructuredOutputs ? convertJSONSchemaToOpenAPISchema(mode.schema) : void 0\n              },\n              contents,\n              systemInstruction,\n              safetySettings: this.settings.safetySettings,\n              cachedContent: this.settings.cachedContent\n            },\n            warnings\n          };\n        }\n      case \"object-tool\":\n        {\n          return {\n            args: {\n              generationConfig,\n              contents,\n              systemInstruction,\n              tools: {\n                functionDeclarations: [{\n                  name: mode.tool.name,\n                  description: (_c = mode.tool.description) != null ? _c : \"\",\n                  parameters: convertJSONSchemaToOpenAPISchema(mode.tool.parameters)\n                }]\n              },\n              toolConfig: {\n                functionCallingConfig: {\n                  mode: \"ANY\"\n                }\n              },\n              safetySettings: this.settings.safetySettings,\n              cachedContent: this.settings.cachedContent\n            },\n            warnings\n          };\n        }\n      default:\n        {\n          const _exhaustiveCheck = type;\n          throw new Error(`Unsupported type: ${_exhaustiveCheck}`);\n        }\n    }\n  }\n  supportsUrl(url2) {\n    return this.config.isSupportedUrl(url2);\n  }\n  async doGenerate(options) {\n    var _a20, _b8, _c, _d, _e;\n    const {\n      args,\n      warnings\n    } = await this.getArgs(options);\n    const body = JSON.stringify(args);\n    const mergedHeaders = combineHeaders3(await resolve2(this.config.headers), options.headers);\n    const {\n      responseHeaders,\n      value: response,\n      rawValue: rawResponse\n    } = await postJsonToApi3({\n      url: `${this.config.baseURL}/${getModelPath(this.modelId)}:generateContent`,\n      headers: mergedHeaders,\n      body: args,\n      failedResponseHandler: googleFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler3(responseSchema),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    const {\n      contents: rawPrompt,\n      ...rawSettings\n    } = args;\n    const candidate = response.candidates[0];\n    const parts = candidate.content == null || typeof candidate.content !== \"object\" || !(\"parts\" in candidate.content) ? [] : candidate.content.parts;\n    const toolCalls = getToolCallsFromParts({\n      parts,\n      // Use candidateParts\n      generateId: this.config.generateId\n    });\n    const usageMetadata = response.usageMetadata;\n    return {\n      text: getTextFromParts(parts),\n      reasoning: getReasoningDetailsFromParts(parts),\n      files: (_a20 = getInlineDataParts(parts)) == null ? void 0 : _a20.map(part => ({\n        data: part.inlineData.data,\n        mimeType: part.inlineData.mimeType\n      })),\n      toolCalls,\n      finishReason: mapGoogleGenerativeAIFinishReason({\n        finishReason: candidate.finishReason,\n        hasToolCalls: toolCalls != null && toolCalls.length > 0\n      }),\n      usage: {\n        promptTokens: (_b8 = usageMetadata == null ? void 0 : usageMetadata.promptTokenCount) != null ? _b8 : NaN,\n        completionTokens: (_c = usageMetadata == null ? void 0 : usageMetadata.candidatesTokenCount) != null ? _c : NaN\n      },\n      rawCall: {\n        rawPrompt,\n        rawSettings\n      },\n      rawResponse: {\n        headers: responseHeaders,\n        body: rawResponse\n      },\n      warnings,\n      providerMetadata: {\n        google: {\n          groundingMetadata: (_d = candidate.groundingMetadata) != null ? _d : null,\n          safetyRatings: (_e = candidate.safetyRatings) != null ? _e : null\n        }\n      },\n      sources: extractSources({\n        groundingMetadata: candidate.groundingMetadata,\n        generateId: this.config.generateId\n      }),\n      request: {\n        body\n      }\n    };\n  }\n  async doStream(options) {\n    const {\n      args,\n      warnings\n    } = await this.getArgs(options);\n    const body = JSON.stringify(args);\n    const headers = combineHeaders3(await resolve2(this.config.headers), options.headers);\n    const {\n      responseHeaders,\n      value: response\n    } = await postJsonToApi3({\n      url: `${this.config.baseURL}/${getModelPath(this.modelId)}:streamGenerateContent?alt=sse`,\n      headers,\n      body: args,\n      failedResponseHandler: googleFailedResponseHandler,\n      successfulResponseHandler: createEventSourceResponseHandler3(chunkSchema),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    const {\n      contents: rawPrompt,\n      ...rawSettings\n    } = args;\n    let finishReason = \"unknown\";\n    let usage = {\n      promptTokens: Number.NaN,\n      completionTokens: Number.NaN\n    };\n    let providerMetadata = void 0;\n    const generateId22 = this.config.generateId;\n    let hasToolCalls = false;\n    return {\n      stream: response.pipeThrough(new TransformStream({\n        transform(chunk, controller) {\n          var _a20, _b8, _c, _d, _e, _f;\n          if (!chunk.success) {\n            controller.enqueue({\n              type: \"error\",\n              error: chunk.error\n            });\n            return;\n          }\n          const value = chunk.value;\n          const usageMetadata = value.usageMetadata;\n          if (usageMetadata != null) {\n            usage = {\n              promptTokens: (_a20 = usageMetadata.promptTokenCount) != null ? _a20 : NaN,\n              completionTokens: (_b8 = usageMetadata.candidatesTokenCount) != null ? _b8 : NaN\n            };\n          }\n          const candidate = (_c = value.candidates) == null ? void 0 : _c[0];\n          if (candidate == null) {\n            return;\n          }\n          const content = candidate.content;\n          if (content != null) {\n            const deltaText = getTextFromParts(content.parts);\n            if (deltaText != null) {\n              controller.enqueue({\n                type: \"text-delta\",\n                textDelta: deltaText\n              });\n            }\n            const reasoningDeltaText = getReasoningDetailsFromParts(content.parts);\n            if (reasoningDeltaText != null) {\n              for (const part of reasoningDeltaText) {\n                controller.enqueue({\n                  type: \"reasoning\",\n                  textDelta: part.text\n                });\n              }\n            }\n            const inlineDataParts = getInlineDataParts(content.parts);\n            if (inlineDataParts != null) {\n              for (const part of inlineDataParts) {\n                controller.enqueue({\n                  type: \"file\",\n                  mimeType: part.inlineData.mimeType,\n                  data: part.inlineData.data\n                });\n              }\n            }\n            const toolCallDeltas = getToolCallsFromParts({\n              parts: content.parts,\n              generateId: generateId22\n            });\n            if (toolCallDeltas != null) {\n              for (const toolCall of toolCallDeltas) {\n                controller.enqueue({\n                  type: \"tool-call-delta\",\n                  toolCallType: \"function\",\n                  toolCallId: toolCall.toolCallId,\n                  toolName: toolCall.toolName,\n                  argsTextDelta: toolCall.args\n                });\n                controller.enqueue({\n                  type: \"tool-call\",\n                  toolCallType: \"function\",\n                  toolCallId: toolCall.toolCallId,\n                  toolName: toolCall.toolName,\n                  args: toolCall.args\n                });\n                hasToolCalls = true;\n              }\n            }\n          }\n          if (candidate.finishReason != null) {\n            finishReason = mapGoogleGenerativeAIFinishReason({\n              finishReason: candidate.finishReason,\n              hasToolCalls\n            });\n            const sources = (_d = extractSources({\n              groundingMetadata: candidate.groundingMetadata,\n              generateId: generateId22\n            })) != null ? _d : [];\n            for (const source of sources) {\n              controller.enqueue({\n                type: \"source\",\n                source\n              });\n            }\n            providerMetadata = {\n              google: {\n                groundingMetadata: (_e = candidate.groundingMetadata) != null ? _e : null,\n                safetyRatings: (_f = candidate.safetyRatings) != null ? _f : null\n              }\n            };\n          }\n        },\n        flush(controller) {\n          controller.enqueue({\n            type: \"finish\",\n            finishReason,\n            usage,\n            providerMetadata\n          });\n        }\n      })),\n      rawCall: {\n        rawPrompt,\n        rawSettings\n      },\n      rawResponse: {\n        headers: responseHeaders\n      },\n      warnings,\n      request: {\n        body\n      }\n    };\n  }\n};\nfunction getToolCallsFromParts({\n  parts,\n  generateId: generateId22\n}) {\n  const functionCallParts = parts == null ? void 0 : parts.filter(part => \"functionCall\" in part);\n  return functionCallParts == null || functionCallParts.length === 0 ? void 0 : functionCallParts.map(part => ({\n    toolCallType: \"function\",\n    toolCallId: generateId22(),\n    toolName: part.functionCall.name,\n    args: JSON.stringify(part.functionCall.args)\n  }));\n}\nfunction getTextFromParts(parts) {\n  const textParts = parts == null ? void 0 : parts.filter(part => \"text\" in part && part.thought !== true);\n  return textParts == null || textParts.length === 0 ? void 0 : textParts.map(part => part.text).join(\"\");\n}\nfunction getReasoningDetailsFromParts(parts) {\n  const reasoningParts = parts == null ? void 0 : parts.filter(part => \"text\" in part && part.thought === true && part.text != null);\n  return reasoningParts == null || reasoningParts.length === 0 ? void 0 : reasoningParts.map(part => ({\n    type: \"text\",\n    text: part.text\n  }));\n}\nfunction getInlineDataParts(parts) {\n  return parts == null ? void 0 : parts.filter(part => \"inlineData\" in part);\n}\nfunction extractSources({\n  groundingMetadata,\n  generateId: generateId22\n}) {\n  var _a20;\n  return (_a20 = groundingMetadata == null ? void 0 : groundingMetadata.groundingChunks) == null ? void 0 : _a20.filter(chunk => chunk.web != null).map(chunk => ({\n    sourceType: \"url\",\n    id: generateId22(),\n    url: chunk.web.uri,\n    title: chunk.web.title\n  }));\n}\nvar contentSchema = external_exports.object({\n  parts: external_exports.array(external_exports.union([\n  // note: order matters since text can be fully empty\n  external_exports.object({\n    functionCall: external_exports.object({\n      name: external_exports.string(),\n      args: external_exports.unknown()\n    })\n  }), external_exports.object({\n    inlineData: external_exports.object({\n      mimeType: external_exports.string(),\n      data: external_exports.string()\n    })\n  }), external_exports.object({\n    text: external_exports.string().nullish(),\n    thought: external_exports.boolean().nullish()\n  })])).nullish()\n});\nvar groundingChunkSchema = external_exports.object({\n  web: external_exports.object({\n    uri: external_exports.string(),\n    title: external_exports.string()\n  }).nullish(),\n  retrievedContext: external_exports.object({\n    uri: external_exports.string(),\n    title: external_exports.string()\n  }).nullish()\n});\nvar groundingMetadataSchema = external_exports.object({\n  webSearchQueries: external_exports.array(external_exports.string()).nullish(),\n  retrievalQueries: external_exports.array(external_exports.string()).nullish(),\n  searchEntryPoint: external_exports.object({\n    renderedContent: external_exports.string()\n  }).nullish(),\n  groundingChunks: external_exports.array(groundingChunkSchema).nullish(),\n  groundingSupports: external_exports.array(external_exports.object({\n    segment: external_exports.object({\n      startIndex: external_exports.number().nullish(),\n      endIndex: external_exports.number().nullish(),\n      text: external_exports.string().nullish()\n    }),\n    segment_text: external_exports.string().nullish(),\n    groundingChunkIndices: external_exports.array(external_exports.number()).nullish(),\n    supportChunkIndices: external_exports.array(external_exports.number()).nullish(),\n    confidenceScores: external_exports.array(external_exports.number()).nullish(),\n    confidenceScore: external_exports.array(external_exports.number()).nullish()\n  })).nullish(),\n  retrievalMetadata: external_exports.union([external_exports.object({\n    webDynamicRetrievalScore: external_exports.number()\n  }), external_exports.object({})]).nullish()\n});\nvar safetyRatingSchema = external_exports.object({\n  category: external_exports.string().nullish(),\n  probability: external_exports.string().nullish(),\n  probabilityScore: external_exports.number().nullish(),\n  severity: external_exports.string().nullish(),\n  severityScore: external_exports.number().nullish(),\n  blocked: external_exports.boolean().nullish()\n});\nvar responseSchema = external_exports.object({\n  candidates: external_exports.array(external_exports.object({\n    content: contentSchema.nullish().or(external_exports.object({}).strict()),\n    finishReason: external_exports.string().nullish(),\n    safetyRatings: external_exports.array(safetyRatingSchema).nullish(),\n    groundingMetadata: groundingMetadataSchema.nullish()\n  })),\n  usageMetadata: external_exports.object({\n    promptTokenCount: external_exports.number().nullish(),\n    candidatesTokenCount: external_exports.number().nullish(),\n    totalTokenCount: external_exports.number().nullish()\n  }).nullish()\n});\nvar chunkSchema = external_exports.object({\n  candidates: external_exports.array(external_exports.object({\n    content: contentSchema.nullish(),\n    finishReason: external_exports.string().nullish(),\n    safetyRatings: external_exports.array(safetyRatingSchema).nullish(),\n    groundingMetadata: groundingMetadataSchema.nullish()\n  })).nullish(),\n  usageMetadata: external_exports.object({\n    promptTokenCount: external_exports.number().nullish(),\n    candidatesTokenCount: external_exports.number().nullish(),\n    totalTokenCount: external_exports.number().nullish()\n  }).nullish()\n});\nvar googleGenerativeAIProviderOptionsSchema = external_exports.object({\n  responseModalities: external_exports.array(external_exports.enum([\"TEXT\", \"IMAGE\"])).nullish(),\n  thinkingConfig: external_exports.object({\n    thinkingBudget: external_exports.number().nullish(),\n    includeThoughts: external_exports.boolean().nullish()\n  }).nullish()\n});\nvar GoogleGenerativeAIEmbeddingModel = class {\n  constructor(modelId, settings, config2) {\n    this.specificationVersion = \"v1\";\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config2;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  get maxEmbeddingsPerCall() {\n    return 2048;\n  }\n  get supportsParallelCalls() {\n    return true;\n  }\n  async doEmbed({\n    values,\n    headers,\n    abortSignal\n  }) {\n    if (values.length > this.maxEmbeddingsPerCall) {\n      throw new TooManyEmbeddingValuesForCallError2({\n        provider: this.provider,\n        modelId: this.modelId,\n        maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,\n        values\n      });\n    }\n    const mergedHeaders = combineHeaders3(await resolve2(this.config.headers), headers);\n    const {\n      responseHeaders,\n      value: response\n    } = await postJsonToApi3({\n      url: `${this.config.baseURL}/models/${this.modelId}:batchEmbedContents`,\n      headers: mergedHeaders,\n      body: {\n        requests: values.map(value => ({\n          model: `models/${this.modelId}`,\n          content: {\n            role: \"user\",\n            parts: [{\n              text: value\n            }]\n          },\n          outputDimensionality: this.settings.outputDimensionality,\n          taskType: this.settings.taskType\n        }))\n      },\n      failedResponseHandler: googleFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler3(googleGenerativeAITextEmbeddingResponseSchema),\n      abortSignal,\n      fetch: this.config.fetch\n    });\n    return {\n      embeddings: response.embeddings.map(item => item.values),\n      usage: void 0,\n      rawResponse: {\n        headers: responseHeaders\n      }\n    };\n  }\n};\nvar googleGenerativeAITextEmbeddingResponseSchema = external_exports.object({\n  embeddings: external_exports.array(external_exports.object({\n    values: external_exports.array(external_exports.number())\n  }))\n});\nfunction isSupportedFileUrl(url2) {\n  return url2.toString().startsWith(\"https://generativelanguage.googleapis.com/v1beta/files/\");\n}\nfunction createGoogleGenerativeAI(options = {}) {\n  var _a20;\n  const baseURL = (_a20 = withoutTrailingSlash3(options.baseURL)) != null ? _a20 : \"https://generativelanguage.googleapis.com/v1beta\";\n  const getHeaders = () => ({\n    \"x-goog-api-key\": loadApiKey2({\n      apiKey: options.apiKey,\n      environmentVariableName: \"GOOGLE_GENERATIVE_AI_API_KEY\",\n      description: \"Google Generative AI\"\n    }),\n    ...options.headers\n  });\n  const createChatModel = (modelId, settings = {}) => {\n    var _a27;\n    return new GoogleGenerativeAILanguageModel(modelId, settings, {\n      provider: \"google.generative-ai\",\n      baseURL,\n      headers: getHeaders,\n      generateId: (_a27 = options.generateId) != null ? _a27 : generateId4,\n      isSupportedUrl: isSupportedFileUrl,\n      fetch: options.fetch\n    });\n  };\n  const createEmbeddingModel = (modelId, settings = {}) => new GoogleGenerativeAIEmbeddingModel(modelId, settings, {\n    provider: \"google.generative-ai\",\n    baseURL,\n    headers: getHeaders,\n    fetch: options.fetch\n  });\n  const provider = function (modelId, settings) {\n    if (new.target) {\n      throw new Error(\"The Google Generative AI model function cannot be called with the new keyword.\");\n    }\n    return createChatModel(modelId, settings);\n  };\n  provider.languageModel = createChatModel;\n  provider.chat = createChatModel;\n  provider.generativeAI = createChatModel;\n  provider.embedding = createEmbeddingModel;\n  provider.textEmbedding = createEmbeddingModel;\n  provider.textEmbeddingModel = createEmbeddingModel;\n  return provider;\n}\nvar google = createGoogleGenerativeAI();\n\n// ../../node_modules/@ai-sdk/groq/dist/index.mjs\nfunction convertToGroqChatMessages(prompt) {\n  const messages = [];\n  for (const {\n    role,\n    content\n  } of prompt) {\n    switch (role) {\n      case \"system\":\n        {\n          messages.push({\n            role: \"system\",\n            content\n          });\n          break;\n        }\n      case \"user\":\n        {\n          if (content.length === 1 && content[0].type === \"text\") {\n            messages.push({\n              role: \"user\",\n              content: content[0].text\n            });\n            break;\n          }\n          messages.push({\n            role: \"user\",\n            content: content.map(part => {\n              var _a20;\n              switch (part.type) {\n                case \"text\":\n                  {\n                    return {\n                      type: \"text\",\n                      text: part.text\n                    };\n                  }\n                case \"image\":\n                  {\n                    return {\n                      type: \"image_url\",\n                      image_url: {\n                        url: part.image instanceof URL ? part.image.toString() : `data:${(_a20 = part.mimeType) != null ? _a20 : \"image/jpeg\"};base64,${convertUint8ArrayToBase643(part.image)}`\n                      }\n                    };\n                  }\n                case \"file\":\n                  {\n                    throw new UnsupportedFunctionalityError3({\n                      functionality: \"File content parts in user messages\"\n                    });\n                  }\n              }\n            })\n          });\n          break;\n        }\n      case \"assistant\":\n        {\n          let text2 = \"\";\n          const toolCalls = [];\n          for (const part of content) {\n            switch (part.type) {\n              case \"text\":\n                {\n                  text2 += part.text;\n                  break;\n                }\n              case \"tool-call\":\n                {\n                  toolCalls.push({\n                    id: part.toolCallId,\n                    type: \"function\",\n                    function: {\n                      name: part.toolName,\n                      arguments: JSON.stringify(part.args)\n                    }\n                  });\n                  break;\n                }\n            }\n          }\n          messages.push({\n            role: \"assistant\",\n            content: text2,\n            tool_calls: toolCalls.length > 0 ? toolCalls : void 0\n          });\n          break;\n        }\n      case \"tool\":\n        {\n          for (const toolResponse of content) {\n            messages.push({\n              role: \"tool\",\n              tool_call_id: toolResponse.toolCallId,\n              content: JSON.stringify(toolResponse.result)\n            });\n          }\n          break;\n        }\n      default:\n        {\n          const _exhaustiveCheck = role;\n          throw new Error(`Unsupported role: ${_exhaustiveCheck}`);\n        }\n    }\n  }\n  return messages;\n}\nfunction getResponseMetadata4({\n  id,\n  model,\n  created\n}) {\n  return {\n    id: id != null ? id : void 0,\n    modelId: model != null ? model : void 0,\n    timestamp: created != null ? new Date(created * 1e3) : void 0\n  };\n}\nvar groqErrorDataSchema = external_exports.object({\n  error: external_exports.object({\n    message: external_exports.string(),\n    type: external_exports.string()\n  })\n});\nvar groqFailedResponseHandler = createJsonErrorResponseHandler3({\n  errorSchema: groqErrorDataSchema,\n  errorToMessage: data => data.error.message\n});\nfunction prepareTools4({\n  mode\n}) {\n  var _a20;\n  const tools = ((_a20 = mode.tools) == null ? void 0 : _a20.length) ? mode.tools : void 0;\n  const toolWarnings = [];\n  if (tools == null) {\n    return {\n      tools: void 0,\n      tool_choice: void 0,\n      toolWarnings\n    };\n  }\n  const toolChoice = mode.toolChoice;\n  const groqTools = [];\n  for (const tool2 of tools) {\n    if (tool2.type === \"provider-defined\") {\n      toolWarnings.push({\n        type: \"unsupported-tool\",\n        tool: tool2\n      });\n    } else {\n      groqTools.push({\n        type: \"function\",\n        function: {\n          name: tool2.name,\n          description: tool2.description,\n          parameters: tool2.parameters\n        }\n      });\n    }\n  }\n  if (toolChoice == null) {\n    return {\n      tools: groqTools,\n      tool_choice: void 0,\n      toolWarnings\n    };\n  }\n  const type = toolChoice.type;\n  switch (type) {\n    case \"auto\":\n    case \"none\":\n    case \"required\":\n      return {\n        tools: groqTools,\n        tool_choice: type,\n        toolWarnings\n      };\n    case \"tool\":\n      return {\n        tools: groqTools,\n        tool_choice: {\n          type: \"function\",\n          function: {\n            name: toolChoice.toolName\n          }\n        },\n        toolWarnings\n      };\n    default:\n      {\n        const _exhaustiveCheck = type;\n        throw new UnsupportedFunctionalityError3({\n          functionality: `Unsupported tool choice type: ${_exhaustiveCheck}`\n        });\n      }\n  }\n}\nfunction mapGroqFinishReason(finishReason) {\n  switch (finishReason) {\n    case \"stop\":\n      return \"stop\";\n    case \"length\":\n      return \"length\";\n    case \"content_filter\":\n      return \"content-filter\";\n    case \"function_call\":\n    case \"tool_calls\":\n      return \"tool-calls\";\n    default:\n      return \"unknown\";\n  }\n}\nvar GroqChatLanguageModel = class {\n  constructor(modelId, settings, config2) {\n    this.specificationVersion = \"v1\";\n    this.supportsStructuredOutputs = false;\n    this.defaultObjectGenerationMode = \"json\";\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config2;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  get supportsImageUrls() {\n    return !this.settings.downloadImages;\n  }\n  getArgs({\n    mode,\n    prompt,\n    maxTokens,\n    temperature,\n    topP,\n    topK,\n    frequencyPenalty,\n    presencePenalty,\n    stopSequences,\n    responseFormat,\n    seed,\n    stream,\n    providerMetadata\n  }) {\n    const type = mode.type;\n    const warnings = [];\n    if (topK != null) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"topK\"\n      });\n    }\n    if (responseFormat != null && responseFormat.type === \"json\" && responseFormat.schema != null) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"responseFormat\",\n        details: \"JSON response format schema is not supported\"\n      });\n    }\n    const groqOptions = parseProviderOptions2({\n      provider: \"groq\",\n      providerOptions: providerMetadata,\n      schema: external_exports.object({\n        reasoningFormat: external_exports.enum([\"parsed\", \"raw\", \"hidden\"]).nullish()\n      })\n    });\n    const baseArgs = {\n      // model id:\n      model: this.modelId,\n      // model specific settings:\n      user: this.settings.user,\n      parallel_tool_calls: this.settings.parallelToolCalls,\n      // standardized settings:\n      max_tokens: maxTokens,\n      temperature,\n      top_p: topP,\n      frequency_penalty: frequencyPenalty,\n      presence_penalty: presencePenalty,\n      stop: stopSequences,\n      seed,\n      // response format:\n      response_format:\n      // json object response format is not supported for streaming:\n      stream === false && (responseFormat == null ? void 0 : responseFormat.type) === \"json\" ? {\n        type: \"json_object\"\n      } : void 0,\n      // provider options:\n      reasoning_format: groqOptions == null ? void 0 : groqOptions.reasoningFormat,\n      // messages:\n      messages: convertToGroqChatMessages(prompt)\n    };\n    switch (type) {\n      case \"regular\":\n        {\n          const {\n            tools,\n            tool_choice,\n            toolWarnings\n          } = prepareTools4({\n            mode\n          });\n          return {\n            args: {\n              ...baseArgs,\n              tools,\n              tool_choice\n            },\n            warnings: [...warnings, ...toolWarnings]\n          };\n        }\n      case \"object-json\":\n        {\n          return {\n            args: {\n              ...baseArgs,\n              response_format:\n              // json object response format is not supported for streaming:\n              stream === false ? {\n                type: \"json_object\"\n              } : void 0\n            },\n            warnings\n          };\n        }\n      case \"object-tool\":\n        {\n          return {\n            args: {\n              ...baseArgs,\n              tool_choice: {\n                type: \"function\",\n                function: {\n                  name: mode.tool.name\n                }\n              },\n              tools: [{\n                type: \"function\",\n                function: {\n                  name: mode.tool.name,\n                  description: mode.tool.description,\n                  parameters: mode.tool.parameters\n                }\n              }]\n            },\n            warnings\n          };\n        }\n      default:\n        {\n          const _exhaustiveCheck = type;\n          throw new Error(`Unsupported type: ${_exhaustiveCheck}`);\n        }\n    }\n  }\n  async doGenerate(options) {\n    var _a20, _b8, _c, _d, _e, _f, _g;\n    const {\n      args,\n      warnings\n    } = this.getArgs({\n      ...options,\n      stream: false\n    });\n    const body = JSON.stringify(args);\n    const {\n      responseHeaders,\n      value: response,\n      rawValue: rawResponse\n    } = await postJsonToApi3({\n      url: this.config.url({\n        path: \"/chat/completions\",\n        modelId: this.modelId\n      }),\n      headers: combineHeaders3(this.config.headers(), options.headers),\n      body: args,\n      failedResponseHandler: groqFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler3(groqChatResponseSchema),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    const {\n      messages: rawPrompt,\n      ...rawSettings\n    } = args;\n    const choice = response.choices[0];\n    return {\n      text: (_a20 = choice.message.content) != null ? _a20 : void 0,\n      reasoning: (_b8 = choice.message.reasoning) != null ? _b8 : void 0,\n      toolCalls: (_c = choice.message.tool_calls) == null ? void 0 : _c.map(toolCall => {\n        var _a27;\n        return {\n          toolCallType: \"function\",\n          toolCallId: (_a27 = toolCall.id) != null ? _a27 : generateId4(),\n          toolName: toolCall.function.name,\n          args: toolCall.function.arguments\n        };\n      }),\n      finishReason: mapGroqFinishReason(choice.finish_reason),\n      usage: {\n        promptTokens: (_e = (_d = response.usage) == null ? void 0 : _d.prompt_tokens) != null ? _e : NaN,\n        completionTokens: (_g = (_f = response.usage) == null ? void 0 : _f.completion_tokens) != null ? _g : NaN\n      },\n      rawCall: {\n        rawPrompt,\n        rawSettings\n      },\n      rawResponse: {\n        headers: responseHeaders,\n        body: rawResponse\n      },\n      response: getResponseMetadata4(response),\n      warnings,\n      request: {\n        body\n      }\n    };\n  }\n  async doStream(options) {\n    const {\n      args,\n      warnings\n    } = this.getArgs({\n      ...options,\n      stream: true\n    });\n    const body = JSON.stringify({\n      ...args,\n      stream: true\n    });\n    const {\n      responseHeaders,\n      value: response\n    } = await postJsonToApi3({\n      url: this.config.url({\n        path: \"/chat/completions\",\n        modelId: this.modelId\n      }),\n      headers: combineHeaders3(this.config.headers(), options.headers),\n      body: {\n        ...args,\n        stream: true\n      },\n      failedResponseHandler: groqFailedResponseHandler,\n      successfulResponseHandler: createEventSourceResponseHandler3(groqChatChunkSchema),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    const {\n      messages: rawPrompt,\n      ...rawSettings\n    } = args;\n    const toolCalls = [];\n    let finishReason = \"unknown\";\n    let usage = {\n      promptTokens: void 0,\n      completionTokens: void 0\n    };\n    let isFirstChunk = true;\n    let providerMetadata;\n    return {\n      stream: response.pipeThrough(new TransformStream({\n        transform(chunk, controller) {\n          var _a20, _b8, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;\n          if (!chunk.success) {\n            finishReason = \"error\";\n            controller.enqueue({\n              type: \"error\",\n              error: chunk.error\n            });\n            return;\n          }\n          const value = chunk.value;\n          if (\"error\" in value) {\n            finishReason = \"error\";\n            controller.enqueue({\n              type: \"error\",\n              error: value.error\n            });\n            return;\n          }\n          if (isFirstChunk) {\n            isFirstChunk = false;\n            controller.enqueue({\n              type: \"response-metadata\",\n              ...getResponseMetadata4(value)\n            });\n          }\n          if (((_a20 = value.x_groq) == null ? void 0 : _a20.usage) != null) {\n            usage = {\n              promptTokens: (_b8 = value.x_groq.usage.prompt_tokens) != null ? _b8 : void 0,\n              completionTokens: (_c = value.x_groq.usage.completion_tokens) != null ? _c : void 0\n            };\n          }\n          const choice = value.choices[0];\n          if ((choice == null ? void 0 : choice.finish_reason) != null) {\n            finishReason = mapGroqFinishReason(choice.finish_reason);\n          }\n          if ((choice == null ? void 0 : choice.delta) == null) {\n            return;\n          }\n          const delta = choice.delta;\n          if (delta.reasoning != null && delta.reasoning.length > 0) {\n            controller.enqueue({\n              type: \"reasoning\",\n              textDelta: delta.reasoning\n            });\n          }\n          if (delta.content != null && delta.content.length > 0) {\n            controller.enqueue({\n              type: \"text-delta\",\n              textDelta: delta.content\n            });\n          }\n          if (delta.tool_calls != null) {\n            for (const toolCallDelta of delta.tool_calls) {\n              const index = toolCallDelta.index;\n              if (toolCalls[index] == null) {\n                if (toolCallDelta.type !== \"function\") {\n                  throw new InvalidResponseDataError2({\n                    data: toolCallDelta,\n                    message: `Expected 'function' type.`\n                  });\n                }\n                if (toolCallDelta.id == null) {\n                  throw new InvalidResponseDataError2({\n                    data: toolCallDelta,\n                    message: `Expected 'id' to be a string.`\n                  });\n                }\n                if (((_d = toolCallDelta.function) == null ? void 0 : _d.name) == null) {\n                  throw new InvalidResponseDataError2({\n                    data: toolCallDelta,\n                    message: `Expected 'function.name' to be a string.`\n                  });\n                }\n                toolCalls[index] = {\n                  id: toolCallDelta.id,\n                  type: \"function\",\n                  function: {\n                    name: toolCallDelta.function.name,\n                    arguments: (_e = toolCallDelta.function.arguments) != null ? _e : \"\"\n                  },\n                  hasFinished: false\n                };\n                const toolCall2 = toolCalls[index];\n                if (((_f = toolCall2.function) == null ? void 0 : _f.name) != null && ((_g = toolCall2.function) == null ? void 0 : _g.arguments) != null) {\n                  if (toolCall2.function.arguments.length > 0) {\n                    controller.enqueue({\n                      type: \"tool-call-delta\",\n                      toolCallType: \"function\",\n                      toolCallId: toolCall2.id,\n                      toolName: toolCall2.function.name,\n                      argsTextDelta: toolCall2.function.arguments\n                    });\n                  }\n                  if (isParsableJson2(toolCall2.function.arguments)) {\n                    controller.enqueue({\n                      type: \"tool-call\",\n                      toolCallType: \"function\",\n                      toolCallId: (_h = toolCall2.id) != null ? _h : generateId4(),\n                      toolName: toolCall2.function.name,\n                      args: toolCall2.function.arguments\n                    });\n                    toolCall2.hasFinished = true;\n                  }\n                }\n                continue;\n              }\n              const toolCall = toolCalls[index];\n              if (toolCall.hasFinished) {\n                continue;\n              }\n              if (((_i = toolCallDelta.function) == null ? void 0 : _i.arguments) != null) {\n                toolCall.function.arguments += (_k = (_j = toolCallDelta.function) == null ? void 0 : _j.arguments) != null ? _k : \"\";\n              }\n              controller.enqueue({\n                type: \"tool-call-delta\",\n                toolCallType: \"function\",\n                toolCallId: toolCall.id,\n                toolName: toolCall.function.name,\n                argsTextDelta: (_l = toolCallDelta.function.arguments) != null ? _l : \"\"\n              });\n              if (((_m = toolCall.function) == null ? void 0 : _m.name) != null && ((_n = toolCall.function) == null ? void 0 : _n.arguments) != null && isParsableJson2(toolCall.function.arguments)) {\n                controller.enqueue({\n                  type: \"tool-call\",\n                  toolCallType: \"function\",\n                  toolCallId: (_o = toolCall.id) != null ? _o : generateId4(),\n                  toolName: toolCall.function.name,\n                  args: toolCall.function.arguments\n                });\n                toolCall.hasFinished = true;\n              }\n            }\n          }\n        },\n        flush(controller) {\n          var _a20, _b8;\n          controller.enqueue({\n            type: \"finish\",\n            finishReason,\n            usage: {\n              promptTokens: (_a20 = usage.promptTokens) != null ? _a20 : NaN,\n              completionTokens: (_b8 = usage.completionTokens) != null ? _b8 : NaN\n            },\n            ...(providerMetadata != null ? {\n              providerMetadata\n            } : {})\n          });\n        }\n      })),\n      rawCall: {\n        rawPrompt,\n        rawSettings\n      },\n      rawResponse: {\n        headers: responseHeaders\n      },\n      warnings,\n      request: {\n        body\n      }\n    };\n  }\n};\nvar groqChatResponseSchema = external_exports.object({\n  id: external_exports.string().nullish(),\n  created: external_exports.number().nullish(),\n  model: external_exports.string().nullish(),\n  choices: external_exports.array(external_exports.object({\n    message: external_exports.object({\n      content: external_exports.string().nullish(),\n      reasoning: external_exports.string().nullish(),\n      tool_calls: external_exports.array(external_exports.object({\n        id: external_exports.string().nullish(),\n        type: external_exports.literal(\"function\"),\n        function: external_exports.object({\n          name: external_exports.string(),\n          arguments: external_exports.string()\n        })\n      })).nullish()\n    }),\n    index: external_exports.number(),\n    finish_reason: external_exports.string().nullish()\n  })),\n  usage: external_exports.object({\n    prompt_tokens: external_exports.number().nullish(),\n    completion_tokens: external_exports.number().nullish()\n  }).nullish()\n});\nvar groqChatChunkSchema = external_exports.union([external_exports.object({\n  id: external_exports.string().nullish(),\n  created: external_exports.number().nullish(),\n  model: external_exports.string().nullish(),\n  choices: external_exports.array(external_exports.object({\n    delta: external_exports.object({\n      content: external_exports.string().nullish(),\n      reasoning: external_exports.string().nullish(),\n      tool_calls: external_exports.array(external_exports.object({\n        index: external_exports.number(),\n        id: external_exports.string().nullish(),\n        type: external_exports.literal(\"function\").optional(),\n        function: external_exports.object({\n          name: external_exports.string().nullish(),\n          arguments: external_exports.string().nullish()\n        })\n      })).nullish()\n    }).nullish(),\n    finish_reason: external_exports.string().nullable().optional(),\n    index: external_exports.number()\n  })),\n  x_groq: external_exports.object({\n    usage: external_exports.object({\n      prompt_tokens: external_exports.number().nullish(),\n      completion_tokens: external_exports.number().nullish()\n    }).nullish()\n  }).nullish()\n}), groqErrorDataSchema]);\nvar groqProviderOptionsSchema = external_exports.object({\n  language: external_exports.string().nullish(),\n  prompt: external_exports.string().nullish(),\n  responseFormat: external_exports.string().nullish(),\n  temperature: external_exports.number().min(0).max(1).nullish(),\n  timestampGranularities: external_exports.array(external_exports.string()).nullish()\n});\nvar GroqTranscriptionModel = class {\n  constructor(modelId, config2) {\n    this.modelId = modelId;\n    this.config = config2;\n    this.specificationVersion = \"v1\";\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  getArgs({\n    audio,\n    mediaType,\n    providerOptions\n  }) {\n    var _a20, _b8, _c, _d, _e;\n    const warnings = [];\n    const groqOptions = parseProviderOptions2({\n      provider: \"groq\",\n      providerOptions,\n      schema: groqProviderOptionsSchema\n    });\n    const formData = new FormData();\n    const blob = audio instanceof Uint8Array ? new Blob([audio]) : new Blob([convertBase64ToUint8Array3(audio)]);\n    formData.append(\"model\", this.modelId);\n    formData.append(\"file\", new File([blob], \"audio\", {\n      type: mediaType\n    }));\n    if (groqOptions) {\n      const transcriptionModelOptions = {\n        language: (_a20 = groqOptions.language) != null ? _a20 : void 0,\n        prompt: (_b8 = groqOptions.prompt) != null ? _b8 : void 0,\n        response_format: (_c = groqOptions.responseFormat) != null ? _c : void 0,\n        temperature: (_d = groqOptions.temperature) != null ? _d : void 0,\n        timestamp_granularities: (_e = groqOptions.timestampGranularities) != null ? _e : void 0\n      };\n      for (const key in transcriptionModelOptions) {\n        const value = transcriptionModelOptions[key];\n        if (value !== void 0) {\n          formData.append(key, String(value));\n        }\n      }\n    }\n    return {\n      formData,\n      warnings\n    };\n  }\n  async doGenerate(options) {\n    var _a20, _b8, _c, _d, _e;\n    const currentDate = (_c = (_b8 = (_a20 = this.config._internal) == null ? void 0 : _a20.currentDate) == null ? void 0 : _b8.call(_a20)) != null ? _c : /* @__PURE__ */new Date();\n    const {\n      formData,\n      warnings\n    } = this.getArgs(options);\n    const {\n      value: response,\n      responseHeaders,\n      rawValue: rawResponse\n    } = await postFormDataToApi2({\n      url: this.config.url({\n        path: \"/audio/transcriptions\",\n        modelId: this.modelId\n      }),\n      headers: combineHeaders3(this.config.headers(), options.headers),\n      formData,\n      failedResponseHandler: groqFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler3(groqTranscriptionResponseSchema),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    return {\n      text: response.text,\n      segments: (_e = (_d = response.segments) == null ? void 0 : _d.map(segment => ({\n        text: segment.text,\n        startSecond: segment.start,\n        endSecond: segment.end\n      }))) != null ? _e : [],\n      language: response.language,\n      durationInSeconds: response.duration,\n      warnings,\n      response: {\n        timestamp: currentDate,\n        modelId: this.modelId,\n        headers: responseHeaders,\n        body: rawResponse\n      }\n    };\n  }\n};\nvar groqTranscriptionResponseSchema = external_exports.object({\n  task: external_exports.string(),\n  language: external_exports.string(),\n  duration: external_exports.number(),\n  text: external_exports.string(),\n  segments: external_exports.array(external_exports.object({\n    id: external_exports.number(),\n    seek: external_exports.number(),\n    start: external_exports.number(),\n    end: external_exports.number(),\n    text: external_exports.string(),\n    tokens: external_exports.array(external_exports.number()),\n    temperature: external_exports.number(),\n    avg_logprob: external_exports.number(),\n    compression_ratio: external_exports.number(),\n    no_speech_prob: external_exports.number()\n  })),\n  x_groq: external_exports.object({\n    id: external_exports.string()\n  })\n});\nfunction createGroq(options = {}) {\n  var _a20;\n  const baseURL = (_a20 = withoutTrailingSlash3(options.baseURL)) != null ? _a20 : \"https://api.groq.com/openai/v1\";\n  const getHeaders = () => ({\n    Authorization: `Bearer ${loadApiKey2({\n      apiKey: options.apiKey,\n      environmentVariableName: \"GROQ_API_KEY\",\n      description: \"Groq\"\n    })}`,\n    ...options.headers\n  });\n  const createChatModel = (modelId, settings = {}) => new GroqChatLanguageModel(modelId, settings, {\n    provider: \"groq.chat\",\n    url: ({\n      path\n    }) => `${baseURL}${path}`,\n    headers: getHeaders,\n    fetch: options.fetch\n  });\n  const createLanguageModel = (modelId, settings) => {\n    if (new.target) {\n      throw new Error(\"The Groq model function cannot be called with the new keyword.\");\n    }\n    return createChatModel(modelId, settings);\n  };\n  const createTranscriptionModel = modelId => {\n    return new GroqTranscriptionModel(modelId, {\n      provider: \"groq.transcription\",\n      url: ({\n        path\n      }) => `${baseURL}${path}`,\n      headers: getHeaders,\n      fetch: options.fetch\n    });\n  };\n  const provider = function (modelId, settings) {\n    return createLanguageModel(modelId, settings);\n  };\n  provider.languageModel = createLanguageModel;\n  provider.chat = createChatModel;\n  provider.textEmbeddingModel = modelId => {\n    throw new NoSuchModelError2({\n      modelId,\n      modelType: \"textEmbeddingModel\"\n    });\n  };\n  provider.transcription = createTranscriptionModel;\n  return provider;\n}\nvar groq = createGroq();\n\n// src/store/agentConnection/providers/ai-sdk.ts\nimport { createXai } from \"@ai-sdk/xai\";\nvar providerImplementations = {\n  openai: apiKey => createOpenAI({\n    apiKey\n  }),\n  anthropic: apiKey => createAnthropic({\n    apiKey\n  }),\n  google: apiKey => createGoogleGenerativeAI({\n    apiKey\n  }),\n  mistral: apiKey => createMistral({\n    apiKey\n  }),\n  groq: apiKey => createGroq({\n    apiKey\n  }),\n  xai: apiKey => createXai({\n    apiKey\n  })\n};\nfunction parseModelString(modelString) {\n  const [provider, ...modelParts] = modelString.split(\"/\");\n  const model = modelParts.join(\"/\");\n  if (!provider || !model) {\n    throw new Error(`Invalid model format: ${modelString}. Expected format: \"provider/model\" (e.g., \"openai/gpt-4o\", \"anthropic/claude-3-sonnet\")`);\n  }\n  return {\n    provider,\n    model\n  };\n}\nvar aiSDKProvider = {\n  callLLM: async (params, config2) => {\n    const {\n      model: modelString,\n      prompt,\n      systemPrompt,\n      temperature,\n      ...rest\n    } = params;\n    const {\n      provider: providerName,\n      model\n    } = parseModelString(modelString);\n    const providerConfig = config2.providers[providerName];\n    if (!providerConfig) {\n      throw new Error(`Provider ${providerName} not configured. Available providers: ${Object.keys(config2.providers).join(\", \")}`);\n    }\n    const getProvider = providerImplementations[providerName];\n    if (!getProvider) {\n      throw new Error(`Provider ${providerName} not supported. Supported providers: ${Object.keys(providerImplementations).join(\", \")}`);\n    }\n    const provider = getProvider(providerConfig.apiKey);\n    const modelName = providerName === \"google\" ? model.replace(\"gemini-\", \"\") : model;\n    const modelInstance = provider(modelName);\n    const result = await generateText({\n      model: modelInstance,\n      messages: [{\n        role: \"user\",\n        content: prompt || \"\"\n      }],\n      system: systemPrompt,\n      temperature,\n      maxRetries: 3,\n      ...rest\n    });\n    return {\n      content: result.text,\n      usage: result.usage ? {\n        promptTokens: result.usage.promptTokens || 0,\n        completionTokens: result.usage.completionTokens || 0,\n        totalTokens: result.usage.totalTokens || 0\n      } : void 0,\n      metadata: {\n        model: modelString,\n        finishReason: result.finishReason\n      }\n    };\n  },\n  callLLMStructured: async (params, config2) => {\n    const {\n      model: modelString,\n      prompt,\n      systemPrompt,\n      temperature,\n      schema,\n      // This is now statically typed as z.ZodType<unknown>\n      schemaName,\n      schemaDescription,\n      ...rest\n    } = params;\n    const {\n      provider: providerName,\n      model\n    } = parseModelString(modelString);\n    const providerConfig = config2.providers[providerName];\n    if (!providerConfig) {\n      throw new Error(`Provider ${providerName} not configured. Available providers: ${Object.keys(config2.providers).join(\", \")}`);\n    }\n    const getProvider = providerImplementations[providerName];\n    if (!getProvider) {\n      throw new Error(`Provider ${providerName} not supported. Supported providers: ${Object.keys(providerImplementations).join(\", \")}`);\n    }\n    const provider = getProvider(providerConfig.apiKey);\n    const modelName = providerName === \"google\" ? model.replace(\"gemini-\", \"\") : model;\n    const modelInstance = provider(modelName);\n    const result = await generateObject({\n      model: modelInstance,\n      messages: [{\n        role: \"user\",\n        content: prompt || \"\"\n      }],\n      system: systemPrompt,\n      temperature,\n      schema,\n      // Already typed as z.ZodType<unknown>\n      ...(schemaName ? {\n        schemaName\n      } : {}),\n      ...(schemaDescription ? {\n        schemaDescription\n      } : {}),\n      maxRetries: 3,\n      ...rest\n    });\n    return {\n      content: JSON.stringify(result.object),\n      object: result.object,\n      usage: result.usage ? {\n        promptTokens: result.usage.promptTokens || 0,\n        completionTokens: result.usage.completionTokens || 0,\n        totalTokens: result.usage.totalTokens || 0\n      } : void 0,\n      metadata: {\n        model: modelString,\n        finishReason: result.finishReason\n      }\n    };\n  },\n  streamLLM: (params, config2, handler) => {\n    const abortController = new AbortController();\n    const completion = (async () => {\n      try {\n        const {\n          model: modelString,\n          prompt,\n          systemPrompt,\n          temperature,\n          ...rest\n        } = params;\n        const {\n          provider: providerName,\n          model\n        } = parseModelString(modelString);\n        const providerConfig = config2.providers[providerName];\n        if (!providerConfig) {\n          throw new Error(`Provider ${providerName} not configured. Available providers: ${Object.keys(config2.providers).join(\", \")}`);\n        }\n        const getProvider = providerImplementations[providerName];\n        if (!getProvider) {\n          throw new Error(`Provider ${providerName} not supported. Supported providers: ${Object.keys(providerImplementations).join(\", \")}`);\n        }\n        const provider = getProvider(providerConfig.apiKey);\n        const modelName = providerName === \"google\" ? model.replace(\"gemini-\", \"\") : model;\n        const modelInstance = provider(modelName);\n        const result = await streamText({\n          model: modelInstance,\n          messages: [{\n            role: \"user\",\n            content: prompt || \"\"\n          }],\n          system: systemPrompt,\n          temperature,\n          maxRetries: 3,\n          abortSignal: abortController.signal,\n          ...rest\n        });\n        const completedItems = [];\n        let fullTextContent = \"\";\n        for await (const chunk of result.textStream) {\n          fullTextContent += chunk;\n          handler({\n            type: \"chunk\",\n            content: chunk\n          });\n        }\n        if (fullTextContent.trim()) {\n          completedItems.push(fullTextContent.trim());\n        }\n        handler({\n          type: \"done\",\n          completedItems\n        });\n      } catch (error40) {\n        if (error40 instanceof Error && error40.name !== \"AbortError\") {\n          handler({\n            type: \"error\",\n            error: error40\n          });\n        }\n      }\n    })();\n    return {\n      abort: () => abortController.abort(),\n      completion\n    };\n  },\n  voiceLLM: async (params, config2) => {\n    const {\n      audioData,\n      voiceSettings,\n      context\n    } = params;\n    const openaiConfig = config2.providers.openai;\n    if (!openaiConfig) {\n      throw new Error(\"OpenAI provider not configured for transcription\");\n    }\n    const openai2 = createOpenAI({\n      apiKey: openaiConfig.apiKey\n    });\n    const transcriptionModel = openai2.transcription(\"whisper-1\");\n    const audioBuffer = await audioData.arrayBuffer();\n    const transcript = await transcribe({\n      model: transcriptionModel,\n      audio: audioBuffer\n    });\n    const responseModelString = \"openai/gpt-4o-mini\";\n    const {\n      provider: responseProviderName,\n      model: responseModel\n    } = parseModelString(responseModelString);\n    const responseProviderConfig = config2.providers[responseProviderName];\n    if (!responseProviderConfig) {\n      throw new Error(`Provider ${responseProviderName} not configured`);\n    }\n    const responseProvider = providerImplementations[responseProviderName];\n    if (!responseProvider) {\n      throw new Error(`Provider ${responseProviderName} not supported`);\n    }\n    const responseProviderInstance = responseProvider(responseProviderConfig.apiKey);\n    const modelInstance = responseProviderInstance(responseModel);\n    const systemPrompt = context ? `Context: ${JSON.stringify(context)}\n\nRespond naturally to the user's voice input.` : \"Respond naturally to the user's voice input.\";\n    const result = await generateText({\n      model: modelInstance,\n      messages: [{\n        role: \"user\",\n        content: transcript.text\n      }],\n      system: systemPrompt,\n      temperature: 0.7,\n      maxRetries: 3\n    });\n    let generatedAudioData;\n    let audioFormat;\n    if (!voiceSettings.useBrowserTTS) {\n      try {\n        const speechModel = openai2.speech(\"tts-1\");\n        const speech = await generateSpeech({\n          model: speechModel,\n          text: result.text,\n          voice: voiceSettings.voiceId || \"alloy\"\n        });\n        const audioUint8Array = speech;\n        const base64Audio = btoa(String.fromCharCode(...audioUint8Array.audioData));\n        generatedAudioData = base64Audio;\n        audioFormat = \"audio/mpeg\";\n      } catch (error40) {\n        console.warn(\"Failed to generate speech, falling back to text response:\", error40);\n      }\n    }\n    return {\n      content: result.text,\n      transcription: transcript.text,\n      audioData: generatedAudioData,\n      audioFormat,\n      usage: result.usage ? {\n        promptTokens: result.usage.promptTokens || 0,\n        completionTokens: result.usage.completionTokens || 0,\n        totalTokens: result.usage.totalTokens || 0\n      } : void 0,\n      metadata: {\n        model: responseModelString,\n        transcriptionModel: \"openai/whisper-1\",\n        language: transcript.language,\n        durationInSeconds: transcript.durationInSeconds,\n        speechModel: generatedAudioData ? \"openai/tts-1\" : void 0\n      }\n    };\n  },\n  handleResponse: async response => {\n    const data = await response.json();\n    return {\n      content: data.text || \"\",\n      usage: data.usage,\n      metadata: data.metadata\n    };\n  }\n};\n\n// src/store/agentConnection/providers/custom.ts\nvar customProvider = {\n  callLLM: async (params, config2) => {\n    if (config2.config.callLLM) {\n      return await config2.config.callLLM(params, config2);\n    }\n    throw new Error(\"Custom provider requires a callLLM function in config\");\n  },\n  callLLMStructured: async (params, config2) => {\n    if (config2.config.callLLMStructured) {\n      return await config2.config.callLLMStructured(params, config2);\n    }\n    if (config2.config.callLLM) {\n      return await config2.config.callLLM(params, config2);\n    }\n    throw new Error(\"Custom provider requires a callLLMStructured function or callLLM function in config\");\n  },\n  streamLLM: (params, config2, handler) => {\n    if (config2.config.streamLLM) {\n      return config2.config.streamLLM(params, config2, handler);\n    }\n    if (config2.config.callLLM) {\n      const abortController = new AbortController();\n      const completion = (async () => {\n        try {\n          const response = await config2.config.callLLM(params, config2);\n          handler({\n            type: \"chunk\",\n            content: response.content || \"\"\n          });\n          handler({\n            type: \"done\",\n            completedItems: [response.content || \"\"]\n          });\n        } catch (error40) {\n          handler({\n            type: \"error\",\n            error: error40\n          });\n        }\n      })();\n      return {\n        abort: () => abortController.abort(),\n        completion\n      };\n    }\n    throw new Error(\"Custom provider requires a streamLLM function or callLLM function in config\");\n  },\n  voiceLLM: async (params, config2) => {\n    if (config2.config.voiceLLM) {\n      return await config2.config.voiceLLM(params, config2);\n    }\n    return {\n      content: \"\"\n    };\n  },\n  handleResponse: async response => {\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.json();\n    return {\n      content: data.content || data.message || \"\",\n      usage: data.usage,\n      metadata: data.metadata || {}\n    };\n  }\n};\n\n// src/store/agentConnection/providers/index.ts\nvar providerRegistry = {\n  openai: openAIProvider,\n  anthropic: openAIProvider,\n  // Anthropic can use OpenAI-compatible endpoints\n  mastra: mastraProvider,\n  \"ai-sdk\": aiSDKProvider,\n  custom: customProvider\n  // Custom providers use their own implementation\n};\nfunction getProviderImplementation(config2) {\n  return providerRegistry[config2.provider];\n}\n\n// src/store/agentConnection/responseProcessors/setStateResponseProcessor.ts\nvar setStateResponseProcessor = {\n  type: \"setState\",\n  namespace: \"default\",\n  execute: async (obj, store) => {\n    const args = \"args\" in obj ? obj.args : void 0;\n    store.executeStateSetter({\n      key: obj.stateKey,\n      setterKey: obj.setterKey,\n      options: {\n        isDiff: true\n      },\n      args\n    });\n    store.addMessage(obj);\n  },\n  validate: obj => (obj.type === \"setState\" || obj.type === \"action\") && \"stateKey\" in obj && \"setterKey\" in obj && typeof obj.stateKey === \"string\" && typeof obj.setterKey === \"string\"\n};\n\n// src/store/agentConnection/responseProcessors/legacyActionResponseProcessor.ts\nvar legacyActionResponseProcessor = {\n  type: \"action\",\n  namespace: \"default\",\n  execute: async (obj, store) => {\n    const args = \"args\" in obj && Array.isArray(obj.args) ? obj.args : [];\n    store.executeStateSetter({\n      key: obj.stateKey,\n      setterKey: obj.setterKey,\n      options: {\n        isDiff: true\n      },\n      args\n    });\n    store.addMessage(obj);\n  },\n  validate: obj => obj.type === \"action\" && \"stateKey\" in obj && \"setterKey\" in obj && typeof obj.stateKey === \"string\" && typeof obj.setterKey === \"string\"\n};\n\n// src/store/agentContext/AgentContextTypes.ts\nvar ContextEntrySchema = zod_default.object({\n  id: zod_default.string(),\n  source: zod_default.enum([\"mention\", \"subscription\", \"manual\", \"function\"]),\n  data: zod_default.unknown(),\n  metadata: zod_default.object({\n    label: zod_default.string().optional(),\n    icon: zod_default.unknown().optional(),\n    // ReactNode - can't validate with Zod\n    color: zod_default.string().optional(),\n    showInChat: zod_default.boolean().optional(),\n    order: zod_default.number().optional()\n  }).catchall(zod_default.unknown()).optional()\n});\nvar AdditionalContextSchema = zod_default.record(zod_default.union([ContextEntrySchema, zod_default.array(ContextEntrySchema)]));\nvar createChatRequestSchema = additionalContextSchema => zod_default.object({\n  message: zod_default.string(),\n  systemPrompt: zod_default.string().optional(),\n  temperature: zod_default.number().min(0).max(2).optional(),\n  maxTokens: zod_default.number().positive().optional(),\n  stream: zod_default.boolean().optional(),\n  additionalContext: (additionalContextSchema || AdditionalContextSchema).optional()\n});\nvar ChatRequestSchema = createChatRequestSchema();\nvar ChatResponseSchema = zod_default.object({\n  content: zod_default.string(),\n  usage: zod_default.object({\n    promptTokens: zod_default.number(),\n    completionTokens: zod_default.number(),\n    totalTokens: zod_default.number()\n  }).optional(),\n  metadata: zod_default.record(zod_default.unknown()).optional(),\n  object: zod_default.union([zod_default.record(zod_default.unknown()), zod_default.array(zod_default.record(zod_default.unknown()))]).optional()\n});\nfunction AdditionalContextParamSchema(dataSchemas) {\n  const contextEntrySchema = zod_default.object({\n    data: zod_default.unknown(),\n    source: zod_default.enum([\"mention\", \"subscription\", \"manual\", \"function\"])\n  });\n  const schemaFields = {\n    frontendTools: zod_default.record(zod_default.string(), zod_default.unknown()).optional(),\n    stateSetters: zod_default.record(zod_default.string(), zod_default.unknown()).optional(),\n    schemas: zod_default.record(zod_default.string(), zod_default.unknown()).optional()\n  };\n  for (const [key, schema] of Object.entries(dataSchemas)) {\n    if (schema instanceof zod_default.ZodOptional) {\n      const innerSchema = schema.unwrap();\n      if (innerSchema instanceof zod_default.ZodArray) {\n        schemaFields[key] = zod_default.array(contextEntrySchema.extend({\n          data: innerSchema.element\n        })).optional();\n      } else {\n        schemaFields[key] = contextEntrySchema.extend({\n          data: innerSchema\n        }).optional();\n      }\n    } else if (schema instanceof zod_default.ZodArray) {\n      schemaFields[key] = zod_default.array(contextEntrySchema.extend({\n        data: schema.element\n      }));\n    } else {\n      schemaFields[key] = contextEntrySchema.extend({\n        data: schema\n      });\n    }\n  }\n  return zod_default.object(schemaFields);\n}\n\n// src/store/agentConnection/AgentConnectionTypes.ts\nvar BaseParamsSchema2 = (dataSchemas, extraFieldsSchema) => external_exports.object({\n  prompt: external_exports.string().optional(),\n  systemPrompt: external_exports.string().optional(),\n  temperature: external_exports.number().optional(),\n  maxTokens: external_exports.number().optional(),\n  stream: external_exports.boolean().optional(),\n  additionalContext: dataSchemas ? AdditionalContextParamSchema(dataSchemas).optional() : external_exports.unknown().optional()\n}).and(extraFieldsSchema || external_exports.object({}));\nvar MastraParamsSchema = (dataSchemas, extraFieldsSchema) => BaseParamsSchema2(dataSchemas, extraFieldsSchema).and(external_exports.object({\n  route: external_exports.string().optional(),\n  resourceId: external_exports.string().optional(),\n  threadId: external_exports.string().optional()\n}));\nvar CustomParamsSchema = (dataSchemas, extraFieldsSchema) => BaseParamsSchema2(dataSchemas, extraFieldsSchema).and(external_exports.object({\n  userId: external_exports.string().optional(),\n  threadId: external_exports.string().optional()\n}));\nvar OpenAIParamsSchema = BaseParamsSchema2().and(external_exports.object({\n  model: external_exports.string()\n}));\nvar AnthropicParamsSchema = BaseParamsSchema2().and(external_exports.object({\n  model: external_exports.string()\n}));\nvar AISDKParamsSchema = BaseParamsSchema2().and(external_exports.object({\n  model: external_exports.string()\n  // Format: \"provider/model\" e.g., \"openai/gpt-4o\"\n}));\nvar BaseStructuredResponseSchema = external_exports.object({\n  type: external_exports.string(),\n  content: external_exports.string().optional()\n}).passthrough();\nvar StructuredResponseSchema = type => external_exports.object({\n  type: external_exports.literal(type),\n  content: external_exports.string().optional()\n}).passthrough();\nvar LLMResponseSchema = objectSchema => external_exports.object({\n  content: external_exports.string(),\n  object: objectSchema ? external_exports.union([objectSchema, external_exports.array(objectSchema)]).optional() : external_exports.union([BaseStructuredResponseSchema, external_exports.array(BaseStructuredResponseSchema)]).optional(),\n  usage: external_exports.object({\n    promptTokens: external_exports.number(),\n    completionTokens: external_exports.number(),\n    totalTokens: external_exports.number()\n  }).optional(),\n  metadata: external_exports.record(external_exports.unknown()).optional()\n});\nvar StreamEventSchema = external_exports.discriminatedUnion(\"type\", [\n// Content chunk event\nexternal_exports.object({\n  type: external_exports.literal(\"chunk\"),\n  content: external_exports.string()\n}),\n// Structured object event\nexternal_exports.object({\n  type: external_exports.literal(\"object\"),\n  object: external_exports.union([BaseStructuredResponseSchema, external_exports.array(BaseStructuredResponseSchema)])\n}),\n// Completion event\nexternal_exports.object({\n  type: external_exports.literal(\"done\"),\n  completedItems: external_exports.array(external_exports.union([external_exports.string(), external_exports.record(external_exports.unknown())]))\n  // Used for logging\n}),\n// Error event\nexternal_exports.object({\n  type: external_exports.literal(\"error\"),\n  error: external_exports.unknown()\n  // Could be Error object or string\n})]);\nvar VoiceLLMResponseSchema = objectSchema => LLMResponseSchema(objectSchema).and(external_exports.object({\n  transcription: external_exports.string().optional(),\n  audioData: external_exports.string().optional(),\n  // Base64 encoded audio\n  audioUrl: external_exports.string().optional(),\n  audioFormat: external_exports.string().optional()\n}));\n\n// src/store/agentConnection/responseProcessors/messageResponseProcessor.ts\nvar messageResponseProcessor = {\n  type: \"message\",\n  namespace: \"default\",\n  execute: (obj, store) => {\n    const role = obj.role || \"assistant\";\n    const content = obj.content;\n    store.addMessage({\n      role,\n      type: \"text\",\n      content\n    });\n  },\n  validate: obj => obj.type === \"message\" && typeof obj.content === \"string\"\n};\nvar BackendMessageResponseSchema = StructuredResponseSchema(\"message\").and(external_exports.object({\n  role: external_exports.enum([\"user\", \"assistant\", \"bot\"]).optional(),\n  content: external_exports.string()\n}));\n\n// src/store/agentConnection/responseProcessors/progressUpdateResponseProcessor.ts\nfunction isProgressUpdateResponse(obj) {\n  return obj && typeof obj === \"object\" && obj.type === \"progress_update\" && typeof obj.text === \"string\" && [\"in_progress\", \"complete\", \"error\"].includes(obj.state);\n}\nfunction isProgressMessage(m) {\n  return !!m && m.type === \"progress_update\";\n}\nvar progressUpdateResponseProcessor = createResponseProcessor({\n  type: \"progress_update\",\n  namespace: \"custom\",\n  execute: async (obj, store) => {\n    const messages = [...store.messages];\n    const last = messages[messages.length - 1];\n    if (obj.state === \"in_progress\") {\n      if (isProgressMessage(last) && last.state === \"in_progress\") {\n        messages[messages.length - 1] = {\n          ...last,\n          text: obj.text\n        };\n      } else {\n        messages.push({\n          id: `message-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`,\n          role: \"assistant\",\n          type: \"progress_update\",\n          text: obj.text,\n          state: \"in_progress\"\n        });\n      }\n      store.setMessages(messages);\n      return;\n    }\n    if (obj.state === \"complete\" || obj.state === \"error\") {\n      const newState = obj.state;\n      const filtered = messages.filter(m => !(m.type === \"progress_update\" && m.state === \"in_progress\"));\n      filtered.push({\n        id: `message-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`,\n        role: \"assistant\",\n        type: \"progress_update\",\n        text: obj.text,\n        state: newState\n      });\n      store.setMessages(filtered);\n    }\n  },\n  validate: isProgressUpdateResponse\n});\nvar ProgressUpdateResponseSchema = StructuredResponseSchema(\"progress_update\").and(external_exports.object({\n  state: external_exports.enum([\"in_progress\", \"complete\", \"error\"]),\n  text: external_exports.string()\n}));\n\n// src/store/agentConnection/responseProcessors/humanInTheLoopResponseProcessor.ts\nvar humanInTheLoopResponseProcessor = {\n  type: \"humanInTheLoop\",\n  namespace: \"default\",\n  execute: async (obj, store) => {\n    const {\n      runId,\n      stepPath,\n      suspendPayload,\n      message,\n      timeoutMs\n    } = obj;\n    const stateKey = \"humanInTheLoop\";\n    const currentState = store.getCedarState(stateKey) || {};\n    const suspendInfo = {\n      runId,\n      stepPath,\n      suspendPayload,\n      suspendedAt: (/* @__PURE__ */new Date()).toISOString(),\n      state: \"suspended\",\n      threadId: store.mainThreadId,\n      messageId: \"\"\n      // Will be set after message creation\n    };\n    const newState = {\n      ...currentState,\n      [runId]: suspendInfo\n    };\n    const existingState = store.getCedarState(stateKey);\n    if (!existingState) {\n      store.registerState({\n        key: stateKey,\n        value: newState,\n        description: \"Human-in-the-loop workflow suspend/resume data\",\n        stateSetters: {\n          resume: {\n            name: \"resume\",\n            description: \"Resume a suspended workflow\",\n            execute: async (current, ...args) => {\n              const [runId2, resumeData] = args;\n              const workflow = current[runId2];\n              if (!workflow) return current;\n              const updatedState = {\n                ...current,\n                [runId2]: {\n                  ...workflow,\n                  state: \"resumed\",\n                  resumeData,\n                  resumedAt: (/* @__PURE__ */new Date()).toISOString()\n                }\n              };\n              if (workflow.messageId) {\n                const originalMessage = store.getMessageById(workflow.messageId);\n                if (originalMessage) {\n                  const resumedMessage = {\n                    ...originalMessage,\n                    id: void 0,\n                    // Let addMessage generate new ID\n                    state: \"resumed\",\n                    resumeData,\n                    resumedAt: (/* @__PURE__ */new Date()).toISOString(),\n                    content: `Successfully resumed workflow.`\n                  };\n                  store.addMessage(resumedMessage);\n                }\n              }\n              const config2 = store.providerConfig;\n              const resumePath = config2?.provider === \"mastra\" ? config2.resumePath || \"/chat/resume\" : \"/chat/resume\";\n              await store.sendMessage({\n                stream: true,\n                route: resumePath,\n                runId: runId2,\n                stepPath: workflow.stepPath,\n                resumeData\n              });\n              return updatedState;\n            }\n          },\n          cancel: {\n            name: \"cancel\",\n            description: \"Cancel a suspended workflow\",\n            execute: async (current, ...args) => {\n              const [runId2] = args;\n              const workflow = current[runId2];\n              if (!workflow) return current;\n              const updatedState = {\n                ...current,\n                [runId2]: {\n                  ...workflow,\n                  state: \"cancelled\",\n                  cancelledAt: (/* @__PURE__ */new Date()).toISOString()\n                }\n              };\n              if (workflow.messageId) {\n                const originalMessage = store.getMessageById(workflow.messageId);\n                if (originalMessage) {\n                  const cancelledMessage = {\n                    ...originalMessage,\n                    id: void 0,\n                    // Let addMessage generate new ID\n                    state: \"cancelled\",\n                    cancelledAt: (/* @__PURE__ */new Date()).toISOString(),\n                    content: `Workflow ${runId2} has been cancelled.`\n                  };\n                  store.addMessage(cancelledMessage);\n                }\n              }\n              return updatedState;\n            }\n          }\n        }\n      });\n    } else {\n      store.setCedarState(stateKey, newState);\n    }\n    const resumeCallback = async resumeData => {\n      await store.executeCustomSetter({\n        key: stateKey,\n        setterKey: \"resume\",\n        args: [runId, resumeData]\n      });\n    };\n    const cancelCallback = async () => {\n      await store.executeCustomSetter({\n        key: stateKey,\n        setterKey: \"cancel\",\n        args: [runId]\n      });\n    };\n    const chatMessage = {\n      type: \"humanInTheLoop\",\n      role: \"assistant\",\n      content: message || `Workflow ${runId} is waiting for your input...`,\n      state: \"suspended\",\n      runId,\n      stepPath,\n      suspendPayload,\n      resumeCallback,\n      cancelCallback,\n      metadata: obj.metadata\n    };\n    const addedMessage = store.addMessage(chatMessage);\n    const finalState = {\n      ...newState,\n      [runId]: {\n        ...suspendInfo,\n        messageId: addedMessage.id\n      }\n    };\n    store.setCedarState(stateKey, finalState);\n    if (timeoutMs && timeoutMs > 0) {\n      setTimeout(() => {\n        const currentWorkflowState = store.getCedarState(stateKey);\n        const workflow = currentWorkflowState?.[runId];\n        if (workflow?.state === \"suspended\") {\n          const originalMessage = store.getMessageById(addedMessage.id);\n          if (originalMessage) {\n            const timeoutMessage = {\n              ...originalMessage,\n              id: void 0,\n              // Let addMessage generate new ID\n              state: \"timeout\",\n              content: `Workflow has timed out and been cancelled.`\n            };\n            store.addMessage(timeoutMessage);\n          }\n          cancelCallback();\n        }\n      }, timeoutMs);\n    }\n  },\n  validate: obj => obj.type === \"humanInTheLoop\" && \"runId\" in obj && \"stepPath\" in obj && \"status\" in obj && obj.status === \"suspended\"\n};\n\n// src/store/agentConnection/responseProcessors/frontendToolResponseProcessor.ts\nvar FrontendToolResponseSchema = external_exports.object({\n  type: external_exports.literal(\"frontendTool\"),\n  toolName: external_exports.string(),\n  args: external_exports.unknown()\n  // Will be validated by the tool's own schema\n});\nvar frontendToolResponseProcessor = {\n  type: \"frontendTool\",\n  namespace: \"default\",\n  execute: async (obj, store) => {\n    const {\n      toolName,\n      args\n    } = obj;\n    try {\n      await store.executeTool(toolName, args);\n      const toolMessage = {\n        type: \"frontendTool\",\n        role: \"assistant\",\n        content: `Executed tool: ${toolName}`,\n        toolName,\n        args,\n        status: \"success\",\n        timestamp: (/* @__PURE__ */new Date()).toISOString()\n      };\n      store.addMessage(toolMessage);\n    } catch (error40) {\n      console.error(`Error executing frontend tool \"${toolName}\":`, error40);\n      const errorMessage = {\n        type: \"frontendTool\",\n        role: \"assistant\",\n        content: `Failed to execute tool: ${toolName}`,\n        toolName,\n        args,\n        error: error40 instanceof Error ? error40.message : String(error40),\n        status: \"error\",\n        timestamp: (/* @__PURE__ */new Date()).toISOString()\n      };\n      store.addMessage(errorMessage);\n    }\n  },\n  validate: obj => {\n    try {\n      FrontendToolResponseSchema.parse(obj);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n};\nfunction createFrontendToolResponseProcessor(config2) {\n  return {\n    type: \"frontendTool\",\n    namespace: config2.namespace || \"default\",\n    execute: async (obj, store) => {\n      if (config2.beforeExecute) {\n        await config2.beforeExecute(obj, store);\n      }\n      try {\n        await store.executeTool(obj.toolName, obj.args);\n      } catch {\n        const toolMessage2 = {\n          ...obj,\n          type: \"frontendTool\",\n          role: \"assistant\",\n          content: `Failed to execute tool: ${obj.toolName}`,\n          status: \"error\"\n        };\n        store.addMessage(toolMessage2);\n      }\n      if (config2.afterExecute) {\n        await config2.afterExecute(obj, store);\n      }\n      const toolMessage = {\n        ...obj,\n        type: \"frontendTool\",\n        role: \"assistant\",\n        content: `Executed tool: ${obj.toolName}`,\n        status: \"success\",\n        timestamp: (/* @__PURE__ */new Date()).toISOString()\n      };\n      store.addMessage(toolMessage);\n    },\n    validate: obj => {\n      if (obj.type !== \"frontendTool\") return false;\n      if (typeof obj.toolName !== \"string\") return false;\n      if (config2.toolName && obj.toolName !== config2.toolName) {\n        return false;\n      }\n      return true;\n    }\n  };\n}\n\n// src/store/agentConnection/responseProcessors/initializeResponseProcessorRegistry.ts\nvar defaultResponseProcessors = [messageResponseProcessor, setStateResponseProcessor, legacyActionResponseProcessor,\n// Backwards compatibility for 'action' type\nprogressUpdateResponseProcessor, humanInTheLoopResponseProcessor,\n// Human-in-the-loop workflow support\nfrontendToolResponseProcessor\n// Frontend tool execution support\n];\nvar initializeResponseProcessorRegistry = processors => {\n  const registry2 = {};\n  processors.forEach(processor => {\n    const existing = registry2[processor.type];\n    if (!existing) {\n      registry2[processor.type] = processor;\n    }\n  });\n  return registry2;\n};\n\n// src/store/agentConnection/agentConnectionSlice.ts\nvar createAgentConnectionSlice = (set2, get) => ({\n  // Default state\n  isConnected: false,\n  isStreaming: false,\n  providerConfig: null,\n  currentAbortController: null,\n  notificationInterval: void 0,\n  currentRequestId: null,\n  responseProcessors: initializeResponseProcessorRegistry(defaultResponseProcessors),\n  // Core methods with runtime type checking\n  callLLM: async params => {\n    const config2 = get().providerConfig;\n    if (!config2) {\n      throw new Error(\"No LLM provider configured\");\n    }\n    switch (config2.provider) {\n      case \"openai\":\n      case \"anthropic\":\n        if (!(\"model\" in params)) {\n          throw new Error(`${config2.provider} provider requires 'model' parameter`);\n        }\n        break;\n      case \"mastra\":\n        if (!(\"route\" in params)) {\n          throw new Error(\"Mastra provider requires 'route' parameter\");\n        }\n        break;\n      case \"ai-sdk\":\n        if (!(\"model\" in params)) {\n          throw new Error(\"AI SDK provider requires 'model' parameter\");\n        }\n        break;\n    }\n    const requestId = get().logAgentRequest(params, config2.provider);\n    set2({\n      currentRequestId: requestId\n    });\n    try {\n      const provider = getProviderImplementation(config2);\n      const response = await provider.callLLM(params, config2);\n      get().logAgentResponse(requestId, response);\n      set2({\n        currentRequestId: null\n      });\n      return response;\n    } catch (error40) {\n      get().logAgentError(requestId, error40);\n      set2({\n        currentRequestId: null\n      });\n      throw error40;\n    }\n  },\n  callLLMStructured: async params => {\n    const config2 = get().providerConfig;\n    if (!config2) {\n      throw new Error(\"No LLM provider configured\");\n    }\n    switch (config2.provider) {\n      case \"openai\":\n      case \"anthropic\":\n        if (!(\"model\" in params)) {\n          throw new Error(`${config2.provider} provider requires 'model' parameter`);\n        }\n        break;\n      case \"mastra\":\n        if (!(\"route\" in params)) {\n          throw new Error(\"Mastra provider requires 'route' parameter\");\n        }\n        break;\n      case \"ai-sdk\":\n        if (!(\"model\" in params)) {\n          throw new Error(\"AI SDK provider requires 'model' parameter\");\n        }\n        if (params.schema && typeof params.schema === \"object\" && !(\"_def\" in params.schema)) {\n          throw new Error(\"AI SDK requires a Zod schema for structured output. Please provide a valid Zod schema.\");\n        }\n        break;\n    }\n    const requestId = get().logAgentRequest(params, config2.provider);\n    set2({\n      currentRequestId: requestId\n    });\n    try {\n      const provider = getProviderImplementation(config2);\n      const response = await provider.callLLMStructured(params, config2);\n      get().logAgentResponse(requestId, response);\n      set2({\n        currentRequestId: null\n      });\n      return response;\n    } catch (error40) {\n      get().logAgentError(requestId, error40);\n      set2({\n        currentRequestId: null\n      });\n      throw error40;\n    }\n  },\n  streamLLM: (params, handler) => {\n    const config2 = get().providerConfig;\n    if (!config2) {\n      throw new Error(\"No LLM provider configured\");\n    }\n    switch (config2.provider) {\n      case \"openai\":\n      case \"anthropic\":\n        if (!(\"model\" in params)) {\n          throw new Error(`${config2.provider} provider requires 'model' parameter`);\n        }\n        break;\n      case \"mastra\":\n        if (!(\"route\" in params)) {\n          throw new Error(\"Mastra provider requires 'route' parameter\");\n        }\n        break;\n      case \"ai-sdk\":\n        if (!(\"model\" in params)) {\n          throw new Error(\"AI SDK provider requires 'model' parameter\");\n        }\n        break;\n    }\n    const streamId = get().logStreamStart(params, config2.provider);\n    set2({\n      currentRequestId: streamId\n    });\n    const provider = getProviderImplementation(config2);\n    const abortController = new AbortController();\n    set2({\n      currentAbortController: abortController,\n      isStreaming: true\n    });\n    const wrappedHandler = event => {\n      if (event.type === \"chunk\") {\n        get().logStreamChunk(streamId, event.content);\n      } else if (event.type === \"done\") {\n        get().logStreamEnd(streamId, event.completedItems);\n        set2({\n          currentRequestId: null\n        });\n      } else if (event.type === \"error\") {\n        get().logAgentError(streamId, event.error);\n        set2({\n          currentRequestId: null\n        });\n      } else if (event.type === \"object\") {\n        get().logStreamObject(streamId, event.object);\n      }\n      handler(event);\n    };\n    const originalResponse = provider.streamLLM(params, config2, wrappedHandler);\n    const wrappedCompletion = originalResponse.completion.finally(() => {\n      set2({\n        isStreaming: false,\n        currentAbortController: null\n      });\n    });\n    return {\n      abort: () => {\n        originalResponse.abort();\n        abortController.abort();\n      },\n      completion: wrappedCompletion\n    };\n  },\n  // Voice LLM method\n  voiceLLM: async params => {\n    const config2 = get().providerConfig;\n    if (!config2) {\n      throw new Error(\"No LLM provider configured\");\n    }\n    let voiceParams = params;\n    if (config2.provider === \"mastra\") {\n      const resourceId = getCedarState(\"userId\");\n      const threadId = get().mainThreadId;\n      voiceParams = {\n        ...params,\n        resourceId,\n        threadId\n      };\n    }\n    try {\n      const provider = getProviderImplementation(config2);\n      const response = await provider.voiceLLM(voiceParams, config2);\n      return response;\n    } catch (error40) {\n      throw error40;\n    }\n  },\n  // Voice streaming LLM method\n  voiceStreamLLM: (params, handler) => {\n    const config2 = get().providerConfig;\n    if (!config2) {\n      throw new Error(\"No LLM provider configured\");\n    }\n    const provider = getProviderImplementation(config2);\n    if (!provider.voiceStreamLLM) {\n      throw new Error(`Provider ${config2.provider} does not support voice streaming`);\n    }\n    let voiceParams = params;\n    if (config2.provider === \"mastra\") {\n      const resourceId = getCedarState(\"userId\");\n      const threadId = get().mainThreadId;\n      voiceParams = {\n        ...params,\n        resourceId,\n        threadId\n      };\n    }\n    const streamId = get().logStreamStart(voiceParams, config2.provider);\n    set2({\n      currentRequestId: streamId\n    });\n    const abortController = new AbortController();\n    set2({\n      currentAbortController: abortController,\n      isStreaming: true\n    });\n    const wrappedHandler = event => {\n      if (event.type === \"chunk\") {\n        get().logStreamChunk(streamId, event.content);\n      } else if (event.type === \"done\") {\n        get().logStreamEnd(streamId, event.completedItems);\n        set2({\n          currentRequestId: null\n        });\n      } else if (event.type === \"error\") {\n        get().logAgentError(streamId, event.error);\n        set2({\n          currentRequestId: null\n        });\n      } else if (event.type === \"object\") {\n        get().logStreamObject(streamId, event.object);\n      } else if (event.type === \"transcription\") {\n        get().logStreamChunk(streamId, `[Transcription] ${event.transcription}`);\n      } else if (event.type === \"audio\") {\n        get().logStreamChunk(streamId, `[Audio] ${event.audioFormat || \"unknown format\"}`);\n      }\n      handler(event);\n    };\n    const originalResponse = provider.voiceStreamLLM(voiceParams, config2, wrappedHandler);\n    const wrappedCompletion = originalResponse.completion.finally(() => {\n      set2({\n        isStreaming: false,\n        currentAbortController: null\n      });\n    });\n    return {\n      abort: () => {\n        originalResponse.abort();\n        abortController.abort();\n      },\n      completion: wrappedCompletion\n    };\n  },\n  // Handle LLM response\n  handleLLMResponse: async itemsToProcess => {\n    const state = get();\n    const requestId = state.currentRequestId;\n    for (const item of itemsToProcess) {\n      if (typeof item === \"string\") {\n        state.appendToLatestMessage(item, !state.isStreaming);\n        state.logResponseProcessorExecution({\n          type: \"text\",\n          content: item\n        }, {\n          type: \"text\",\n          namespace: \"builtin\",\n          execute: () => {}\n        }, requestId || void 0);\n      } else if (item && typeof item === \"object\") {\n        const structuredResponse = item;\n        const processed = await state.processStructuredResponse(structuredResponse);\n        if (!processed) {\n          state.addMessage({\n            role: \"bot\",\n            ...structuredResponse\n          });\n          state.logResponseProcessorExecution(structuredResponse, {\n            type: \"unhandled\",\n            namespace: \"fallback\",\n            execute: () => {}\n          }, requestId || void 0);\n        }\n      }\n    }\n  },\n  // Response processor methods\n  registerResponseProcessor: processor => {\n    set2(state => {\n      const type = processor.type;\n      return {\n        responseProcessors: {\n          ...state.responseProcessors,\n          [type]: processor\n        }\n      };\n    });\n  },\n  getResponseProcessors: type => {\n    return get().responseProcessors[type];\n  },\n  processStructuredResponse: async obj => {\n    const state = get();\n    const requestId = state.currentRequestId;\n    if (!obj.type || typeof obj.type !== \"string\") {\n      state.logResponseProcessorExecution(obj, {\n        type: \"untyped\",\n        namespace: \"fallback\",\n        execute: () => {}\n      }, requestId || void 0);\n      return false;\n    }\n    const processor = state.getResponseProcessors(obj.type);\n    if (!processor) {\n      state.logResponseProcessorExecution(obj, {\n        type: obj.type,\n        namespace: \"unknown\",\n        execute: () => {}\n      }, requestId || void 0);\n      return false;\n    }\n    if (processor.validate && !processor.validate(obj)) {\n      state.logResponseProcessorExecution(obj, {\n        type: processor.type,\n        namespace: \"validation-failed\",\n        execute: () => {}\n      }, requestId || void 0);\n      return false;\n    }\n    try {\n      await processor.execute(obj, state);\n      state.logResponseProcessorExecution(obj, processor, requestId || void 0);\n      return true;\n    } catch (error40) {\n      console.error(`Error executing response processor for type ${obj.type}:`, error40);\n      state.logResponseProcessorExecution(obj, {\n        type: processor.type,\n        namespace: \"execution-error\",\n        execute: () => {}\n      }, requestId || void 0);\n      return false;\n    }\n  },\n  sendMessage: async params => {\n    const {\n      model,\n      systemPrompt,\n      temperature,\n      maxTokens,\n      route,\n      stream,\n      threadId,\n      userId,\n      additionalContext,\n      ...customFields\n    } = params || {};\n    const state = get();\n    state.setIsProcessing(true);\n    try {\n      const editorContent = state.stringifyEditor();\n      const fullContext = state.stringifyInputContext();\n      const unifiedMessage = fullContext;\n      if (editorContent) {\n        state.addMessage({\n          role: \"user\",\n          type: \"text\",\n          content: editorContent\n        });\n      }\n      state.clearMentions();\n      const config2 = state.providerConfig;\n      if (!config2) {\n        throw new Error(\"No provider configured\");\n      }\n      let llmParams = {\n        prompt: unifiedMessage,\n        // Generated by Cedar\n        systemPrompt,\n        temperature,\n        maxTokens,\n        ...customFields\n      };\n      const resolvedThreadId = threadId || state.mainThreadId;\n      const resolvedUserId = userId || getCedarState(\"userId\");\n      switch (config2.provider) {\n        case \"openai\":\n        case \"anthropic\":\n          const threadMessages = state.getThreadMessages(resolvedThreadId);\n          const messagesArray = [];\n          if (systemPrompt) {\n            messagesArray.push({\n              role: \"system\",\n              content: systemPrompt\n            });\n          }\n          if (threadMessages.length > 1) {\n            const previousMessages = threadMessages.slice(0, -1);\n            previousMessages.forEach(msg => {\n              if (msg.type === \"text\" && msg.content) {\n                messagesArray.push({\n                  role: msg.role === \"user\" ? \"user\" : \"assistant\",\n                  content: msg.content\n                });\n              }\n            });\n          }\n          messagesArray.push({\n            role: \"user\",\n            content: unifiedMessage\n          });\n          llmParams = {\n            ...llmParams,\n            model: model || \"gpt-4o-mini\",\n            messages: messagesArray,\n            // Still include prompt for backward compatibility\n            prompt: unifiedMessage\n          };\n          break;\n        case \"mastra\":\n          const chatPath = config2.chatPath || \"/chat\";\n          llmParams = {\n            ...llmParams,\n            prompt: editorContent,\n            additionalContext: additionalContext || state.compileAdditionalContext(),\n            route: route || `${chatPath}`,\n            resourceId: resolvedUserId,\n            threadId: resolvedThreadId,\n            ...customFields\n          };\n          break;\n        case \"ai-sdk\":\n          const aiSDKThreadMessages = state.getThreadMessages(resolvedThreadId);\n          let aiSDKContextPrompt = unifiedMessage;\n          if (aiSDKThreadMessages.length > 1) {\n            const previousMessages = aiSDKThreadMessages.slice(0, -1);\n            const contextMessages = previousMessages.map(msg => {\n              if (msg.type === \"text\") {\n                return `${msg.role === \"user\" ? \"User\" : \"Assistant\"}: ${msg.content}`;\n              }\n              return null;\n            }).filter(Boolean).join(\"\\n\");\n            if (contextMessages) {\n              aiSDKContextPrompt = `Previous conversation:\n${contextMessages}\n\nCurrent message:\n${unifiedMessage}`;\n            }\n          }\n          llmParams = {\n            ...llmParams,\n            prompt: aiSDKContextPrompt,\n            model: model || \"openai/gpt-4o-mini\"\n          };\n          break;\n        case \"custom\":\n          llmParams = {\n            ...llmParams,\n            prompt: editorContent,\n            additionalContext: additionalContext || state.compileAdditionalContext(),\n            userId: resolvedUserId,\n            threadId: resolvedThreadId,\n            ...customFields\n          };\n          break;\n      }\n      if (stream) {\n        const startIdx = get().messages.length;\n        const streamResponse = state.streamLLM(llmParams, async event => {\n          switch (event.type) {\n            case \"chunk\":\n              await state.handleLLMResponse([event.content]);\n              break;\n            case \"object\":\n              await state.handleLLMResponse(Array.isArray(event.object) ? event.object : [event.object]);\n              break;\n            case \"done\":\n              break;\n            case \"error\":\n              console.error(\"Stream error:\", event.error);\n              break;\n          }\n        });\n        await streamResponse.completion;\n        const newMessages = get().messages.slice(startIdx);\n        for (const m of newMessages) {\n          await state.persistMessageStorageMessage(m);\n        }\n      } else {\n        const response = await state.callLLM(llmParams);\n        if (response.content) {\n          await state.handleLLMResponse([response.content]);\n        }\n        if (response.object) {\n          await state.handleLLMResponse(Array.isArray(response.object) ? response.object : [response.object]);\n        }\n      }\n      state.setChatInputContent({\n        type: \"doc\",\n        content: [{\n          type: \"paragraph\",\n          content: []\n        }]\n      });\n    } catch (error40) {\n      console.error(\"Error sending message:\", error40);\n      state.addMessage({\n        role: \"assistant\",\n        type: \"text\",\n        content: \"An error occurred while sending your message.\"\n      });\n    } finally {\n      state.setIsProcessing(false);\n    }\n  },\n  // Configuration methods\n  setProviderConfig: config2 => {\n    set2({\n      providerConfig: config2\n    });\n    if (config2.provider === \"mastra\" && config2.voiceRoute) {\n      const voiceEndpoint = `${config2.baseURL}${config2.voiceRoute}`;\n      get().updateVoiceSettings({\n        endpoint: voiceEndpoint\n      });\n    }\n  },\n  // Connection management\n  connect: async () => {\n    set2({\n      isConnected: true\n    });\n  },\n  disconnect: () => {\n    const state = get();\n    state.cancelStream();\n    set2({\n      isConnected: false\n    });\n  },\n  // Utility methods\n  cancelStream: () => {\n    const {\n      currentAbortController\n    } = get();\n    if (currentAbortController) {\n      currentAbortController.abort();\n    }\n  },\n  /* ------------------------------------------------------------------\n   * Notification polling for Mastra threads\n   * ------------------------------------------------------------------*/\n  subscribeToNotifications: () => {\n    if (get().notificationInterval !== void 0) return;\n    const provider = get().providerConfig;\n    if (!provider || provider.provider !== \"mastra\") return;\n    const baseURL = provider.baseURL;\n    const threadId = get().mainThreadId;\n    if (!threadId) return;\n    const endpoint = `${baseURL}/chat/notifications`;\n    get().notificationInterval = window.setInterval(async () => {\n      try {\n        const response = await fetch(endpoint, {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\"\n          },\n          body: JSON.stringify({\n            threadId\n          })\n        });\n        if (!response.ok) throw new Error(`HTTP ${response.status}`);\n        const data = await response.json();\n        if (Array.isArray(data?.notifications)) {\n          for (const msg of data.notifications) {\n            get().addMessage(msg);\n          }\n        }\n      } catch (err) {\n        console.warn(\"Notification polling error:\", err);\n      }\n    }, 6e4);\n  },\n  unsubscribeFromNotifications: () => {\n    const id = get().notificationInterval;\n    if (id !== void 0) {\n      clearInterval(id);\n      set2({\n        notificationInterval: void 0\n      });\n    }\n  }\n});\n\n// src/store/voice/voiceSlice.ts\nvar initialVoiceState = {\n  isVoiceEnabled: false,\n  isListening: false,\n  isSpeaking: false,\n  voicePermissionStatus: \"prompt\",\n  audioStream: null,\n  audioContext: null,\n  mediaRecorder: null,\n  voiceError: null,\n  voiceSettings: {\n    language: \"en-US\",\n    pitch: 1,\n    rate: 1,\n    volume: 1,\n    useBrowserTTS: false,\n    autoAddToMessages: true,\n    // Default to true for automatic message integration\n    stream: false\n    // Default to non-streaming\n  }\n};\nvar createVoiceSlice = (set2, get) => ({\n  ...initialVoiceState,\n  checkVoiceSupport: () => {\n    if (typeof window === \"undefined\") return false;\n    return !!(navigator.mediaDevices && typeof navigator.mediaDevices.getUserMedia === \"function\" && window.MediaRecorder && window.AudioContext);\n  },\n  requestVoicePermission: async () => {\n    try {\n      if (!get().checkVoiceSupport()) {\n        set2({\n          voicePermissionStatus: \"not-supported\",\n          voiceError: \"Voice features are not supported in this browser\"\n        });\n        return;\n      }\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n      const audioContext = new AudioContext();\n      set2({\n        audioStream: stream,\n        audioContext,\n        voicePermissionStatus: \"granted\",\n        voiceError: null\n      });\n    } catch (error40) {\n      set2({\n        voicePermissionStatus: \"denied\",\n        voiceError: error40 instanceof Error ? error40.message : \"Failed to get microphone permission\"\n      });\n    }\n  },\n  startListening: async () => {\n    const state = get();\n    if (state.voicePermissionStatus !== \"granted\") {\n      await get().requestVoicePermission();\n      if (get().voicePermissionStatus !== \"granted\") {\n        return;\n      }\n    }\n    if (!state.audioStream) {\n      set2({\n        voiceError: \"No audio stream available\"\n      });\n      return;\n    }\n    try {\n      const mediaRecorder = new MediaRecorder(state.audioStream, {\n        mimeType: \"audio/webm;codecs=opus\"\n      });\n      const audioChunks = [];\n      mediaRecorder.ondataavailable = event => {\n        if (event.data.size > 0) {\n          audioChunks.push(event.data);\n        }\n      };\n      mediaRecorder.onstop = async () => {\n        const audioBlob = new Blob(audioChunks, {\n          type: \"audio/webm\"\n        });\n        const {\n          voiceSettings\n        } = get();\n        if (voiceSettings.stream) {\n          await get().streamAudioToEndpointStream(audioBlob);\n        } else {\n          await get().streamAudioToEndpoint(audioBlob);\n        }\n      };\n      mediaRecorder.start();\n      set2({\n        mediaRecorder,\n        isListening: true,\n        voiceError: null\n      });\n    } catch (error40) {\n      set2({\n        voiceError: error40 instanceof Error ? error40.message : \"Failed to start recording\"\n      });\n    }\n  },\n  stopListening: () => {\n    const {\n      mediaRecorder\n    } = get();\n    if (mediaRecorder && mediaRecorder.state !== \"inactive\") {\n      mediaRecorder.stop();\n    }\n    set2({\n      isListening: false\n    });\n  },\n  toggleVoice: () => {\n    const {\n      isListening\n    } = get();\n    if (isListening) {\n      get().stopListening();\n    } else {\n      get().startListening();\n    }\n  },\n  streamAudioToEndpoint: async audioData => {\n    const {\n      voiceSettings\n    } = get();\n    try {\n      set2({\n        isSpeaking: false\n      });\n      get().setIsProcessing(true);\n      const providerConfig = get().providerConfig;\n      if (!providerConfig) {\n        throw new Error(\"No provider configured for voice\");\n      }\n      if ((providerConfig.provider === \"mastra\" || providerConfig.provider === \"custom\") && !voiceSettings.endpoint) {\n        throw new Error(\"Voice endpoint not configured\");\n      }\n      const contextString = get().compileAdditionalContext();\n      const response = await get().voiceLLM({\n        audioData,\n        voiceSettings,\n        context: contextString,\n        prompt: \"\"\n      });\n      await get().handleLLMVoice(response);\n    } catch (error40) {\n      set2({\n        voiceError: error40 instanceof Error ? error40.message : \"Failed to process voice\"\n      });\n      get().setIsProcessing(false);\n    }\n  },\n  streamAudioToEndpointStream: async audioData => {\n    const {\n      voiceSettings\n    } = get();\n    try {\n      set2({\n        isSpeaking: false\n      });\n      get().setIsProcessing(true);\n      const providerConfig = get().providerConfig;\n      if (!providerConfig) {\n        throw new Error(\"No provider configured for voice\");\n      }\n      if ((providerConfig.provider === \"mastra\" || providerConfig.provider === \"custom\") && !voiceSettings.endpoint) {\n        throw new Error(\"Voice endpoint not configured\");\n      }\n      const contextString = get().compileAdditionalContext();\n      const streamResponse = get().voiceStreamLLM({\n        audioData,\n        voiceSettings,\n        context: contextString,\n        prompt: \"\"\n      }, async event => {\n        switch (event.type) {\n          case \"transcription\":\n            if (voiceSettings.autoAddToMessages && event.transcription) {\n              const {\n                addMessage\n              } = get();\n              addMessage({\n                type: \"text\",\n                role: \"user\",\n                content: event.transcription,\n                metadata: {\n                  source: \"voice\",\n                  timestamp: (/* @__PURE__ */new Date()).toISOString()\n                }\n              });\n            }\n            break;\n          case \"audio\":\n            if (event.audioData && event.audioFormat) {\n              const binaryString = atob(event.audioData);\n              const bytes = new Uint8Array(binaryString.length);\n              for (let i = 0; i < binaryString.length; i++) {\n                bytes[i] = binaryString.charCodeAt(i);\n              }\n              const audioBuffer = bytes.buffer;\n              await get().playAudioResponse(audioBuffer);\n            }\n            if (event.content) {\n              get().addMessage({\n                type: \"text\",\n                role: \"bot\",\n                content: event.content,\n                metadata: {\n                  source: \"voice\",\n                  timestamp: (/* @__PURE__ */new Date()).toISOString()\n                }\n              });\n            }\n            break;\n          case \"chunk\":\n            await get().handleLLMResponse([event.content]);\n            break;\n          case \"object\":\n            await get().handleLLMResponse(Array.isArray(event.object) ? event.object : [event.object]);\n            break;\n          case \"done\":\n            get().setIsProcessing(false);\n            break;\n          case \"error\":\n            console.error(\"Voice stream error:\", event.error);\n            set2({\n              voiceError: event.error instanceof Error ? event.error.message : \"Voice stream error\"\n            });\n            get().setIsProcessing(false);\n            break;\n        }\n      });\n      await streamResponse.completion;\n    } catch (error40) {\n      set2({\n        voiceError: error40 instanceof Error ? error40.message : \"Failed to process voice stream\"\n      });\n      get().setIsProcessing(false);\n    }\n  },\n  handleLLMVoice: async response => {\n    const {\n      voiceSettings\n    } = get();\n    try {\n      set2({\n        isSpeaking: false\n      });\n      if (response.audioData && response.audioFormat) {\n        const binaryString = atob(response.audioData);\n        const bytes = new Uint8Array(binaryString.length);\n        for (let i = 0; i < binaryString.length; i++) {\n          bytes[i] = binaryString.charCodeAt(i);\n        }\n        const audioBuffer = bytes.buffer;\n        await get().playAudioResponse(audioBuffer);\n      } else if (response.audioUrl) {\n        await get().playAudioResponse(response.audioUrl);\n      } else if (response.content && voiceSettings.useBrowserTTS) {\n        if (\"speechSynthesis\" in window) {\n          const utterance = new SpeechSynthesisUtterance(response.content);\n          utterance.lang = voiceSettings.language;\n          utterance.rate = voiceSettings.rate || 1;\n          utterance.pitch = voiceSettings.pitch || 1;\n          utterance.volume = voiceSettings.volume || 1;\n          set2({\n            isSpeaking: true\n          });\n          utterance.onend = () => set2({\n            isSpeaking: false\n          });\n          speechSynthesis.speak(utterance);\n        }\n      }\n      if (voiceSettings.autoAddToMessages && response.transcription) {\n        const {\n          addMessage\n        } = get();\n        addMessage({\n          type: \"text\",\n          role: \"user\",\n          content: response.transcription,\n          metadata: {\n            source: \"voice\",\n            timestamp: (/* @__PURE__ */new Date()).toISOString()\n          }\n        });\n      }\n      const items = [];\n      if (response.content) {\n        items.push(response.content);\n      }\n      if (response.object) {\n        if (Array.isArray(response.object)) {\n          items.push(...response.object);\n        } else {\n          items.push(response.object);\n        }\n      }\n      if (items.length > 0) {\n        const {\n          handleLLMResponse\n        } = get();\n        await handleLLMResponse(items);\n      }\n      get().setIsProcessing(false);\n    } catch (error40) {\n      set2({\n        voiceError: error40 instanceof Error ? error40.message : \"Failed to process voice\"\n      });\n      get().setIsProcessing(false);\n    }\n  },\n  playAudioResponse: async audioData => {\n    try {\n      set2({\n        isSpeaking: true\n      });\n      const audio = new Audio();\n      if (typeof audioData === \"string\") {\n        audio.src = audioData;\n      } else {\n        const blob = new Blob([audioData], {\n          type: \"audio/mpeg\"\n        });\n        audio.src = URL.createObjectURL(blob);\n      }\n      audio.onended = () => {\n        set2({\n          isSpeaking: false\n        });\n        if (typeof audioData !== \"string\") {\n          URL.revokeObjectURL(audio.src);\n        }\n      };\n      await audio.play();\n    } catch (error40) {\n      set2({\n        isSpeaking: false,\n        voiceError: error40 instanceof Error ? error40.message : \"Failed to play audio\"\n      });\n    }\n  },\n  setVoiceEndpoint: endpoint => {\n    set2(state => ({\n      voiceSettings: {\n        ...state.voiceSettings,\n        endpoint\n      }\n    }));\n  },\n  updateVoiceSettings: settings => {\n    set2(state => ({\n      voiceSettings: {\n        ...state.voiceSettings,\n        ...settings\n      }\n    }));\n  },\n  setVoiceError: error40 => {\n    set2({\n      voiceError: error40\n    });\n  },\n  resetVoiceState: () => {\n    const {\n      audioStream,\n      audioContext,\n      mediaRecorder\n    } = get();\n    if (mediaRecorder && mediaRecorder.state !== \"inactive\") {\n      mediaRecorder.stop();\n    }\n    if (audioStream) {\n      audioStream.getTracks().forEach(track => track.stop());\n    }\n    if (audioContext && audioContext.state !== \"closed\") {\n      audioContext.close();\n    }\n    set2(initialVoiceState);\n  }\n});\n\n// src/store/debugger/debuggerSlice.ts\nvar createDebuggerSlice = (set2, get) => ({\n  // Default state\n  agentConnectionLogs: [],\n  maxLogs: 50,\n  isDebugEnabled: true,\n  activeStreams: /* @__PURE__ */new Map(),\n  activeRequests: /* @__PURE__ */new Map(),\n  collapsedSections: {},\n  // Actions\n  logAgentRequest: (params, provider) => {\n    const state = get();\n    if (!state.isDebugEnabled) return \"\";\n    const requestId = `req_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`;\n    let apiRoute;\n    if (provider === \"mastra\" && \"route\" in params) {\n      apiRoute = params.route;\n    }\n    const requestTracker = {\n      requestId,\n      startTime: /* @__PURE__ */new Date(),\n      handlers: []\n    };\n    const newActiveRequests = new Map(state.activeRequests);\n    newActiveRequests.set(requestId, requestTracker);\n    const entry = {\n      id: requestId,\n      timestamp: /* @__PURE__ */new Date(),\n      type: \"request\",\n      provider,\n      apiRoute,\n      data: {\n        params\n      }\n    };\n    set2(state2 => ({\n      agentConnectionLogs: [...state2.agentConnectionLogs.slice(0, state2.maxLogs - 1), entry],\n      activeRequests: newActiveRequests\n    }));\n    return requestId;\n  },\n  logAgentResponse: (requestId, response) => {\n    const state = get();\n    if (!state.isDebugEnabled) return;\n    const requestLog = state.agentConnectionLogs.find(log => log.id === requestId && log.type === \"request\");\n    const requestTracker = state.activeRequests.get(requestId);\n    const handlers = requestTracker?.handlers || [];\n    const entry = {\n      id: `res_${requestId}`,\n      timestamp: /* @__PURE__ */new Date(),\n      type: \"response\",\n      provider: requestLog?.provider,\n      apiRoute: requestLog?.apiRoute,\n      data: {\n        response,\n        handlers: handlers.length > 0 ? handlers : void 0\n      },\n      duration: requestLog ? (/* @__PURE__ */new Date()).getTime() - requestLog.timestamp.getTime() : void 0\n    };\n    const newActiveRequests = new Map(state.activeRequests);\n    newActiveRequests.delete(requestId);\n    set2(state2 => ({\n      agentConnectionLogs: [...state2.agentConnectionLogs.slice(0, state2.maxLogs - 1), entry],\n      activeRequests: newActiveRequests\n    }));\n  },\n  logAgentError: (requestId, error40) => {\n    const state = get();\n    if (!state.isDebugEnabled) return;\n    const isStreamError = state.activeStreams.has(requestId);\n    if (isStreamError) {\n      const tracker = state.activeStreams.get(requestId);\n      let apiRoute;\n      if (tracker.provider === \"mastra\" && tracker.params && \"route\" in tracker.params) {\n        apiRoute = tracker.params.route;\n      }\n      const entry = {\n        id: requestId,\n        timestamp: tracker.startTime,\n        type: \"stream-error\",\n        provider: tracker.provider,\n        apiRoute,\n        data: {\n          params: tracker.params,\n          error: error40,\n          streamContent: tracker.chunks.join(\"\"),\n          streamObjects: tracker.objects\n        },\n        duration: (/* @__PURE__ */new Date()).getTime() - tracker.startTime.getTime()\n      };\n      const newActiveStreams = new Map(state.activeStreams);\n      newActiveStreams.delete(requestId);\n      set2(state2 => ({\n        agentConnectionLogs: [...state2.agentConnectionLogs.slice(0, state2.maxLogs - 1), entry],\n        activeStreams: newActiveStreams\n      }));\n    } else {\n      const requestLog = state.agentConnectionLogs.find(log => log.id === requestId && log.type === \"request\");\n      const entry = {\n        id: `err_${requestId}`,\n        timestamp: /* @__PURE__ */new Date(),\n        type: \"error\",\n        provider: requestLog?.provider,\n        apiRoute: requestLog?.apiRoute,\n        data: {\n          error: error40\n        },\n        duration: requestLog ? (/* @__PURE__ */new Date()).getTime() - requestLog.timestamp.getTime() : void 0\n      };\n      set2(state2 => ({\n        agentConnectionLogs: [...state2.agentConnectionLogs.slice(0, state2.maxLogs - 1), entry]\n      }));\n    }\n  },\n  logStreamStart: (params, provider) => {\n    const state = get();\n    if (!state.isDebugEnabled) return \"\";\n    const streamId = `stream_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`;\n    const tracker = {\n      streamId,\n      startTime: /* @__PURE__ */new Date(),\n      provider,\n      params,\n      chunks: [],\n      objects: [],\n      handlers: []\n    };\n    const newActiveStreams = new Map(state.activeStreams);\n    newActiveStreams.set(streamId, tracker);\n    set2({\n      activeStreams: newActiveStreams\n    });\n    return streamId;\n  },\n  logStreamChunk: (streamId, chunk) => {\n    const state = get();\n    if (!state.isDebugEnabled) return;\n    const tracker = state.activeStreams.get(streamId);\n    if (!tracker) return;\n    tracker.chunks.push(chunk);\n  },\n  logStreamObject: (streamId, object3) => {\n    const state = get();\n    if (!state.isDebugEnabled) return;\n    const tracker = state.activeStreams.get(streamId);\n    if (!tracker) return;\n    tracker.objects.push(object3);\n  },\n  logStreamEnd: (streamId, completedItems) => {\n    const state = get();\n    if (!state.isDebugEnabled) return;\n    const tracker = state.activeStreams.get(streamId);\n    if (!tracker) return;\n    let apiRoute;\n    if (tracker.provider === \"mastra\" && tracker.params && \"route\" in tracker.params) {\n      apiRoute = tracker.params.route;\n    }\n    const entry = {\n      id: streamId,\n      timestamp: tracker.startTime,\n      type: \"stream-complete\",\n      provider: tracker.provider,\n      apiRoute,\n      data: {\n        params: tracker.params,\n        streamContent: tracker.chunks.join(\"\"),\n        streamObjects: tracker.objects,\n        completedItems: completedItems || [...(tracker.chunks.length > 0 ? [tracker.chunks.join(\"\")] : []), ...tracker.objects],\n        handlers: tracker.handlers.length > 0 ? tracker.handlers : void 0\n      },\n      duration: (/* @__PURE__ */new Date()).getTime() - tracker.startTime.getTime()\n    };\n    const newActiveStreams = new Map(state.activeStreams);\n    newActiveStreams.delete(streamId);\n    set2(state2 => ({\n      agentConnectionLogs: [...state2.agentConnectionLogs.slice(0, state2.maxLogs - 1), entry],\n      activeStreams: newActiveStreams\n    }));\n  },\n  logResponseProcessorExecution: (obj, processor, requestOrStreamId) => {\n    const state = get();\n    if (!state.isDebugEnabled) return;\n    const processorName = processor.namespace ? `${processor.namespace}:${processor.type}` : processor.type;\n    const handlerInfo = {\n      processorName,\n      handledObject: obj\n    };\n    const streamTracker = requestOrStreamId ? state.activeStreams.get(requestOrStreamId) : null;\n    if (streamTracker) {\n      if (processorName === \"builtin:text\") {\n        const lastHandler = streamTracker.handlers[streamTracker.handlers.length - 1];\n        if (lastHandler && lastHandler.processorName === \"builtin:text\") {\n          const existingContent = \"content\" in lastHandler.handledObject ? String(lastHandler.handledObject.content) : \"\";\n          const newContent = \"content\" in obj ? String(obj.content) : \"\";\n          lastHandler.handledObject = {\n            type: \"text\",\n            content: existingContent + newContent\n          };\n          return;\n        }\n      }\n      streamTracker.handlers.push(handlerInfo);\n      return;\n    }\n    const requestTracker = requestOrStreamId ? state.activeRequests.get(requestOrStreamId) : null;\n    if (requestTracker) {\n      if (processorName === \"builtin:text\") {\n        const lastHandler = requestTracker.handlers[requestTracker.handlers.length - 1];\n        if (lastHandler && lastHandler.processorName === \"builtin:text\") {\n          const existingContent = \"content\" in lastHandler.handledObject ? String(lastHandler.handledObject.content) : \"\";\n          const newContent = \"content\" in obj ? String(obj.content) : \"\";\n          lastHandler.handledObject = {\n            type: \"text\",\n            content: existingContent + newContent\n          };\n          return;\n        }\n      }\n      requestTracker.handlers.push(handlerInfo);\n      return;\n    }\n    if (requestOrStreamId) {\n      const newTracker = {\n        requestId: requestOrStreamId,\n        startTime: /* @__PURE__ */new Date(),\n        handlers: [handlerInfo]\n      };\n      const newActiveRequests = new Map(state.activeRequests);\n      newActiveRequests.set(requestOrStreamId, newTracker);\n      set2({\n        activeRequests: newActiveRequests\n      });\n    }\n  },\n  clearDebugLogs: () => set2({\n    agentConnectionLogs: []\n  }),\n  setDebugEnabled: enabled => set2({\n    isDebugEnabled: enabled\n  }),\n  setMaxLogs: max => set2({\n    maxLogs: max\n  }),\n  toggleSectionCollapse: (stateKey, section) => {\n    const state = get();\n    const currentCollapsed = state.collapsedSections[stateKey]?.[section] || false;\n    set2(state2 => ({\n      collapsedSections: {\n        ...state2.collapsedSections,\n        [stateKey]: {\n          ...state2.collapsedSections[stateKey],\n          [section]: !currentCollapsed\n        }\n      }\n    }));\n  },\n  setSectionCollapse: (stateKey, section, collapsed) => {\n    set2(state => ({\n      collapsedSections: {\n        ...state.collapsedSections,\n        [stateKey]: {\n          ...state.collapsedSections[stateKey],\n          [section]: collapsed\n        }\n      }\n    }));\n  },\n  initializeSectionCollapse: (stateKey, hasDiffStates) => {\n    const state = get();\n    if (!state.collapsedSections[stateKey]) {\n      set2(state2 => ({\n        collapsedSections: {\n          ...state2.collapsedSections,\n          [stateKey]: {\n            // Collapse registered state by default if diff states are present\n            registeredState: hasDiffStates,\n            // Keep diff state expanded by default when present\n            diffState: false\n          }\n        }\n      }));\n    }\n  }\n});\n\n// src/store/spellSlice/SpellTypes.ts\nvar Hotkey = /* @__PURE__ */(Hotkey2 => {\n  Hotkey2[\"A\"] = \"a\";\n  Hotkey2[\"B\"] = \"b\";\n  Hotkey2[\"C\"] = \"c\";\n  Hotkey2[\"D\"] = \"d\";\n  Hotkey2[\"E\"] = \"e\";\n  Hotkey2[\"F\"] = \"f\";\n  Hotkey2[\"G\"] = \"g\";\n  Hotkey2[\"H\"] = \"h\";\n  Hotkey2[\"I\"] = \"i\";\n  Hotkey2[\"J\"] = \"j\";\n  Hotkey2[\"K\"] = \"k\";\n  Hotkey2[\"L\"] = \"l\";\n  Hotkey2[\"M\"] = \"m\";\n  Hotkey2[\"N\"] = \"n\";\n  Hotkey2[\"O\"] = \"o\";\n  Hotkey2[\"P\"] = \"p\";\n  Hotkey2[\"Q\"] = \"q\";\n  Hotkey2[\"R\"] = \"r\";\n  Hotkey2[\"S\"] = \"s\";\n  Hotkey2[\"T\"] = \"t\";\n  Hotkey2[\"U\"] = \"u\";\n  Hotkey2[\"V\"] = \"v\";\n  Hotkey2[\"W\"] = \"w\";\n  Hotkey2[\"X\"] = \"x\";\n  Hotkey2[\"Y\"] = \"y\";\n  Hotkey2[\"Z\"] = \"z\";\n  Hotkey2[\"F1\"] = \"f1\";\n  Hotkey2[\"F2\"] = \"f2\";\n  Hotkey2[\"F3\"] = \"f3\";\n  Hotkey2[\"F4\"] = \"f4\";\n  Hotkey2[\"F5\"] = \"f5\";\n  Hotkey2[\"F6\"] = \"f6\";\n  Hotkey2[\"F7\"] = \"f7\";\n  Hotkey2[\"F8\"] = \"f8\";\n  Hotkey2[\"F9\"] = \"f9\";\n  Hotkey2[\"F10\"] = \"f10\";\n  Hotkey2[\"F11\"] = \"f11\";\n  Hotkey2[\"F12\"] = \"f12\";\n  Hotkey2[\"ESCAPE\"] = \"escape\";\n  Hotkey2[\"ENTER\"] = \"enter\";\n  Hotkey2[\"SPACE\"] = \"space\";\n  Hotkey2[\"TAB\"] = \"tab\";\n  Hotkey2[\"DELETE\"] = \"delete\";\n  Hotkey2[\"BACKSPACE\"] = \"backspace\";\n  Hotkey2[\"ARROW_UP\"] = \"arrowup\";\n  Hotkey2[\"ARROW_DOWN\"] = \"arrowdown\";\n  Hotkey2[\"ARROW_LEFT\"] = \"arrowleft\";\n  Hotkey2[\"ARROW_RIGHT\"] = \"arrowright\";\n  Hotkey2[\"CTRL\"] = \"ctrl\";\n  Hotkey2[\"CMD\"] = \"cmd\";\n  Hotkey2[\"META\"] = \"meta\";\n  Hotkey2[\"ALT\"] = \"alt\";\n  Hotkey2[\"SHIFT\"] = \"shift\";\n  return Hotkey2;\n})(Hotkey || {});\nvar MouseEvent = /* @__PURE__ */(MouseEvent2 => {\n  MouseEvent2[\"RIGHT_CLICK\"] = \"right-click\";\n  MouseEvent2[\"DOUBLE_CLICK\"] = \"double-click\";\n  MouseEvent2[\"MIDDLE_CLICK\"] = \"middle-click\";\n  MouseEvent2[\"MOUSE_SCROLL\"] = \"mouse-scroll\";\n  MouseEvent2[\"SHIFT_CLICK\"] = \"shift+click\";\n  MouseEvent2[\"CTRL_CLICK\"] = \"ctrl+click\";\n  MouseEvent2[\"CMD_CLICK\"] = \"cmd+click\";\n  MouseEvent2[\"ALT_CLICK\"] = \"alt+click\";\n  return MouseEvent2;\n})(MouseEvent || {});\nvar SelectionEvent = /* @__PURE__ */(SelectionEvent2 => {\n  SelectionEvent2[\"TEXT_SELECT\"] = \"text-select\";\n  return SelectionEvent2;\n})(SelectionEvent || {});\nvar ActivationMode = /* @__PURE__ */(ActivationMode2 => {\n  ActivationMode2[\"TOGGLE\"] = \"toggle\";\n  ActivationMode2[\"HOLD\"] = \"hold\";\n  ActivationMode2[\"TRIGGER\"] = \"trigger\";\n  return ActivationMode2;\n})(ActivationMode || {});\n\n// src/store/spellSlice/SpellActivationManager.ts\nvar _SpellActivationManager = class _SpellActivationManager {\n  constructor() {\n    __publicField(this, \"registrations\", /* @__PURE__ */new Map());\n    __publicField(this, \"isListening\", false);\n    __publicField(this, \"lastMousePosition\", {\n      x: 0,\n      y: 0\n    });\n    // Bound event handlers (for proper removal)\n    __publicField(this, \"boundHandlers\", {\n      keydown: this.handleKeyDown.bind(this),\n      keyup: this.handleKeyUp.bind(this),\n      mousemove: this.handleMouseMove.bind(this),\n      mouseup: this.handleMouseUp.bind(this),\n      click: this.handleClick.bind(this),\n      contextmenu: this.handleContextMenu.bind(this),\n      dblclick: this.handleDoubleClick.bind(this),\n      auxclick: this.handleAuxClick.bind(this),\n      selectionchange: this.handleSelectionChange.bind(this)\n    });\n    __publicField(this, \"selectionTimeout\", null);\n  }\n  static getInstance() {\n    if (!_SpellActivationManager.instance) {\n      _SpellActivationManager.instance = new _SpellActivationManager();\n    }\n    return _SpellActivationManager.instance;\n  }\n  /**\n   * Destroy the singleton instance (primarily for testing)\n   * This allows complete reset of the manager between tests\n   */\n  static destroyInstance() {\n    if (_SpellActivationManager.instance) {\n      _SpellActivationManager.instance.reset();\n      _SpellActivationManager.instance = null;\n    }\n  }\n  /**\n   * Register a spell with its activation conditions\n   */\n  register(spellId, conditions, callbacks) {\n    const registration = {\n      spellId,\n      conditions,\n      onActivate: callbacks.onActivate,\n      onDeactivate: callbacks.onDeactivate,\n      preventDefaultEvents: callbacks.preventDefaultEvents ?? true,\n      ignoreInputElements: callbacks.ignoreInputElements ?? true,\n      isActive: false,\n      lastTriggerTime: 0,\n      isOnCooldown: false,\n      heldKeys: /* @__PURE__ */new Set(),\n      activeHoldEvent: null\n    };\n    this.registrations.set(spellId, registration);\n    this.startListening();\n  }\n  /**\n   * Reset the manager (primarily for testing)\n   * Clears all registrations and stops listening\n   */\n  reset() {\n    for (const registration of this.registrations.values()) {\n      if (registration.isActive) {\n        this.deactivateSpell(registration);\n      }\n    }\n    this.registrations.clear();\n    this.stopListening();\n    this.isListening = false;\n    this.lastMousePosition = {\n      x: 0,\n      y: 0\n    };\n    if (this.selectionTimeout) {\n      clearTimeout(this.selectionTimeout);\n      this.selectionTimeout = null;\n    }\n  }\n  /**\n   * Get registrations (primarily for testing)\n   */\n  getRegistrations() {\n    return this.registrations;\n  }\n  /**\n   * Unregister a spell\n   */\n  unregister(spellId) {\n    const registration = this.registrations.get(spellId);\n    if (registration && registration.isActive) {\n      this.deactivateSpell(registration);\n    }\n    this.registrations.delete(spellId);\n    if (this.registrations.size === 0) {\n      this.stopListening();\n    }\n  }\n  /**\n   * Get activation state for a spell\n   */\n  getActivationState(spellId) {\n    const registration = this.registrations.get(spellId);\n    return {\n      isActive: registration?.isActive ?? false\n    };\n  }\n  /**\n   * Start listening to events (if not already)\n   */\n  startListening() {\n    if (this.isListening) return;\n    this.isListening = true;\n    window.addEventListener(\"keydown\", this.boundHandlers.keydown);\n    window.addEventListener(\"keyup\", this.boundHandlers.keyup);\n    window.addEventListener(\"mousemove\", this.boundHandlers.mousemove);\n    window.addEventListener(\"mouseup\", this.boundHandlers.mouseup);\n    window.addEventListener(\"click\", this.boundHandlers.click);\n    window.addEventListener(\"contextmenu\", this.boundHandlers.contextmenu);\n    window.addEventListener(\"dblclick\", this.boundHandlers.dblclick);\n    window.addEventListener(\"auxclick\", this.boundHandlers.auxclick);\n    document.addEventListener(\"selectionchange\", this.boundHandlers.selectionchange);\n  }\n  /**\n   * Stop listening to events\n   */\n  stopListening() {\n    if (!this.isListening) return;\n    this.isListening = false;\n    window.removeEventListener(\"keydown\", this.boundHandlers.keydown);\n    window.removeEventListener(\"keyup\", this.boundHandlers.keyup);\n    window.removeEventListener(\"mousemove\", this.boundHandlers.mousemove);\n    window.removeEventListener(\"mouseup\", this.boundHandlers.mouseup);\n    window.removeEventListener(\"click\", this.boundHandlers.click);\n    window.removeEventListener(\"contextmenu\", this.boundHandlers.contextmenu);\n    window.removeEventListener(\"dblclick\", this.boundHandlers.dblclick);\n    window.removeEventListener(\"auxclick\", this.boundHandlers.auxclick);\n    document.removeEventListener(\"selectionchange\", this.boundHandlers.selectionchange);\n    if (this.selectionTimeout) {\n      clearTimeout(this.selectionTimeout);\n      this.selectionTimeout = null;\n    }\n  }\n  /**\n   * Helper to check if event target is an input element\n   */\n  isInputElement(target, ignoreInputElements) {\n    if (!ignoreInputElements) return false;\n    if (!target || !(target instanceof HTMLElement)) return false;\n    return target.closest('input, textarea, [contenteditable=\"true\"]') !== null;\n  }\n  /**\n   * Parse hotkey combo string\n   */\n  parseHotkeyCombo(combo) {\n    const parts = combo.toLowerCase().split(\"+\");\n    const key = parts[parts.length - 1];\n    return {\n      key,\n      modifiers: {\n        ctrl: parts.includes(\"ctrl\"),\n        cmd: parts.includes(\"cmd\"),\n        meta: parts.includes(\"meta\") || parts.includes(\"cmd\"),\n        alt: parts.includes(\"alt\"),\n        shift: parts.includes(\"shift\")\n      }\n    };\n  }\n  /**\n   * Check if keyboard event matches hotkey\n   */\n  matchesHotkey(event, hotkey) {\n    if (typeof hotkey === \"string\" && hotkey.includes(\"+\")) {\n      const combo = this.parseHotkeyCombo(hotkey);\n      const keyMatches = event.key.toLowerCase() === combo.key;\n      const modifiersMatch = event.ctrlKey === combo.modifiers.ctrl && event.metaKey === combo.modifiers.meta && event.altKey === combo.modifiers.alt && event.shiftKey === combo.modifiers.shift;\n      return keyMatches && modifiersMatch;\n    } else {\n      const hasUnexpectedModifiers = event.ctrlKey || event.metaKey || event.altKey;\n      if (hasUnexpectedModifiers) {\n        return false;\n      }\n      return event.key.toLowerCase() === hotkey.toLowerCase();\n    }\n  }\n  /**\n   * Check if a string is a keyboard combo\n   */\n  isKeyboardCombo(value) {\n    return value.includes(\"+\") && !value.includes(\"click\");\n  }\n  /**\n   * Extract event types from conditions\n   */\n  extractEventTypes(events) {\n    const hotkeyEvents = events.filter(c => Object.values(Hotkey).includes(c) || typeof c === \"string\" && this.isKeyboardCombo(c));\n    const mouseEvents = events.filter(c => Object.values(MouseEvent).includes(c));\n    const selectionEvents = events.filter(c => Object.values(SelectionEvent).includes(c));\n    return {\n      hotkeyEvents,\n      mouseEvents,\n      selectionEvents\n    };\n  }\n  /**\n   * Activate a spell\n   */\n  activateSpell(registration, triggerData, event) {\n    const mode = registration.conditions.mode || \"toggle\" /* TOGGLE */;\n    const cooldown = registration.conditions.cooldown || 0;\n    if (mode === \"trigger\" /* TRIGGER */) {\n      const now2 = Date.now();\n      if (registration.isOnCooldown || now2 - registration.lastTriggerTime < cooldown) {\n        return;\n      }\n      registration.lastTriggerTime = now2;\n      if (cooldown > 0) {\n        registration.isOnCooldown = true;\n        setTimeout(() => {\n          registration.isOnCooldown = false;\n        }, cooldown);\n      }\n    }\n    if (mode === \"hold\" /* HOLD */ && event) {\n      registration.activeHoldEvent = event;\n    }\n    registration.isActive = true;\n    const state = {\n      isActive: true,\n      triggerData\n    };\n    registration.onActivate?.(state);\n    if (mode === \"trigger\" /* TRIGGER */) {\n      setTimeout(() => {\n        this.deactivateSpell(registration);\n      }, 100);\n    }\n  }\n  /**\n   * Deactivate a spell\n   */\n  deactivateSpell(registration) {\n    registration.activeHoldEvent = null;\n    registration.heldKeys.clear();\n    registration.isActive = false;\n    registration.onDeactivate?.();\n  }\n  // Event Handlers\n  handleMouseMove(event) {\n    this.lastMousePosition = {\n      x: event.clientX,\n      y: event.clientY\n    };\n  }\n  handleKeyDown(event) {\n    for (const registration of this.registrations.values()) {\n      if (this.isInputElement(event.target, registration.ignoreInputElements ?? true)) {\n        continue;\n      }\n      const {\n        hotkeyEvents\n      } = this.extractEventTypes(registration.conditions.events);\n      const mode = registration.conditions.mode || \"toggle\" /* TOGGLE */;\n      for (const hotkey of hotkeyEvents) {\n        if (this.matchesHotkey(event, hotkey)) {\n          if (registration.preventDefaultEvents) {\n            event.preventDefault();\n            event.stopPropagation();\n          }\n          const keyString = typeof hotkey === \"string\" ? hotkey : hotkey;\n          if (mode === \"toggle\" /* TOGGLE */) {\n            if (registration.isActive) {\n              this.deactivateSpell(registration);\n            } else {\n              this.activateSpell(registration, {\n                type: \"hotkey\",\n                event: hotkey,\n                mousePosition: this.lastMousePosition,\n                originalEvent: event\n              }, hotkey);\n            }\n          } else if (mode === \"hold\" /* HOLD */) {\n            if (!registration.heldKeys.has(keyString)) {\n              registration.heldKeys.add(keyString);\n              if (!registration.isActive) {\n                this.activateSpell(registration, {\n                  type: \"hotkey\",\n                  event: hotkey,\n                  mousePosition: this.lastMousePosition,\n                  originalEvent: event\n                }, hotkey);\n              }\n            }\n          } else if (mode === \"trigger\" /* TRIGGER */) {\n            if (!registration.isActive) {\n              this.activateSpell(registration, {\n                type: \"hotkey\",\n                event: hotkey,\n                mousePosition: this.lastMousePosition,\n                originalEvent: event\n              }, hotkey);\n            }\n          }\n          break;\n        }\n      }\n    }\n  }\n  handleKeyUp(event) {\n    for (const registration of this.registrations.values()) {\n      const mode = registration.conditions.mode || \"toggle\" /* TOGGLE */;\n      if (mode !== \"hold\" /* HOLD */) continue;\n      const {\n        hotkeyEvents\n      } = this.extractEventTypes(registration.conditions.events);\n      for (const hotkey of hotkeyEvents) {\n        if (this.matchesHotkey(event, hotkey)) {\n          const keyString = typeof hotkey === \"string\" ? hotkey : hotkey;\n          registration.heldKeys.delete(keyString);\n          if (registration.heldKeys.size === 0 && registration.isActive) {\n            this.deactivateSpell(registration);\n          }\n          break;\n        }\n      }\n    }\n  }\n  handleClick(event) {\n    for (const registration of this.registrations.values()) {\n      const {\n        mouseEvents\n      } = this.extractEventTypes(registration.conditions.events);\n      const mode = registration.conditions.mode || \"toggle\" /* TOGGLE */;\n      let matchedEvent = null;\n      if (event.shiftKey && mouseEvents.includes(\"shift+click\" /* SHIFT_CLICK */)) {\n        matchedEvent = \"shift+click\" /* SHIFT_CLICK */;\n      } else if (event.ctrlKey && mouseEvents.includes(\"ctrl+click\" /* CTRL_CLICK */)) {\n        matchedEvent = \"ctrl+click\" /* CTRL_CLICK */;\n      } else if (event.metaKey && mouseEvents.includes(\"cmd+click\" /* CMD_CLICK */)) {\n        matchedEvent = \"cmd+click\" /* CMD_CLICK */;\n      } else if (event.altKey && mouseEvents.includes(\"alt+click\" /* ALT_CLICK */)) {\n        matchedEvent = \"alt+click\" /* ALT_CLICK */;\n      }\n      if (matchedEvent) {\n        if (registration.preventDefaultEvents) {\n          event.preventDefault();\n          event.stopPropagation();\n        }\n        if (mode === \"toggle\" /* TOGGLE */) {\n          if (registration.isActive) {\n            this.deactivateSpell(registration);\n          } else {\n            this.activateSpell(registration, {\n              type: \"mouse\",\n              event: matchedEvent,\n              mousePosition: {\n                x: event.clientX,\n                y: event.clientY\n              },\n              originalEvent: event\n            }, matchedEvent);\n          }\n        } else {\n          this.activateSpell(registration, {\n            type: \"mouse\",\n            event: matchedEvent,\n            mousePosition: {\n              x: event.clientX,\n              y: event.clientY\n            },\n            originalEvent: event\n          }, matchedEvent);\n        }\n      }\n    }\n  }\n  handleContextMenu(event) {\n    for (const registration of this.registrations.values()) {\n      const {\n        mouseEvents\n      } = this.extractEventTypes(registration.conditions.events);\n      const mode = registration.conditions.mode || \"toggle\" /* TOGGLE */;\n      if (mouseEvents.includes(\"right-click\" /* RIGHT_CLICK */)) {\n        if (registration.preventDefaultEvents) {\n          event.preventDefault();\n        }\n        if (mode === \"hold\" /* HOLD */) {\n          this.activateSpell(registration, {\n            type: \"mouse\",\n            event: \"right-click\" /* RIGHT_CLICK */,\n            mousePosition: {\n              x: event.clientX,\n              y: event.clientY\n            },\n            originalEvent: event\n          }, \"right-click\" /* RIGHT_CLICK */);\n          const handleMouseUp = () => {\n            if (registration.activeHoldEvent === \"right-click\" /* RIGHT_CLICK */) {\n              this.deactivateSpell(registration);\n            }\n            window.removeEventListener(\"mouseup\", handleMouseUp);\n          };\n          window.addEventListener(\"mouseup\", handleMouseUp);\n        } else {\n          if (mode === \"toggle\" /* TOGGLE */ && registration.isActive) {\n            this.deactivateSpell(registration);\n          } else {\n            this.activateSpell(registration, {\n              type: \"mouse\",\n              event: \"right-click\" /* RIGHT_CLICK */,\n              mousePosition: {\n                x: event.clientX,\n                y: event.clientY\n              },\n              originalEvent: event\n            }, \"right-click\" /* RIGHT_CLICK */);\n          }\n        }\n      }\n    }\n  }\n  handleDoubleClick(event) {\n    for (const registration of this.registrations.values()) {\n      const {\n        mouseEvents\n      } = this.extractEventTypes(registration.conditions.events);\n      const mode = registration.conditions.mode || \"toggle\" /* TOGGLE */;\n      if (mouseEvents.includes(\"double-click\" /* DOUBLE_CLICK */)) {\n        if (mode === \"toggle\" /* TOGGLE */ && registration.isActive) {\n          this.deactivateSpell(registration);\n        } else {\n          this.activateSpell(registration, {\n            type: \"mouse\",\n            event: \"double-click\" /* DOUBLE_CLICK */,\n            mousePosition: {\n              x: event.clientX,\n              y: event.clientY\n            },\n            originalEvent: event\n          }, \"double-click\" /* DOUBLE_CLICK */);\n        }\n      }\n    }\n  }\n  handleAuxClick(event) {\n    if (event.button !== 1) return;\n    for (const registration of this.registrations.values()) {\n      const {\n        mouseEvents\n      } = this.extractEventTypes(registration.conditions.events);\n      const mode = registration.conditions.mode || \"toggle\" /* TOGGLE */;\n      if (mouseEvents.includes(\"middle-click\" /* MIDDLE_CLICK */)) {\n        if (registration.preventDefaultEvents) {\n          event.preventDefault();\n        }\n        if (mode === \"toggle\" /* TOGGLE */ && registration.isActive) {\n          this.deactivateSpell(registration);\n        } else {\n          this.activateSpell(registration, {\n            type: \"mouse\",\n            event: \"middle-click\" /* MIDDLE_CLICK */,\n            mousePosition: {\n              x: event.clientX,\n              y: event.clientY\n            },\n            originalEvent: event\n          }, \"middle-click\" /* MIDDLE_CLICK */);\n        }\n      }\n    }\n  }\n  handleMouseUp() {}\n  handleSelectionChange() {\n    if (this.selectionTimeout) {\n      clearTimeout(this.selectionTimeout);\n    }\n    this.selectionTimeout = setTimeout(() => {\n      const selection = window.getSelection();\n      const selectedText = selection?.toString().trim();\n      for (const registration of this.registrations.values()) {\n        const {\n          selectionEvents\n        } = this.extractEventTypes(registration.conditions.events);\n        if (selectionEvents.includes(\"text-select\" /* TEXT_SELECT */)) {\n          if (selectedText && selectedText.length > 0) {\n            this.activateSpell(registration, {\n              type: \"selection\",\n              event: \"text-select\" /* TEXT_SELECT */,\n              selectedText\n            }, \"text-select\" /* TEXT_SELECT */);\n          } else if (registration.isActive) {\n            this.deactivateSpell(registration);\n          }\n        }\n      }\n    }, 200);\n  }\n};\n__publicField(_SpellActivationManager, \"instance\", null);\nvar SpellActivationManager = _SpellActivationManager;\nvar SpellActivationManager_default = SpellActivationManager;\n\n// src/store/spellSlice/spellSlice.ts\nvar initialSpells = {};\nvar createSpellSlice = (set2, get) => {\n  return {\n    // -----------------------------------------------------------------\n    // State\n    // -----------------------------------------------------------------\n    spells: initialSpells,\n    // -----------------------------------------------------------------\n    // Actions\n    // -----------------------------------------------------------------\n    registerSpell: registration => {\n      const manager = SpellActivationManager_default.getInstance();\n      const {\n        id,\n        activationConditions,\n        onActivate,\n        onDeactivate,\n        ...options\n      } = registration;\n      set2(state => ({\n        spells: {\n          ...state.spells,\n          [id]: {\n            isActive: false,\n            registration\n          }\n        }\n      }));\n      manager.register(id, activationConditions, {\n        onActivate: state => {\n          set2(store => ({\n            spells: {\n              ...store.spells,\n              [id]: {\n                ...store.spells[id],\n                isActive: true\n              }\n            }\n          }));\n          onActivate?.(state);\n        },\n        onDeactivate: () => {\n          set2(store => ({\n            spells: {\n              ...store.spells,\n              [id]: {\n                ...store.spells[id],\n                isActive: false\n              }\n            }\n          }));\n          onDeactivate?.();\n        },\n        preventDefaultEvents: options.preventDefaultEvents,\n        ignoreInputElements: options.ignoreInputElements\n      });\n    },\n    unregisterSpell: spellId => {\n      const manager = SpellActivationManager_default.getInstance();\n      manager.unregister(spellId);\n      set2(state => {\n        const newSpells = {\n          ...state.spells\n        };\n        delete newSpells[spellId];\n        return {\n          spells: newSpells\n        };\n      });\n    },\n    activateSpell: (spellId, triggerData) => {\n      const spell = get().spells[spellId];\n      if (!spell) return;\n      set2(state => ({\n        spells: {\n          ...state.spells,\n          [spellId]: {\n            ...spell,\n            isActive: true\n          }\n        }\n      }));\n      spell.registration.onActivate?.({\n        isActive: true,\n        triggerData\n      });\n    },\n    deactivateSpell: spellId => {\n      const spell = get().spells[spellId];\n      if (!spell) return;\n      set2(state => ({\n        spells: {\n          ...state.spells,\n          [spellId]: {\n            ...spell,\n            isActive: false\n          }\n        }\n      }));\n      spell.registration.onDeactivate?.();\n    },\n    toggleSpell: spellId => {\n      const state = get();\n      const spell = state.spells[spellId];\n      if (!spell) return;\n      if (spell.isActive) {\n        state.deactivateSpell(spellId);\n      } else {\n        state.activateSpell(spellId);\n      }\n    },\n    clearSpells: () => {\n      const manager = SpellActivationManager_default.getInstance();\n      manager.reset();\n      set2({\n        spells: {}\n      });\n    }\n  };\n};\n\n// src/store/diffHistoryStateSlice/diffHistorySlice.ts\nimport { compare, applyPatch } from \"fast-json-patch\";\nimport { isEqual as isEqual2, cloneDeep } from \"lodash\";\nfunction getValueAtPath(obj, path) {\n  if (!path || path === \"\" || path === \"/\") {\n    return obj;\n  }\n  const pathParts = path.startsWith(\"/\") ? path.slice(1).split(\"/\") : path.split(\"/\");\n  let current = obj;\n  for (const part of pathParts) {\n    if (current == null || typeof current !== \"object\") {\n      return void 0;\n    }\n    current = current[part];\n  }\n  return current;\n}\nfunction setValueAtPathForDiff(obj, path, value) {\n  if (!path || path === \"\" || path === \"/\") {\n    return value;\n  }\n  const pathParts = path.startsWith(\"/\") ? path.slice(1).split(\"/\") : path.split(\"/\");\n  const result = cloneDeep(obj);\n  let current = result;\n  for (let i = 0; i < pathParts.length - 1; i++) {\n    const part = pathParts[i];\n    if (!(part in current)) {\n      current[part] = {};\n    }\n    current = current[part];\n  }\n  const lastPart = pathParts[pathParts.length - 1];\n  current[lastPart] = value;\n  return result;\n}\nfunction getItemIdentifier(item, identificationField) {\n  if (typeof identificationField === \"function\") {\n    return identificationField(item);\n  }\n  return item[identificationField];\n}\nfunction handlePrimitiveArrayDiff(params) {\n  const {\n    get,\n    key,\n    jsonPath,\n    oldArray,\n    newArray,\n    action,\n    currentDiffHistoryState,\n    targetId,\n    diffMode,\n    computeState\n  } = params;\n  const {\n    diffState,\n    history\n  } = currentDiffHistoryState;\n  let resultNewArray;\n  let resultOldArray;\n  if (action === \"accept\") {\n    resultNewArray = [...newArray];\n    if (!oldArray.includes(targetId)) {\n      resultOldArray = [...oldArray, targetId];\n    } else {\n      resultOldArray = [...oldArray];\n    }\n  } else if (action === \"reject\") {\n    const oldCount = oldArray.filter(item => item === targetId).length;\n    const newCount = newArray.filter(item => item === targetId).length;\n    if (newCount <= oldCount) {\n      resultNewArray = [...newArray];\n    } else {\n      const itemsToKeep = oldCount;\n      let keptCount = 0;\n      resultNewArray = newArray.filter(item => {\n        if (item === targetId) {\n          if (keptCount < itemsToKeep) {\n            keptCount++;\n            return true;\n          } else {\n            return false;\n          }\n        }\n        return true;\n      });\n    }\n    resultOldArray = [...oldArray];\n  } else {\n    return false;\n  }\n  const newStateWithUpdatedArray = setValueAtPathForDiff(diffState.newState, jsonPath, resultNewArray);\n  const finalOldState = setValueAtPathForDiff(diffState.oldState, jsonPath, resultOldArray);\n  const finalNewState = newStateWithUpdatedArray;\n  let finalComputedState;\n  let stillInDiffMode = false;\n  if (computeState) {\n    finalComputedState = computeState(finalOldState, finalNewState, []);\n    stillInDiffMode = !areStatesEquivalent(finalOldState, finalNewState);\n  } else {\n    finalComputedState = finalNewState;\n    stillInDiffMode = !areStatesEquivalent(finalOldState, finalNewState);\n  }\n  const updatedDiffState = {\n    oldState: finalOldState,\n    newState: finalNewState,\n    computedState: finalComputedState,\n    isDiffMode: stillInDiffMode,\n    patches: []\n  };\n  const updatedHistory = [...history, diffState];\n  const updatedDiffHistoryState = {\n    diffState: updatedDiffState,\n    history: updatedHistory,\n    redoStack: [],\n    diffMode,\n    computeState\n  };\n  get().setDiffState(key, updatedDiffHistoryState);\n  return true;\n}\nfunction areStatesEquivalent(oldState, newState) {\n  return isEqual2(oldState, newState);\n}\nfunction removeDiffMarkers(item, diffMarkerPaths) {\n  let cleanedItem = {\n    ...item\n  };\n  const pathsToCheck = diffMarkerPaths || [\"/data/diff\", \"/diff\", \"/meta/diff\"];\n  for (const path of pathsToCheck) {\n    const diffValue = getValueAtPath(cleanedItem, path);\n    if (diffValue) {\n      const pathParts = path.split(\"/\").filter(p => p);\n      if (pathParts.length === 1) {\n        const itemRecord = cleanedItem;\n        const {\n          [pathParts[0]]: _,\n          ...itemWithoutDiff\n        } = itemRecord;\n        cleanedItem = itemWithoutDiff;\n      } else {\n        const parentPathStr = \"/\" + pathParts.slice(0, -1).join(\"/\");\n        const parentValue = getValueAtPath(cleanedItem, parentPathStr);\n        if (parentValue && typeof parentValue === \"object\") {\n          const parentRecord = parentValue;\n          const diffField = pathParts[pathParts.length - 1];\n          const {\n            [diffField]: _,\n            ...parentWithoutDiff\n          } = parentRecord;\n          cleanedItem = setValueAtPathForDiff(cleanedItem, parentPathStr, parentWithoutDiff);\n        }\n      }\n    }\n  }\n  return cleanedItem;\n}\nfunction handleSingleDiff(get, key, jsonPath, identificationField, action, targetId, diffMarkerPaths) {\n  const currentDiffHistoryState = get().getDiffHistoryState(key);\n  if (!currentDiffHistoryState || !currentDiffHistoryState.diffState.isDiffMode) {\n    return false;\n  }\n  const {\n    diffState\n  } = currentDiffHistoryState;\n  const oldValue = getValueAtPath(diffState.oldState, jsonPath);\n  const newValue = getValueAtPath(diffState.newState, jsonPath);\n  const isArray = Array.isArray(oldValue) || Array.isArray(newValue);\n  if (isArray) {\n    const oldArray = oldValue;\n    const newArray = newValue;\n    if (!Array.isArray(oldArray) || !Array.isArray(newArray)) {\n      console.warn(`Value at path \"${jsonPath}\" is not consistently an array`);\n      return false;\n    }\n    return handleArrayDiff({\n      get,\n      key,\n      jsonPath,\n      oldArray,\n      newArray,\n      identificationField,\n      action,\n      currentDiffHistoryState,\n      targetId,\n      diffMarkerPaths\n    });\n  } else {\n    return handleObjectFieldDiff({\n      get,\n      key,\n      jsonPath,\n      oldValue,\n      newValue,\n      action,\n      currentDiffHistoryState,\n      diffMarkerPaths\n    });\n  }\n}\nfunction handleObjectFieldDiff(params) {\n  const {\n    get,\n    key,\n    jsonPath,\n    oldValue,\n    newValue,\n    action,\n    currentDiffHistoryState,\n    diffMarkerPaths\n  } = params;\n  const {\n    diffState,\n    history,\n    diffMode,\n    computeState\n  } = currentDiffHistoryState;\n  let finalValue;\n  if (action === \"accept\") {\n    finalValue = typeof newValue === \"object\" && newValue !== null ? removeDiffMarkers(newValue, diffMarkerPaths) : newValue;\n  } else {\n    finalValue = oldValue;\n  }\n  const updatedNewState = setValueAtPathForDiff(diffState.newState, jsonPath, finalValue);\n  const updatedOldState = action === \"accept\" ? setValueAtPathForDiff(diffState.oldState, jsonPath, finalValue) : diffState.oldState;\n  let finalComputedState;\n  let stillInDiffMode = false;\n  if (computeState) {\n    finalComputedState = computeState(updatedOldState, updatedNewState, []);\n    const checkForDiffs = obj => {\n      if (!obj || typeof obj !== \"object\") return false;\n      const pathsToCheck = diffMarkerPaths || [\"/data/diff\", \"/diff\", \"/meta/diff\"];\n      for (const path of pathsToCheck) {\n        if (getValueAtPath(obj, path)) return true;\n      }\n      for (const value of Object.values(obj)) {\n        if (checkForDiffs(value)) return true;\n      }\n      return false;\n    };\n    stillInDiffMode = checkForDiffs(finalComputedState);\n  } else {\n    finalComputedState = updatedNewState;\n  }\n  const statesAreEquivalent = areStatesEquivalent(updatedOldState, updatedNewState);\n  const finalIsDiffMode = statesAreEquivalent ? false : stillInDiffMode;\n  const updatedDiffState = {\n    oldState: updatedOldState,\n    newState: updatedNewState,\n    computedState: finalComputedState,\n    isDiffMode: finalIsDiffMode,\n    patches: []\n  };\n  const updatedHistory = [...history, diffState];\n  const updatedDiffHistoryState = {\n    diffState: updatedDiffState,\n    history: updatedHistory,\n    redoStack: [],\n    diffMode,\n    computeState\n  };\n  get().setDiffState(key, updatedDiffHistoryState);\n  return true;\n}\nfunction handleArrayDiff(params) {\n  const {\n    get,\n    key,\n    jsonPath,\n    oldArray,\n    newArray,\n    identificationField,\n    action,\n    currentDiffHistoryState,\n    targetId,\n    diffMarkerPaths\n  } = params;\n  const {\n    diffState,\n    history,\n    diffMode,\n    computeState\n  } = currentDiffHistoryState;\n  const isPrimitiveArray = oldArray.length > 0 && (typeof oldArray[0] === \"string\" || typeof oldArray[0] === \"number\" || typeof oldArray[0] === \"boolean\") || newArray.length > 0 && (typeof newArray[0] === \"string\" || typeof newArray[0] === \"number\" || typeof newArray[0] === \"boolean\");\n  if (isPrimitiveArray && targetId !== void 0) {\n    return handlePrimitiveArrayDiff({\n      get,\n      key,\n      jsonPath,\n      oldArray,\n      newArray,\n      action,\n      currentDiffHistoryState,\n      targetId,\n      diffMode,\n      computeState\n    });\n  }\n  const oldMap = new Map(oldArray.map(item => [getItemIdentifier(item, identificationField), item]));\n  const newMap = new Map(newArray.map(item => [getItemIdentifier(item, identificationField), item]));\n  const allIds = /* @__PURE__ */new Set([...oldMap.keys(), ...newMap.keys()]);\n  const changedIds = /* @__PURE__ */new Set();\n  for (const id of allIds) {\n    if (targetId !== void 0 && id !== targetId) {\n      continue;\n    }\n    const oldItem = oldMap.get(id);\n    const newItem = newMap.get(id);\n    if (!oldItem && newItem) {\n      changedIds.add(id);\n    } else if (oldItem && !newItem) {\n      changedIds.add(id);\n    } else if (oldItem && newItem) {\n      if (JSON.stringify(oldItem) !== JSON.stringify(newItem)) {\n        changedIds.add(id);\n      }\n    }\n  }\n  if (changedIds.size === 0) {\n    return false;\n  }\n  let resultArray = [];\n  if (action === \"accept\") {\n    resultArray = newArray.map(item => {\n      const itemId = getItemIdentifier(item, identificationField);\n      if (targetId !== void 0 && itemId !== targetId) {\n        return item;\n      }\n      const shouldProcessItem = targetId === void 0 || itemId === targetId;\n      if (!shouldProcessItem || !changedIds.has(itemId)) {\n        return item;\n      }\n      return removeDiffMarkers(item, diffMarkerPaths);\n    });\n  } else if (action === \"reject\") {\n    if (targetId !== void 0) {\n      for (const item of newArray) {\n        const itemId = getItemIdentifier(item, identificationField);\n        if (itemId === targetId && changedIds.has(itemId)) {\n          const oldItem = oldMap.get(itemId);\n          if (oldItem) {\n            resultArray.push(oldItem);\n          }\n        } else {\n          resultArray.push(item);\n        }\n      }\n    } else {\n      for (const item of oldArray) {\n        const itemId = getItemIdentifier(item, identificationField);\n        if (changedIds.has(itemId)) {\n          resultArray.push(item);\n        } else {\n          const newItem = newMap.get(itemId);\n          if (newItem) {\n            resultArray.push(newItem);\n          }\n        }\n      }\n    }\n  }\n  const newStateWithUpdatedArray = setValueAtPathForDiff(diffState.newState, jsonPath, resultArray);\n  let finalOldState = diffState.oldState;\n  const finalNewState = newStateWithUpdatedArray;\n  let finalComputedState;\n  if (targetId !== void 0) {\n    const currentComputedArray = getValueAtPath(diffState.computedState, jsonPath);\n    const finalComputedArray = currentComputedArray.map(item => {\n      const itemId = getItemIdentifier(item, identificationField);\n      if (itemId === targetId) {\n        const processedItem = resultArray.find(i => getItemIdentifier(i, identificationField) === targetId);\n        return processedItem || item;\n      }\n      return item;\n    }).filter(item => {\n      if (action === \"reject\") {\n        const itemId = getItemIdentifier(item, identificationField);\n        if (itemId === targetId) {\n          const oldItem = oldMap.get(itemId);\n          if (!oldItem) {\n            return false;\n          }\n        }\n      }\n      return true;\n    });\n    finalComputedState = setValueAtPathForDiff(diffState.computedState, jsonPath, finalComputedArray);\n    if (action === \"accept\") {\n      const updatedOldArray = [...oldArray];\n      const targetIndex = updatedOldArray.findIndex(item => getItemIdentifier(item, identificationField) === targetId);\n      const acceptedItem = resultArray.find(item => getItemIdentifier(item, identificationField) === targetId);\n      if (acceptedItem) {\n        if (targetIndex >= 0) {\n          updatedOldArray[targetIndex] = acceptedItem;\n        } else {\n          updatedOldArray.push(acceptedItem);\n        }\n        finalOldState = setValueAtPathForDiff(diffState.oldState, jsonPath, updatedOldArray);\n      }\n    }\n  } else {\n    finalComputedState = newStateWithUpdatedArray;\n    if (action === \"accept\") {\n      finalOldState = newStateWithUpdatedArray;\n    }\n  }\n  const stillInDiffMode = targetId !== void 0 ?\n  // For single-item, check if computed state has any remaining diff markers\n  (() => {\n    const computedArray = getValueAtPath(finalComputedState, jsonPath);\n    const pathsToCheck = diffMarkerPaths || [\"/data/diff\", \"/diff\", \"/meta/diff\"];\n    return computedArray?.some(item => {\n      for (const path of pathsToCheck) {\n        const diffValue = getValueAtPath(item, path);\n        if (diffValue === \"added\" || diffValue === \"changed\" || diffValue === \"removed\") {\n          return true;\n        }\n      }\n      return false;\n    }) || false;\n  })() : false;\n  const statesAreEquivalent = areStatesEquivalent(finalOldState, finalNewState);\n  const finalIsDiffMode = statesAreEquivalent ? false : stillInDiffMode;\n  const updatedDiffState = {\n    oldState: finalOldState,\n    newState: finalNewState,\n    computedState: finalComputedState,\n    isDiffMode: finalIsDiffMode,\n    patches: []\n  };\n  const updatedHistory = [...history, diffState];\n  const updatedDiffHistoryState = {\n    diffState: updatedDiffState,\n    history: updatedHistory,\n    redoStack: [],\n    // Clear redo stack on changes\n    diffMode,\n    computeState\n  };\n  get().setDiffState(key, updatedDiffHistoryState);\n  return true;\n}\nvar createDiffHistorySlice = (set2, get) => ({\n  diffHistoryStates: {},\n  getDiffHistoryState: key => {\n    return get().diffHistoryStates[key];\n  },\n  getDiffState: key => {\n    const diffHistoryState = get().diffHistoryStates[key];\n    return diffHistoryState?.diffState;\n  },\n  registerDiffState: config2 => {\n    const {\n      key,\n      value,\n      setValue,\n      description,\n      schema,\n      stateSetters,\n      diffMode = \"defaultAccept\",\n      computeState\n    } = config2;\n    const existingDiffState = get().getDiffHistoryState(key);\n    if (!existingDiffState) {\n      get().registerState({\n        key,\n        value,\n        setValue,\n        description,\n        schema,\n        stateSetters\n      });\n      const initialDiffHistoryState = {\n        diffState: {\n          oldState: value,\n          newState: value,\n          computedState: value,\n          // Initial state is the same for all\n          isDiffMode: false,\n          patches: []\n        },\n        history: [],\n        redoStack: [],\n        diffMode,\n        computeState\n      };\n      get().setDiffState(key, initialDiffHistoryState);\n    } else {\n      const currentNewState = existingDiffState.diffState.newState;\n      const currentComputedState = existingDiffState.diffState.computedState;\n      if (!isEqual2(currentNewState, value) && !isEqual2(currentComputedState, value)) {\n        get().newDiffState(key, value);\n      }\n    }\n  },\n  setDiffState: (key, diffHistoryState) => {\n    const oldState = diffHistoryState.diffState?.oldState;\n    const diffNewState = diffHistoryState.diffState?.newState;\n    const statesAreEquivalent = oldState && diffNewState ? areStatesEquivalent(oldState, diffNewState) : false;\n    const correctedDiffHistoryState = statesAreEquivalent && diffHistoryState.diffState?.isDiffMode ? {\n      ...diffHistoryState,\n      diffState: {\n        ...diffHistoryState.diffState,\n        isDiffMode: false\n      }\n    } : diffHistoryState;\n    set2(state => ({\n      diffHistoryStates: {\n        ...state.diffHistoryStates,\n        [key]: correctedDiffHistoryState\n      }\n    }));\n    const newState = correctedDiffHistoryState.diffState?.computedState ? correctedDiffHistoryState.diffState?.computedState : correctedDiffHistoryState.computeState ? correctedDiffHistoryState.computeState(correctedDiffHistoryState.diffState?.oldState, correctedDiffHistoryState.diffState?.newState, correctedDiffHistoryState.diffState?.patches || []) : correctedDiffHistoryState.diffState?.newState;\n    if (newState !== void 0) {\n      const registeredState = get().registeredStates?.[key];\n      if (!registeredState) {\n        get().registerState({\n          key,\n          value: newState,\n          // Change\n          description: `Diff-tracked state: ${key}`\n        });\n      } else {\n        const currentValue = registeredState.value;\n        if (!isEqual2(currentValue, newState)) {\n          set2(state => ({\n            registeredStates: {\n              ...state.registeredStates,\n              [key]: {\n                ...state.registeredStates[key],\n                value: newState\n              }\n            }\n          }));\n          registeredState.setValue?.(newState);\n        }\n      }\n    }\n  },\n  newDiffState: (key, newState, isDiffChange) => {\n    const currentDiffHistoryState = get().getDiffHistoryState(key);\n    if (!currentDiffHistoryState) {\n      console.warn(`No diff history state found for key: ${key}`);\n      return;\n    }\n    const {\n      diffState: originalDiffState,\n      history,\n      diffMode,\n      computeState\n    } = currentDiffHistoryState;\n    const effectiveIsDiffChange = isDiffChange ?? originalDiffState.isDiffMode;\n    const updatedHistory = [...history, originalDiffState];\n    let oldStateForDiff;\n    if (!effectiveIsDiffChange) {\n      oldStateForDiff = newState;\n    } else {\n      oldStateForDiff = originalDiffState.isDiffMode ? originalDiffState.oldState : originalDiffState.newState;\n    }\n    const patches = compare(oldStateForDiff, newState);\n    const computedStateValue = computeState ? computeState(oldStateForDiff, newState, patches) : diffMode === \"defaultAccept\" ? newState : oldStateForDiff;\n    const statesAreEquivalent = areStatesEquivalent(oldStateForDiff, newState);\n    const finalIsDiffMode = statesAreEquivalent ? false : effectiveIsDiffChange;\n    const newDiffState = {\n      oldState: oldStateForDiff,\n      newState,\n      computedState: computedStateValue,\n      isDiffMode: finalIsDiffMode,\n      patches\n    };\n    const updatedDiffHistoryState = {\n      diffState: newDiffState,\n      history: updatedHistory,\n      redoStack: [],\n      // Clear redo stack on new changes\n      diffMode,\n      // Keep the same diff mode\n      computeState\n      // Preserve the computeState function\n    };\n    set2(state => ({\n      diffHistoryStates: {\n        ...state.diffHistoryStates,\n        [key]: updatedDiffHistoryState\n      }\n    }));\n    const registeredState = get().registeredStates?.[key];\n    if (registeredState) {\n      const currentValue = registeredState.value;\n      if (!isEqual2(currentValue, computedStateValue)) {\n        set2(state => ({\n          registeredStates: {\n            ...state.registeredStates,\n            [key]: {\n              ...state.registeredStates[key],\n              value: computedStateValue\n            }\n          }\n        }));\n        registeredState.setValue?.(newState);\n      }\n    }\n  },\n  getCleanState: key => {\n    const diffHistoryState = get().getDiffHistoryState(key);\n    if (!diffHistoryState || !diffHistoryState.diffState) return void 0;\n    const {\n      diffState,\n      diffMode\n    } = diffHistoryState;\n    if (diffMode === \"defaultAccept\") {\n      return diffState.newState;\n    } else {\n      return diffState.oldState;\n    }\n  },\n  getComputedState: key => {\n    const diffHistoryState = get().getDiffHistoryState(key);\n    if (!diffHistoryState) return void 0;\n    return diffHistoryState.diffState.computedState;\n  },\n  setComputeStateFunction: (key, computeState) => {\n    const currentDiffHistoryState = get().getDiffHistoryState(key);\n    if (!currentDiffHistoryState) {\n      console.warn(`No diff history state found for key: ${key}`);\n      return;\n    }\n    const updatedDiffHistoryState = {\n      ...currentDiffHistoryState,\n      computeState\n    };\n    get().setDiffState(key, updatedDiffHistoryState);\n  },\n  executeDiffSetter: (key, setterKey, options = {}, args) => {\n    const isDiff = options.isDiff ?? false;\n    const currentDiffHistoryState = get().getDiffHistoryState(key);\n    if (!currentDiffHistoryState) {\n      console.warn(`No diff history state found for key: ${key}`);\n      return;\n    }\n    const currentNewState = currentDiffHistoryState.diffState.newState;\n    const registeredState = get().registeredStates?.[key];\n    if (!registeredState) {\n      console.warn(`No registered state found for key: ${key}`);\n      return;\n    }\n    const stateSetters = registeredState.stateSetters || registeredState.customSetters;\n    if (!stateSetters || !stateSetters[setterKey]) {\n      console.warn(`State setter \"${setterKey}\" not found for state \"${key}\"`);\n      return;\n    }\n    let resultState = currentNewState;\n    const setValueFunc = newValue => {\n      resultState = newValue;\n    };\n    try {\n      const setter = stateSetters[setterKey];\n      setter.execute(currentNewState, setValueFunc, args);\n      get().newDiffState(key, resultState, isDiff);\n    } catch (error40) {\n      console.error(`Error executing diff setter for \"${key}\":`, error40);\n    }\n  },\n  applyPatchesToDiffState: (key, patches, isDiffChange) => {\n    const currentDiffHistoryState = get().getDiffHistoryState(key);\n    if (!currentDiffHistoryState) {\n      console.warn(`No diff history state found for key: ${key}`);\n      return;\n    }\n    const {\n      diffState: originalDiffState,\n      history,\n      diffMode,\n      computeState\n    } = currentDiffHistoryState;\n    const updatedHistory = [...history, originalDiffState];\n    const currentNewState = cloneDeep(originalDiffState.newState);\n    const patchResult = applyPatch(currentNewState, patches, false,\n    // Don't validate (for performance)\n    false\n    // Don't mutate the original\n    ).newDocument;\n    let oldStateForDiff;\n    if (!isDiffChange) {\n      oldStateForDiff = currentNewState;\n    } else {\n      oldStateForDiff = originalDiffState.isDiffMode ? originalDiffState.oldState : originalDiffState.newState;\n    }\n    const diffPatches = compare(oldStateForDiff, patchResult);\n    const computedStateValue = computeState ? computeState(oldStateForDiff, patchResult, diffPatches) : diffMode === \"defaultAccept\" ? patchResult : oldStateForDiff;\n    const statesAreEquivalent = areStatesEquivalent(oldStateForDiff, patchResult);\n    const finalIsDiffMode = statesAreEquivalent ? false : isDiffChange;\n    const newDiffState = {\n      oldState: oldStateForDiff,\n      newState: patchResult,\n      computedState: computedStateValue,\n      isDiffMode: finalIsDiffMode,\n      patches: diffPatches\n    };\n    const updatedDiffHistoryState = {\n      diffState: newDiffState,\n      history: updatedHistory,\n      redoStack: [],\n      // Clear redo stack on new changes\n      diffMode,\n      // Keep the same diff mode\n      computeState\n      // Preserve the computeState function\n    };\n    get().setDiffState(key, updatedDiffHistoryState);\n  },\n  acceptAllDiffs: key => {\n    const currentDiffHistoryState = get().getDiffHistoryState(key);\n    if (!currentDiffHistoryState || !currentDiffHistoryState.diffState.isDiffMode) {\n      return false;\n    }\n    const {\n      diffState,\n      history,\n      diffMode,\n      computeState\n    } = currentDiffHistoryState;\n    const acceptedComputedState = computeState ? computeState(diffState.newState, diffState.newState, []) : diffState.newState;\n    const acceptedDiffState = {\n      oldState: diffState.newState,\n      // Copy newState to oldState\n      newState: diffState.newState,\n      // Keep newState as is\n      computedState: acceptedComputedState,\n      // Call computeState if available\n      isDiffMode: false,\n      // No longer in diff mode\n      patches: []\n      // Empty patches as states are synced\n    };\n    const updatedHistory = [...history, diffState];\n    const updatedDiffHistoryState = {\n      diffState: acceptedDiffState,\n      history: updatedHistory,\n      redoStack: currentDiffHistoryState.redoStack || [],\n      // Preserve redo stack\n      diffMode,\n      computeState\n      // Preserve the computeState function\n    };\n    get().setDiffState(key, updatedDiffHistoryState);\n    return true;\n  },\n  rejectAllDiffs: key => {\n    const currentDiffHistoryState = get().getDiffHistoryState(key);\n    if (!currentDiffHistoryState || !currentDiffHistoryState.diffState.isDiffMode) {\n      return false;\n    }\n    const {\n      diffState,\n      history,\n      diffMode,\n      computeState\n    } = currentDiffHistoryState;\n    const rejectedComputedState = computeState ? computeState(diffState.oldState, diffState.oldState, []) : diffState.oldState;\n    const rejectedDiffState = {\n      oldState: diffState.oldState,\n      // Keep oldState as is\n      newState: diffState.oldState,\n      // Copy oldState to newState\n      computedState: rejectedComputedState,\n      // Call computeState if available\n      isDiffMode: false,\n      // No longer in diff mode\n      patches: []\n      // Empty patches as states are synced\n    };\n    const updatedHistory = [...history, diffState];\n    const updatedDiffHistoryState = {\n      diffState: rejectedDiffState,\n      history: updatedHistory,\n      redoStack: currentDiffHistoryState.redoStack || [],\n      // Preserve redo stack\n      diffMode,\n      computeState\n      // Preserve the computeState function\n    };\n    get().setDiffState(key, updatedDiffHistoryState);\n    return true;\n  },\n  undo: key => {\n    const currentDiffHistoryState = get().getDiffHistoryState(key);\n    if (!currentDiffHistoryState || currentDiffHistoryState.history.length === 0) {\n      return false;\n    }\n    const {\n      diffState: currentDiffState,\n      history,\n      redoStack = [],\n      diffMode,\n      computeState\n    } = currentDiffHistoryState;\n    const newHistory = [...history];\n    const previousState = newHistory.pop();\n    if (!previousState) {\n      return false;\n    }\n    const newRedoStack = [...redoStack, currentDiffState];\n    const updatedDiffHistoryState = {\n      diffState: previousState,\n      history: newHistory,\n      redoStack: newRedoStack,\n      diffMode,\n      computeState\n      // Preserve the computeState function\n    };\n    get().setDiffState(key, updatedDiffHistoryState);\n    return true;\n  },\n  redo: key => {\n    const currentDiffHistoryState = get().getDiffHistoryState(key);\n    if (!currentDiffHistoryState || !currentDiffHistoryState.redoStack || currentDiffHistoryState.redoStack.length === 0) {\n      return false;\n    }\n    const {\n      diffState: currentDiffState,\n      history,\n      redoStack,\n      diffMode,\n      computeState\n    } = currentDiffHistoryState;\n    const newRedoStack = [...redoStack];\n    const redoState = newRedoStack.pop();\n    if (!redoState) {\n      return false;\n    }\n    const newHistory = [...history, currentDiffState];\n    const updatedDiffHistoryState = {\n      diffState: redoState,\n      history: newHistory,\n      redoStack: newRedoStack,\n      diffMode,\n      computeState\n      // Preserve the computeState function\n    };\n    get().setDiffState(key, updatedDiffHistoryState);\n    return true;\n  },\n  acceptDiff: (key, jsonPath, identificationField, targetId, diffMarkerPaths) => {\n    return handleSingleDiff(get, key, jsonPath, identificationField, \"accept\", targetId, diffMarkerPaths);\n  },\n  rejectDiff: (key, jsonPath, identificationField, targetId, diffMarkerPaths) => {\n    return handleSingleDiff(get, key, jsonPath, identificationField, \"reject\", targetId, diffMarkerPaths);\n  }\n});\n\n// src/store/diffHistoryStateSlice/useCedarDiffState.ts\nimport { useEffect as useEffect2, useCallback } from \"react\";\nfunction useCedarDiffState(key, initialValue, diffMode, description, customSetters, schema) {\n  const effectiveSchema = schema ?? external_exports2.any();\n  const registerStateFn = useCedarStore(s => s.registerState);\n  useEffect2(() => {\n    registerStateFn({\n      key,\n      value: initialValue,\n      description,\n      customSetters,\n      schema: effectiveSchema\n    });\n  }, [key]);\n  const getDiffHistoryState = useCedarStore(s => s.getDiffHistoryState);\n  const getCleanState = useCedarStore(s => s.getCleanState);\n  const setDiffState = useCedarStore(s => s.setDiffState);\n  const newDiffState = useCedarStore(s => s.newDiffState);\n  useEffect2(() => {\n    const existingDiffState = getDiffHistoryState(key);\n    if (!existingDiffState) {\n      const initialDiffState = {\n        oldState: initialValue,\n        newState: initialValue,\n        computedState: initialValue,\n        isDiffMode: false\n      };\n      const initialDiffHistoryState = {\n        diffState: initialDiffState,\n        history: [initialDiffState],\n        redoStack: [],\n        diffMode\n      };\n      setDiffState(key, initialDiffHistoryState);\n    }\n  }, [key]);\n  const cleanState = getCleanState(key) ?? initialValue;\n  const diffHistoryState = getDiffHistoryState(key);\n  const diffState = diffHistoryState?.diffState;\n  const stableSetState = useCallback(newValue => {\n    registerStateFn({\n      key,\n      value: newValue,\n      description,\n      customSetters,\n      schema: effectiveSchema\n    });\n    newDiffState(key, newValue, true);\n  }, [key, registerStateFn, description, customSetters, effectiveSchema, setDiffState]);\n  return [cleanState, stableSetState, diffState];\n}\n\n// src/store/diffHistoryStateSlice/useSubscribeToDiffValue.ts\nimport { useCallback as useCallback2, useMemo as useMemo2 } from \"react\";\nimport { useShallow } from \"zustand/react/shallow\";\nimport { getValueByPointer } from \"fast-json-patch\";\nimport { isEqual as isEqual3 } from \"lodash\";\nfunction useSubscribeToDiffValue(key, path, options = {}) {\n  const {\n    defaultValue,\n    equalityFn\n  } = options;\n  const selector = useCallback2(state => {\n    const diffHistoryState = state.getDiffHistoryState(key);\n    if (!diffHistoryState) {\n      return {\n        oldValue: defaultValue,\n        newValue: defaultValue,\n        isDiffMode: false,\n        diffMode: \"defaultAccept\"\n      };\n    }\n    const {\n      diffState,\n      diffMode\n    } = diffHistoryState;\n    let oldValue;\n    let newValue;\n    if (path === \"\" || path === \"/\") {\n      oldValue = diffState.oldState;\n      newValue = diffState.newState;\n    } else {\n      try {\n        oldValue = diffState.oldState && typeof diffState.oldState === \"object\" ? getValueByPointer(diffState.oldState, path) : void 0;\n      } catch {\n        oldValue = void 0;\n      }\n      try {\n        newValue = diffState.newState && typeof diffState.newState === \"object\" ? getValueByPointer(diffState.newState, path) : void 0;\n      } catch {\n        newValue = void 0;\n      }\n    }\n    return {\n      oldValue: oldValue ?? defaultValue,\n      newValue: newValue ?? defaultValue,\n      isDiffMode: diffState.isDiffMode,\n      diffMode\n    };\n  }, [key, path, defaultValue]);\n  const diffData = useCedarStore(useShallow(selector));\n  const result = useMemo2(() => {\n    const {\n      oldValue,\n      newValue,\n      isDiffMode,\n      diffMode\n    } = diffData;\n    const cleanValue = diffMode === \"defaultAccept\" ? newValue : oldValue;\n    const hasChanges = equalityFn ? !equalityFn(oldValue, newValue) : !isEqual3(oldValue, newValue);\n    return {\n      oldValue,\n      newValue,\n      isDiffMode,\n      cleanValue,\n      hasChanges\n    };\n  }, [diffData, equalityFn]);\n  return result;\n}\nfunction useSubscribeToDiffValues(key, paths, options = {}) {\n  const results = {};\n  const hookResults = paths.map(path => {\n    return useSubscribeToDiffValue(key, path, options);\n  });\n  paths.forEach((path, index) => {\n    results[path] = hookResults[index];\n  });\n  return results;\n}\n\n// src/store/diffHistoryStateSlice/useRegisterDiffState.ts\nimport { compare as compare2 } from \"fast-json-patch\";\nimport { useEffect as useEffect3 } from \"react\";\nimport { cloneDeep as cloneDeep2 } from \"lodash\";\nfunction filterPatchesByDiffChecker(patches, diffChecker) {\n  if (!diffChecker) {\n    return patches;\n  }\n  const {\n    type,\n    fields\n  } = diffChecker;\n  if (type === \"ignore\") {\n    return patches.filter(patch => {\n      return !fields.some(field => {\n        const normalizedField = field.startsWith(\"/\") ? field : `/${field}`;\n        const patchPath = patch.path;\n        return patchPath.startsWith(normalizedField);\n      });\n    });\n  } else if (type === \"listen\") {\n    return patches.filter(patch => {\n      return fields.some(field => {\n        const normalizedField = field.startsWith(\"/\") ? field : `/${field}`;\n        const patchPath = patch.path;\n        return patchPath.startsWith(normalizedField);\n      });\n    });\n  }\n  return patches;\n}\nfunction addDiffToArrayObjs(oldState, newState, idField = \"id\", diffPath = \"\", diffChecker) {\n  const isPrimitiveArray = oldState.length > 0 && (typeof oldState[0] === \"string\" || typeof oldState[0] === \"number\" || typeof oldState[0] === \"boolean\") || newState.length > 0 && (typeof newState[0] === \"string\" || typeof newState[0] === \"number\" || typeof newState[0] === \"boolean\");\n  if (isPrimitiveArray) {\n    console.warn(\"addDiffToArrayObjs called with primitive array. Primitive arrays should use handlePrimitiveArrayDiff instead.\");\n    return newState;\n  }\n  const oldMap = new Map(oldState.map(item => [item[idField], item]));\n  const newMap = new Map(newState.map(item => [item[idField], item]));\n  const result = [];\n  newState.forEach(item => {\n    const id = item[idField];\n    const oldItem = oldMap.get(id);\n    let diffType = null;\n    if (!oldItem) {\n      diffType = \"added\";\n    } else {\n      const patches = compare2(oldItem, item);\n      const filteredPatches = filterPatchesByDiffChecker(patches, diffChecker);\n      if (filteredPatches.length > 0) {\n        diffType = \"changed\";\n      }\n    }\n    if (!diffType) {\n      result.push(item);\n    } else {\n      result.push(setValueAtPath(item, diffPath, diffType));\n    }\n  });\n  oldState.forEach(oldItem => {\n    const id = oldItem[idField];\n    if (!newMap.has(id)) {\n      result.push(setValueAtPath(oldItem, diffPath, \"removed\"));\n    }\n  });\n  return result;\n}\nfunction addDiffToPrimitiveArray(oldState, newState) {\n  return [...newState];\n}\nfunction addDiffToMapObj(oldState, newState, diffPath = \"\", diffChecker) {\n  const result = {};\n  for (const [key, newItem] of Object.entries(newState)) {\n    const oldItem = oldState[key];\n    let diffType = null;\n    if (!oldItem) {\n      diffType = \"added\";\n    } else {\n      const patches = compare2(oldItem, newItem);\n      const filteredPatches = filterPatchesByDiffChecker(patches, diffChecker);\n      if (filteredPatches.length > 0) {\n        diffType = \"changed\";\n      }\n    }\n    if (!diffType) {\n      result[key] = newItem;\n    } else {\n      const itemWithDiff = setValueAtPath(newItem, diffPath, diffType);\n      result[key] = itemWithDiff;\n    }\n  }\n  for (const [key, oldItem] of Object.entries(oldState)) {\n    if (!(key in newState)) {\n      const itemWithDiff = setValueAtPath(oldItem, diffPath, \"removed\");\n      result[key] = itemWithDiff;\n    }\n  }\n  return result;\n}\nfunction setValueAtPath(obj, path, value) {\n  if (!path || path === \"\" || path === \"/\") {\n    return {\n      ...obj,\n      diff: value\n    };\n  }\n  const pathParts = path.startsWith(\"/\") ? path.slice(1).split(\"/\") : path.split(\"/\");\n  const result = cloneDeep2(obj);\n  let current = result;\n  for (let i = 0; i < pathParts.length - 1; i++) {\n    const part = pathParts[i];\n    if (!(part in current)) {\n      current[part] = {};\n    }\n    current = current[part];\n  }\n  const lastPart = pathParts[pathParts.length - 1];\n  if (typeof current === \"object\" && current !== null) {\n    const currentValue = current[lastPart];\n    current[lastPart] = {\n      ...(currentValue || {}),\n      diff: value\n    };\n  }\n  return result;\n}\nfunction useRegisterDiffState(config2) {\n  const registerDiffState = useCedarStore(state => state.registerDiffState);\n  useEffect3(() => {\n    registerDiffState(config2);\n  }, [config2.key,\n  // Intentionally exclude config.value to prevent infinite loops\n  // The value is managed by the store and synced back via setValue\n  config2.setValue, config2.description, config2.schema, config2.stateSetters, config2.diffMode, config2.computeState, registerDiffState]);\n}\n\n// src/store/diffHistoryStateSlice/useDiffState.ts\nimport { useCallback as useCallback3, useEffect as useEffect4, useRef } from \"react\";\nfunction useDiffState(key, initialValue, options) {\n  const effectiveSchema = options?.schema ?? external_exports.any();\n  const store = useCedarStore();\n  const {\n    registerDiffState,\n    getComputedState,\n    newDiffState\n  } = store;\n  const hasRegistered = useRef(false);\n  useEffect4(() => {\n    if (!hasRegistered.current) {\n      hasRegistered.current = true;\n      registerDiffState({\n        key,\n        value: initialValue,\n        // setValue is intentionally omitted to avoid circular dependencies\n        description: options?.description,\n        schema: effectiveSchema,\n        stateSetters: options?.stateSetters,\n        diffMode: options?.diffMode,\n        computeState: options?.computeState\n      });\n    }\n  }, []);\n  const computedState = getComputedState(key) ?? initialValue;\n  const setState = useCallback3(newValue => {\n    newDiffState(key, newValue);\n  }, [key, newDiffState]);\n  return [computedState, setState];\n}\nfunction useDiffStateOperations(key) {\n  const store = useCedarStore();\n  const {\n    getDiffHistoryState,\n    undo: undoFn,\n    redo: redoFn,\n    acceptAllDiffs: acceptFn,\n    rejectAllDiffs: rejectFn\n  } = store;\n  const diffHistoryState = getDiffHistoryState(key);\n  const undo = useCallback3(() => undoFn(key), [key, undoFn]);\n  const redo = useCallback3(() => redoFn(key), [key, redoFn]);\n  const acceptAllDiffs = useCallback3(() => acceptFn(key), [key, acceptFn]);\n  const rejectAllDiffs = useCallback3(() => rejectFn(key), [key, rejectFn]);\n  if (!diffHistoryState) {\n    return null;\n  }\n  return {\n    undo,\n    redo,\n    acceptAllDiffs,\n    rejectAllDiffs,\n    oldState: diffHistoryState.diffState.oldState,\n    newState: diffHistoryState.diffState.newState\n  };\n}\n\n// src/store/diffHistoryStateSlice/useDiffStateHelpers.ts\nimport { useCallback as useCallback4 } from \"react\";\nvar useDiffStateHelpers = key => {\n  const computedValue = useCedarStore(state => {\n    const diffHistoryState = state.diffHistoryStates[key];\n    if (!diffHistoryState) return void 0;\n    return diffHistoryState.diffState.computedState;\n  });\n  const undoMethod = useCedarStore(state => state.undo);\n  const redoMethod = useCedarStore(state => state.redo);\n  const undo = useCallback4(() => {\n    return undoMethod(key);\n  }, [undoMethod, key]);\n  const redo = useCallback4(() => {\n    return redoMethod(key);\n  }, [redoMethod, key]);\n  return {\n    computedValue,\n    undo,\n    redo\n  };\n};\n\n// src/store/toolsSlice/toolsSlice.ts\nvar createToolsSlice = (set2, get) => ({\n  // Initial state\n  registeredTools: /* @__PURE__ */new Map(),\n  // Register a new tool\n  registerTool: config2 => {\n    set2(state => {\n      const newTools = new Map(state.registeredTools);\n      const toolEntry = {\n        name: config2.name,\n        execute: config2.execute,\n        argsSchema: config2.argsSchema,\n        description: config2.description\n      };\n      newTools.set(config2.name, toolEntry);\n      return {\n        registeredTools: newTools\n      };\n    });\n  },\n  // Unregister a tool\n  unregisterTool: name19 => {\n    set2(state => {\n      const newTools = new Map(state.registeredTools);\n      newTools.delete(name19);\n      return {\n        registeredTools: newTools\n      };\n    });\n  },\n  // Execute a tool with validated arguments\n  executeTool: async (name19, args) => {\n    const tool2 = get().registeredTools.get(name19);\n    if (!tool2) {\n      console.error(`Tool \"${name19}\" not found`);\n      return;\n    }\n    try {\n      const validatedArgs = tool2.argsSchema.parse(args);\n      await tool2.execute(validatedArgs);\n    } catch (error40) {\n      if (error40 instanceof external_exports.ZodError) {\n        console.error(`Validation error for tool \"${name19}\":`, error40.errors);\n      } else {\n        console.error(`Error executing tool \"${name19}\":`, error40);\n      }\n    }\n  },\n  // Get all registered tools for agent\n  getRegisteredTools: () => get().registeredTools,\n  // Clear all tools\n  clearTools: () => {\n    set2({\n      registeredTools: /* @__PURE__ */new Map()\n    });\n  }\n});\n\n// src/store/CedarStore.ts\nimport { useMemo as useMemo4 } from \"react\";\n\n// src/store/spellSlice/useSpell.ts\nimport { useEffect as useEffect5, useRef as useRef2, useMemo as useMemo3 } from \"react\";\nfunction useSpell(options) {\n  const {\n    spells,\n    registerSpell,\n    unregisterSpell,\n    activateSpell,\n    deactivateSpell,\n    toggleSpell\n  } = useSpells();\n  const onActivateRef = useRef2(options.onActivate);\n  const onDeactivateRef = useRef2(options.onDeactivate);\n  useEffect5(() => {\n    onActivateRef.current = options.onActivate;\n    onDeactivateRef.current = options.onDeactivate;\n  }, [options.onActivate, options.onDeactivate]);\n  const activationConditionsHash = useMemo3(() => JSON.stringify(options.activationConditions), [options.activationConditions]);\n  useEffect5(() => {\n    registerSpell({\n      id: options.id,\n      activationConditions: options.activationConditions,\n      onActivate: state => onActivateRef.current?.(state),\n      onDeactivate: () => onDeactivateRef.current?.(),\n      preventDefaultEvents: options.preventDefaultEvents,\n      ignoreInputElements: options.ignoreInputElements\n    });\n    return () => {\n      unregisterSpell(options.id);\n    };\n  }, [options.id, activationConditionsHash, options.preventDefaultEvents, options.ignoreInputElements, registerSpell, unregisterSpell]);\n  const spell = spells[options.id];\n  const isActive = spell?.isActive ?? false;\n  return {\n    isActive,\n    activate: () => activateSpell(options.id),\n    deactivate: () => deactivateSpell(options.id),\n    toggle: () => toggleSpell(options.id)\n  };\n}\n\n// src/store/spellSlice/useMultipleSpells.ts\nimport { useEffect as useEffect6, useRef as useRef3 } from \"react\";\nfunction useMultipleSpells({\n  spells\n}) {\n  const {\n    registerSpell,\n    unregisterSpell\n  } = useSpells();\n  const currentSpellIds = useRef3(/* @__PURE__ */new Set());\n  useEffect6(() => {\n    const newSpellIds = new Set(spells.map(spell => spell.id));\n    const previousSpellIds = currentSpellIds.current;\n    for (const spellId of previousSpellIds) {\n      if (!newSpellIds.has(spellId)) {\n        unregisterSpell(spellId);\n      }\n    }\n    spells.forEach(spell => {\n      registerSpell({\n        id: spell.id,\n        activationConditions: spell.activationConditions,\n        onActivate: spell.onActivate,\n        onDeactivate: spell.onDeactivate,\n        preventDefaultEvents: spell.preventDefaultEvents,\n        ignoreInputElements: spell.ignoreInputElements\n      });\n    });\n    currentSpellIds.current = newSpellIds;\n  }, [spells, registerSpell, unregisterSpell]);\n  useEffect6(() => {\n    return () => {\n      for (const spellId of currentSpellIds.current) {\n        unregisterSpell(spellId);\n      }\n      currentSpellIds.current.clear();\n    };\n  }, [unregisterSpell]);\n}\n\n// src/store/toolsSlice/useRegisterFrontendTool.ts\nimport { useEffect as useEffect7, useRef as useRef4 } from \"react\";\nfunction useRegisterFrontendTool(options) {\n  const registerTool = useCedarStore(state => state.registerTool);\n  const unregisterTool = useCedarStore(state => state.unregisterTool);\n  const executeRef = useRef4(options.execute);\n  const nameRef = useRef4(options.name);\n  useEffect7(() => {\n    executeRef.current = options.execute;\n  }, [options.execute]);\n  useEffect7(() => {\n    nameRef.current = options.name;\n  }, [options.name]);\n  useEffect7(() => {\n    if (options.enabled === false) {\n      return;\n    }\n    registerTool({\n      name: options.name,\n      execute: args => executeRef.current(args),\n      argsSchema: options.argsSchema,\n      description: options.description\n    });\n    return () => {\n      unregisterTool(nameRef.current);\n    };\n  }, [options.name, options.argsSchema, options.description, options.enabled, registerTool, unregisterTool]);\n  return {\n    unregister: () => unregisterTool(options.name)\n  };\n}\n\n// src/store/CedarStore.ts\nvar useCedarStore = create()((...a) => ({\n  ...createStylingSlice(...a),\n  ...createAgentContextSlice(...a),\n  ...createStateSlice(...a),\n  ...createMessagesSlice(...a),\n  ...createAgentConnectionSlice(...a),\n  ...createVoiceSlice(...a),\n  ...createDebuggerSlice(...a),\n  ...createSpellSlice(...a),\n  ...createDiffHistorySlice(...a),\n  ...createToolsSlice(...a)\n}));\nvar useMessages = () => ({\n  messages: useCedarStore(state => state.messages),\n  isProcessing: useCedarStore(state => state.isProcessing),\n  showChat: useCedarStore(state => state.showChat),\n  setMessages: useCedarStore(state => state.setMessages),\n  addMessage: useCedarStore(state => state.addMessage),\n  clearMessages: useCedarStore(state => state.clearMessages),\n  setIsProcessing: useCedarStore(state => state.setIsProcessing),\n  setShowChat: useCedarStore(state => state.setShowChat)\n});\nvar useThreadMessages = threadId => {\n  const mainThreadId = useCedarStore(state => state.mainThreadId);\n  const targetThreadId = threadId || mainThreadId;\n  const threadData = useCedarStore(state => state.threadMap[targetThreadId]);\n  return {\n    messages: threadData?.messages || [],\n    threadId: targetThreadId,\n    lastLoaded: threadData?.lastLoaded,\n    isCurrentThread: targetThreadId === mainThreadId,\n    // Thread-specific actions\n    setMessages: messages => useCedarStore.getState().setMessages(messages, targetThreadId),\n    addMessage: (message, isComplete) => useCedarStore.getState().addMessage(message, isComplete, targetThreadId),\n    clearMessages: () => useCedarStore.getState().clearMessages(targetThreadId),\n    switchToThread: () => useCedarStore.getState().switchThread(targetThreadId)\n  };\n};\nvar useThreadController = () => {\n  const mainThreadId = useCedarStore(state => state.mainThreadId);\n  const threadMap = useCedarStore(state => state.threadMap);\n  const threadIds = useMemo4(() => Object.keys(threadMap), [threadMap]);\n  return {\n    currentThreadId: mainThreadId,\n    threadIds,\n    setMainThreadId: useCedarStore(state => state.setMainThreadId),\n    createThread: useCedarStore(state => state.createThread),\n    deleteThread: useCedarStore(state => state.deleteThread),\n    switchThread: useCedarStore(state => state.switchThread),\n    updateThreadName: useCedarStore(state => state.updateThreadName),\n    getAllThreadIds: useCedarStore(state => state.getAllThreadIds)\n  };\n};\nvar setCedarStore = useCedarStore.setState;\nvar useStyling = () => ({\n  styling: useCedarStore(state => state.styling),\n  setStyling: useCedarStore(state => state.setStyling),\n  toggleDarkMode: useCedarStore(state => state.toggleDarkMode)\n});\nvar useChatInput = () => ({\n  chatInputContent: useCedarStore(state => state.chatInputContent),\n  setChatInputContent: useCedarStore(state => state.setChatInputContent),\n  overrideInputContent: useCedarStore(state => state.overrideInputContent),\n  setOverrideInputContent: useCedarStore(state => state.setOverrideInputContent)\n});\nvar registerState = config2 => useCedarStore.getState().registerState(config2);\nvar getCedarState = key => useCedarStore.getState().getCedarState(key);\nvar setCedarState = (key, value) => useCedarStore.getState().setCedarState(key, value);\nvar useVoice = () => ({\n  isVoiceEnabled: useCedarStore(state => state.isVoiceEnabled),\n  isListening: useCedarStore(state => state.isListening),\n  isSpeaking: useCedarStore(state => state.isSpeaking),\n  voicePermissionStatus: useCedarStore(state => state.voicePermissionStatus),\n  voiceError: useCedarStore(state => state.voiceError),\n  voiceSettings: useCedarStore(state => state.voiceSettings),\n  requestVoicePermission: useCedarStore(state => state.requestVoicePermission),\n  checkVoiceSupport: useCedarStore(state => state.checkVoiceSupport),\n  startListening: useCedarStore(state => state.startListening),\n  stopListening: useCedarStore(state => state.stopListening),\n  toggleVoice: useCedarStore(state => state.toggleVoice),\n  updateVoiceSettings: useCedarStore(state => state.updateVoiceSettings),\n  setVoiceError: useCedarStore(state => state.setVoiceError),\n  resetVoiceState: useCedarStore(state => state.resetVoiceState)\n});\nvar useDebugger = () => ({\n  agentConnectionLogs: useCedarStore(state => state.agentConnectionLogs),\n  maxLogs: useCedarStore(state => state.maxLogs),\n  isDebugEnabled: useCedarStore(state => state.isDebugEnabled),\n  logAgentRequest: useCedarStore(state => state.logAgentRequest),\n  logAgentResponse: useCedarStore(state => state.logAgentResponse),\n  logAgentError: useCedarStore(state => state.logAgentError),\n  logStreamStart: useCedarStore(state => state.logStreamStart),\n  logStreamChunk: useCedarStore(state => state.logStreamChunk),\n  logStreamEnd: useCedarStore(state => state.logStreamEnd),\n  clearDebugLogs: useCedarStore(state => state.clearDebugLogs),\n  setDebugEnabled: useCedarStore(state => state.setDebugEnabled),\n  setMaxLogs: useCedarStore(state => state.setMaxLogs)\n});\nvar useSpells = () => ({\n  spells: useCedarStore(state => state.spells),\n  // Unified API\n  registerSpell: useCedarStore(state => state.registerSpell),\n  unregisterSpell: useCedarStore(state => state.unregisterSpell),\n  // Programmatic control\n  activateSpell: useCedarStore(state => state.activateSpell),\n  deactivateSpell: useCedarStore(state => state.deactivateSpell),\n  toggleSpell: useCedarStore(state => state.toggleSpell),\n  clearSpells: useCedarStore(state => state.clearSpells)\n});\nvar useDiffHistory = () => ({\n  diffHistoryStates: useCedarStore(state => state.diffHistoryStates),\n  getDiffHistoryState: useCedarStore(state => state.getDiffHistoryState),\n  getCleanState: useCedarStore(state => state.getCleanState),\n  setDiffState: useCedarStore(state => state.setDiffState),\n  newDiffState: useCedarStore(state => state.newDiffState),\n  acceptAllDiffs: useCedarStore(state => state.acceptAllDiffs),\n  rejectAllDiffs: useCedarStore(state => state.rejectAllDiffs),\n  undo: useCedarStore(state => state.undo),\n  redo: useCedarStore(state => state.redo)\n});\nvar useTools = () => ({\n  registeredTools: useCedarStore(state => state.registeredTools),\n  registerTool: useCedarStore(state => state.registerTool),\n  unregisterTool: useCedarStore(state => state.unregisterTool),\n  executeTool: useCedarStore(state => state.executeTool),\n  getRegisteredTools: useCedarStore(state => state.getRegisteredTools),\n  clearTools: useCedarStore(state => state.clearTools)\n});\n\n// src/store/stateSlice/useCedarState.ts\nimport { useEffect as useEffect8, useCallback as useCallback5 } from \"react\";\nfunction useCedarState(config2) {\n  const {\n    key,\n    initialValue,\n    description,\n    stateSetters,\n    customSetters,\n    schema\n  } = config2;\n  if (customSetters && !stateSetters) {\n    console.warn(`\\u26A0\\uFE0F 'customSetters' is deprecated in useCedarState for state \"${key}\". Use 'stateSetters' instead.`);\n  }\n  const effectiveSchema = schema ?? external_exports.any();\n  const registerStateFn = useCedarStore(s => s.registerState);\n  const unregisterState = useCedarStore(s => s.unregisterState);\n  useEffect8(() => {\n    registerStateFn({\n      key,\n      value: initialValue,\n      description,\n      stateSetters,\n      customSetters,\n      // Keep for backward compatibility\n      schema: effectiveSchema\n    });\n    return () => {\n      unregisterState(key);\n    };\n  }, [key, unregisterState]);\n  const stateValue = useCedarStore(state => state.registeredStates[key]?.value);\n  const value = stateValue !== void 0 ? stateValue : initialValue;\n  const stableSetState = useCallback5(newValue => {\n    registerStateFn({\n      key,\n      value: newValue,\n      description,\n      stateSetters,\n      customSetters,\n      // Keep for backward compatibility\n      schema: effectiveSchema\n    });\n  }, [key, registerStateFn, description, stateSetters, customSetters, effectiveSchema]);\n  return [value, stableSetState];\n}\nfunction useRegisterState(config2) {\n  const registerState2 = useCedarStore(s => s.registerState);\n  const unregisterState = useCedarStore(s => s.unregisterState);\n  useEffect8(() => {\n    registerState2(config2);\n    return () => {\n      unregisterState(config2.key);\n    };\n  }, [config2.key, config2.value, config2.setValue, config2.description, config2.schema, config2.stateSetters, config2.customSetters, registerState2, unregisterState]);\n}\n\n// src/components/CedarCopilot.client.tsx\nimport { Fragment, jsx as jsx9 } from \"react/jsx-runtime\";\nfunction CedarCopilotClient({\n  children,\n  userId = null,\n  threadId = null,\n  llmProvider,\n  messageStorage,\n  voiceSettings,\n  responseProcessors = [],\n  messageRenderers = []\n}) {\n  const updateVoiceSettings = useCedarStore(state => state.updateVoiceSettings);\n  useEffect9(() => {\n    if (voiceSettings) {\n      updateVoiceSettings(voiceSettings);\n    }\n  }, [voiceSettings, updateVoiceSettings]);\n  const setProviderConfig = useCedarStore(state => state.setProviderConfig);\n  useEffect9(() => {\n    if (llmProvider) {\n      setProviderConfig(llmProvider);\n    }\n  }, [llmProvider, setProviderConfig]);\n  const [cedarUserId, setCedarUserId] = useCedarState({\n    key: \"userId\",\n    initialValue: userId ?? \"\"\n  });\n  useEffect9(() => {\n    if (userId !== null) {\n      setCedarUserId(userId);\n    }\n  }, [userId, setCedarUserId]);\n  const switchThread = useCedarStore(state => state.switchThread);\n  useEffect9(() => {\n    if (threadId) {\n      switchThread(threadId);\n    }\n  }, [threadId, switchThread]);\n  const hasInitializedRef = React3.useRef(false);\n  const previousThreadIdRef = React3.useRef(threadId);\n  useEffect9(() => {\n    const threadIdChanged = previousThreadIdRef.current !== threadId;\n    if (cedarUserId && (!hasInitializedRef.current || threadIdChanged) && messageStorage) {\n      if (!useCedarStore.getState().messageStorageAdapter) {\n        useCedarStore.getState().setMessageStorageAdapter(messageStorage);\n      }\n      useCedarStore.getState().initializeChat?.({\n        userId: cedarUserId,\n        threadId\n      }).then(() => {\n        hasInitializedRef.current = true;\n        previousThreadIdRef.current = threadId;\n      }).catch(error40 => {\n        console.error(\"Failed to initialize chat:\", error40);\n      });\n    }\n  }, [cedarUserId, threadId, messageStorage]);\n  useEffect9(() => {\n    const store = useCedarStore.getState();\n    responseProcessors.forEach(processor => {\n      store.registerResponseProcessor(processor);\n    });\n  }, [responseProcessors]);\n  useEffect9(() => {\n    const store = useCedarStore.getState();\n    messageRenderers.forEach(renderer => {\n      store.registerMessageRenderer(renderer);\n    });\n    return () => {\n      messageRenderers.forEach(renderer => {\n        store.unregisterMessageRenderer(renderer.type, renderer.namespace);\n      });\n    };\n  }, [messageRenderers]);\n  return /* @__PURE__ */jsx9(Fragment, {\n    children\n  });\n}\n\n// src/components/CedarCopilot.tsx\nimport { jsx as jsx10 } from \"react/jsx-runtime\";\nfunction CedarCopilot(props) {\n  return /* @__PURE__ */jsx10(CedarCopilotClient, {\n    ...props\n  });\n}\n\n// src/components/debugger/DebuggerPanel.tsx\nimport { useState as useState5, useRef as useRef6, useCallback as useCallback6, useEffect as useEffect12 } from \"react\";\nimport { motion as motion7, AnimatePresence as AnimatePresence5, useDragControls } from \"framer-motion\";\n\n// src/components/ui/tabs.tsx\nimport * as TabsPrimitive from \"@radix-ui/react-tabs\";\n\n// node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs\nfunction r(e) {\n  var t,\n    f,\n    n = \"\";\n  if (\"string\" == typeof e || \"number\" == typeof e) n += e;else if (\"object\" == typeof e) if (Array.isArray(e)) {\n    var o = e.length;\n    for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += \" \"), n += f);\n  } else for (f in e) e[f] && (n && (n += \" \"), n += f);\n  return n;\n}\nfunction clsx() {\n  for (var e, t, f = 0, n = \"\", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += \" \"), n += t);\n  return n;\n}\n\n// node_modules/.pnpm/tailwind-merge@3.2.0/node_modules/tailwind-merge/dist/bundle-mjs.mjs\nvar CLASS_PART_SEPARATOR = \"-\";\nvar createClassGroupUtils = config2 => {\n  const classMap = createClassMap(config2);\n  const {\n    conflictingClassGroups,\n    conflictingClassGroupModifiers\n  } = config2;\n  const getClassGroupId = className => {\n    const classParts = className.split(CLASS_PART_SEPARATOR);\n    if (classParts[0] === \"\" && classParts.length !== 1) {\n      classParts.shift();\n    }\n    return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);\n  };\n  const getConflictingClassGroupIds = (classGroupId, hasPostfixModifier) => {\n    const conflicts = conflictingClassGroups[classGroupId] || [];\n    if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {\n      return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];\n    }\n    return conflicts;\n  };\n  return {\n    getClassGroupId,\n    getConflictingClassGroupIds\n  };\n};\nvar getGroupRecursive = (classParts, classPartObject) => {\n  if (classParts.length === 0) {\n    return classPartObject.classGroupId;\n  }\n  const currentClassPart = classParts[0];\n  const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);\n  const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : void 0;\n  if (classGroupFromNextClassPart) {\n    return classGroupFromNextClassPart;\n  }\n  if (classPartObject.validators.length === 0) {\n    return void 0;\n  }\n  const classRest = classParts.join(CLASS_PART_SEPARATOR);\n  return classPartObject.validators.find(({\n    validator: validator5\n  }) => validator5(classRest))?.classGroupId;\n};\nvar arbitraryPropertyRegex = /^\\[(.+)\\]$/;\nvar getGroupIdForArbitraryProperty = className => {\n  if (arbitraryPropertyRegex.test(className)) {\n    const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];\n    const property = arbitraryPropertyClassName?.substring(0, arbitraryPropertyClassName.indexOf(\":\"));\n    if (property) {\n      return \"arbitrary..\" + property;\n    }\n  }\n};\nvar createClassMap = config2 => {\n  const {\n    theme,\n    classGroups\n  } = config2;\n  const classMap = {\n    nextPart: /* @__PURE__ */new Map(),\n    validators: []\n  };\n  for (const classGroupId in classGroups) {\n    processClassesRecursively(classGroups[classGroupId], classMap, classGroupId, theme);\n  }\n  return classMap;\n};\nvar processClassesRecursively = (classGroup, classPartObject, classGroupId, theme) => {\n  classGroup.forEach(classDefinition => {\n    if (typeof classDefinition === \"string\") {\n      const classPartObjectToEdit = classDefinition === \"\" ? classPartObject : getPart(classPartObject, classDefinition);\n      classPartObjectToEdit.classGroupId = classGroupId;\n      return;\n    }\n    if (typeof classDefinition === \"function\") {\n      if (isThemeGetter(classDefinition)) {\n        processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);\n        return;\n      }\n      classPartObject.validators.push({\n        validator: classDefinition,\n        classGroupId\n      });\n      return;\n    }\n    Object.entries(classDefinition).forEach(([key, classGroup2]) => {\n      processClassesRecursively(classGroup2, getPart(classPartObject, key), classGroupId, theme);\n    });\n  });\n};\nvar getPart = (classPartObject, path) => {\n  let currentClassPartObject = classPartObject;\n  path.split(CLASS_PART_SEPARATOR).forEach(pathPart => {\n    if (!currentClassPartObject.nextPart.has(pathPart)) {\n      currentClassPartObject.nextPart.set(pathPart, {\n        nextPart: /* @__PURE__ */new Map(),\n        validators: []\n      });\n    }\n    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);\n  });\n  return currentClassPartObject;\n};\nvar isThemeGetter = func => func.isThemeGetter;\nvar createLruCache = maxCacheSize => {\n  if (maxCacheSize < 1) {\n    return {\n      get: () => void 0,\n      set: () => {}\n    };\n  }\n  let cacheSize = 0;\n  let cache = /* @__PURE__ */new Map();\n  let previousCache = /* @__PURE__ */new Map();\n  const update = (key, value) => {\n    cache.set(key, value);\n    cacheSize++;\n    if (cacheSize > maxCacheSize) {\n      cacheSize = 0;\n      previousCache = cache;\n      cache = /* @__PURE__ */new Map();\n    }\n  };\n  return {\n    get(key) {\n      let value = cache.get(key);\n      if (value !== void 0) {\n        return value;\n      }\n      if ((value = previousCache.get(key)) !== void 0) {\n        update(key, value);\n        return value;\n      }\n    },\n    set(key, value) {\n      if (cache.has(key)) {\n        cache.set(key, value);\n      } else {\n        update(key, value);\n      }\n    }\n  };\n};\nvar IMPORTANT_MODIFIER = \"!\";\nvar MODIFIER_SEPARATOR = \":\";\nvar MODIFIER_SEPARATOR_LENGTH = MODIFIER_SEPARATOR.length;\nvar createParseClassName = config2 => {\n  const {\n    prefix,\n    experimentalParseClassName\n  } = config2;\n  let parseClassName = className => {\n    const modifiers = [];\n    let bracketDepth = 0;\n    let parenDepth = 0;\n    let modifierStart = 0;\n    let postfixModifierPosition;\n    for (let index = 0; index < className.length; index++) {\n      let currentCharacter = className[index];\n      if (bracketDepth === 0 && parenDepth === 0) {\n        if (currentCharacter === MODIFIER_SEPARATOR) {\n          modifiers.push(className.slice(modifierStart, index));\n          modifierStart = index + MODIFIER_SEPARATOR_LENGTH;\n          continue;\n        }\n        if (currentCharacter === \"/\") {\n          postfixModifierPosition = index;\n          continue;\n        }\n      }\n      if (currentCharacter === \"[\") {\n        bracketDepth++;\n      } else if (currentCharacter === \"]\") {\n        bracketDepth--;\n      } else if (currentCharacter === \"(\") {\n        parenDepth++;\n      } else if (currentCharacter === \")\") {\n        parenDepth--;\n      }\n    }\n    const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);\n    const baseClassName = stripImportantModifier(baseClassNameWithImportantModifier);\n    const hasImportantModifier = baseClassName !== baseClassNameWithImportantModifier;\n    const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;\n    return {\n      modifiers,\n      hasImportantModifier,\n      baseClassName,\n      maybePostfixModifierPosition\n    };\n  };\n  if (prefix) {\n    const fullPrefix = prefix + MODIFIER_SEPARATOR;\n    const parseClassNameOriginal = parseClassName;\n    parseClassName = className => className.startsWith(fullPrefix) ? parseClassNameOriginal(className.substring(fullPrefix.length)) : {\n      isExternal: true,\n      modifiers: [],\n      hasImportantModifier: false,\n      baseClassName: className,\n      maybePostfixModifierPosition: void 0\n    };\n  }\n  if (experimentalParseClassName) {\n    const parseClassNameOriginal = parseClassName;\n    parseClassName = className => experimentalParseClassName({\n      className,\n      parseClassName: parseClassNameOriginal\n    });\n  }\n  return parseClassName;\n};\nvar stripImportantModifier = baseClassName => {\n  if (baseClassName.endsWith(IMPORTANT_MODIFIER)) {\n    return baseClassName.substring(0, baseClassName.length - 1);\n  }\n  if (baseClassName.startsWith(IMPORTANT_MODIFIER)) {\n    return baseClassName.substring(1);\n  }\n  return baseClassName;\n};\nvar createSortModifiers = config2 => {\n  const orderSensitiveModifiers = Object.fromEntries(config2.orderSensitiveModifiers.map(modifier => [modifier, true]));\n  const sortModifiers = modifiers => {\n    if (modifiers.length <= 1) {\n      return modifiers;\n    }\n    const sortedModifiers = [];\n    let unsortedModifiers = [];\n    modifiers.forEach(modifier => {\n      const isPositionSensitive = modifier[0] === \"[\" || orderSensitiveModifiers[modifier];\n      if (isPositionSensitive) {\n        sortedModifiers.push(...unsortedModifiers.sort(), modifier);\n        unsortedModifiers = [];\n      } else {\n        unsortedModifiers.push(modifier);\n      }\n    });\n    sortedModifiers.push(...unsortedModifiers.sort());\n    return sortedModifiers;\n  };\n  return sortModifiers;\n};\nvar createConfigUtils = config2 => ({\n  cache: createLruCache(config2.cacheSize),\n  parseClassName: createParseClassName(config2),\n  sortModifiers: createSortModifiers(config2),\n  ...createClassGroupUtils(config2)\n});\nvar SPLIT_CLASSES_REGEX = /\\s+/;\nvar mergeClassList = (classList, configUtils) => {\n  const {\n    parseClassName,\n    getClassGroupId,\n    getConflictingClassGroupIds,\n    sortModifiers\n  } = configUtils;\n  const classGroupsInConflict = [];\n  const classNames = classList.trim().split(SPLIT_CLASSES_REGEX);\n  let result = \"\";\n  for (let index = classNames.length - 1; index >= 0; index -= 1) {\n    const originalClassName = classNames[index];\n    const {\n      isExternal,\n      modifiers,\n      hasImportantModifier,\n      baseClassName,\n      maybePostfixModifierPosition\n    } = parseClassName(originalClassName);\n    if (isExternal) {\n      result = originalClassName + (result.length > 0 ? \" \" + result : result);\n      continue;\n    }\n    let hasPostfixModifier = !!maybePostfixModifierPosition;\n    let classGroupId = getClassGroupId(hasPostfixModifier ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);\n    if (!classGroupId) {\n      if (!hasPostfixModifier) {\n        result = originalClassName + (result.length > 0 ? \" \" + result : result);\n        continue;\n      }\n      classGroupId = getClassGroupId(baseClassName);\n      if (!classGroupId) {\n        result = originalClassName + (result.length > 0 ? \" \" + result : result);\n        continue;\n      }\n      hasPostfixModifier = false;\n    }\n    const variantModifier = sortModifiers(modifiers).join(\":\");\n    const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;\n    const classId = modifierId + classGroupId;\n    if (classGroupsInConflict.includes(classId)) {\n      continue;\n    }\n    classGroupsInConflict.push(classId);\n    const conflictGroups = getConflictingClassGroupIds(classGroupId, hasPostfixModifier);\n    for (let i = 0; i < conflictGroups.length; ++i) {\n      const group = conflictGroups[i];\n      classGroupsInConflict.push(modifierId + group);\n    }\n    result = originalClassName + (result.length > 0 ? \" \" + result : result);\n  }\n  return result;\n};\nfunction twJoin() {\n  let index = 0;\n  let argument;\n  let resolvedValue;\n  let string4 = \"\";\n  while (index < arguments.length) {\n    if (argument = arguments[index++]) {\n      if (resolvedValue = toValue(argument)) {\n        string4 && (string4 += \" \");\n        string4 += resolvedValue;\n      }\n    }\n  }\n  return string4;\n}\nvar toValue = mix => {\n  if (typeof mix === \"string\") {\n    return mix;\n  }\n  let resolvedValue;\n  let string4 = \"\";\n  for (let k = 0; k < mix.length; k++) {\n    if (mix[k]) {\n      if (resolvedValue = toValue(mix[k])) {\n        string4 && (string4 += \" \");\n        string4 += resolvedValue;\n      }\n    }\n  }\n  return string4;\n};\nfunction createTailwindMerge(createConfigFirst, ...createConfigRest) {\n  let configUtils;\n  let cacheGet;\n  let cacheSet;\n  let functionToCall = initTailwindMerge;\n  function initTailwindMerge(classList) {\n    const config2 = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());\n    configUtils = createConfigUtils(config2);\n    cacheGet = configUtils.cache.get;\n    cacheSet = configUtils.cache.set;\n    functionToCall = tailwindMerge;\n    return tailwindMerge(classList);\n  }\n  function tailwindMerge(classList) {\n    const cachedResult = cacheGet(classList);\n    if (cachedResult) {\n      return cachedResult;\n    }\n    const result = mergeClassList(classList, configUtils);\n    cacheSet(classList, result);\n    return result;\n  }\n  return function callTailwindMerge() {\n    return functionToCall(twJoin.apply(null, arguments));\n  };\n}\nvar fromTheme = key => {\n  const themeGetter = theme => theme[key] || [];\n  themeGetter.isThemeGetter = true;\n  return themeGetter;\n};\nvar arbitraryValueRegex = /^\\[(?:(\\w[\\w-]*):)?(.+)\\]$/i;\nvar arbitraryVariableRegex = /^\\((?:(\\w[\\w-]*):)?(.+)\\)$/i;\nvar fractionRegex = /^\\d+\\/\\d+$/;\nvar tshirtUnitRegex = /^(\\d+(\\.\\d+)?)?(xs|sm|md|lg|xl)$/;\nvar lengthUnitRegex = /\\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\\b(calc|min|max|clamp)\\(.+\\)|^0$/;\nvar colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\\(.+\\)$/;\nvar shadowRegex = /^(inset_)?-?((\\d+)?\\.?(\\d+)[a-z]+|0)_-?((\\d+)?\\.?(\\d+)[a-z]+|0)/;\nvar imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\\(.+\\)$/;\nvar isFraction = value => fractionRegex.test(value);\nvar isNumber = value => !!value && !Number.isNaN(Number(value));\nvar isInteger = value => !!value && Number.isInteger(Number(value));\nvar isPercent = value => value.endsWith(\"%\") && isNumber(value.slice(0, -1));\nvar isTshirtSize = value => tshirtUnitRegex.test(value);\nvar isAny = () => true;\nvar isLengthOnly = value =>\n// `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.\n// For example, `hsl(0 0% 0%)` would be classified as a length without this check.\n// I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.\nlengthUnitRegex.test(value) && !colorFunctionRegex.test(value);\nvar isNever = () => false;\nvar isShadow = value => shadowRegex.test(value);\nvar isImage = value => imageRegex.test(value);\nvar isAnyNonArbitrary = value => !isArbitraryValue(value) && !isArbitraryVariable(value);\nvar isArbitrarySize = value => getIsArbitraryValue(value, isLabelSize, isNever);\nvar isArbitraryValue = value => arbitraryValueRegex.test(value);\nvar isArbitraryLength = value => getIsArbitraryValue(value, isLabelLength, isLengthOnly);\nvar isArbitraryNumber = value => getIsArbitraryValue(value, isLabelNumber, isNumber);\nvar isArbitraryPosition = value => getIsArbitraryValue(value, isLabelPosition, isNever);\nvar isArbitraryImage = value => getIsArbitraryValue(value, isLabelImage, isImage);\nvar isArbitraryShadow = value => getIsArbitraryValue(value, isLabelShadow, isShadow);\nvar isArbitraryVariable = value => arbitraryVariableRegex.test(value);\nvar isArbitraryVariableLength = value => getIsArbitraryVariable(value, isLabelLength);\nvar isArbitraryVariableFamilyName = value => getIsArbitraryVariable(value, isLabelFamilyName);\nvar isArbitraryVariablePosition = value => getIsArbitraryVariable(value, isLabelPosition);\nvar isArbitraryVariableSize = value => getIsArbitraryVariable(value, isLabelSize);\nvar isArbitraryVariableImage = value => getIsArbitraryVariable(value, isLabelImage);\nvar isArbitraryVariableShadow = value => getIsArbitraryVariable(value, isLabelShadow, true);\nvar getIsArbitraryValue = (value, testLabel, testValue) => {\n  const result = arbitraryValueRegex.exec(value);\n  if (result) {\n    if (result[1]) {\n      return testLabel(result[1]);\n    }\n    return testValue(result[2]);\n  }\n  return false;\n};\nvar getIsArbitraryVariable = (value, testLabel, shouldMatchNoLabel = false) => {\n  const result = arbitraryVariableRegex.exec(value);\n  if (result) {\n    if (result[1]) {\n      return testLabel(result[1]);\n    }\n    return shouldMatchNoLabel;\n  }\n  return false;\n};\nvar isLabelPosition = label => label === \"position\" || label === \"percentage\";\nvar isLabelImage = label => label === \"image\" || label === \"url\";\nvar isLabelSize = label => label === \"length\" || label === \"size\" || label === \"bg-size\";\nvar isLabelLength = label => label === \"length\";\nvar isLabelNumber = label => label === \"number\";\nvar isLabelFamilyName = label => label === \"family-name\";\nvar isLabelShadow = label => label === \"shadow\";\nvar getDefaultConfig = () => {\n  const themeColor = fromTheme(\"color\");\n  const themeFont = fromTheme(\"font\");\n  const themeText = fromTheme(\"text\");\n  const themeFontWeight = fromTheme(\"font-weight\");\n  const themeTracking = fromTheme(\"tracking\");\n  const themeLeading = fromTheme(\"leading\");\n  const themeBreakpoint = fromTheme(\"breakpoint\");\n  const themeContainer = fromTheme(\"container\");\n  const themeSpacing = fromTheme(\"spacing\");\n  const themeRadius = fromTheme(\"radius\");\n  const themeShadow = fromTheme(\"shadow\");\n  const themeInsetShadow = fromTheme(\"inset-shadow\");\n  const themeTextShadow = fromTheme(\"text-shadow\");\n  const themeDropShadow = fromTheme(\"drop-shadow\");\n  const themeBlur = fromTheme(\"blur\");\n  const themePerspective = fromTheme(\"perspective\");\n  const themeAspect = fromTheme(\"aspect\");\n  const themeEase = fromTheme(\"ease\");\n  const themeAnimate = fromTheme(\"animate\");\n  const scaleBreak = () => [\"auto\", \"avoid\", \"all\", \"avoid-page\", \"page\", \"left\", \"right\", \"column\"];\n  const scalePosition = () => [\"center\", \"top\", \"bottom\", \"left\", \"right\", \"top-left\",\n  // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378\n  \"left-top\", \"top-right\",\n  // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378\n  \"right-top\", \"bottom-right\",\n  // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378\n  \"right-bottom\", \"bottom-left\",\n  // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378\n  \"left-bottom\"];\n  const scalePositionWithArbitrary = () => [...scalePosition(), isArbitraryVariable, isArbitraryValue];\n  const scaleOverflow = () => [\"auto\", \"hidden\", \"clip\", \"visible\", \"scroll\"];\n  const scaleOverscroll = () => [\"auto\", \"contain\", \"none\"];\n  const scaleUnambiguousSpacing = () => [isArbitraryVariable, isArbitraryValue, themeSpacing];\n  const scaleInset = () => [isFraction, \"full\", \"auto\", ...scaleUnambiguousSpacing()];\n  const scaleGridTemplateColsRows = () => [isInteger, \"none\", \"subgrid\", isArbitraryVariable, isArbitraryValue];\n  const scaleGridColRowStartAndEnd = () => [\"auto\", {\n    span: [\"full\", isInteger, isArbitraryVariable, isArbitraryValue]\n  }, isInteger, isArbitraryVariable, isArbitraryValue];\n  const scaleGridColRowStartOrEnd = () => [isInteger, \"auto\", isArbitraryVariable, isArbitraryValue];\n  const scaleGridAutoColsRows = () => [\"auto\", \"min\", \"max\", \"fr\", isArbitraryVariable, isArbitraryValue];\n  const scaleAlignPrimaryAxis = () => [\"start\", \"end\", \"center\", \"between\", \"around\", \"evenly\", \"stretch\", \"baseline\", \"center-safe\", \"end-safe\"];\n  const scaleAlignSecondaryAxis = () => [\"start\", \"end\", \"center\", \"stretch\", \"center-safe\", \"end-safe\"];\n  const scaleMargin = () => [\"auto\", ...scaleUnambiguousSpacing()];\n  const scaleSizing = () => [isFraction, \"auto\", \"full\", \"dvw\", \"dvh\", \"lvw\", \"lvh\", \"svw\", \"svh\", \"min\", \"max\", \"fit\", ...scaleUnambiguousSpacing()];\n  const scaleColor = () => [themeColor, isArbitraryVariable, isArbitraryValue];\n  const scaleBgPosition = () => [...scalePosition(), isArbitraryVariablePosition, isArbitraryPosition, {\n    position: [isArbitraryVariable, isArbitraryValue]\n  }];\n  const scaleBgRepeat = () => [\"no-repeat\", {\n    repeat: [\"\", \"x\", \"y\", \"space\", \"round\"]\n  }];\n  const scaleBgSize = () => [\"auto\", \"cover\", \"contain\", isArbitraryVariableSize, isArbitrarySize, {\n    size: [isArbitraryVariable, isArbitraryValue]\n  }];\n  const scaleGradientStopPosition = () => [isPercent, isArbitraryVariableLength, isArbitraryLength];\n  const scaleRadius = () => [\n  // Deprecated since Tailwind CSS v4.0.0\n  \"\", \"none\", \"full\", themeRadius, isArbitraryVariable, isArbitraryValue];\n  const scaleBorderWidth = () => [\"\", isNumber, isArbitraryVariableLength, isArbitraryLength];\n  const scaleLineStyle = () => [\"solid\", \"dashed\", \"dotted\", \"double\"];\n  const scaleBlendMode = () => [\"normal\", \"multiply\", \"screen\", \"overlay\", \"darken\", \"lighten\", \"color-dodge\", \"color-burn\", \"hard-light\", \"soft-light\", \"difference\", \"exclusion\", \"hue\", \"saturation\", \"color\", \"luminosity\"];\n  const scaleMaskImagePosition = () => [isNumber, isPercent, isArbitraryVariablePosition, isArbitraryPosition];\n  const scaleBlur = () => [\n  // Deprecated since Tailwind CSS v4.0.0\n  \"\", \"none\", themeBlur, isArbitraryVariable, isArbitraryValue];\n  const scaleRotate = () => [\"none\", isNumber, isArbitraryVariable, isArbitraryValue];\n  const scaleScale = () => [\"none\", isNumber, isArbitraryVariable, isArbitraryValue];\n  const scaleSkew = () => [isNumber, isArbitraryVariable, isArbitraryValue];\n  const scaleTranslate = () => [isFraction, \"full\", ...scaleUnambiguousSpacing()];\n  return {\n    cacheSize: 500,\n    theme: {\n      animate: [\"spin\", \"ping\", \"pulse\", \"bounce\"],\n      aspect: [\"video\"],\n      blur: [isTshirtSize],\n      breakpoint: [isTshirtSize],\n      color: [isAny],\n      container: [isTshirtSize],\n      \"drop-shadow\": [isTshirtSize],\n      ease: [\"in\", \"out\", \"in-out\"],\n      font: [isAnyNonArbitrary],\n      \"font-weight\": [\"thin\", \"extralight\", \"light\", \"normal\", \"medium\", \"semibold\", \"bold\", \"extrabold\", \"black\"],\n      \"inset-shadow\": [isTshirtSize],\n      leading: [\"none\", \"tight\", \"snug\", \"normal\", \"relaxed\", \"loose\"],\n      perspective: [\"dramatic\", \"near\", \"normal\", \"midrange\", \"distant\", \"none\"],\n      radius: [isTshirtSize],\n      shadow: [isTshirtSize],\n      spacing: [\"px\", isNumber],\n      text: [isTshirtSize],\n      \"text-shadow\": [isTshirtSize],\n      tracking: [\"tighter\", \"tight\", \"normal\", \"wide\", \"wider\", \"widest\"]\n    },\n    classGroups: {\n      // --------------\n      // --- Layout ---\n      // --------------\n      /**\n       * Aspect Ratio\n       * @see https://tailwindcss.com/docs/aspect-ratio\n       */\n      aspect: [{\n        aspect: [\"auto\", \"square\", isFraction, isArbitraryValue, isArbitraryVariable, themeAspect]\n      }],\n      /**\n       * Container\n       * @see https://tailwindcss.com/docs/container\n       * @deprecated since Tailwind CSS v4.0.0\n       */\n      container: [\"container\"],\n      /**\n       * Columns\n       * @see https://tailwindcss.com/docs/columns\n       */\n      columns: [{\n        columns: [isNumber, isArbitraryValue, isArbitraryVariable, themeContainer]\n      }],\n      /**\n       * Break After\n       * @see https://tailwindcss.com/docs/break-after\n       */\n      \"break-after\": [{\n        \"break-after\": scaleBreak()\n      }],\n      /**\n       * Break Before\n       * @see https://tailwindcss.com/docs/break-before\n       */\n      \"break-before\": [{\n        \"break-before\": scaleBreak()\n      }],\n      /**\n       * Break Inside\n       * @see https://tailwindcss.com/docs/break-inside\n       */\n      \"break-inside\": [{\n        \"break-inside\": [\"auto\", \"avoid\", \"avoid-page\", \"avoid-column\"]\n      }],\n      /**\n       * Box Decoration Break\n       * @see https://tailwindcss.com/docs/box-decoration-break\n       */\n      \"box-decoration\": [{\n        \"box-decoration\": [\"slice\", \"clone\"]\n      }],\n      /**\n       * Box Sizing\n       * @see https://tailwindcss.com/docs/box-sizing\n       */\n      box: [{\n        box: [\"border\", \"content\"]\n      }],\n      /**\n       * Display\n       * @see https://tailwindcss.com/docs/display\n       */\n      display: [\"block\", \"inline-block\", \"inline\", \"flex\", \"inline-flex\", \"table\", \"inline-table\", \"table-caption\", \"table-cell\", \"table-column\", \"table-column-group\", \"table-footer-group\", \"table-header-group\", \"table-row-group\", \"table-row\", \"flow-root\", \"grid\", \"inline-grid\", \"contents\", \"list-item\", \"hidden\"],\n      /**\n       * Screen Reader Only\n       * @see https://tailwindcss.com/docs/display#screen-reader-only\n       */\n      sr: [\"sr-only\", \"not-sr-only\"],\n      /**\n       * Floats\n       * @see https://tailwindcss.com/docs/float\n       */\n      float: [{\n        float: [\"right\", \"left\", \"none\", \"start\", \"end\"]\n      }],\n      /**\n       * Clear\n       * @see https://tailwindcss.com/docs/clear\n       */\n      clear: [{\n        clear: [\"left\", \"right\", \"both\", \"none\", \"start\", \"end\"]\n      }],\n      /**\n       * Isolation\n       * @see https://tailwindcss.com/docs/isolation\n       */\n      isolation: [\"isolate\", \"isolation-auto\"],\n      /**\n       * Object Fit\n       * @see https://tailwindcss.com/docs/object-fit\n       */\n      \"object-fit\": [{\n        object: [\"contain\", \"cover\", \"fill\", \"none\", \"scale-down\"]\n      }],\n      /**\n       * Object Position\n       * @see https://tailwindcss.com/docs/object-position\n       */\n      \"object-position\": [{\n        object: scalePositionWithArbitrary()\n      }],\n      /**\n       * Overflow\n       * @see https://tailwindcss.com/docs/overflow\n       */\n      overflow: [{\n        overflow: scaleOverflow()\n      }],\n      /**\n       * Overflow X\n       * @see https://tailwindcss.com/docs/overflow\n       */\n      \"overflow-x\": [{\n        \"overflow-x\": scaleOverflow()\n      }],\n      /**\n       * Overflow Y\n       * @see https://tailwindcss.com/docs/overflow\n       */\n      \"overflow-y\": [{\n        \"overflow-y\": scaleOverflow()\n      }],\n      /**\n       * Overscroll Behavior\n       * @see https://tailwindcss.com/docs/overscroll-behavior\n       */\n      overscroll: [{\n        overscroll: scaleOverscroll()\n      }],\n      /**\n       * Overscroll Behavior X\n       * @see https://tailwindcss.com/docs/overscroll-behavior\n       */\n      \"overscroll-x\": [{\n        \"overscroll-x\": scaleOverscroll()\n      }],\n      /**\n       * Overscroll Behavior Y\n       * @see https://tailwindcss.com/docs/overscroll-behavior\n       */\n      \"overscroll-y\": [{\n        \"overscroll-y\": scaleOverscroll()\n      }],\n      /**\n       * Position\n       * @see https://tailwindcss.com/docs/position\n       */\n      position: [\"static\", \"fixed\", \"absolute\", \"relative\", \"sticky\"],\n      /**\n       * Top / Right / Bottom / Left\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      inset: [{\n        inset: scaleInset()\n      }],\n      /**\n       * Right / Left\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      \"inset-x\": [{\n        \"inset-x\": scaleInset()\n      }],\n      /**\n       * Top / Bottom\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      \"inset-y\": [{\n        \"inset-y\": scaleInset()\n      }],\n      /**\n       * Start\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      start: [{\n        start: scaleInset()\n      }],\n      /**\n       * End\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      end: [{\n        end: scaleInset()\n      }],\n      /**\n       * Top\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      top: [{\n        top: scaleInset()\n      }],\n      /**\n       * Right\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      right: [{\n        right: scaleInset()\n      }],\n      /**\n       * Bottom\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      bottom: [{\n        bottom: scaleInset()\n      }],\n      /**\n       * Left\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      left: [{\n        left: scaleInset()\n      }],\n      /**\n       * Visibility\n       * @see https://tailwindcss.com/docs/visibility\n       */\n      visibility: [\"visible\", \"invisible\", \"collapse\"],\n      /**\n       * Z-Index\n       * @see https://tailwindcss.com/docs/z-index\n       */\n      z: [{\n        z: [isInteger, \"auto\", isArbitraryVariable, isArbitraryValue]\n      }],\n      // ------------------------\n      // --- Flexbox and Grid ---\n      // ------------------------\n      /**\n       * Flex Basis\n       * @see https://tailwindcss.com/docs/flex-basis\n       */\n      basis: [{\n        basis: [isFraction, \"full\", \"auto\", themeContainer, ...scaleUnambiguousSpacing()]\n      }],\n      /**\n       * Flex Direction\n       * @see https://tailwindcss.com/docs/flex-direction\n       */\n      \"flex-direction\": [{\n        flex: [\"row\", \"row-reverse\", \"col\", \"col-reverse\"]\n      }],\n      /**\n       * Flex Wrap\n       * @see https://tailwindcss.com/docs/flex-wrap\n       */\n      \"flex-wrap\": [{\n        flex: [\"nowrap\", \"wrap\", \"wrap-reverse\"]\n      }],\n      /**\n       * Flex\n       * @see https://tailwindcss.com/docs/flex\n       */\n      flex: [{\n        flex: [isNumber, isFraction, \"auto\", \"initial\", \"none\", isArbitraryValue]\n      }],\n      /**\n       * Flex Grow\n       * @see https://tailwindcss.com/docs/flex-grow\n       */\n      grow: [{\n        grow: [\"\", isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Flex Shrink\n       * @see https://tailwindcss.com/docs/flex-shrink\n       */\n      shrink: [{\n        shrink: [\"\", isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Order\n       * @see https://tailwindcss.com/docs/order\n       */\n      order: [{\n        order: [isInteger, \"first\", \"last\", \"none\", isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Grid Template Columns\n       * @see https://tailwindcss.com/docs/grid-template-columns\n       */\n      \"grid-cols\": [{\n        \"grid-cols\": scaleGridTemplateColsRows()\n      }],\n      /**\n       * Grid Column Start / End\n       * @see https://tailwindcss.com/docs/grid-column\n       */\n      \"col-start-end\": [{\n        col: scaleGridColRowStartAndEnd()\n      }],\n      /**\n       * Grid Column Start\n       * @see https://tailwindcss.com/docs/grid-column\n       */\n      \"col-start\": [{\n        \"col-start\": scaleGridColRowStartOrEnd()\n      }],\n      /**\n       * Grid Column End\n       * @see https://tailwindcss.com/docs/grid-column\n       */\n      \"col-end\": [{\n        \"col-end\": scaleGridColRowStartOrEnd()\n      }],\n      /**\n       * Grid Template Rows\n       * @see https://tailwindcss.com/docs/grid-template-rows\n       */\n      \"grid-rows\": [{\n        \"grid-rows\": scaleGridTemplateColsRows()\n      }],\n      /**\n       * Grid Row Start / End\n       * @see https://tailwindcss.com/docs/grid-row\n       */\n      \"row-start-end\": [{\n        row: scaleGridColRowStartAndEnd()\n      }],\n      /**\n       * Grid Row Start\n       * @see https://tailwindcss.com/docs/grid-row\n       */\n      \"row-start\": [{\n        \"row-start\": scaleGridColRowStartOrEnd()\n      }],\n      /**\n       * Grid Row End\n       * @see https://tailwindcss.com/docs/grid-row\n       */\n      \"row-end\": [{\n        \"row-end\": scaleGridColRowStartOrEnd()\n      }],\n      /**\n       * Grid Auto Flow\n       * @see https://tailwindcss.com/docs/grid-auto-flow\n       */\n      \"grid-flow\": [{\n        \"grid-flow\": [\"row\", \"col\", \"dense\", \"row-dense\", \"col-dense\"]\n      }],\n      /**\n       * Grid Auto Columns\n       * @see https://tailwindcss.com/docs/grid-auto-columns\n       */\n      \"auto-cols\": [{\n        \"auto-cols\": scaleGridAutoColsRows()\n      }],\n      /**\n       * Grid Auto Rows\n       * @see https://tailwindcss.com/docs/grid-auto-rows\n       */\n      \"auto-rows\": [{\n        \"auto-rows\": scaleGridAutoColsRows()\n      }],\n      /**\n       * Gap\n       * @see https://tailwindcss.com/docs/gap\n       */\n      gap: [{\n        gap: scaleUnambiguousSpacing()\n      }],\n      /**\n       * Gap X\n       * @see https://tailwindcss.com/docs/gap\n       */\n      \"gap-x\": [{\n        \"gap-x\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Gap Y\n       * @see https://tailwindcss.com/docs/gap\n       */\n      \"gap-y\": [{\n        \"gap-y\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Justify Content\n       * @see https://tailwindcss.com/docs/justify-content\n       */\n      \"justify-content\": [{\n        justify: [...scaleAlignPrimaryAxis(), \"normal\"]\n      }],\n      /**\n       * Justify Items\n       * @see https://tailwindcss.com/docs/justify-items\n       */\n      \"justify-items\": [{\n        \"justify-items\": [...scaleAlignSecondaryAxis(), \"normal\"]\n      }],\n      /**\n       * Justify Self\n       * @see https://tailwindcss.com/docs/justify-self\n       */\n      \"justify-self\": [{\n        \"justify-self\": [\"auto\", ...scaleAlignSecondaryAxis()]\n      }],\n      /**\n       * Align Content\n       * @see https://tailwindcss.com/docs/align-content\n       */\n      \"align-content\": [{\n        content: [\"normal\", ...scaleAlignPrimaryAxis()]\n      }],\n      /**\n       * Align Items\n       * @see https://tailwindcss.com/docs/align-items\n       */\n      \"align-items\": [{\n        items: [...scaleAlignSecondaryAxis(), {\n          baseline: [\"\", \"last\"]\n        }]\n      }],\n      /**\n       * Align Self\n       * @see https://tailwindcss.com/docs/align-self\n       */\n      \"align-self\": [{\n        self: [\"auto\", ...scaleAlignSecondaryAxis(), {\n          baseline: [\"\", \"last\"]\n        }]\n      }],\n      /**\n       * Place Content\n       * @see https://tailwindcss.com/docs/place-content\n       */\n      \"place-content\": [{\n        \"place-content\": scaleAlignPrimaryAxis()\n      }],\n      /**\n       * Place Items\n       * @see https://tailwindcss.com/docs/place-items\n       */\n      \"place-items\": [{\n        \"place-items\": [...scaleAlignSecondaryAxis(), \"baseline\"]\n      }],\n      /**\n       * Place Self\n       * @see https://tailwindcss.com/docs/place-self\n       */\n      \"place-self\": [{\n        \"place-self\": [\"auto\", ...scaleAlignSecondaryAxis()]\n      }],\n      // Spacing\n      /**\n       * Padding\n       * @see https://tailwindcss.com/docs/padding\n       */\n      p: [{\n        p: scaleUnambiguousSpacing()\n      }],\n      /**\n       * Padding X\n       * @see https://tailwindcss.com/docs/padding\n       */\n      px: [{\n        px: scaleUnambiguousSpacing()\n      }],\n      /**\n       * Padding Y\n       * @see https://tailwindcss.com/docs/padding\n       */\n      py: [{\n        py: scaleUnambiguousSpacing()\n      }],\n      /**\n       * Padding Start\n       * @see https://tailwindcss.com/docs/padding\n       */\n      ps: [{\n        ps: scaleUnambiguousSpacing()\n      }],\n      /**\n       * Padding End\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pe: [{\n        pe: scaleUnambiguousSpacing()\n      }],\n      /**\n       * Padding Top\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pt: [{\n        pt: scaleUnambiguousSpacing()\n      }],\n      /**\n       * Padding Right\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pr: [{\n        pr: scaleUnambiguousSpacing()\n      }],\n      /**\n       * Padding Bottom\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pb: [{\n        pb: scaleUnambiguousSpacing()\n      }],\n      /**\n       * Padding Left\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pl: [{\n        pl: scaleUnambiguousSpacing()\n      }],\n      /**\n       * Margin\n       * @see https://tailwindcss.com/docs/margin\n       */\n      m: [{\n        m: scaleMargin()\n      }],\n      /**\n       * Margin X\n       * @see https://tailwindcss.com/docs/margin\n       */\n      mx: [{\n        mx: scaleMargin()\n      }],\n      /**\n       * Margin Y\n       * @see https://tailwindcss.com/docs/margin\n       */\n      my: [{\n        my: scaleMargin()\n      }],\n      /**\n       * Margin Start\n       * @see https://tailwindcss.com/docs/margin\n       */\n      ms: [{\n        ms: scaleMargin()\n      }],\n      /**\n       * Margin End\n       * @see https://tailwindcss.com/docs/margin\n       */\n      me: [{\n        me: scaleMargin()\n      }],\n      /**\n       * Margin Top\n       * @see https://tailwindcss.com/docs/margin\n       */\n      mt: [{\n        mt: scaleMargin()\n      }],\n      /**\n       * Margin Right\n       * @see https://tailwindcss.com/docs/margin\n       */\n      mr: [{\n        mr: scaleMargin()\n      }],\n      /**\n       * Margin Bottom\n       * @see https://tailwindcss.com/docs/margin\n       */\n      mb: [{\n        mb: scaleMargin()\n      }],\n      /**\n       * Margin Left\n       * @see https://tailwindcss.com/docs/margin\n       */\n      ml: [{\n        ml: scaleMargin()\n      }],\n      /**\n       * Space Between X\n       * @see https://tailwindcss.com/docs/margin#adding-space-between-children\n       */\n      \"space-x\": [{\n        \"space-x\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Space Between X Reverse\n       * @see https://tailwindcss.com/docs/margin#adding-space-between-children\n       */\n      \"space-x-reverse\": [\"space-x-reverse\"],\n      /**\n       * Space Between Y\n       * @see https://tailwindcss.com/docs/margin#adding-space-between-children\n       */\n      \"space-y\": [{\n        \"space-y\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Space Between Y Reverse\n       * @see https://tailwindcss.com/docs/margin#adding-space-between-children\n       */\n      \"space-y-reverse\": [\"space-y-reverse\"],\n      // --------------\n      // --- Sizing ---\n      // --------------\n      /**\n       * Size\n       * @see https://tailwindcss.com/docs/width#setting-both-width-and-height\n       */\n      size: [{\n        size: scaleSizing()\n      }],\n      /**\n       * Width\n       * @see https://tailwindcss.com/docs/width\n       */\n      w: [{\n        w: [themeContainer, \"screen\", ...scaleSizing()]\n      }],\n      /**\n       * Min-Width\n       * @see https://tailwindcss.com/docs/min-width\n       */\n      \"min-w\": [{\n        \"min-w\": [themeContainer, \"screen\", /** Deprecated. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */\n        \"none\", ...scaleSizing()]\n      }],\n      /**\n       * Max-Width\n       * @see https://tailwindcss.com/docs/max-width\n       */\n      \"max-w\": [{\n        \"max-w\": [themeContainer, \"screen\", \"none\", /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */\n        \"prose\", /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */\n        {\n          screen: [themeBreakpoint]\n        }, ...scaleSizing()]\n      }],\n      /**\n       * Height\n       * @see https://tailwindcss.com/docs/height\n       */\n      h: [{\n        h: [\"screen\", ...scaleSizing()]\n      }],\n      /**\n       * Min-Height\n       * @see https://tailwindcss.com/docs/min-height\n       */\n      \"min-h\": [{\n        \"min-h\": [\"screen\", \"none\", ...scaleSizing()]\n      }],\n      /**\n       * Max-Height\n       * @see https://tailwindcss.com/docs/max-height\n       */\n      \"max-h\": [{\n        \"max-h\": [\"screen\", ...scaleSizing()]\n      }],\n      // ------------------\n      // --- Typography ---\n      // ------------------\n      /**\n       * Font Size\n       * @see https://tailwindcss.com/docs/font-size\n       */\n      \"font-size\": [{\n        text: [\"base\", themeText, isArbitraryVariableLength, isArbitraryLength]\n      }],\n      /**\n       * Font Smoothing\n       * @see https://tailwindcss.com/docs/font-smoothing\n       */\n      \"font-smoothing\": [\"antialiased\", \"subpixel-antialiased\"],\n      /**\n       * Font Style\n       * @see https://tailwindcss.com/docs/font-style\n       */\n      \"font-style\": [\"italic\", \"not-italic\"],\n      /**\n       * Font Weight\n       * @see https://tailwindcss.com/docs/font-weight\n       */\n      \"font-weight\": [{\n        font: [themeFontWeight, isArbitraryVariable, isArbitraryNumber]\n      }],\n      /**\n       * Font Stretch\n       * @see https://tailwindcss.com/docs/font-stretch\n       */\n      \"font-stretch\": [{\n        \"font-stretch\": [\"ultra-condensed\", \"extra-condensed\", \"condensed\", \"semi-condensed\", \"normal\", \"semi-expanded\", \"expanded\", \"extra-expanded\", \"ultra-expanded\", isPercent, isArbitraryValue]\n      }],\n      /**\n       * Font Family\n       * @see https://tailwindcss.com/docs/font-family\n       */\n      \"font-family\": [{\n        font: [isArbitraryVariableFamilyName, isArbitraryValue, themeFont]\n      }],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      \"fvn-normal\": [\"normal-nums\"],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      \"fvn-ordinal\": [\"ordinal\"],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      \"fvn-slashed-zero\": [\"slashed-zero\"],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      \"fvn-figure\": [\"lining-nums\", \"oldstyle-nums\"],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      \"fvn-spacing\": [\"proportional-nums\", \"tabular-nums\"],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      \"fvn-fraction\": [\"diagonal-fractions\", \"stacked-fractions\"],\n      /**\n       * Letter Spacing\n       * @see https://tailwindcss.com/docs/letter-spacing\n       */\n      tracking: [{\n        tracking: [themeTracking, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Line Clamp\n       * @see https://tailwindcss.com/docs/line-clamp\n       */\n      \"line-clamp\": [{\n        \"line-clamp\": [isNumber, \"none\", isArbitraryVariable, isArbitraryNumber]\n      }],\n      /**\n       * Line Height\n       * @see https://tailwindcss.com/docs/line-height\n       */\n      leading: [{\n        leading: [/** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */\n        themeLeading, ...scaleUnambiguousSpacing()]\n      }],\n      /**\n       * List Style Image\n       * @see https://tailwindcss.com/docs/list-style-image\n       */\n      \"list-image\": [{\n        \"list-image\": [\"none\", isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * List Style Position\n       * @see https://tailwindcss.com/docs/list-style-position\n       */\n      \"list-style-position\": [{\n        list: [\"inside\", \"outside\"]\n      }],\n      /**\n       * List Style Type\n       * @see https://tailwindcss.com/docs/list-style-type\n       */\n      \"list-style-type\": [{\n        list: [\"disc\", \"decimal\", \"none\", isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Text Alignment\n       * @see https://tailwindcss.com/docs/text-align\n       */\n      \"text-alignment\": [{\n        text: [\"left\", \"center\", \"right\", \"justify\", \"start\", \"end\"]\n      }],\n      /**\n       * Placeholder Color\n       * @deprecated since Tailwind CSS v3.0.0\n       * @see https://v3.tailwindcss.com/docs/placeholder-color\n       */\n      \"placeholder-color\": [{\n        placeholder: scaleColor()\n      }],\n      /**\n       * Text Color\n       * @see https://tailwindcss.com/docs/text-color\n       */\n      \"text-color\": [{\n        text: scaleColor()\n      }],\n      /**\n       * Text Decoration\n       * @see https://tailwindcss.com/docs/text-decoration\n       */\n      \"text-decoration\": [\"underline\", \"overline\", \"line-through\", \"no-underline\"],\n      /**\n       * Text Decoration Style\n       * @see https://tailwindcss.com/docs/text-decoration-style\n       */\n      \"text-decoration-style\": [{\n        decoration: [...scaleLineStyle(), \"wavy\"]\n      }],\n      /**\n       * Text Decoration Thickness\n       * @see https://tailwindcss.com/docs/text-decoration-thickness\n       */\n      \"text-decoration-thickness\": [{\n        decoration: [isNumber, \"from-font\", \"auto\", isArbitraryVariable, isArbitraryLength]\n      }],\n      /**\n       * Text Decoration Color\n       * @see https://tailwindcss.com/docs/text-decoration-color\n       */\n      \"text-decoration-color\": [{\n        decoration: scaleColor()\n      }],\n      /**\n       * Text Underline Offset\n       * @see https://tailwindcss.com/docs/text-underline-offset\n       */\n      \"underline-offset\": [{\n        \"underline-offset\": [isNumber, \"auto\", isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Text Transform\n       * @see https://tailwindcss.com/docs/text-transform\n       */\n      \"text-transform\": [\"uppercase\", \"lowercase\", \"capitalize\", \"normal-case\"],\n      /**\n       * Text Overflow\n       * @see https://tailwindcss.com/docs/text-overflow\n       */\n      \"text-overflow\": [\"truncate\", \"text-ellipsis\", \"text-clip\"],\n      /**\n       * Text Wrap\n       * @see https://tailwindcss.com/docs/text-wrap\n       */\n      \"text-wrap\": [{\n        text: [\"wrap\", \"nowrap\", \"balance\", \"pretty\"]\n      }],\n      /**\n       * Text Indent\n       * @see https://tailwindcss.com/docs/text-indent\n       */\n      indent: [{\n        indent: scaleUnambiguousSpacing()\n      }],\n      /**\n       * Vertical Alignment\n       * @see https://tailwindcss.com/docs/vertical-align\n       */\n      \"vertical-align\": [{\n        align: [\"baseline\", \"top\", \"middle\", \"bottom\", \"text-top\", \"text-bottom\", \"sub\", \"super\", isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Whitespace\n       * @see https://tailwindcss.com/docs/whitespace\n       */\n      whitespace: [{\n        whitespace: [\"normal\", \"nowrap\", \"pre\", \"pre-line\", \"pre-wrap\", \"break-spaces\"]\n      }],\n      /**\n       * Word Break\n       * @see https://tailwindcss.com/docs/word-break\n       */\n      break: [{\n        break: [\"normal\", \"words\", \"all\", \"keep\"]\n      }],\n      /**\n       * Overflow Wrap\n       * @see https://tailwindcss.com/docs/overflow-wrap\n       */\n      wrap: [{\n        wrap: [\"break-word\", \"anywhere\", \"normal\"]\n      }],\n      /**\n       * Hyphens\n       * @see https://tailwindcss.com/docs/hyphens\n       */\n      hyphens: [{\n        hyphens: [\"none\", \"manual\", \"auto\"]\n      }],\n      /**\n       * Content\n       * @see https://tailwindcss.com/docs/content\n       */\n      content: [{\n        content: [\"none\", isArbitraryVariable, isArbitraryValue]\n      }],\n      // -------------------\n      // --- Backgrounds ---\n      // -------------------\n      /**\n       * Background Attachment\n       * @see https://tailwindcss.com/docs/background-attachment\n       */\n      \"bg-attachment\": [{\n        bg: [\"fixed\", \"local\", \"scroll\"]\n      }],\n      /**\n       * Background Clip\n       * @see https://tailwindcss.com/docs/background-clip\n       */\n      \"bg-clip\": [{\n        \"bg-clip\": [\"border\", \"padding\", \"content\", \"text\"]\n      }],\n      /**\n       * Background Origin\n       * @see https://tailwindcss.com/docs/background-origin\n       */\n      \"bg-origin\": [{\n        \"bg-origin\": [\"border\", \"padding\", \"content\"]\n      }],\n      /**\n       * Background Position\n       * @see https://tailwindcss.com/docs/background-position\n       */\n      \"bg-position\": [{\n        bg: scaleBgPosition()\n      }],\n      /**\n       * Background Repeat\n       * @see https://tailwindcss.com/docs/background-repeat\n       */\n      \"bg-repeat\": [{\n        bg: scaleBgRepeat()\n      }],\n      /**\n       * Background Size\n       * @see https://tailwindcss.com/docs/background-size\n       */\n      \"bg-size\": [{\n        bg: scaleBgSize()\n      }],\n      /**\n       * Background Image\n       * @see https://tailwindcss.com/docs/background-image\n       */\n      \"bg-image\": [{\n        bg: [\"none\", {\n          linear: [{\n            to: [\"t\", \"tr\", \"r\", \"br\", \"b\", \"bl\", \"l\", \"tl\"]\n          }, isInteger, isArbitraryVariable, isArbitraryValue],\n          radial: [\"\", isArbitraryVariable, isArbitraryValue],\n          conic: [isInteger, isArbitraryVariable, isArbitraryValue]\n        }, isArbitraryVariableImage, isArbitraryImage]\n      }],\n      /**\n       * Background Color\n       * @see https://tailwindcss.com/docs/background-color\n       */\n      \"bg-color\": [{\n        bg: scaleColor()\n      }],\n      /**\n       * Gradient Color Stops From Position\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      \"gradient-from-pos\": [{\n        from: scaleGradientStopPosition()\n      }],\n      /**\n       * Gradient Color Stops Via Position\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      \"gradient-via-pos\": [{\n        via: scaleGradientStopPosition()\n      }],\n      /**\n       * Gradient Color Stops To Position\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      \"gradient-to-pos\": [{\n        to: scaleGradientStopPosition()\n      }],\n      /**\n       * Gradient Color Stops From\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      \"gradient-from\": [{\n        from: scaleColor()\n      }],\n      /**\n       * Gradient Color Stops Via\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      \"gradient-via\": [{\n        via: scaleColor()\n      }],\n      /**\n       * Gradient Color Stops To\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      \"gradient-to\": [{\n        to: scaleColor()\n      }],\n      // ---------------\n      // --- Borders ---\n      // ---------------\n      /**\n       * Border Radius\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      rounded: [{\n        rounded: scaleRadius()\n      }],\n      /**\n       * Border Radius Start\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-s\": [{\n        \"rounded-s\": scaleRadius()\n      }],\n      /**\n       * Border Radius End\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-e\": [{\n        \"rounded-e\": scaleRadius()\n      }],\n      /**\n       * Border Radius Top\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-t\": [{\n        \"rounded-t\": scaleRadius()\n      }],\n      /**\n       * Border Radius Right\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-r\": [{\n        \"rounded-r\": scaleRadius()\n      }],\n      /**\n       * Border Radius Bottom\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-b\": [{\n        \"rounded-b\": scaleRadius()\n      }],\n      /**\n       * Border Radius Left\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-l\": [{\n        \"rounded-l\": scaleRadius()\n      }],\n      /**\n       * Border Radius Start Start\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-ss\": [{\n        \"rounded-ss\": scaleRadius()\n      }],\n      /**\n       * Border Radius Start End\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-se\": [{\n        \"rounded-se\": scaleRadius()\n      }],\n      /**\n       * Border Radius End End\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-ee\": [{\n        \"rounded-ee\": scaleRadius()\n      }],\n      /**\n       * Border Radius End Start\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-es\": [{\n        \"rounded-es\": scaleRadius()\n      }],\n      /**\n       * Border Radius Top Left\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-tl\": [{\n        \"rounded-tl\": scaleRadius()\n      }],\n      /**\n       * Border Radius Top Right\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-tr\": [{\n        \"rounded-tr\": scaleRadius()\n      }],\n      /**\n       * Border Radius Bottom Right\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-br\": [{\n        \"rounded-br\": scaleRadius()\n      }],\n      /**\n       * Border Radius Bottom Left\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-bl\": [{\n        \"rounded-bl\": scaleRadius()\n      }],\n      /**\n       * Border Width\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      \"border-w\": [{\n        border: scaleBorderWidth()\n      }],\n      /**\n       * Border Width X\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      \"border-w-x\": [{\n        \"border-x\": scaleBorderWidth()\n      }],\n      /**\n       * Border Width Y\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      \"border-w-y\": [{\n        \"border-y\": scaleBorderWidth()\n      }],\n      /**\n       * Border Width Start\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      \"border-w-s\": [{\n        \"border-s\": scaleBorderWidth()\n      }],\n      /**\n       * Border Width End\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      \"border-w-e\": [{\n        \"border-e\": scaleBorderWidth()\n      }],\n      /**\n       * Border Width Top\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      \"border-w-t\": [{\n        \"border-t\": scaleBorderWidth()\n      }],\n      /**\n       * Border Width Right\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      \"border-w-r\": [{\n        \"border-r\": scaleBorderWidth()\n      }],\n      /**\n       * Border Width Bottom\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      \"border-w-b\": [{\n        \"border-b\": scaleBorderWidth()\n      }],\n      /**\n       * Border Width Left\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      \"border-w-l\": [{\n        \"border-l\": scaleBorderWidth()\n      }],\n      /**\n       * Divide Width X\n       * @see https://tailwindcss.com/docs/border-width#between-children\n       */\n      \"divide-x\": [{\n        \"divide-x\": scaleBorderWidth()\n      }],\n      /**\n       * Divide Width X Reverse\n       * @see https://tailwindcss.com/docs/border-width#between-children\n       */\n      \"divide-x-reverse\": [\"divide-x-reverse\"],\n      /**\n       * Divide Width Y\n       * @see https://tailwindcss.com/docs/border-width#between-children\n       */\n      \"divide-y\": [{\n        \"divide-y\": scaleBorderWidth()\n      }],\n      /**\n       * Divide Width Y Reverse\n       * @see https://tailwindcss.com/docs/border-width#between-children\n       */\n      \"divide-y-reverse\": [\"divide-y-reverse\"],\n      /**\n       * Border Style\n       * @see https://tailwindcss.com/docs/border-style\n       */\n      \"border-style\": [{\n        border: [...scaleLineStyle(), \"hidden\", \"none\"]\n      }],\n      /**\n       * Divide Style\n       * @see https://tailwindcss.com/docs/border-style#setting-the-divider-style\n       */\n      \"divide-style\": [{\n        divide: [...scaleLineStyle(), \"hidden\", \"none\"]\n      }],\n      /**\n       * Border Color\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      \"border-color\": [{\n        border: scaleColor()\n      }],\n      /**\n       * Border Color X\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      \"border-color-x\": [{\n        \"border-x\": scaleColor()\n      }],\n      /**\n       * Border Color Y\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      \"border-color-y\": [{\n        \"border-y\": scaleColor()\n      }],\n      /**\n       * Border Color S\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      \"border-color-s\": [{\n        \"border-s\": scaleColor()\n      }],\n      /**\n       * Border Color E\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      \"border-color-e\": [{\n        \"border-e\": scaleColor()\n      }],\n      /**\n       * Border Color Top\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      \"border-color-t\": [{\n        \"border-t\": scaleColor()\n      }],\n      /**\n       * Border Color Right\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      \"border-color-r\": [{\n        \"border-r\": scaleColor()\n      }],\n      /**\n       * Border Color Bottom\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      \"border-color-b\": [{\n        \"border-b\": scaleColor()\n      }],\n      /**\n       * Border Color Left\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      \"border-color-l\": [{\n        \"border-l\": scaleColor()\n      }],\n      /**\n       * Divide Color\n       * @see https://tailwindcss.com/docs/divide-color\n       */\n      \"divide-color\": [{\n        divide: scaleColor()\n      }],\n      /**\n       * Outline Style\n       * @see https://tailwindcss.com/docs/outline-style\n       */\n      \"outline-style\": [{\n        outline: [...scaleLineStyle(), \"none\", \"hidden\"]\n      }],\n      /**\n       * Outline Offset\n       * @see https://tailwindcss.com/docs/outline-offset\n       */\n      \"outline-offset\": [{\n        \"outline-offset\": [isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Outline Width\n       * @see https://tailwindcss.com/docs/outline-width\n       */\n      \"outline-w\": [{\n        outline: [\"\", isNumber, isArbitraryVariableLength, isArbitraryLength]\n      }],\n      /**\n       * Outline Color\n       * @see https://tailwindcss.com/docs/outline-color\n       */\n      \"outline-color\": [{\n        outline: scaleColor()\n      }],\n      // ---------------\n      // --- Effects ---\n      // ---------------\n      /**\n       * Box Shadow\n       * @see https://tailwindcss.com/docs/box-shadow\n       */\n      shadow: [{\n        shadow: [\n        // Deprecated since Tailwind CSS v4.0.0\n        \"\", \"none\", themeShadow, isArbitraryVariableShadow, isArbitraryShadow]\n      }],\n      /**\n       * Box Shadow Color\n       * @see https://tailwindcss.com/docs/box-shadow#setting-the-shadow-color\n       */\n      \"shadow-color\": [{\n        shadow: scaleColor()\n      }],\n      /**\n       * Inset Box Shadow\n       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-shadow\n       */\n      \"inset-shadow\": [{\n        \"inset-shadow\": [\"none\", themeInsetShadow, isArbitraryVariableShadow, isArbitraryShadow]\n      }],\n      /**\n       * Inset Box Shadow Color\n       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-shadow-color\n       */\n      \"inset-shadow-color\": [{\n        \"inset-shadow\": scaleColor()\n      }],\n      /**\n       * Ring Width\n       * @see https://tailwindcss.com/docs/box-shadow#adding-a-ring\n       */\n      \"ring-w\": [{\n        ring: scaleBorderWidth()\n      }],\n      /**\n       * Ring Width Inset\n       * @see https://v3.tailwindcss.com/docs/ring-width#inset-rings\n       * @deprecated since Tailwind CSS v4.0.0\n       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158\n       */\n      \"ring-w-inset\": [\"ring-inset\"],\n      /**\n       * Ring Color\n       * @see https://tailwindcss.com/docs/box-shadow#setting-the-ring-color\n       */\n      \"ring-color\": [{\n        ring: scaleColor()\n      }],\n      /**\n       * Ring Offset Width\n       * @see https://v3.tailwindcss.com/docs/ring-offset-width\n       * @deprecated since Tailwind CSS v4.0.0\n       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158\n       */\n      \"ring-offset-w\": [{\n        \"ring-offset\": [isNumber, isArbitraryLength]\n      }],\n      /**\n       * Ring Offset Color\n       * @see https://v3.tailwindcss.com/docs/ring-offset-color\n       * @deprecated since Tailwind CSS v4.0.0\n       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158\n       */\n      \"ring-offset-color\": [{\n        \"ring-offset\": scaleColor()\n      }],\n      /**\n       * Inset Ring Width\n       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-ring\n       */\n      \"inset-ring-w\": [{\n        \"inset-ring\": scaleBorderWidth()\n      }],\n      /**\n       * Inset Ring Color\n       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-ring-color\n       */\n      \"inset-ring-color\": [{\n        \"inset-ring\": scaleColor()\n      }],\n      /**\n       * Text Shadow\n       * @see https://tailwindcss.com/docs/text-shadow\n       */\n      \"text-shadow\": [{\n        \"text-shadow\": [\"none\", themeTextShadow, isArbitraryVariableShadow, isArbitraryShadow]\n      }],\n      /**\n       * Text Shadow Color\n       * @see https://tailwindcss.com/docs/text-shadow#setting-the-shadow-color\n       */\n      \"text-shadow-color\": [{\n        \"text-shadow\": scaleColor()\n      }],\n      /**\n       * Opacity\n       * @see https://tailwindcss.com/docs/opacity\n       */\n      opacity: [{\n        opacity: [isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Mix Blend Mode\n       * @see https://tailwindcss.com/docs/mix-blend-mode\n       */\n      \"mix-blend\": [{\n        \"mix-blend\": [...scaleBlendMode(), \"plus-darker\", \"plus-lighter\"]\n      }],\n      /**\n       * Background Blend Mode\n       * @see https://tailwindcss.com/docs/background-blend-mode\n       */\n      \"bg-blend\": [{\n        \"bg-blend\": scaleBlendMode()\n      }],\n      /**\n       * Mask Clip\n       * @see https://tailwindcss.com/docs/mask-clip\n       */\n      \"mask-clip\": [{\n        \"mask-clip\": [\"border\", \"padding\", \"content\", \"fill\", \"stroke\", \"view\"]\n      }, \"mask-no-clip\"],\n      /**\n       * Mask Composite\n       * @see https://tailwindcss.com/docs/mask-composite\n       */\n      \"mask-composite\": [{\n        mask: [\"add\", \"subtract\", \"intersect\", \"exclude\"]\n      }],\n      /**\n       * Mask Image\n       * @see https://tailwindcss.com/docs/mask-image\n       */\n      \"mask-image-linear-pos\": [{\n        \"mask-linear\": [isNumber]\n      }],\n      \"mask-image-linear-from-pos\": [{\n        \"mask-linear-from\": scaleMaskImagePosition()\n      }],\n      \"mask-image-linear-to-pos\": [{\n        \"mask-linear-to\": scaleMaskImagePosition()\n      }],\n      \"mask-image-linear-from-color\": [{\n        \"mask-linear-from\": scaleColor()\n      }],\n      \"mask-image-linear-to-color\": [{\n        \"mask-linear-to\": scaleColor()\n      }],\n      \"mask-image-t-from-pos\": [{\n        \"mask-t-from\": scaleMaskImagePosition()\n      }],\n      \"mask-image-t-to-pos\": [{\n        \"mask-t-to\": scaleMaskImagePosition()\n      }],\n      \"mask-image-t-from-color\": [{\n        \"mask-t-from\": scaleColor()\n      }],\n      \"mask-image-t-to-color\": [{\n        \"mask-t-to\": scaleColor()\n      }],\n      \"mask-image-r-from-pos\": [{\n        \"mask-r-from\": scaleMaskImagePosition()\n      }],\n      \"mask-image-r-to-pos\": [{\n        \"mask-r-to\": scaleMaskImagePosition()\n      }],\n      \"mask-image-r-from-color\": [{\n        \"mask-r-from\": scaleColor()\n      }],\n      \"mask-image-r-to-color\": [{\n        \"mask-r-to\": scaleColor()\n      }],\n      \"mask-image-b-from-pos\": [{\n        \"mask-b-from\": scaleMaskImagePosition()\n      }],\n      \"mask-image-b-to-pos\": [{\n        \"mask-b-to\": scaleMaskImagePosition()\n      }],\n      \"mask-image-b-from-color\": [{\n        \"mask-b-from\": scaleColor()\n      }],\n      \"mask-image-b-to-color\": [{\n        \"mask-b-to\": scaleColor()\n      }],\n      \"mask-image-l-from-pos\": [{\n        \"mask-l-from\": scaleMaskImagePosition()\n      }],\n      \"mask-image-l-to-pos\": [{\n        \"mask-l-to\": scaleMaskImagePosition()\n      }],\n      \"mask-image-l-from-color\": [{\n        \"mask-l-from\": scaleColor()\n      }],\n      \"mask-image-l-to-color\": [{\n        \"mask-l-to\": scaleColor()\n      }],\n      \"mask-image-x-from-pos\": [{\n        \"mask-x-from\": scaleMaskImagePosition()\n      }],\n      \"mask-image-x-to-pos\": [{\n        \"mask-x-to\": scaleMaskImagePosition()\n      }],\n      \"mask-image-x-from-color\": [{\n        \"mask-x-from\": scaleColor()\n      }],\n      \"mask-image-x-to-color\": [{\n        \"mask-x-to\": scaleColor()\n      }],\n      \"mask-image-y-from-pos\": [{\n        \"mask-y-from\": scaleMaskImagePosition()\n      }],\n      \"mask-image-y-to-pos\": [{\n        \"mask-y-to\": scaleMaskImagePosition()\n      }],\n      \"mask-image-y-from-color\": [{\n        \"mask-y-from\": scaleColor()\n      }],\n      \"mask-image-y-to-color\": [{\n        \"mask-y-to\": scaleColor()\n      }],\n      \"mask-image-radial\": [{\n        \"mask-radial\": [isArbitraryVariable, isArbitraryValue]\n      }],\n      \"mask-image-radial-from-pos\": [{\n        \"mask-radial-from\": scaleMaskImagePosition()\n      }],\n      \"mask-image-radial-to-pos\": [{\n        \"mask-radial-to\": scaleMaskImagePosition()\n      }],\n      \"mask-image-radial-from-color\": [{\n        \"mask-radial-from\": scaleColor()\n      }],\n      \"mask-image-radial-to-color\": [{\n        \"mask-radial-to\": scaleColor()\n      }],\n      \"mask-image-radial-shape\": [{\n        \"mask-radial\": [\"circle\", \"ellipse\"]\n      }],\n      \"mask-image-radial-size\": [{\n        \"mask-radial\": [{\n          closest: [\"side\", \"corner\"],\n          farthest: [\"side\", \"corner\"]\n        }]\n      }],\n      \"mask-image-radial-pos\": [{\n        \"mask-radial-at\": scalePosition()\n      }],\n      \"mask-image-conic-pos\": [{\n        \"mask-conic\": [isNumber]\n      }],\n      \"mask-image-conic-from-pos\": [{\n        \"mask-conic-from\": scaleMaskImagePosition()\n      }],\n      \"mask-image-conic-to-pos\": [{\n        \"mask-conic-to\": scaleMaskImagePosition()\n      }],\n      \"mask-image-conic-from-color\": [{\n        \"mask-conic-from\": scaleColor()\n      }],\n      \"mask-image-conic-to-color\": [{\n        \"mask-conic-to\": scaleColor()\n      }],\n      /**\n       * Mask Mode\n       * @see https://tailwindcss.com/docs/mask-mode\n       */\n      \"mask-mode\": [{\n        mask: [\"alpha\", \"luminance\", \"match\"]\n      }],\n      /**\n       * Mask Origin\n       * @see https://tailwindcss.com/docs/mask-origin\n       */\n      \"mask-origin\": [{\n        \"mask-origin\": [\"border\", \"padding\", \"content\", \"fill\", \"stroke\", \"view\"]\n      }],\n      /**\n       * Mask Position\n       * @see https://tailwindcss.com/docs/mask-position\n       */\n      \"mask-position\": [{\n        mask: scaleBgPosition()\n      }],\n      /**\n       * Mask Repeat\n       * @see https://tailwindcss.com/docs/mask-repeat\n       */\n      \"mask-repeat\": [{\n        mask: scaleBgRepeat()\n      }],\n      /**\n       * Mask Size\n       * @see https://tailwindcss.com/docs/mask-size\n       */\n      \"mask-size\": [{\n        mask: scaleBgSize()\n      }],\n      /**\n       * Mask Type\n       * @see https://tailwindcss.com/docs/mask-type\n       */\n      \"mask-type\": [{\n        \"mask-type\": [\"alpha\", \"luminance\"]\n      }],\n      /**\n       * Mask Image\n       * @see https://tailwindcss.com/docs/mask-image\n       */\n      \"mask-image\": [{\n        mask: [\"none\", isArbitraryVariable, isArbitraryValue]\n      }],\n      // ---------------\n      // --- Filters ---\n      // ---------------\n      /**\n       * Filter\n       * @see https://tailwindcss.com/docs/filter\n       */\n      filter: [{\n        filter: [\n        // Deprecated since Tailwind CSS v3.0.0\n        \"\", \"none\", isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Blur\n       * @see https://tailwindcss.com/docs/blur\n       */\n      blur: [{\n        blur: scaleBlur()\n      }],\n      /**\n       * Brightness\n       * @see https://tailwindcss.com/docs/brightness\n       */\n      brightness: [{\n        brightness: [isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Contrast\n       * @see https://tailwindcss.com/docs/contrast\n       */\n      contrast: [{\n        contrast: [isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Drop Shadow\n       * @see https://tailwindcss.com/docs/drop-shadow\n       */\n      \"drop-shadow\": [{\n        \"drop-shadow\": [\n        // Deprecated since Tailwind CSS v4.0.0\n        \"\", \"none\", themeDropShadow, isArbitraryVariableShadow, isArbitraryShadow]\n      }],\n      /**\n       * Drop Shadow Color\n       * @see https://tailwindcss.com/docs/filter-drop-shadow#setting-the-shadow-color\n       */\n      \"drop-shadow-color\": [{\n        \"drop-shadow\": scaleColor()\n      }],\n      /**\n       * Grayscale\n       * @see https://tailwindcss.com/docs/grayscale\n       */\n      grayscale: [{\n        grayscale: [\"\", isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Hue Rotate\n       * @see https://tailwindcss.com/docs/hue-rotate\n       */\n      \"hue-rotate\": [{\n        \"hue-rotate\": [isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Invert\n       * @see https://tailwindcss.com/docs/invert\n       */\n      invert: [{\n        invert: [\"\", isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Saturate\n       * @see https://tailwindcss.com/docs/saturate\n       */\n      saturate: [{\n        saturate: [isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Sepia\n       * @see https://tailwindcss.com/docs/sepia\n       */\n      sepia: [{\n        sepia: [\"\", isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Backdrop Filter\n       * @see https://tailwindcss.com/docs/backdrop-filter\n       */\n      \"backdrop-filter\": [{\n        \"backdrop-filter\": [\n        // Deprecated since Tailwind CSS v3.0.0\n        \"\", \"none\", isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Backdrop Blur\n       * @see https://tailwindcss.com/docs/backdrop-blur\n       */\n      \"backdrop-blur\": [{\n        \"backdrop-blur\": scaleBlur()\n      }],\n      /**\n       * Backdrop Brightness\n       * @see https://tailwindcss.com/docs/backdrop-brightness\n       */\n      \"backdrop-brightness\": [{\n        \"backdrop-brightness\": [isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Backdrop Contrast\n       * @see https://tailwindcss.com/docs/backdrop-contrast\n       */\n      \"backdrop-contrast\": [{\n        \"backdrop-contrast\": [isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Backdrop Grayscale\n       * @see https://tailwindcss.com/docs/backdrop-grayscale\n       */\n      \"backdrop-grayscale\": [{\n        \"backdrop-grayscale\": [\"\", isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Backdrop Hue Rotate\n       * @see https://tailwindcss.com/docs/backdrop-hue-rotate\n       */\n      \"backdrop-hue-rotate\": [{\n        \"backdrop-hue-rotate\": [isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Backdrop Invert\n       * @see https://tailwindcss.com/docs/backdrop-invert\n       */\n      \"backdrop-invert\": [{\n        \"backdrop-invert\": [\"\", isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Backdrop Opacity\n       * @see https://tailwindcss.com/docs/backdrop-opacity\n       */\n      \"backdrop-opacity\": [{\n        \"backdrop-opacity\": [isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Backdrop Saturate\n       * @see https://tailwindcss.com/docs/backdrop-saturate\n       */\n      \"backdrop-saturate\": [{\n        \"backdrop-saturate\": [isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Backdrop Sepia\n       * @see https://tailwindcss.com/docs/backdrop-sepia\n       */\n      \"backdrop-sepia\": [{\n        \"backdrop-sepia\": [\"\", isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      // --------------\n      // --- Tables ---\n      // --------------\n      /**\n       * Border Collapse\n       * @see https://tailwindcss.com/docs/border-collapse\n       */\n      \"border-collapse\": [{\n        border: [\"collapse\", \"separate\"]\n      }],\n      /**\n       * Border Spacing\n       * @see https://tailwindcss.com/docs/border-spacing\n       */\n      \"border-spacing\": [{\n        \"border-spacing\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Border Spacing X\n       * @see https://tailwindcss.com/docs/border-spacing\n       */\n      \"border-spacing-x\": [{\n        \"border-spacing-x\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Border Spacing Y\n       * @see https://tailwindcss.com/docs/border-spacing\n       */\n      \"border-spacing-y\": [{\n        \"border-spacing-y\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Table Layout\n       * @see https://tailwindcss.com/docs/table-layout\n       */\n      \"table-layout\": [{\n        table: [\"auto\", \"fixed\"]\n      }],\n      /**\n       * Caption Side\n       * @see https://tailwindcss.com/docs/caption-side\n       */\n      caption: [{\n        caption: [\"top\", \"bottom\"]\n      }],\n      // ---------------------------------\n      // --- Transitions and Animation ---\n      // ---------------------------------\n      /**\n       * Transition Property\n       * @see https://tailwindcss.com/docs/transition-property\n       */\n      transition: [{\n        transition: [\"\", \"all\", \"colors\", \"opacity\", \"shadow\", \"transform\", \"none\", isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Transition Behavior\n       * @see https://tailwindcss.com/docs/transition-behavior\n       */\n      \"transition-behavior\": [{\n        transition: [\"normal\", \"discrete\"]\n      }],\n      /**\n       * Transition Duration\n       * @see https://tailwindcss.com/docs/transition-duration\n       */\n      duration: [{\n        duration: [isNumber, \"initial\", isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Transition Timing Function\n       * @see https://tailwindcss.com/docs/transition-timing-function\n       */\n      ease: [{\n        ease: [\"linear\", \"initial\", themeEase, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Transition Delay\n       * @see https://tailwindcss.com/docs/transition-delay\n       */\n      delay: [{\n        delay: [isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Animation\n       * @see https://tailwindcss.com/docs/animation\n       */\n      animate: [{\n        animate: [\"none\", themeAnimate, isArbitraryVariable, isArbitraryValue]\n      }],\n      // ------------------\n      // --- Transforms ---\n      // ------------------\n      /**\n       * Backface Visibility\n       * @see https://tailwindcss.com/docs/backface-visibility\n       */\n      backface: [{\n        backface: [\"hidden\", \"visible\"]\n      }],\n      /**\n       * Perspective\n       * @see https://tailwindcss.com/docs/perspective\n       */\n      perspective: [{\n        perspective: [themePerspective, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Perspective Origin\n       * @see https://tailwindcss.com/docs/perspective-origin\n       */\n      \"perspective-origin\": [{\n        \"perspective-origin\": scalePositionWithArbitrary()\n      }],\n      /**\n       * Rotate\n       * @see https://tailwindcss.com/docs/rotate\n       */\n      rotate: [{\n        rotate: scaleRotate()\n      }],\n      /**\n       * Rotate X\n       * @see https://tailwindcss.com/docs/rotate\n       */\n      \"rotate-x\": [{\n        \"rotate-x\": scaleRotate()\n      }],\n      /**\n       * Rotate Y\n       * @see https://tailwindcss.com/docs/rotate\n       */\n      \"rotate-y\": [{\n        \"rotate-y\": scaleRotate()\n      }],\n      /**\n       * Rotate Z\n       * @see https://tailwindcss.com/docs/rotate\n       */\n      \"rotate-z\": [{\n        \"rotate-z\": scaleRotate()\n      }],\n      /**\n       * Scale\n       * @see https://tailwindcss.com/docs/scale\n       */\n      scale: [{\n        scale: scaleScale()\n      }],\n      /**\n       * Scale X\n       * @see https://tailwindcss.com/docs/scale\n       */\n      \"scale-x\": [{\n        \"scale-x\": scaleScale()\n      }],\n      /**\n       * Scale Y\n       * @see https://tailwindcss.com/docs/scale\n       */\n      \"scale-y\": [{\n        \"scale-y\": scaleScale()\n      }],\n      /**\n       * Scale Z\n       * @see https://tailwindcss.com/docs/scale\n       */\n      \"scale-z\": [{\n        \"scale-z\": scaleScale()\n      }],\n      /**\n       * Scale 3D\n       * @see https://tailwindcss.com/docs/scale\n       */\n      \"scale-3d\": [\"scale-3d\"],\n      /**\n       * Skew\n       * @see https://tailwindcss.com/docs/skew\n       */\n      skew: [{\n        skew: scaleSkew()\n      }],\n      /**\n       * Skew X\n       * @see https://tailwindcss.com/docs/skew\n       */\n      \"skew-x\": [{\n        \"skew-x\": scaleSkew()\n      }],\n      /**\n       * Skew Y\n       * @see https://tailwindcss.com/docs/skew\n       */\n      \"skew-y\": [{\n        \"skew-y\": scaleSkew()\n      }],\n      /**\n       * Transform\n       * @see https://tailwindcss.com/docs/transform\n       */\n      transform: [{\n        transform: [isArbitraryVariable, isArbitraryValue, \"\", \"none\", \"gpu\", \"cpu\"]\n      }],\n      /**\n       * Transform Origin\n       * @see https://tailwindcss.com/docs/transform-origin\n       */\n      \"transform-origin\": [{\n        origin: scalePositionWithArbitrary()\n      }],\n      /**\n       * Transform Style\n       * @see https://tailwindcss.com/docs/transform-style\n       */\n      \"transform-style\": [{\n        transform: [\"3d\", \"flat\"]\n      }],\n      /**\n       * Translate\n       * @see https://tailwindcss.com/docs/translate\n       */\n      translate: [{\n        translate: scaleTranslate()\n      }],\n      /**\n       * Translate X\n       * @see https://tailwindcss.com/docs/translate\n       */\n      \"translate-x\": [{\n        \"translate-x\": scaleTranslate()\n      }],\n      /**\n       * Translate Y\n       * @see https://tailwindcss.com/docs/translate\n       */\n      \"translate-y\": [{\n        \"translate-y\": scaleTranslate()\n      }],\n      /**\n       * Translate Z\n       * @see https://tailwindcss.com/docs/translate\n       */\n      \"translate-z\": [{\n        \"translate-z\": scaleTranslate()\n      }],\n      /**\n       * Translate None\n       * @see https://tailwindcss.com/docs/translate\n       */\n      \"translate-none\": [\"translate-none\"],\n      // ---------------------\n      // --- Interactivity ---\n      // ---------------------\n      /**\n       * Accent Color\n       * @see https://tailwindcss.com/docs/accent-color\n       */\n      accent: [{\n        accent: scaleColor()\n      }],\n      /**\n       * Appearance\n       * @see https://tailwindcss.com/docs/appearance\n       */\n      appearance: [{\n        appearance: [\"none\", \"auto\"]\n      }],\n      /**\n       * Caret Color\n       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities\n       */\n      \"caret-color\": [{\n        caret: scaleColor()\n      }],\n      /**\n       * Color Scheme\n       * @see https://tailwindcss.com/docs/color-scheme\n       */\n      \"color-scheme\": [{\n        scheme: [\"normal\", \"dark\", \"light\", \"light-dark\", \"only-dark\", \"only-light\"]\n      }],\n      /**\n       * Cursor\n       * @see https://tailwindcss.com/docs/cursor\n       */\n      cursor: [{\n        cursor: [\"auto\", \"default\", \"pointer\", \"wait\", \"text\", \"move\", \"help\", \"not-allowed\", \"none\", \"context-menu\", \"progress\", \"cell\", \"crosshair\", \"vertical-text\", \"alias\", \"copy\", \"no-drop\", \"grab\", \"grabbing\", \"all-scroll\", \"col-resize\", \"row-resize\", \"n-resize\", \"e-resize\", \"s-resize\", \"w-resize\", \"ne-resize\", \"nw-resize\", \"se-resize\", \"sw-resize\", \"ew-resize\", \"ns-resize\", \"nesw-resize\", \"nwse-resize\", \"zoom-in\", \"zoom-out\", isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Field Sizing\n       * @see https://tailwindcss.com/docs/field-sizing\n       */\n      \"field-sizing\": [{\n        \"field-sizing\": [\"fixed\", \"content\"]\n      }],\n      /**\n       * Pointer Events\n       * @see https://tailwindcss.com/docs/pointer-events\n       */\n      \"pointer-events\": [{\n        \"pointer-events\": [\"auto\", \"none\"]\n      }],\n      /**\n       * Resize\n       * @see https://tailwindcss.com/docs/resize\n       */\n      resize: [{\n        resize: [\"none\", \"\", \"y\", \"x\"]\n      }],\n      /**\n       * Scroll Behavior\n       * @see https://tailwindcss.com/docs/scroll-behavior\n       */\n      \"scroll-behavior\": [{\n        scroll: [\"auto\", \"smooth\"]\n      }],\n      /**\n       * Scroll Margin\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      \"scroll-m\": [{\n        \"scroll-m\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Margin X\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      \"scroll-mx\": [{\n        \"scroll-mx\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Margin Y\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      \"scroll-my\": [{\n        \"scroll-my\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Margin Start\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      \"scroll-ms\": [{\n        \"scroll-ms\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Margin End\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      \"scroll-me\": [{\n        \"scroll-me\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Margin Top\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      \"scroll-mt\": [{\n        \"scroll-mt\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Margin Right\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      \"scroll-mr\": [{\n        \"scroll-mr\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Margin Bottom\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      \"scroll-mb\": [{\n        \"scroll-mb\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Margin Left\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      \"scroll-ml\": [{\n        \"scroll-ml\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Padding\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      \"scroll-p\": [{\n        \"scroll-p\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Padding X\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      \"scroll-px\": [{\n        \"scroll-px\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Padding Y\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      \"scroll-py\": [{\n        \"scroll-py\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Padding Start\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      \"scroll-ps\": [{\n        \"scroll-ps\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Padding End\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      \"scroll-pe\": [{\n        \"scroll-pe\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Padding Top\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      \"scroll-pt\": [{\n        \"scroll-pt\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Padding Right\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      \"scroll-pr\": [{\n        \"scroll-pr\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Padding Bottom\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      \"scroll-pb\": [{\n        \"scroll-pb\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Padding Left\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      \"scroll-pl\": [{\n        \"scroll-pl\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Snap Align\n       * @see https://tailwindcss.com/docs/scroll-snap-align\n       */\n      \"snap-align\": [{\n        snap: [\"start\", \"end\", \"center\", \"align-none\"]\n      }],\n      /**\n       * Scroll Snap Stop\n       * @see https://tailwindcss.com/docs/scroll-snap-stop\n       */\n      \"snap-stop\": [{\n        snap: [\"normal\", \"always\"]\n      }],\n      /**\n       * Scroll Snap Type\n       * @see https://tailwindcss.com/docs/scroll-snap-type\n       */\n      \"snap-type\": [{\n        snap: [\"none\", \"x\", \"y\", \"both\"]\n      }],\n      /**\n       * Scroll Snap Type Strictness\n       * @see https://tailwindcss.com/docs/scroll-snap-type\n       */\n      \"snap-strictness\": [{\n        snap: [\"mandatory\", \"proximity\"]\n      }],\n      /**\n       * Touch Action\n       * @see https://tailwindcss.com/docs/touch-action\n       */\n      touch: [{\n        touch: [\"auto\", \"none\", \"manipulation\"]\n      }],\n      /**\n       * Touch Action X\n       * @see https://tailwindcss.com/docs/touch-action\n       */\n      \"touch-x\": [{\n        \"touch-pan\": [\"x\", \"left\", \"right\"]\n      }],\n      /**\n       * Touch Action Y\n       * @see https://tailwindcss.com/docs/touch-action\n       */\n      \"touch-y\": [{\n        \"touch-pan\": [\"y\", \"up\", \"down\"]\n      }],\n      /**\n       * Touch Action Pinch Zoom\n       * @see https://tailwindcss.com/docs/touch-action\n       */\n      \"touch-pz\": [\"touch-pinch-zoom\"],\n      /**\n       * User Select\n       * @see https://tailwindcss.com/docs/user-select\n       */\n      select: [{\n        select: [\"none\", \"text\", \"all\", \"auto\"]\n      }],\n      /**\n       * Will Change\n       * @see https://tailwindcss.com/docs/will-change\n       */\n      \"will-change\": [{\n        \"will-change\": [\"auto\", \"scroll\", \"contents\", \"transform\", isArbitraryVariable, isArbitraryValue]\n      }],\n      // -----------\n      // --- SVG ---\n      // -----------\n      /**\n       * Fill\n       * @see https://tailwindcss.com/docs/fill\n       */\n      fill: [{\n        fill: [\"none\", ...scaleColor()]\n      }],\n      /**\n       * Stroke Width\n       * @see https://tailwindcss.com/docs/stroke-width\n       */\n      \"stroke-w\": [{\n        stroke: [isNumber, isArbitraryVariableLength, isArbitraryLength, isArbitraryNumber]\n      }],\n      /**\n       * Stroke\n       * @see https://tailwindcss.com/docs/stroke\n       */\n      stroke: [{\n        stroke: [\"none\", ...scaleColor()]\n      }],\n      // ---------------------\n      // --- Accessibility ---\n      // ---------------------\n      /**\n       * Forced Color Adjust\n       * @see https://tailwindcss.com/docs/forced-color-adjust\n       */\n      \"forced-color-adjust\": [{\n        \"forced-color-adjust\": [\"auto\", \"none\"]\n      }]\n    },\n    conflictingClassGroups: {\n      overflow: [\"overflow-x\", \"overflow-y\"],\n      overscroll: [\"overscroll-x\", \"overscroll-y\"],\n      inset: [\"inset-x\", \"inset-y\", \"start\", \"end\", \"top\", \"right\", \"bottom\", \"left\"],\n      \"inset-x\": [\"right\", \"left\"],\n      \"inset-y\": [\"top\", \"bottom\"],\n      flex: [\"basis\", \"grow\", \"shrink\"],\n      gap: [\"gap-x\", \"gap-y\"],\n      p: [\"px\", \"py\", \"ps\", \"pe\", \"pt\", \"pr\", \"pb\", \"pl\"],\n      px: [\"pr\", \"pl\"],\n      py: [\"pt\", \"pb\"],\n      m: [\"mx\", \"my\", \"ms\", \"me\", \"mt\", \"mr\", \"mb\", \"ml\"],\n      mx: [\"mr\", \"ml\"],\n      my: [\"mt\", \"mb\"],\n      size: [\"w\", \"h\"],\n      \"font-size\": [\"leading\"],\n      \"fvn-normal\": [\"fvn-ordinal\", \"fvn-slashed-zero\", \"fvn-figure\", \"fvn-spacing\", \"fvn-fraction\"],\n      \"fvn-ordinal\": [\"fvn-normal\"],\n      \"fvn-slashed-zero\": [\"fvn-normal\"],\n      \"fvn-figure\": [\"fvn-normal\"],\n      \"fvn-spacing\": [\"fvn-normal\"],\n      \"fvn-fraction\": [\"fvn-normal\"],\n      \"line-clamp\": [\"display\", \"overflow\"],\n      rounded: [\"rounded-s\", \"rounded-e\", \"rounded-t\", \"rounded-r\", \"rounded-b\", \"rounded-l\", \"rounded-ss\", \"rounded-se\", \"rounded-ee\", \"rounded-es\", \"rounded-tl\", \"rounded-tr\", \"rounded-br\", \"rounded-bl\"],\n      \"rounded-s\": [\"rounded-ss\", \"rounded-es\"],\n      \"rounded-e\": [\"rounded-se\", \"rounded-ee\"],\n      \"rounded-t\": [\"rounded-tl\", \"rounded-tr\"],\n      \"rounded-r\": [\"rounded-tr\", \"rounded-br\"],\n      \"rounded-b\": [\"rounded-br\", \"rounded-bl\"],\n      \"rounded-l\": [\"rounded-tl\", \"rounded-bl\"],\n      \"border-spacing\": [\"border-spacing-x\", \"border-spacing-y\"],\n      \"border-w\": [\"border-w-x\", \"border-w-y\", \"border-w-s\", \"border-w-e\", \"border-w-t\", \"border-w-r\", \"border-w-b\", \"border-w-l\"],\n      \"border-w-x\": [\"border-w-r\", \"border-w-l\"],\n      \"border-w-y\": [\"border-w-t\", \"border-w-b\"],\n      \"border-color\": [\"border-color-x\", \"border-color-y\", \"border-color-s\", \"border-color-e\", \"border-color-t\", \"border-color-r\", \"border-color-b\", \"border-color-l\"],\n      \"border-color-x\": [\"border-color-r\", \"border-color-l\"],\n      \"border-color-y\": [\"border-color-t\", \"border-color-b\"],\n      translate: [\"translate-x\", \"translate-y\", \"translate-none\"],\n      \"translate-none\": [\"translate\", \"translate-x\", \"translate-y\", \"translate-z\"],\n      \"scroll-m\": [\"scroll-mx\", \"scroll-my\", \"scroll-ms\", \"scroll-me\", \"scroll-mt\", \"scroll-mr\", \"scroll-mb\", \"scroll-ml\"],\n      \"scroll-mx\": [\"scroll-mr\", \"scroll-ml\"],\n      \"scroll-my\": [\"scroll-mt\", \"scroll-mb\"],\n      \"scroll-p\": [\"scroll-px\", \"scroll-py\", \"scroll-ps\", \"scroll-pe\", \"scroll-pt\", \"scroll-pr\", \"scroll-pb\", \"scroll-pl\"],\n      \"scroll-px\": [\"scroll-pr\", \"scroll-pl\"],\n      \"scroll-py\": [\"scroll-pt\", \"scroll-pb\"],\n      touch: [\"touch-x\", \"touch-y\", \"touch-pz\"],\n      \"touch-x\": [\"touch\"],\n      \"touch-y\": [\"touch\"],\n      \"touch-pz\": [\"touch\"]\n    },\n    conflictingClassGroupModifiers: {\n      \"font-size\": [\"leading\"]\n    },\n    orderSensitiveModifiers: [\"*\", \"**\", \"after\", \"backdrop\", \"before\", \"details-content\", \"file\", \"first-letter\", \"first-line\", \"marker\", \"placeholder\", \"selection\"]\n  };\n};\nvar twMerge = /* @__PURE__ */createTailwindMerge(getDefaultConfig);\n\n// src/styles/stylingUtils.ts\nimport { cloneElement, isValidElement } from \"react\";\nvar luminanceThreshold = 0.412;\nfunction isDarkMode() {\n  if (typeof window === \"undefined\") return false;\n  return document.documentElement.classList.contains(\"dark\");\n}\nfunction cn(...inputs) {\n  return twMerge(clsx(inputs));\n}\nvar hexToRgb = hex => {\n  const r2 = parseInt(hex.slice(1, 3), 16);\n  const g = parseInt(hex.slice(3, 5), 16);\n  const b = parseInt(hex.slice(5, 7), 16);\n  return {\n    r: r2,\n    g,\n    b\n  };\n};\nvar getShadedColor = (hex, shade) => {\n  const {\n    r: r2,\n    g,\n    b\n  } = hexToRgb(hex);\n  return `rgb(${Math.max(0, r2 - shade)}, ${Math.max(0, g - shade)}, ${Math.max(0, b - shade)})`;\n};\nvar getLightenedColor = (hex, lighten) => {\n  const {\n    r: r2,\n    g,\n    b\n  } = hexToRgb(hex);\n  return `rgb(${Math.min(255, r2 + lighten)}, ${Math.min(255, g + lighten)}, ${Math.min(255, b + lighten)})`;\n};\nfunction createBorderColor(color) {\n  return getShadedColor(color, 70);\n}\nvar getTextColorForBackground = (backgroundColor, secondary) => {\n  const hex = backgroundColor.replace(\"#\", \"\");\n  const r2 = parseInt(hex.substring(0, 2), 16);\n  const g = parseInt(hex.substring(2, 4), 16);\n  const b = parseInt(hex.substring(4, 6), 16);\n  const luminance = (0.299 * r2 + 0.587 * g + 0.114 * b) / 255;\n  const baseColor = luminance > luminanceThreshold ? \"#000000\" : \"#ffffff\";\n  if (secondary) {\n    return luminance > luminanceThreshold ? \"#374151\" : \"#D1D5DB\";\n  }\n  return baseColor;\n};\nfunction withClassName(node, className) {\n  if (isValidElement(node)) {\n    const element = node;\n    const existingClass = element.props.className;\n    return cloneElement(element, {\n      className: cn(existingClass, className)\n    });\n  }\n  return node;\n}\nvar desaturateColor = color => {\n  if (color.startsWith(\"rgba\")) return color;\n  if (color.startsWith(\"#\")) {\n    return `${color}40`;\n  }\n  return color.replace(\"rgb\", \"rgba\").replace(\")\", \", 0.7)\");\n};\n\n// src/components/ui/tabs.tsx\nimport { jsx as jsx11 } from \"react/jsx-runtime\";\nfunction Tabs({\n  className,\n  ...props\n}) {\n  return /* @__PURE__ */jsx11(TabsPrimitive.Root, {\n    \"data-slot\": \"tabs\",\n    className: cn(\"flex flex-col gap-2\", className),\n    ...props\n  });\n}\nfunction TabsList({\n  className,\n  ...props\n}) {\n  return /* @__PURE__ */jsx11(TabsPrimitive.List, {\n    \"data-slot\": \"tabs-list\",\n    className: cn(\"bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]\", className),\n    ...props\n  });\n}\nfunction TabsTrigger({\n  className,\n  ...props\n}) {\n  return /* @__PURE__ */jsx11(TabsPrimitive.Trigger, {\n    \"data-slot\": \"tabs-trigger\",\n    className: cn(\"data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4\", className),\n    ...props\n  });\n}\nfunction TabsContent({\n  className,\n  ...props\n}) {\n  return /* @__PURE__ */jsx11(TabsPrimitive.Content, {\n    \"data-slot\": \"tabs-content\",\n    className: cn(\"flex-1 outline-none\", className),\n    ...props\n  });\n}\n\n// src/components/containers/Container3D.tsx\nimport { motion as motion2 } from \"framer-motion\";\nimport { jsx as jsx12 } from \"react/jsx-runtime\";\nvar Container3D = ({\n  children,\n  className = \"\",\n  motionProps = {},\n  id,\n  style,\n  color\n}) => {\n  const {\n    styling\n  } = useStyling();\n  const isDarkMode2 = styling.darkMode ?? false;\n  const shadeBase = color || (isDarkMode2 ? \"#000000\" : \"#ffffff\");\n  const restMotionProps = motionProps;\n  const baseStyle = {\n    boxShadow: isDarkMode2 ? [`0px 2px 0px 0px ${getShadedColor(shadeBase, 80)}`, \"-12px 18px 16px 0px rgba(0,0,0,0.4)\", \"-6px 10px 8px 0px rgba(0,0,0,0.4)\", \"-2px 4px 3px 0px rgba(0,0,0,0.3)\", \"-1px 2px 3px 0px rgba(255,255,255,0.05) inset\"].join(\", \") : [`0px 2px 0px 0px ${getShadedColor(shadeBase, 50)}`, \"-12px 18px 16px 0px rgba(0,0,0,0.14)\", \"-6px 10px 8px 0px rgba(0,0,0,0.14)\", \"-2px 4px 3px 0px rgba(0,0,0,0.15)\", \"-1px 2px 3px 0px rgba(0,0,0,0.12) inset\"].join(\", \"),\n    willChange: \"transform, backdrop-filter\",\n    transform: \"translateZ(0)\"\n  };\n  const colorStyle = color ? {\n    backgroundColor: color,\n    borderColor: createBorderColor(color)\n  } : {};\n  const textStyle = color ? {\n    color: getTextColorForBackground(color)\n  } : {};\n  const combinedStyle = {\n    ...baseStyle,\n    ...colorStyle,\n    ...textStyle,\n    ...style\n  };\n  return /* @__PURE__ */jsx12(motion2.div, {\n    id,\n    className: cn(\"w-full h-full rounded-xl border-[3px] backdrop-blur-[12px]\",\n    // Only apply default border/background when no custom color provided\n    !color && (isDarkMode2 ? \"border-gray-700 bg-black/40\" : \"border-white bg-[#FAF9F580]\"), className),\n    style: combinedStyle,\n    ...restMotionProps,\n    children\n  });\n};\nvar Container3D_default = Container3D;\n\n// src/components/debugger/NetworkTab.tsx\nimport React4, { useState as useState2, useEffect as useEffect10, useRef as useRef5 } from \"react\";\nimport { motion as motion4, AnimatePresence as AnimatePresence2 } from \"framer-motion\";\nimport { Check as Check2, Copy, ChevronDown as ChevronDown3, ChevronRight as ChevronRight3 } from \"lucide-react\";\n\n// src/components/debugger/CollapsibleSection.tsx\nimport { motion as motion3, AnimatePresence } from \"framer-motion\";\nimport { ChevronDown as ChevronDown2, ChevronRight as ChevronRight2 } from \"lucide-react\";\nimport { jsx as jsx13, jsxs as jsxs3 } from \"react/jsx-runtime\";\nvar CollapsibleSection = ({\n  title,\n  isExpanded,\n  onToggle,\n  badges,\n  children\n}) => {\n  const getBadgeColor = color => {\n    const colors = {\n      gray: \"bg-gray-100 dark:bg-gray-800 text-gray-700 dark:text-gray-300\",\n      blue: \"bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-300\",\n      green: \"bg-green-100 dark:bg-green-900 text-green-700 dark:text-green-300\",\n      purple: \"bg-purple-100 dark:bg-purple-900 text-purple-700 dark:text-purple-300\",\n      amber: \"bg-amber-100 dark:bg-amber-900 text-amber-700 dark:text-amber-300\",\n      red: \"bg-red-100 dark:bg-red-900 text-red-700 dark:text-red-300\",\n      yellow: \"bg-yellow-100 dark:bg-yellow-900 text-yellow-700 dark:text-yellow-300\"\n    };\n    return colors[color];\n  };\n  return /* @__PURE__ */jsxs3(\"div\", {\n    className: \"border border-gray-200 dark:border-gray-700 rounded-lg\",\n    children: [/* @__PURE__ */jsx13(\"div\", {\n      className: cn(\"flex items-center justify-between p-2 cursor-pointer transition-colors hover:bg-gray-50 dark:hover:bg-gray-800/50\", isExpanded ? \"rounded-t-lg\" : \"rounded-lg\"),\n      onClick: onToggle,\n      children: /* @__PURE__ */jsxs3(\"div\", {\n        className: \"flex items-center gap-2 flex-1\",\n        children: [isExpanded ? /* @__PURE__ */jsx13(ChevronDown2, {\n          className: \"w-4 h-4\"\n        }) : /* @__PURE__ */jsx13(ChevronRight2, {\n          className: \"w-4 h-4\"\n        }), /* @__PURE__ */jsx13(\"span\", {\n          className: \"font-medium text-sm\",\n          children: title\n        }), /* @__PURE__ */jsx13(\"div\", {\n          className: \"flex items-center gap-1 ml-2\",\n          children: badges.map(badge => /* @__PURE__ */jsx13(\"span\", {\n            className: cn(\"px-2 py-0.5 rounded text-xs\", getBadgeColor(badge.color)),\n            children: badge.label\n          }, badge.label))\n        })]\n      })\n    }), /* @__PURE__ */jsx13(AnimatePresence, {\n      children: isExpanded && /* @__PURE__ */jsx13(motion3.div, {\n        initial: {\n          height: 0,\n          opacity: 0\n        },\n        animate: {\n          height: \"auto\",\n          opacity: 1\n        },\n        exit: {\n          height: 0,\n          opacity: 0\n        },\n        transition: {\n          duration: 0.2\n        },\n        className: \"overflow-hidden\",\n        children: /* @__PURE__ */jsx13(\"div\", {\n          className: \"p-3 pt-0 rounded-b-lg\",\n          children\n        })\n      })\n    })]\n  });\n};\n\n// src/components/debugger/NetworkTab.tsx\nimport { jsx as jsx14, jsxs as jsxs4 } from \"react/jsx-runtime\";\nvar NetworkTab = ({\n  logs,\n  onCopy,\n  copiedId\n}) => {\n  const [expandedLogs, setExpandedLogs] = useState2(/* @__PURE__ */new Set());\n  const [expandedSections, setExpandedSections] = useState2(/* @__PURE__ */new Set());\n  const scrollRef = useRef5(null);\n  const safeStringify = (obj, indent = 2) => {\n    try {\n      return JSON.stringify(obj, null, indent);\n    } catch (error40) {\n      try {\n        const sanitized = sanitizeJson(obj);\n        return JSON.stringify(sanitized, null, indent);\n      } catch {\n        return `[Error serializing object: ${error40 instanceof Error ? error40.message : \"Unknown error\"}]`;\n      }\n    }\n  };\n  const chronologicalLogs = React4.useMemo(() => {\n    return [...logs].reverse().filter(log => log.type !== \"handler\");\n  }, [logs]);\n  useEffect10(() => {\n    if (scrollRef.current) {\n      scrollRef.current.scrollTop = scrollRef.current.scrollHeight;\n    }\n  }, [chronologicalLogs.length]);\n  const toggleExpanded = logId => {\n    setExpandedLogs(prev => {\n      const next = new Set(prev);\n      if (next.has(logId)) {\n        next.delete(logId);\n      } else {\n        next.add(logId);\n      }\n      return next;\n    });\n  };\n  const toggleSection = sectionId => {\n    setExpandedSections(prev => {\n      const next = new Set(prev);\n      if (next.has(sectionId)) {\n        next.delete(sectionId);\n      } else {\n        next.add(sectionId);\n      }\n      return next;\n    });\n  };\n  const getLogTypeColor = log => {\n    switch (log.type) {\n      case \"error\":\n      case \"stream-error\":\n        return \"bg-red-50 dark:bg-red-950 border-red-200 dark:border-red-800\";\n      case \"stream-complete\":\n        return \"bg-purple-50 dark:bg-purple-950 border-purple-200 dark:border-purple-800\";\n      case \"response\":\n        return \"bg-green-50 dark:bg-green-950 border-green-200 dark:border-green-800\";\n      case \"request\":\n        return \"bg-blue-50 dark:bg-blue-950 border-blue-200 dark:border-blue-800\";\n      case \"handler\":\n        return \"bg-amber-50 dark:bg-amber-950 border-amber-200 dark:border-amber-800\";\n      default:\n        return \"bg-gray-50 dark:bg-gray-950 border-gray-200 dark:border-gray-800\";\n    }\n  };\n  const getLogTypeHover = log => {\n    switch (log.type) {\n      case \"error\":\n      case \"stream-error\":\n        return \"hover:bg-red-100 dark:hover:bg-red-900/80\";\n      case \"stream-complete\":\n        return \"hover:bg-purple-100 dark:hover:bg-purple-900/80\";\n      case \"response\":\n        return \"hover:bg-green-100 dark:hover:bg-green-900/80\";\n      case \"request\":\n        return \"hover:bg-blue-100 dark:hover:bg-blue-900/80\";\n      case \"handler\":\n        return \"hover:bg-amber-100 dark:hover:bg-amber-900/80\";\n      default:\n        return \"hover:bg-gray-100 dark:hover:bg-gray-900/80\";\n    }\n  };\n  const getLogTypeIcon = log => {\n    switch (log.type) {\n      case \"error\":\n      case \"stream-error\":\n        return \"\\u2715\";\n      case \"stream-complete\":\n        return \"\\u25C8\";\n      case \"response\":\n        return \"\\u2190\";\n      case \"request\":\n        return \"\\u2192\";\n      case \"handler\":\n        return \"\\u26A1\";\n      default:\n        return \"\\u2022\";\n    }\n  };\n  const getLogTypeLabel = log => {\n    switch (log.type) {\n      case \"error\":\n        return \"Error\";\n      case \"stream-error\":\n        return \"Stream Error\";\n      case \"stream-complete\":\n        const chunkLength = log.data.streamContent?.length || 0;\n        const objectCount = log.data.streamObjects?.length || 0;\n        if (chunkLength > 0 && objectCount > 0) {\n          return `Stream (${chunkLength} chars, ${objectCount} objects)`;\n        } else if (chunkLength > 0) {\n          return `Stream (${chunkLength} chars)`;\n        } else if (objectCount > 0) {\n          return `Stream (${objectCount} objects)`;\n        }\n        return \"Stream\";\n      case \"response\":\n        return \"Response\";\n      case \"request\":\n        return \"Request\";\n      case \"handler\":\n        return \"Handler\";\n      default:\n        return \"Unknown\";\n    }\n  };\n  const formatTimestamp = date5 => {\n    const now2 = /* @__PURE__ */new Date();\n    const diffMs = now2.getTime() - date5.getTime();\n    const diffMinutes = Math.floor(diffMs / (1e3 * 60));\n    const diffSeconds = Math.floor(diffMs / 1e3);\n    if (diffMinutes >= 1) {\n      return `${diffMinutes} minute${diffMinutes === 1 ? \"\" : \"s\"} ago`;\n    } else if (diffSeconds >= 1) {\n      return `${diffSeconds} second${diffSeconds === 1 ? \"\" : \"s\"} ago`;\n    } else {\n      return \"just now\";\n    }\n  };\n  return /* @__PURE__ */jsx14(\"div\", {\n    ref: scrollRef,\n    className: \"h-full overflow-y-auto p-2 space-y-1\",\n    children: chronologicalLogs.length === 0 ? /* @__PURE__ */jsx14(\"div\", {\n      className: \"text-center text-gray-500 dark:text-gray-400 py-4 text-xs\",\n      children: \"No network activity yet\"\n    }) : chronologicalLogs.map(log => {\n      const isExpanded = expandedLogs.has(log.id);\n      return /* @__PURE__ */jsxs4(\"div\", {\n        className: cn(\"border rounded-lg transition-all\", getLogTypeColor(log)),\n        children: [/* @__PURE__ */jsxs4(\"div\", {\n          className: cn(\"flex items-center justify-between p-2 cursor-pointer transition-colors\", isExpanded ? \"rounded-t-lg\" : \"rounded-lg\", getLogTypeHover(log)),\n          onClick: () => toggleExpanded(log.id),\n          children: [/* @__PURE__ */jsxs4(\"div\", {\n            className: \"flex items-center gap-1.5 flex-1\",\n            children: [/* @__PURE__ */jsx14(\"span\", {\n              className: \"text-sm\",\n              children: getLogTypeIcon(log)\n            }), /* @__PURE__ */jsxs4(\"div\", {\n              className: \"flex flex-col\",\n              children: [/* @__PURE__ */jsxs4(\"div\", {\n                className: \"flex items-center gap-1.5\",\n                children: [/* @__PURE__ */jsx14(\"span\", {\n                  className: \"font-medium text-xs\",\n                  children: getLogTypeLabel(log)\n                }), log.provider && log.type !== \"handler\" && /* @__PURE__ */jsx14(\"span\", {\n                  className: \"px-1.5 py-0.5 bg-gray-200 dark:bg-gray-700 rounded text-xs\",\n                  children: log.provider\n                }), log.processorName && log.type === \"handler\" && /* @__PURE__ */jsx14(\"span\", {\n                  className: \"px-1.5 py-0.5 bg-amber-200 dark:bg-amber-700 rounded text-xs\",\n                  children: log.processorName\n                }), log.duration && /* @__PURE__ */jsxs4(\"span\", {\n                  className: \"text-xs text-gray-600 dark:text-gray-400\",\n                  children: [log.duration, \"ms\"]\n                })]\n              }), log.apiRoute && /* @__PURE__ */jsx14(\"span\", {\n                className: \"text-xs text-gray-500 dark:text-gray-400 font-mono\",\n                children: log.apiRoute\n              })]\n            }), /* @__PURE__ */jsx14(\"span\", {\n              className: \"text-xs text-gray-500 dark:text-gray-500 ml-auto mr-2\",\n              children: formatTimestamp(log.timestamp)\n            })]\n          }), /* @__PURE__ */jsxs4(\"div\", {\n            className: \"flex items-center gap-1\",\n            children: [/* @__PURE__ */jsx14(\"button\", {\n              onClick: e => {\n                e.stopPropagation();\n                onCopy(safeStringify(log.data), log.id);\n              },\n              className: cn(\"p-0.5 rounded transition-colors\", (() => {\n                switch (log.type) {\n                  case \"error\":\n                  case \"stream-error\":\n                    return \"hover:bg-red-200 dark:hover:bg-red-800\";\n                  case \"stream-complete\":\n                    return \"hover:bg-purple-200 dark:hover:bg-purple-800\";\n                  case \"response\":\n                    return \"hover:bg-green-200 dark:hover:bg-green-800\";\n                  case \"request\":\n                    return \"hover:bg-blue-200 dark:hover:bg-blue-800\";\n                  case \"handler\":\n                    return \"hover:bg-amber-200 dark:hover:bg-amber-800\";\n                  default:\n                    return \"hover:bg-gray-200 dark:hover:bg-gray-700\";\n                }\n              })()),\n              children: copiedId === log.id ? /* @__PURE__ */jsx14(Check2, {\n                className: \"w-3 h-3 text-green-600\"\n              }) : /* @__PURE__ */jsx14(Copy, {\n                className: \"w-3 h-3\"\n              })\n            }), isExpanded ? /* @__PURE__ */jsx14(ChevronDown3, {\n              className: \"w-3 h-3\"\n            }) : /* @__PURE__ */jsx14(ChevronRight3, {\n              className: \"w-3 h-3\"\n            })]\n          })]\n        }), /* @__PURE__ */jsx14(AnimatePresence2, {\n          children: isExpanded && /* @__PURE__ */jsx14(motion4.div, {\n            initial: {\n              height: 0,\n              opacity: 0\n            },\n            animate: {\n              height: \"auto\",\n              opacity: 1\n            },\n            exit: {\n              height: 0,\n              opacity: 0\n            },\n            transition: {\n              duration: 0.2\n            },\n            className: \"overflow-hidden\",\n            children: /* @__PURE__ */jsxs4(\"div\", {\n              className: \"p-2 pt-0 space-y-2 rounded-b-lg\",\n              children: [log.data.params && /* @__PURE__ */jsx14(CollapsibleSection, {\n                id: `${log.id}-context`,\n                title: \"Additional Context\",\n                isExpanded: expandedSections.has(`${log.id}-context`),\n                onToggle: () => toggleSection(`${log.id}-context`),\n                badges: [],\n                children: /* @__PURE__ */jsx14(\"pre\", {\n                  className: \"text-xs bg-gray-100 dark:bg-gray-800 p-2 rounded overflow-x-auto\",\n                  children: safeStringify(log.data.params)\n                })\n              }), log.data.params && /* @__PURE__ */jsx14(CollapsibleSection, {\n                id: `${log.id}-request`,\n                title: \"Request\",\n                isExpanded: expandedSections.has(`${log.id}-request`),\n                onToggle: () => toggleSection(`${log.id}-request`),\n                badges: [{\n                  label: `Path: ${log.apiRoute || \"/api/unknown\"}`,\n                  color: \"gray\"\n                }, {\n                  label: \"Method: POST\",\n                  color: \"blue\"\n                }, {\n                  label: (() => {\n                    const sizeBytes = safeStringify(log.data.params).length;\n                    if (sizeBytes < 1024) {\n                      return `Size: ${sizeBytes}B`;\n                    } else {\n                      return `Size: ${(sizeBytes / 1024).toFixed(1)}KB`;\n                    }\n                  })(),\n                  color: \"gray\"\n                }],\n                children: /* @__PURE__ */jsx14(\"pre\", {\n                  className: \"text-xs bg-gray-100 dark:bg-gray-800 p-2 rounded overflow-x-auto\",\n                  children: safeStringify(log.data.params)\n                })\n              }), (log.data.response || log.data.streamContent || log.data.streamObjects) && /* @__PURE__ */jsxs4(CollapsibleSection, {\n                id: `${log.id}-response`,\n                title: \"Response\",\n                isExpanded: expandedSections.has(`${log.id}-response`),\n                onToggle: () => toggleSection(`${log.id}-response`),\n                badges: [{\n                  label: log.type === \"error\" ? \"Status: Error\" : \"Status: Success\",\n                  color: log.type === \"error\" ? \"red\" : \"green\"\n                }, {\n                  label: `Time: ${log.duration || 0}ms`,\n                  color: \"gray\"\n                }, ...(log.data.streamContent ? [{\n                  label: `Chars: ${log.data.streamContent.length}`,\n                  color: \"purple\"\n                }] : []), {\n                  label: `Provider: ${log.provider || \"unknown\"}`,\n                  color: \"gray\"\n                }],\n                children: [log.data.streamContent && /* @__PURE__ */jsxs4(\"div\", {\n                  className: \"mb-2\",\n                  children: [/* @__PURE__ */jsx14(\"div\", {\n                    className: \"text-xs font-semibold mb-1\",\n                    children: \"Stream Content:\"\n                  }), /* @__PURE__ */jsx14(\"pre\", {\n                    className: \"text-xs bg-gray-100 dark:bg-gray-800 p-2 rounded overflow-x-auto max-h-60 overflow-y-auto\",\n                    children: log.data.streamContent\n                  })]\n                }), log.data.streamObjects && log.data.streamObjects.length > 0 && /* @__PURE__ */jsxs4(\"div\", {\n                  className: \"mb-2\",\n                  children: [/* @__PURE__ */jsxs4(\"div\", {\n                    className: \"text-xs font-semibold mb-1\",\n                    children: [\"Stream Objects (\", log.data.streamObjects.length, \"):\"]\n                  }), /* @__PURE__ */jsx14(\"pre\", {\n                    className: \"text-xs bg-gray-100 dark:bg-gray-800 p-2 rounded overflow-x-auto max-h-60 overflow-y-auto\",\n                    children: safeStringify(log.data.streamObjects)\n                  })]\n                }), log.data.response && /* @__PURE__ */jsxs4(\"div\", {\n                  children: [/* @__PURE__ */jsx14(\"div\", {\n                    className: \"text-xs font-semibold mb-1\",\n                    children: \"Response Data:\"\n                  }), /* @__PURE__ */jsx14(\"pre\", {\n                    className: \"text-xs bg-gray-100 dark:bg-gray-800 p-2 rounded overflow-x-auto\",\n                    children: safeStringify(log.data.response)\n                  })]\n                })]\n              }), log.data.handlers && log.data.handlers.length > 0 && /* @__PURE__ */jsx14(CollapsibleSection, {\n                id: `${log.id}-handlers`,\n                title: \"Response Handlers\",\n                isExpanded: expandedSections.has(`${log.id}-handlers`),\n                onToggle: () => toggleSection(`${log.id}-handlers`),\n                badges: (() => {\n                  const handlerCounts = log.data.handlers.reduce((acc, handler) => {\n                    const name19 = handler.processorName;\n                    acc[name19] = (acc[name19] || 0) + 1;\n                    return acc;\n                  }, {});\n                  return Object.entries(handlerCounts).map(([processorName, count]) => ({\n                    label: count > 1 ? `${processorName} (${count})` : processorName,\n                    color: (() => {\n                      if (processorName?.includes(\"builtin\")) return \"green\";\n                      if (processorName?.includes(\"fallback\") || processorName?.includes(\"unhandled\")) return \"yellow\";\n                      if (processorName?.includes(\"unknown\") || processorName?.includes(\"untyped\")) return \"gray\";\n                      if (processorName?.includes(\"validation-failed\")) return \"red\";\n                      if (processorName?.includes(\"execution-error\")) return \"red\";\n                      if (processorName?.includes(\"default\")) return \"blue\";\n                      return \"amber\";\n                    })()\n                  }));\n                })(),\n                children: /* @__PURE__ */jsx14(\"div\", {\n                  className: \"space-y-2\",\n                  children: log.data.handlers.map((handler, idx) => {\n                    if (handler.processorName === \"builtin:text\") {\n                      const content = \"content\" in handler.handledObject ? String(handler.handledObject.content) : \"\";\n                      return /* @__PURE__ */jsxs4(\"div\", {\n                        className: \"border border-gray-200 dark:border-gray-700 rounded p-2\",\n                        children: [/* @__PURE__ */jsxs4(\"div\", {\n                          className: \"flex items-center gap-2 mb-1\",\n                          children: [/* @__PURE__ */jsx14(\"span\", {\n                            className: \"bg-green-200 dark:bg-green-800 text-green-800 dark:text-green-200 px-1.5 py-0.5 rounded text-xs\",\n                            children: \"builtin:text\"\n                          }), /* @__PURE__ */jsxs4(\"span\", {\n                            className: \"text-xs text-gray-500 dark:text-gray-400\",\n                            children: [content.length, \" characters\"]\n                          })]\n                        }), /* @__PURE__ */jsx14(\"pre\", {\n                          className: \"text-xs bg-gray-100 dark:bg-gray-800 p-2 rounded overflow-x-auto max-h-40 overflow-y-auto whitespace-pre-wrap\",\n                          children: content\n                        })]\n                      }, idx);\n                    }\n                    return /* @__PURE__ */jsxs4(\"div\", {\n                      className: \"border border-gray-200 dark:border-gray-700 rounded p-2\",\n                      children: [/* @__PURE__ */jsxs4(\"div\", {\n                        className: \"flex items-center gap-2 mb-1\",\n                        children: [/* @__PURE__ */jsx14(\"span\", {\n                          className: cn(\"px-1.5 py-0.5 rounded text-xs\", (() => {\n                            if (handler.processorName?.includes(\"builtin\")) return \"bg-green-200 dark:bg-green-800 text-green-800 dark:text-green-200\";\n                            if (handler.processorName?.includes(\"fallback\") || handler.processorName?.includes(\"unhandled\")) return \"bg-yellow-200 dark:bg-yellow-800 text-yellow-800 dark:text-yellow-200\";\n                            if (handler.processorName?.includes(\"unknown\") || handler.processorName?.includes(\"untyped\")) return \"bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200\";\n                            if (handler.processorName?.includes(\"validation-failed\")) return \"bg-red-200 dark:bg-red-800 text-red-800 dark:text-red-200\";\n                            if (handler.processorName?.includes(\"execution-error\")) return \"bg-red-200 dark:bg-red-800 text-red-800 dark:text-red-200\";\n                            if (handler.processorName?.includes(\"default\")) return \"bg-blue-200 dark:bg-blue-800 text-blue-800 dark:text-blue-200\";\n                            return \"bg-amber-200 dark:bg-amber-800 text-amber-800 dark:text-amber-200\";\n                          })()),\n                          children: handler.processorName\n                        }), /* @__PURE__ */jsxs4(\"span\", {\n                          className: \"text-xs text-gray-500 dark:text-gray-400\",\n                          children: [\"Type:\", \" \", \"type\" in handler.handledObject ? String(handler.handledObject.type) : \"untyped\"]\n                        })]\n                      }), /* @__PURE__ */jsx14(\"pre\", {\n                        className: \"text-xs bg-gray-100 dark:bg-gray-800 p-2 rounded overflow-x-auto max-h-40 overflow-y-auto\",\n                        children: safeStringify(handler.handledObject)\n                      })]\n                    }, idx);\n                  })\n                })\n              }), log.data.error && /* @__PURE__ */jsxs4(\"div\", {\n                className: \"border border-red-200 dark:border-red-800 rounded-lg bg-red-50 dark:bg-red-950 p-2\",\n                children: [/* @__PURE__ */jsx14(\"div\", {\n                  className: \"text-xs font-semibold mb-1 text-red-600\",\n                  children: \"Error:\"\n                }), /* @__PURE__ */jsx14(\"pre\", {\n                  className: \"text-xs bg-red-100 dark:bg-red-900/20 p-2 rounded overflow-x-auto text-red-700 dark:text-red-300\",\n                  children: log.data.error.message || safeStringify(log.data.error)\n                })]\n              })]\n            })\n          })\n        })]\n      }, log.id);\n    })\n  });\n};\n\n// src/components/debugger/MessagesTab.tsx\nimport React5, { useState as useState3 } from \"react\";\nimport { motion as motion5, AnimatePresence as AnimatePresence3 } from \"framer-motion\";\nimport { User, Bot, Check as Check3, Copy as Copy2, ChevronDown as ChevronDown4, ChevronRight as ChevronRight4 } from \"lucide-react\";\nimport { jsx as jsx15, jsxs as jsxs5 } from \"react/jsx-runtime\";\nvar MessagesTab = ({\n  messages,\n  onCopy,\n  copiedId\n}) => {\n  const [expandedMessages, setExpandedMessages] = useState3(/* @__PURE__ */new Set());\n  const [selectedThread, setSelectedThread] = useState3(null);\n  const threads = React5.useMemo(() => {\n    const threadMap = /* @__PURE__ */new Map();\n    messages.forEach(msg => {\n      const threadId = msg.threadId || \"default\";\n      if (!threadMap.has(threadId)) {\n        threadMap.set(threadId, []);\n      }\n      threadMap.get(threadId).push(msg);\n    });\n    return threadMap;\n  }, [messages]);\n  const currentMessages = selectedThread ? threads.get(selectedThread) || [] : messages;\n  const toggleExpanded = messageId => {\n    setExpandedMessages(prev => {\n      const next = new Set(prev);\n      if (next.has(messageId)) {\n        next.delete(messageId);\n      } else {\n        next.add(messageId);\n      }\n      return next;\n    });\n  };\n  const getMessageTypeColor = type => {\n    const colors = {\n      text: \"bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-300\",\n      progress_update: \"bg-purple-100 dark:bg-purple-900 text-purple-700 dark:text-purple-300\",\n      humanInTheLoop: \"bg-amber-100 dark:bg-amber-900 text-amber-700 dark:text-amber-300\",\n      dialogue_options: \"bg-green-100 dark:bg-green-900 text-green-700 dark:text-green-300\",\n      multiple_choice: \"bg-indigo-100 dark:bg-indigo-900 text-indigo-700 dark:text-indigo-300\",\n      todolist: \"bg-pink-100 dark:bg-pink-900 text-pink-700 dark:text-pink-300\",\n      ticker: \"bg-cyan-100 dark:bg-cyan-900 text-cyan-700 dark:text-cyan-300\"\n    };\n    return colors[type] || \"bg-gray-100 dark:bg-gray-900 text-gray-700 dark:text-gray-300\";\n  };\n  const formatTimestamp = msg => {\n    const timestamp = msg.timestamp || msg.createdAt;\n    if (!timestamp) return null;\n    return new Date(timestamp).toLocaleTimeString(\"en-US\", {\n      hour12: false,\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n      second: \"2-digit\"\n    });\n  };\n  return /* @__PURE__ */jsxs5(\"div\", {\n    className: \"h-full flex flex-col\",\n    children: [threads.size > 1 && /* @__PURE__ */jsx15(\"div\", {\n      className: \"px-2 py-1 border-b border-gray-200 dark:border-gray-700\",\n      children: /* @__PURE__ */jsxs5(\"select\", {\n        value: selectedThread || \"all\",\n        onChange: e => setSelectedThread(e.target.value === \"all\" ? null : e.target.value),\n        className: \"text-xs px-1.5 py-0.5 rounded border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800\",\n        children: [/* @__PURE__ */jsxs5(\"option\", {\n          value: \"all\",\n          children: [\"All Threads (\", messages.length, \")\"]\n        }), Array.from(threads.entries()).map(([threadId, msgs]) => /* @__PURE__ */jsxs5(\"option\", {\n          value: threadId,\n          children: [\"Thread: \", threadId, \" (\", msgs.length, \")\"]\n        }, threadId))]\n      })\n    }), /* @__PURE__ */jsx15(\"div\", {\n      className: \"flex-1 overflow-y-auto p-2 space-y-1\",\n      children: currentMessages.length === 0 ? /* @__PURE__ */jsx15(\"div\", {\n        className: \"text-center text-gray-500 dark:text-gray-400 py-4 text-xs\",\n        children: \"No messages yet\"\n      }) : currentMessages.map(msg => {\n        const isExpanded = expandedMessages.has(msg.id);\n        const timestamp = formatTimestamp(msg);\n        return /* @__PURE__ */jsxs5(\"div\", {\n          className: cn(\"border rounded-lg transition-all cursor-pointer hover:shadow-md\", msg.role === \"user\" ? \"bg-blue-50 dark:bg-blue-950 border-blue-200 dark:border-blue-800 hover:bg-blue-100 dark:hover:bg-blue-900/80\" : \"bg-gray-50 dark:bg-gray-950 border-gray-200 dark:border-gray-800 hover:bg-gray-100 dark:hover:bg-gray-900/80\"),\n          onClick: () => toggleExpanded(msg.id),\n          children: [/* @__PURE__ */jsxs5(\"div\", {\n            className: \"flex items-center justify-between p-2 rounded-t-lg\",\n            children: [/* @__PURE__ */jsxs5(\"div\", {\n              className: \"flex items-center gap-1.5 flex-1\",\n              children: [msg.role === \"user\" ? /* @__PURE__ */jsx15(User, {\n                className: \"w-3 h-3\"\n              }) : /* @__PURE__ */jsx15(Bot, {\n                className: \"w-3 h-3\"\n              }), /* @__PURE__ */jsx15(\"span\", {\n                className: \"font-medium text-xs\",\n                children: msg.role === \"user\" ? \"User\" : \"Assistant\"\n              }), /* @__PURE__ */jsx15(\"span\", {\n                className: cn(\"px-1.5 py-0.5 rounded text-xs\", getMessageTypeColor(msg.type)),\n                children: msg.type\n              }), timestamp && /* @__PURE__ */jsx15(\"span\", {\n                className: \"text-xs text-gray-500 dark:text-gray-500 ml-auto mr-2\",\n                children: timestamp\n              })]\n            }), /* @__PURE__ */jsxs5(\"div\", {\n              className: \"flex items-center gap-1\",\n              children: [/* @__PURE__ */jsx15(\"button\", {\n                onClick: e => {\n                  e.stopPropagation();\n                  onCopy(JSON.stringify(msg, null, 2), msg.id);\n                },\n                className: cn(\"p-0.5 rounded transition-colors\", msg.role === \"user\" ? \"hover:bg-blue-200 dark:hover:bg-blue-800\" : \"hover:bg-gray-200 dark:hover:bg-gray-700\"),\n                children: copiedId === msg.id ? /* @__PURE__ */jsx15(Check3, {\n                  className: \"w-3 h-3 text-green-600\"\n                }) : /* @__PURE__ */jsx15(Copy2, {\n                  className: \"w-3 h-3\"\n                })\n              }), isExpanded ? /* @__PURE__ */jsx15(ChevronDown4, {\n                className: \"w-3 h-3\"\n              }) : /* @__PURE__ */jsx15(ChevronRight4, {\n                className: \"w-3 h-3\"\n              })]\n            })]\n          }), !isExpanded && msg.content && /* @__PURE__ */jsx15(\"div\", {\n            className: \"px-2 pb-2 text-xs text-gray-600 dark:text-gray-400 line-clamp-2\",\n            children: (() => {\n              if (typeof msg.content === \"string\") {\n                return msg.content.substring(0, 100) + (msg.content.length > 100 ? \"...\" : \"\");\n              } else {\n                const stringified = JSON.stringify(msg.content);\n                return stringified.substring(0, 100) + (stringified.length > 100 ? \"...\" : \"\");\n              }\n            })()\n          }), /* @__PURE__ */jsx15(AnimatePresence3, {\n            children: isExpanded && /* @__PURE__ */jsx15(motion5.div, {\n              initial: {\n                height: 0,\n                opacity: 0\n              },\n              animate: {\n                height: \"auto\",\n                opacity: 1\n              },\n              exit: {\n                height: 0,\n                opacity: 0\n              },\n              transition: {\n                duration: 0.2\n              },\n              className: \"overflow-hidden\",\n              children: /* @__PURE__ */jsx15(\"div\", {\n                className: \"p-2 pt-0 rounded-b-lg\",\n                children: /* @__PURE__ */jsx15(\"pre\", {\n                  className: \"text-xs bg-gray-100 dark:bg-gray-800 p-2 rounded overflow-x-auto\",\n                  children: JSON.stringify(msg, null, 2)\n                })\n              })\n            })\n          })]\n        }, msg.id);\n      })\n    })]\n  });\n};\n\n// src/components/debugger/StatesTab.tsx\nimport { useState as useState4, useEffect as useEffect11 } from \"react\";\nimport { motion as motion6, AnimatePresence as AnimatePresence4 } from \"framer-motion\";\nimport { Hash, Check as Check4, Copy as Copy3, ChevronDown as ChevronDown5, ChevronRight as ChevronRight5, GitCompare, AlertTriangle, Plus, Minus, Edit } from \"lucide-react\";\nimport { isEqual as isEqual4 } from \"lodash\";\nimport { diffLines, diffJson, diffWords } from \"diff\";\nimport { jsx as jsx16, jsxs as jsxs6 } from \"react/jsx-runtime\";\nvar StatesTab = ({\n  states,\n  diffStates = {},\n  onCopy,\n  copiedId\n}) => {\n  const [expandedStates, setExpandedStates] = useState4(/* @__PURE__ */new Set());\n  const store = useCedarStore();\n  useEffect11(() => {\n    Object.keys(states).forEach(key => {\n      const hasDiffStates = diffStates[key] != null;\n      store.initializeSectionCollapse?.(key, hasDiffStates);\n    });\n  }, [states, diffStates, store]);\n  const isSectionCollapsed = (stateKey, section) => {\n    return store.collapsedSections?.[stateKey]?.[section] ?? false;\n  };\n  const toggleSectionCollapse = (stateKey, section) => {\n    store.toggleSectionCollapse?.(stateKey, section);\n  };\n  const toggleExpanded = stateKey => {\n    setExpandedStates(prev => {\n      const next = new Set(prev);\n      if (next.has(stateKey)) {\n        next.delete(stateKey);\n      } else {\n        next.add(stateKey);\n      }\n      return next;\n    });\n  };\n  const getStatePreview = registeredState => {\n    const value = registeredState?.value;\n    if (value === null) return \"null\";\n    if (value === void 0) return \"undefined\";\n    if (typeof value === \"string\") return `\"${value.substring(0, 50)}${value.length > 50 ? \"...\" : \"\"}\"`;\n    if (typeof value === \"number\" || typeof value === \"boolean\") return String(value);\n    if (Array.isArray(value)) return `Array(${value.length})`;\n    if (typeof value === \"object\") return `Object(${Object.keys(value).length} keys)`;\n    return String(value);\n  };\n  const getDiffAnalysis = key => {\n    const diffHistoryState = diffStates[key];\n    if (!diffHistoryState?.diffState) return null;\n    const {\n      oldState,\n      newState,\n      computedState,\n      isDiffMode\n    } = diffHistoryState.diffState;\n    const registeredState = states[key];\n    const hasStateDifference = !isEqual4(oldState, newState);\n    const hasComputedDifference = registeredState ? !isEqual4(computedState, registeredState.value) : false;\n    return {\n      oldState,\n      newState,\n      computedState,\n      isDiffMode,\n      hasStateDifference,\n      hasComputedDifference,\n      cleanState: diffHistoryState.diffMode === \"defaultAccept\" ? newState : oldState\n    };\n  };\n  const renderDiffIndicator = key => {\n    const diffAnalysis = getDiffAnalysis(key);\n    if (!diffAnalysis) return null;\n    const {\n      isDiffMode,\n      hasStateDifference,\n      hasComputedDifference\n    } = diffAnalysis;\n    if (isDiffMode && hasStateDifference) {\n      return /* @__PURE__ */jsx16(\"div\", {\n        className: \"flex items-center gap-1 ml-1\",\n        title: \"Has diff changes\",\n        children: /* @__PURE__ */jsx16(GitCompare, {\n          className: \"w-3 h-3 text-orange-500\"\n        })\n      });\n    }\n    if (hasComputedDifference) {\n      return /* @__PURE__ */jsx16(\"div\", {\n        className: \"flex items-center gap-1 ml-1\",\n        title: \"Computed state differs from registered state\",\n        children: /* @__PURE__ */jsx16(AlertTriangle, {\n          className: \"w-3 h-3 text-yellow-500\"\n        })\n      });\n    }\n    return null;\n  };\n  const getJSONDifferences = (oldObj, newObj) => {\n    const oldStr = JSON.stringify(oldObj, null, 2);\n    const newStr = JSON.stringify(newObj, null, 2);\n    try {\n      const jsonDiff = diffJson(oldObj, newObj);\n      if (jsonDiff.length > 1) {\n        return {\n          type: \"json\",\n          diff: jsonDiff,\n          oldStr,\n          newStr\n        };\n      }\n    } catch {}\n    const lineDiff = diffLines(oldStr, newStr);\n    return {\n      type: \"lines\",\n      diff: lineDiff,\n      oldStr,\n      newStr\n    };\n  };\n  const renderPreciseDiff = changes => {\n    return /* @__PURE__ */jsx16(\"div\", {\n      className: \"text-xs font-mono\",\n      children: changes.map((change, index) => {\n        let className = \"\";\n        let prefix = \"\";\n        if (change.added) {\n          className = \"bg-green-100 dark:bg-green-900/30 text-green-800 dark:text-green-200\";\n          prefix = \"+\";\n        } else if (change.removed) {\n          className = \"bg-red-100 dark:bg-red-900/30 text-red-800 dark:text-red-200\";\n          prefix = \"-\";\n        } else {\n          className = \"text-gray-700 dark:text-gray-300\";\n          prefix = \" \";\n        }\n        const lines = change.value.split(\"\\n\");\n        return lines.map((line, lineIndex) => {\n          if (lineIndex === lines.length - 1 && line === \"\") {\n            return null;\n          }\n          return /* @__PURE__ */jsxs6(\"div\", {\n            className: `${className} flex`,\n            children: [/* @__PURE__ */jsx16(\"span\", {\n              className: \"select-none opacity-50 mr-2 flex-shrink-0\",\n              children: prefix\n            }), /* @__PURE__ */jsx16(\"pre\", {\n              className: \"whitespace-pre font-mono text-xs m-0 p-0 bg-transparent\",\n              children: line\n            })]\n          }, `${index}-${lineIndex}`);\n        }).filter(Boolean);\n      })\n    });\n  };\n  const renderWordDiff = (oldText, newText) => {\n    const wordDiff = diffWords(oldText, newText);\n    return /* @__PURE__ */jsx16(\"pre\", {\n      className: \"text-xs font-mono whitespace-pre-wrap m-0 p-0 bg-transparent\",\n      children: wordDiff.map((change, index) => {\n        if (change.added) {\n          return /* @__PURE__ */jsx16(\"span\", {\n            className: \"bg-green-200 dark:bg-green-800/50 text-green-800 dark:text-green-200 px-1 rounded\",\n            children: change.value\n          }, index);\n        } else if (change.removed) {\n          return /* @__PURE__ */jsx16(\"span\", {\n            className: \"bg-red-200 dark:bg-red-800/50 text-red-800 dark:text-red-200 px-1 rounded line-through\",\n            children: change.value\n          }, index);\n        } else {\n          return /* @__PURE__ */jsx16(\"span\", {\n            children: change.value\n          }, index);\n        }\n      })\n    });\n  };\n  const renderObjectDiff = (oldObj, newObj, title, copyId) => {\n    const oldStr = JSON.stringify(oldObj, null, 2);\n    const newStr = JSON.stringify(newObj, null, 2);\n    if (oldStr === newStr) {\n      return /* @__PURE__ */jsxs6(\"div\", {\n        children: [/* @__PURE__ */jsxs6(\"div\", {\n          className: \"flex items-center gap-2 mb-2\",\n          children: [/* @__PURE__ */jsx16(\"span\", {\n            className: \"text-xs font-semibold text-gray-700 dark:text-gray-300\",\n            children: title\n          }), /* @__PURE__ */jsx16(\"span\", {\n            className: \"text-xs text-gray-500 dark:text-gray-400\",\n            children: \"(No differences)\"\n          }), /* @__PURE__ */jsx16(\"button\", {\n            onClick: e => {\n              e.stopPropagation();\n              onCopy(newStr, copyId);\n            },\n            className: \"p-0.5 hover:bg-gray-200 dark:hover:bg-gray-700 rounded transition-colors\",\n            children: copiedId === copyId ? /* @__PURE__ */jsx16(Check4, {\n              className: \"w-3 h-3 text-green-600\"\n            }) : /* @__PURE__ */jsx16(Copy3, {\n              className: \"w-3 h-3\"\n            })\n          })]\n        }), /* @__PURE__ */jsx16(\"pre\", {\n          className: \"text-xs bg-gray-100 dark:bg-gray-800 p-2 rounded overflow-x-auto whitespace-pre font-mono\",\n          children: newStr\n        })]\n      });\n    }\n    const diffResult = getJSONDifferences(oldObj, newObj);\n    const {\n      type,\n      diff\n    } = diffResult;\n    const addedCount = diff.filter(change => change.added).length;\n    const removedCount = diff.filter(change => change.removed).length;\n    const totalChanges = addedCount + removedCount;\n    return /* @__PURE__ */jsxs6(\"div\", {\n      children: [/* @__PURE__ */jsxs6(\"div\", {\n        className: \"flex items-center gap-2 mb-2\",\n        children: [/* @__PURE__ */jsx16(\"span\", {\n          className: \"text-xs font-semibold text-gray-700 dark:text-gray-300\",\n          children: title\n        }), /* @__PURE__ */jsx16(\"div\", {\n          title: \"Has differences\",\n          children: /* @__PURE__ */jsx16(Edit, {\n            className: \"w-3 h-3 text-orange-500\"\n          })\n        }), /* @__PURE__ */jsxs6(\"span\", {\n          className: \"text-xs bg-orange-100 dark:bg-orange-900/30 text-orange-700 dark:text-orange-300 px-2 py-0.5 rounded\",\n          children: [totalChanges, \" change\", totalChanges !== 1 ? \"s\" : \"\", \" (\", type, \" diff)\"]\n        }), /* @__PURE__ */jsx16(\"button\", {\n          onClick: e => {\n            e.stopPropagation();\n            onCopy(`OLD:\n${oldStr}\n\nNEW:\n${newStr}`, copyId);\n          },\n          className: \"p-0.5 hover:bg-gray-200 dark:hover:bg-gray-700 rounded transition-colors\",\n          children: copiedId === copyId ? /* @__PURE__ */jsx16(Check4, {\n            className: \"w-3 h-3 text-green-600\"\n          }) : /* @__PURE__ */jsx16(Copy3, {\n            className: \"w-3 h-3\"\n          })\n        })]\n      }), totalChanges > 0 && /* @__PURE__ */jsxs6(\"div\", {\n        className: \"mb-3 p-2 bg-gray-50 dark:bg-gray-900 rounded border\",\n        children: [/* @__PURE__ */jsx16(\"div\", {\n          className: \"text-xs font-semibold text-gray-700 dark:text-gray-300 mb-1\",\n          children: \"Diff Summary:\"\n        }), /* @__PURE__ */jsxs6(\"div\", {\n          className: \"flex gap-4 text-xs\",\n          children: [addedCount > 0 && /* @__PURE__ */jsxs6(\"span\", {\n            className: \"text-green-600 dark:text-green-400\",\n            children: [\"+\", addedCount, \" addition\", addedCount !== 1 ? \"s\" : \"\"]\n          }), removedCount > 0 && /* @__PURE__ */jsxs6(\"span\", {\n            className: \"text-red-600 dark:text-red-400\",\n            children: [\"-\", removedCount, \" deletion\", removedCount !== 1 ? \"s\" : \"\"]\n          })]\n        })]\n      }), /* @__PURE__ */jsxs6(\"div\", {\n        className: \"mb-4\",\n        children: [/* @__PURE__ */jsx16(\"div\", {\n          className: \"text-xs font-semibold text-gray-700 dark:text-gray-300 mb-2\",\n          children: \"Unified Diff:\"\n        }), /* @__PURE__ */jsx16(\"div\", {\n          className: \"bg-gray-50 dark:bg-gray-900 rounded border border-gray-200 dark:border-gray-700 overflow-x-auto\",\n          children: renderPreciseDiff(diff)\n        })]\n      }), type === \"lines\" && oldStr.length < 1e3 && newStr.length < 1e3 && /* @__PURE__ */jsxs6(\"div\", {\n        className: \"mb-4\",\n        children: [/* @__PURE__ */jsx16(\"div\", {\n          className: \"text-xs font-semibold text-gray-700 dark:text-gray-300 mb-2\",\n          children: \"Word-level Changes:\"\n        }), /* @__PURE__ */jsx16(\"div\", {\n          className: \"bg-gray-50 dark:bg-gray-900 rounded border border-gray-200 dark:border-gray-700 p-3 overflow-x-auto\",\n          children: renderWordDiff(oldStr, newStr)\n        })]\n      }), /* @__PURE__ */jsxs6(\"details\", {\n        className: \"mt-4\",\n        children: [/* @__PURE__ */jsx16(\"summary\", {\n          className: \"text-xs font-semibold text-gray-700 dark:text-gray-300 cursor-pointer hover:text-gray-900 dark:hover:text-gray-100\",\n          children: \"Show Side-by-Side Comparison\"\n        }), /* @__PURE__ */jsxs6(\"div\", {\n          className: \"grid grid-cols-1 lg:grid-cols-2 gap-2 mt-2\",\n          children: [/* @__PURE__ */jsxs6(\"div\", {\n            children: [/* @__PURE__ */jsxs6(\"div\", {\n              className: \"flex items-center gap-1 mb-1\",\n              children: [/* @__PURE__ */jsx16(Minus, {\n                className: \"w-3 h-3 text-red-500\"\n              }), /* @__PURE__ */jsx16(\"span\", {\n                className: \"text-xs text-red-700 dark:text-red-300 font-medium\",\n                children: \"Before\"\n              })]\n            }), /* @__PURE__ */jsx16(\"pre\", {\n              className: \"text-xs bg-red-50 dark:bg-red-900/20 p-2 rounded overflow-x-auto border border-red-200 dark:border-red-800 whitespace-pre font-mono\",\n              children: oldStr\n            })]\n          }), /* @__PURE__ */jsxs6(\"div\", {\n            children: [/* @__PURE__ */jsxs6(\"div\", {\n              className: \"flex items-center gap-1 mb-1\",\n              children: [/* @__PURE__ */jsx16(Plus, {\n                className: \"w-3 h-3 text-green-500\"\n              }), /* @__PURE__ */jsx16(\"span\", {\n                className: \"text-xs text-green-700 dark:text-green-300 font-medium\",\n                children: \"After\"\n              })]\n            }), /* @__PURE__ */jsx16(\"pre\", {\n              className: \"text-xs bg-green-50 dark:bg-green-900/20 p-2 rounded overflow-x-auto border border-green-200 dark:border-green-800 whitespace-pre font-mono\",\n              children: newStr\n            })]\n          })]\n        })]\n      })]\n    });\n  };\n  return /* @__PURE__ */jsx16(\"div\", {\n    className: \"h-full overflow-y-auto p-2 space-y-1\",\n    children: Object.keys(states).length === 0 ? /* @__PURE__ */jsx16(\"div\", {\n      className: \"text-center text-gray-500 dark:text-gray-400 py-4 text-xs\",\n      children: \"No states registered yet\"\n    }) : Object.entries(states).map(([key, registeredState]) => {\n      const isExpanded = expandedStates.has(key);\n      return /* @__PURE__ */jsxs6(\"div\", {\n        className: \"border rounded-lg bg-gray-50 dark:bg-gray-950 border-gray-200 dark:border-gray-800\",\n        children: [/* @__PURE__ */jsxs6(\"div\", {\n          className: `flex items-center justify-between p-2 cursor-pointer transition-colors hover:bg-gray-100 dark:hover:bg-gray-900/80 ${isExpanded ? \"rounded-t-lg\" : \"rounded-lg\"}`,\n          onClick: () => toggleExpanded(key),\n          children: [/* @__PURE__ */jsxs6(\"div\", {\n            className: \"flex items-center gap-1.5 flex-1\",\n            children: [/* @__PURE__ */jsx16(Hash, {\n              className: \"w-3 h-3 text-gray-500\"\n            }), /* @__PURE__ */jsx16(\"span\", {\n              className: \"font-medium text-xs font-mono\",\n              children: key\n            }), renderDiffIndicator(key), !isExpanded && /* @__PURE__ */jsx16(\"span\", {\n              className: \"text-xs text-gray-500 dark:text-gray-500 ml-1\",\n              children: getStatePreview(registeredState)\n            })]\n          }), /* @__PURE__ */jsxs6(\"div\", {\n            className: \"flex items-center gap-1\",\n            children: [/* @__PURE__ */jsx16(\"button\", {\n              onClick: e => {\n                e.stopPropagation();\n                onCopy(JSON.stringify(registeredState, null, 2), key);\n              },\n              className: \"p-0.5 hover:bg-gray-200 dark:hover:bg-gray-700 rounded transition-colors\",\n              children: copiedId === key ? /* @__PURE__ */jsx16(Check4, {\n                className: \"w-3 h-3 text-green-600\"\n              }) : /* @__PURE__ */jsx16(Copy3, {\n                className: \"w-3 h-3\"\n              })\n            }), isExpanded ? /* @__PURE__ */jsx16(ChevronDown5, {\n              className: \"w-3 h-3\"\n            }) : /* @__PURE__ */jsx16(ChevronRight5, {\n              className: \"w-3 h-3\"\n            })]\n          })]\n        }), /* @__PURE__ */jsx16(AnimatePresence4, {\n          children: isExpanded && /* @__PURE__ */jsx16(motion6.div, {\n            initial: {\n              height: 0,\n              opacity: 0\n            },\n            animate: {\n              height: \"auto\",\n              opacity: 1\n            },\n            exit: {\n              height: 0,\n              opacity: 0\n            },\n            transition: {\n              duration: 0.2\n            },\n            className: \"overflow-hidden\",\n            children: /* @__PURE__ */jsxs6(\"div\", {\n              className: \"p-3 pt-0 rounded-b-lg space-y-3\",\n              children: [/* @__PURE__ */jsxs6(\"div\", {\n                className: \"border rounded-lg bg-white dark:bg-gray-900 border-gray-200 dark:border-gray-700\",\n                children: [/* @__PURE__ */jsxs6(\"div\", {\n                  className: \"flex items-center justify-between p-2 cursor-pointer transition-colors hover:bg-gray-50 dark:hover:bg-gray-800/50 rounded-t-lg\",\n                  onClick: () => toggleSectionCollapse(key, \"registeredState\"),\n                  children: [/* @__PURE__ */jsx16(\"div\", {\n                    className: \"flex items-center gap-2\",\n                    children: /* @__PURE__ */jsx16(\"span\", {\n                      className: \"text-xs font-semibold text-gray-700 dark:text-gray-300\",\n                      children: \"Registered State\"\n                    })\n                  }), /* @__PURE__ */jsxs6(\"div\", {\n                    className: \"flex items-center gap-1\",\n                    children: [/* @__PURE__ */jsx16(\"button\", {\n                      onClick: e => {\n                        e.stopPropagation();\n                        onCopy(JSON.stringify(registeredState, null, 2), `${key}-registered`);\n                      },\n                      className: \"p-0.5 hover:bg-gray-200 dark:hover:bg-gray-700 rounded transition-colors\",\n                      children: copiedId === `${key}-registered` ? /* @__PURE__ */jsx16(Check4, {\n                        className: \"w-3 h-3 text-green-600\"\n                      }) : /* @__PURE__ */jsx16(Copy3, {\n                        className: \"w-3 h-3\"\n                      })\n                    }), isSectionCollapsed(key, \"registeredState\") ? /* @__PURE__ */jsx16(ChevronRight5, {\n                      className: \"w-3 h-3\"\n                    }) : /* @__PURE__ */jsx16(ChevronDown5, {\n                      className: \"w-3 h-3\"\n                    })]\n                  })]\n                }), /* @__PURE__ */jsx16(AnimatePresence4, {\n                  children: !isSectionCollapsed(key, \"registeredState\") && /* @__PURE__ */jsx16(motion6.div, {\n                    initial: {\n                      height: 0,\n                      opacity: 0\n                    },\n                    animate: {\n                      height: \"auto\",\n                      opacity: 1\n                    },\n                    exit: {\n                      height: 0,\n                      opacity: 0\n                    },\n                    transition: {\n                      duration: 0.2\n                    },\n                    className: \"overflow-hidden\",\n                    children: /* @__PURE__ */jsx16(\"div\", {\n                      className: \"p-2 pt-0 border-t border-gray-200 dark:border-gray-700\",\n                      children: /* @__PURE__ */jsx16(\"pre\", {\n                        className: \"text-xs bg-gray-100 dark:bg-gray-800 p-2 rounded overflow-x-auto whitespace-pre font-mono\",\n                        children: JSON.stringify(registeredState, null, 2)\n                      })\n                    })\n                  })\n                })]\n              }), (() => {\n                const diffAnalysis = getDiffAnalysis(key);\n                if (!diffAnalysis) return null;\n                return /* @__PURE__ */jsxs6(\"div\", {\n                  className: \"border rounded-lg bg-white dark:bg-gray-900 border-gray-200 dark:border-gray-700\",\n                  children: [/* @__PURE__ */jsxs6(\"div\", {\n                    className: \"flex items-center justify-between p-2 cursor-pointer transition-colors hover:bg-gray-50 dark:hover:bg-gray-800/50 rounded-t-lg\",\n                    onClick: () => toggleSectionCollapse(key, \"diffState\"),\n                    children: [/* @__PURE__ */jsxs6(\"div\", {\n                      className: \"flex items-center gap-2\",\n                      children: [/* @__PURE__ */jsx16(GitCompare, {\n                        className: \"w-3 h-3 text-blue-600\"\n                      }), /* @__PURE__ */jsx16(\"span\", {\n                        className: \"text-xs font-semibold text-blue-700 dark:text-blue-300\",\n                        children: \"Diff State Information\"\n                      })]\n                    }), /* @__PURE__ */jsx16(\"div\", {\n                      className: \"flex items-center gap-1\",\n                      children: isSectionCollapsed(key, \"diffState\") ? /* @__PURE__ */jsx16(ChevronRight5, {\n                        className: \"w-3 h-3\"\n                      }) : /* @__PURE__ */jsx16(ChevronDown5, {\n                        className: \"w-3 h-3\"\n                      })\n                    })]\n                  }), /* @__PURE__ */jsx16(AnimatePresence4, {\n                    children: !isSectionCollapsed(key, \"diffState\") && /* @__PURE__ */jsx16(motion6.div, {\n                      initial: {\n                        height: 0,\n                        opacity: 0\n                      },\n                      animate: {\n                        height: \"auto\",\n                        opacity: 1\n                      },\n                      exit: {\n                        height: 0,\n                        opacity: 0\n                      },\n                      transition: {\n                        duration: 0.2\n                      },\n                      className: \"overflow-hidden\",\n                      children: /* @__PURE__ */jsxs6(\"div\", {\n                        className: \"p-3 pt-0 border-t border-gray-200 dark:border-gray-700 space-y-3\",\n                        children: [/* @__PURE__ */jsxs6(\"div\", {\n                          className: \"bg-blue-50 dark:bg-blue-900/20 p-2 rounded border border-blue-200 dark:border-blue-800\",\n                          children: [/* @__PURE__ */jsxs6(\"div\", {\n                            className: \"flex items-center gap-2 mb-2\",\n                            children: [/* @__PURE__ */jsx16(GitCompare, {\n                              className: \"w-3 h-3 text-blue-600\"\n                            }), /* @__PURE__ */jsx16(\"span\", {\n                              className: \"text-xs font-semibold text-blue-700 dark:text-blue-300\",\n                              children: \"Diff State\"\n                            })]\n                          }), /* @__PURE__ */jsxs6(\"div\", {\n                            className: \"text-xs text-blue-600 dark:text-blue-400 space-y-1\",\n                            children: [/* @__PURE__ */jsxs6(\"div\", {\n                              children: [\"Diff Mode:\", \" \", /* @__PURE__ */jsx16(\"span\", {\n                                className: \"font-mono\",\n                                children: diffAnalysis.isDiffMode ? \"Active\" : \"Inactive\"\n                              })]\n                            }), /* @__PURE__ */jsxs6(\"div\", {\n                              children: [\"Has State Difference:\", \" \", /* @__PURE__ */jsx16(\"span\", {\n                                className: \"font-mono\",\n                                children: diffAnalysis.hasStateDifference ? \"Yes\" : \"No\"\n                              })]\n                            }), /* @__PURE__ */jsxs6(\"div\", {\n                              children: [\"Computed vs Registered Diff:\", \" \", /* @__PURE__ */jsx16(\"span\", {\n                                className: \"font-mono\",\n                                children: diffAnalysis.hasComputedDifference ? \"Yes\" : \"No\"\n                              })]\n                            })]\n                          })]\n                        }), renderObjectDiff(diffAnalysis.oldState, diffAnalysis.newState, \"State Changes\", `${key}-diff`), renderObjectDiff(diffAnalysis.cleanState, diffAnalysis.computedState, \"Computed vs Clean State\", `${key}-computed-clean-diff`), /* @__PURE__ */jsxs6(\"details\", {\n                          className: \"mt-4\",\n                          children: [/* @__PURE__ */jsx16(\"summary\", {\n                            className: \"text-xs font-semibold text-gray-700 dark:text-gray-300 cursor-pointer hover:text-gray-900 dark:hover:text-gray-100\",\n                            children: \"Show Individual State Views\"\n                          }), /* @__PURE__ */jsxs6(\"div\", {\n                            className: \"grid grid-cols-1 lg:grid-cols-2 gap-3 mt-3\",\n                            children: [/* @__PURE__ */jsxs6(\"div\", {\n                              children: [/* @__PURE__ */jsxs6(\"div\", {\n                                className: \"flex items-center gap-2 mb-2\",\n                                children: [/* @__PURE__ */jsx16(\"span\", {\n                                  className: \"text-xs font-semibold text-purple-700 dark:text-purple-300\",\n                                  children: \"Computed State\"\n                                }), /* @__PURE__ */jsx16(\"button\", {\n                                  onClick: e => {\n                                    e.stopPropagation();\n                                    onCopy(JSON.stringify(diffAnalysis.computedState, null, 2), `${key}-computed`);\n                                  },\n                                  className: \"p-0.5 hover:bg-gray-200 dark:hover:bg-gray-700 rounded transition-colors\",\n                                  children: copiedId === `${key}-computed` ? /* @__PURE__ */jsx16(Check4, {\n                                    className: \"w-3 h-3 text-green-600\"\n                                  }) : /* @__PURE__ */jsx16(Copy3, {\n                                    className: \"w-3 h-3\"\n                                  })\n                                })]\n                              }), /* @__PURE__ */jsx16(\"pre\", {\n                                className: \"text-xs bg-purple-50 dark:bg-purple-900/20 p-2 rounded overflow-x-auto border border-purple-200 dark:border-purple-800 whitespace-pre font-mono\",\n                                children: JSON.stringify(diffAnalysis.computedState, null, 2)\n                              })]\n                            }), /* @__PURE__ */jsxs6(\"div\", {\n                              children: [/* @__PURE__ */jsxs6(\"div\", {\n                                className: \"flex items-center gap-2 mb-2\",\n                                children: [/* @__PURE__ */jsx16(\"span\", {\n                                  className: \"text-xs font-semibold text-gray-700 dark:text-gray-300\",\n                                  children: \"Clean State\"\n                                }), /* @__PURE__ */jsx16(\"button\", {\n                                  onClick: e => {\n                                    e.stopPropagation();\n                                    onCopy(JSON.stringify(diffAnalysis.cleanState, null, 2), `${key}-clean`);\n                                  },\n                                  className: \"p-0.5 hover:bg-gray-200 dark:hover:bg-gray-700 rounded transition-colors\",\n                                  children: copiedId === `${key}-clean` ? /* @__PURE__ */jsx16(Check4, {\n                                    className: \"w-3 h-3 text-green-600\"\n                                  }) : /* @__PURE__ */jsx16(Copy3, {\n                                    className: \"w-3 h-3\"\n                                  })\n                                })]\n                              }), /* @__PURE__ */jsx16(\"pre\", {\n                                className: \"text-xs bg-gray-100 dark:bg-gray-800 p-2 rounded overflow-x-auto whitespace-pre font-mono\",\n                                children: JSON.stringify(diffAnalysis.cleanState, null, 2)\n                              })]\n                            })]\n                          })]\n                        }), diffAnalysis.hasComputedDifference && /* @__PURE__ */jsxs6(\"div\", {\n                          className: \"bg-yellow-50 dark:bg-yellow-900/20 p-3 rounded border border-yellow-200 dark:border-yellow-800\",\n                          children: [/* @__PURE__ */jsxs6(\"div\", {\n                            className: \"flex items-center gap-2 mb-3\",\n                            children: [/* @__PURE__ */jsx16(AlertTriangle, {\n                              className: \"w-4 h-4 text-yellow-600\"\n                            }), /* @__PURE__ */jsx16(\"span\", {\n                              className: \"text-xs font-semibold text-yellow-700 dark:text-yellow-300\",\n                              children: \"State Synchronization Issue\"\n                            })]\n                          }), /* @__PURE__ */jsx16(\"div\", {\n                            className: \"text-xs text-yellow-700 dark:text-yellow-300 mb-3\",\n                            children: \"The computed state differs from the registered state, indicating a potential synchronization issue.\"\n                          }), renderObjectDiff(registeredState.value, diffAnalysis.computedState, \"Registered vs Computed State\", `${key}-sync-diff`)]\n                        })]\n                      })\n                    })\n                  })]\n                });\n              })()]\n            })\n          })\n        })]\n      }, key);\n    })\n  });\n};\n\n// src/components/debugger/DebuggerPanel.tsx\nimport { Bug, X as X2, Network, MessageSquare, Database, Trash2, RefreshCw, GripHorizontal } from \"lucide-react\";\nimport { Fragment as Fragment2, jsx as jsx17, jsxs as jsxs7 } from \"react/jsx-runtime\";\nvar DebuggerPanel = ({\n  initialPosition,\n  className\n}) => {\n  const store = useCedarStore();\n  const [isExpanded, setIsExpanded] = useState5(false);\n  const [activeTab, setActiveTab] = useState5(\"network\");\n  const [copiedId, setCopiedId] = useState5(null);\n  const [position, setPosition] = useState5({\n    x: 0,\n    y: 0\n  });\n  const [panelWidth, setPanelWidth] = useState5(500);\n  const [panelHeight, setPanelHeight] = useState5(350);\n  const minWidth = 350;\n  const minHeight = 250;\n  const calculatedMaxWidth = typeof window !== \"undefined\" ? window.innerWidth * 0.8 : 1e3;\n  const calculatedMaxHeight = typeof window !== \"undefined\" ? window.innerHeight * 0.8 : 800;\n  useEffect12(() => {\n    if (typeof window !== \"undefined\") {\n      const defaultPosition = {\n        x: window.innerWidth - 80,\n        y: 20\n      };\n      setPosition(initialPosition || defaultPosition);\n    }\n  }, [initialPosition]);\n  const [isResizing, setIsResizing] = useState5(null);\n  const dragStartX = useRef6(0);\n  const dragStartY = useRef6(0);\n  const dragStartWidth = useRef6(0);\n  const dragStartHeight = useRef6(0);\n  const dragControls = useDragControls();\n  const constraintsRef = useRef6(null);\n  const agentConnectionLogs = store.agentConnectionLogs || [];\n  const messages = store.messages || [];\n  const isDebugEnabled = store.isDebugEnabled ?? true;\n  const registeredStates = store.registeredStates || {};\n  const diffHistoryStates = store.diffHistoryStates || {};\n  const handleMouseMove = useCallback6(e => {\n    if (!isResizing) return;\n    let newWidth = panelWidth;\n    let newHeight = panelHeight;\n    if (isResizing === \"width\" || isResizing === \"both\" || isResizing === \"bottom-left\" || isResizing === \"bottom-right\") {\n      let deltaX = e.clientX - dragStartX.current;\n      if (isResizing === \"bottom-left\") {\n        deltaX = -deltaX;\n      }\n      newWidth = Math.max(minWidth, Math.min(calculatedMaxWidth, dragStartWidth.current + deltaX));\n      setPanelWidth(newWidth);\n    }\n    if (isResizing === \"height\" || isResizing === \"both\" || isResizing === \"bottom-left\" || isResizing === \"bottom-right\") {\n      const deltaY = e.clientY - dragStartY.current;\n      newHeight = Math.max(minHeight, Math.min(calculatedMaxHeight, dragStartHeight.current + deltaY));\n      setPanelHeight(newHeight);\n    }\n  }, [isResizing, minWidth, minHeight, calculatedMaxWidth, calculatedMaxHeight, panelWidth, panelHeight]);\n  const handleMouseUp = useCallback6(() => {\n    setIsResizing(null);\n    if (typeof document !== \"undefined\") {\n      document.body.style.cursor = \"\";\n      document.body.style.userSelect = \"\";\n      document.body.style.webkitUserSelect = \"\";\n    }\n  }, []);\n  useEffect12(() => {\n    if (isResizing) {\n      if (typeof document !== \"undefined\") {\n        document.addEventListener(\"mousemove\", handleMouseMove);\n        document.addEventListener(\"mouseup\", handleMouseUp);\n        document.body.style.userSelect = \"none\";\n        document.body.style.webkitUserSelect = \"none\";\n        if (isResizing === \"width\") document.body.style.cursor = \"col-resize\";\n        if (isResizing === \"height\") document.body.style.cursor = \"row-resize\";\n        if (isResizing === \"both\" || isResizing === \"bottom-left\" || isResizing === \"bottom-right\") document.body.style.cursor = \"nwse-resize\";\n      }\n    }\n    return () => {\n      if (typeof document !== \"undefined\") {\n        document.removeEventListener(\"mousemove\", handleMouseMove);\n        document.removeEventListener(\"mouseup\", handleMouseUp);\n      }\n    };\n  }, [isResizing, handleMouseMove, handleMouseUp]);\n  const startResize = (direction, e) => {\n    e.preventDefault();\n    e.stopPropagation();\n    setIsResizing(direction);\n    dragStartX.current = e.clientX;\n    dragStartY.current = e.clientY;\n    dragStartWidth.current = panelWidth;\n    dragStartHeight.current = panelHeight;\n  };\n  const handleCopy = (text2, id) => {\n    navigator.clipboard.writeText(text2);\n    setCopiedId(id);\n    setTimeout(() => setCopiedId(null), 2e3);\n  };\n  const handleClearLogs = () => {\n    if (store.clearDebugLogs) {\n      store.clearDebugLogs();\n    }\n  };\n  const handleToggleDebug = () => {\n    if (store.setDebugEnabled) {\n      store.setDebugEnabled(!isDebugEnabled);\n    }\n  };\n  const getExpandedPanelPosition = () => {\n    if (typeof window === \"undefined\") {\n      return {\n        x: 0,\n        y: 0\n      };\n    }\n    const windowWidth = window.innerWidth;\n    const windowHeight = window.innerHeight;\n    const margin = 20;\n    let x = position.x - panelWidth / 2;\n    let y = position.y - panelHeight / 2;\n    x = Math.max(margin, Math.min(x, windowWidth - panelWidth - margin));\n    y = Math.max(margin, Math.min(y, windowHeight - panelHeight - margin));\n    return {\n      x,\n      y\n    };\n  };\n  const expandedPosition = getExpandedPanelPosition();\n  return /* @__PURE__ */jsxs7(Fragment2, {\n    children: [/* @__PURE__ */jsx17(motion7.div, {\n      ref: constraintsRef,\n      className: \"fixed inset-0 pointer-events-none\",\n      style: {\n        zIndex: 9998\n      }\n    }), /* @__PURE__ */jsx17(AnimatePresence5, {\n      mode: \"wait\",\n      children: !isExpanded ?\n      // Collapsed state - Container3D button\n      /* @__PURE__ */\n      jsx17(motion7.div, {\n        drag: true,\n        dragControls,\n        dragConstraints: constraintsRef,\n        dragElastic: 0,\n        dragMomentum: false,\n        initial: {\n          scale: 0,\n          opacity: 0\n        },\n        animate: {\n          scale: 1,\n          opacity: 1\n        },\n        exit: {\n          scale: 0,\n          opacity: 0\n        },\n        transition: {\n          type: \"spring\",\n          damping: 20,\n          stiffness: 300\n        },\n        style: {\n          position: \"fixed\",\n          x: position.x,\n          y: position.y,\n          zIndex: 9999,\n          width: 48,\n          height: 48\n        },\n        className: cn(\"cursor-move select-none\", className),\n        children: /* @__PURE__ */jsxs7(\"div\", {\n          className: \"relative cursor-pointer hover:scale-105 active:scale-95 transition-transform\",\n          onClick: () => setIsExpanded(true),\n          children: [/* @__PURE__ */jsx17(Container3D_default, {\n            className: \"w-12 h-12 flex items-center justify-center\",\n            children: /* @__PURE__ */jsx17(Bug, {\n              className: \"w-4 h-4\"\n            })\n          }), agentConnectionLogs.length > 0 && /* @__PURE__ */jsx17(\"div\", {\n            className: \"absolute -top-1 -right-1 w-5 h-5 bg-red-500 rounded-full flex items-center justify-center\",\n            children: /* @__PURE__ */jsx17(\"span\", {\n              className: \"text-white text-xs font-bold\",\n              children: Math.min(agentConnectionLogs.length, 99)\n            })\n          })]\n        })\n      }, \"collapsed\") :\n      // Expanded state - full panel\n      /* @__PURE__ */\n      jsxs7(motion7.div, {\n        drag: true,\n        dragControls,\n        dragConstraints: constraintsRef,\n        dragElastic: 0.2,\n        dragMomentum: false,\n        dragListener: false,\n        initial: {\n          scale: 0.8,\n          opacity: 0\n        },\n        animate: {\n          scale: 1,\n          opacity: 1\n        },\n        exit: {\n          scale: 0.8,\n          opacity: 0\n        },\n        transition: {\n          type: \"spring\",\n          damping: 20,\n          stiffness: 300\n        },\n        style: {\n          position: \"fixed\",\n          x: expandedPosition.x,\n          y: expandedPosition.y,\n          zIndex: 9999,\n          width: panelWidth,\n          height: panelHeight\n        },\n        className: cn(\"bg-white dark:bg-gray-900 rounded-lg shadow-2xl border border-gray-200 dark:border-gray-700\", \"flex flex-col\", className),\n        children: [/* @__PURE__ */jsxs7(\"div\", {\n          className: \"flex items-center justify-between px-2 py-1 border-b border-gray-200 dark:border-gray-700 cursor-move select-none\",\n          onPointerDown: e => dragControls.start(e),\n          style: {\n            touchAction: \"none\"\n          },\n          children: [/* @__PURE__ */jsxs7(\"div\", {\n            className: \"flex items-center gap-1.5\",\n            children: [/* @__PURE__ */jsx17(GripHorizontal, {\n              className: \"w-3 h-3 text-gray-400\"\n            }), /* @__PURE__ */jsx17(Bug, {\n              className: \"w-3.5 h-3.5 text-purple-600 dark:text-purple-400\"\n            }), /* @__PURE__ */jsx17(\"span\", {\n              className: \"font-medium text-xs\",\n              children: \"Cedar Debugger\"\n            }), /* @__PURE__ */jsx17(\"div\", {\n              className: cn(\"px-1.5 py-0.5 rounded-full text-xs\", isDebugEnabled ? \"bg-green-100 text-green-700 dark:bg-green-900 dark:text-green-300\" : \"bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-300\"),\n              children: isDebugEnabled ? \"Active\" : \"Paused\"\n            })]\n          }), /* @__PURE__ */jsxs7(\"div\", {\n            className: \"flex items-center gap-1\",\n            children: [/* @__PURE__ */jsx17(\"button\", {\n              onClick: handleToggleDebug,\n              className: \"p-1 hover:bg-gray-100 dark:hover:bg-gray-800 rounded transition-colors\",\n              title: isDebugEnabled ? \"Pause debugging\" : \"Resume debugging\",\n              children: /* @__PURE__ */jsx17(RefreshCw, {\n                className: cn(\"w-3 h-3\", isDebugEnabled && \"text-green-600 dark:text-green-400\")\n              })\n            }), /* @__PURE__ */jsx17(\"button\", {\n              onClick: handleClearLogs,\n              className: \"p-1 hover:bg-gray-100 dark:hover:bg-gray-800 rounded transition-colors\",\n              title: \"Clear all logs\",\n              children: /* @__PURE__ */jsx17(Trash2, {\n                className: \"w-3 h-3\"\n              })\n            }), /* @__PURE__ */jsx17(\"button\", {\n              onClick: () => setIsExpanded(false),\n              className: \"p-1 hover:bg-gray-100 dark:hover:bg-gray-800 rounded transition-colors\",\n              children: /* @__PURE__ */jsx17(X2, {\n                className: \"w-3 h-3\"\n              })\n            })]\n          })]\n        }), /* @__PURE__ */jsxs7(Tabs, {\n          value: activeTab,\n          onValueChange: setActiveTab,\n          className: \"flex-1 flex flex-col overflow-hidden\",\n          children: [/* @__PURE__ */jsxs7(TabsList, {\n            className: \"mx-2 mt-1 w-[calc(100%-1rem)] grid grid-cols-3 h-8\",\n            children: [/* @__PURE__ */jsxs7(TabsTrigger, {\n              value: \"network\",\n              className: \"flex items-center gap-1 text-xs py-1 px-2\",\n              children: [/* @__PURE__ */jsx17(Network, {\n                className: \"w-3 h-3\"\n              }), \"Network\", agentConnectionLogs.length > 0 && /* @__PURE__ */jsx17(\"span\", {\n                className: \"ml-0.5 px-1 py-0.5 text-xs bg-purple-100 dark:bg-purple-900 text-purple-700 dark:text-purple-300 rounded-full min-w-[16px] h-4 flex items-center justify-center leading-none\",\n                children: agentConnectionLogs.length\n              })]\n            }), /* @__PURE__ */jsxs7(TabsTrigger, {\n              value: \"messages\",\n              className: \"flex items-center gap-1 text-xs py-1 px-2\",\n              children: [/* @__PURE__ */jsx17(MessageSquare, {\n                className: \"w-3 h-3\"\n              }), \"Messages\", messages.length > 0 && /* @__PURE__ */jsx17(\"span\", {\n                className: \"ml-0.5 px-1 py-0.5 text-xs bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-300 rounded-full min-w-[16px] h-4 flex items-center justify-center leading-none\",\n                children: messages.length\n              })]\n            }), /* @__PURE__ */jsxs7(TabsTrigger, {\n              value: \"states\",\n              className: \"flex items-center gap-1 text-xs py-1 px-2\",\n              children: [/* @__PURE__ */jsx17(Database, {\n                className: \"w-3 h-3\"\n              }), \"States\", Object.keys(registeredStates).length > 0 && /* @__PURE__ */jsx17(\"span\", {\n                className: \"ml-0.5 px-1 py-0.5 text-xs bg-green-100 dark:bg-green-900 text-green-700 dark:text-green-300 rounded-full min-w-[16px] h-4 flex items-center justify-center leading-none\",\n                children: Object.keys(registeredStates).length\n              })]\n            })]\n          }), /* @__PURE__ */jsxs7(\"div\", {\n            className: \"flex-1 overflow-hidden\",\n            children: [/* @__PURE__ */jsx17(TabsContent, {\n              value: \"network\",\n              className: \"h-full\",\n              children: /* @__PURE__ */jsx17(NetworkTab, {\n                logs: agentConnectionLogs,\n                onCopy: handleCopy,\n                copiedId\n              })\n            }), /* @__PURE__ */jsx17(TabsContent, {\n              value: \"messages\",\n              className: \"h-full\",\n              children: /* @__PURE__ */jsx17(MessagesTab, {\n                messages,\n                onCopy: handleCopy,\n                copiedId\n              })\n            }), /* @__PURE__ */jsx17(TabsContent, {\n              value: \"states\",\n              className: \"h-full\",\n              children: /* @__PURE__ */jsx17(StatesTab, {\n                states: registeredStates,\n                diffStates: diffHistoryStates,\n                onCopy: handleCopy,\n                copiedId\n              })\n            })]\n          })]\n        }), /* @__PURE__ */jsxs7(Fragment2, {\n          children: [/* @__PURE__ */jsx17(\"div\", {\n            className: \"absolute bottom-0 left-0 w-4 h-4 cursor-nwse-resize hover:bg-blue-400/30 group\",\n            onMouseDown: e => startResize(\"bottom-left\", e)\n          }), /* @__PURE__ */jsx17(\"div\", {\n            className: \"absolute bottom-0 right-0 w-4 h-4 cursor-nwse-resize hover:bg-blue-400/30 group\",\n            onMouseDown: e => startResize(\"bottom-right\", e)\n          }), /* @__PURE__ */jsx17(\"div\", {\n            className: \"absolute bottom-0 left-4 right-4 h-1 cursor-row-resize hover:bg-blue-400/30\",\n            onMouseDown: e => startResize(\"height\", e)\n          }), /* @__PURE__ */jsx17(\"div\", {\n            className: \"absolute top-12 bottom-4 right-0 w-1 cursor-col-resize hover:bg-blue-400/30\",\n            onMouseDown: e => startResize(\"width\", e)\n          })]\n        })]\n      }, \"expanded\")\n    })]\n  });\n};\n\n// src/components/chatInput/useCedarEditor.ts\nimport Document from \"@tiptap/extension-document\";\nimport Placeholder from \"@tiptap/extension-placeholder\";\nimport { useEditor } from \"@tiptap/react\";\nimport StarterKit from \"@tiptap/starter-kit\";\nimport Mention from \"@tiptap/extension-mention\";\nimport { ReactNodeViewRenderer } from \"@tiptap/react\";\n\n// src/store/agentContext/mentionProviders.ts\nimport { useEffect as useEffect13 } from \"react\";\nimport { v4 as v42 } from \"uuid\";\nfunction getLabel(item, labelField) {\n  if (typeof labelField === \"function\") {\n    return labelField(item);\n  } else if (typeof labelField === \"string\") {\n    return item[labelField] || item.id || \"Unknown\";\n  }\n  return item.title || item.label || item.name || item.id || \"Unknown\";\n}\nfunction searchItem(item, query, config2) {\n  const lowerQuery = query.toLowerCase();\n  if (getLabel(item, config2.labelField).toLowerCase().includes(lowerQuery)) {\n    return true;\n  }\n  for (const field of config2.searchFields || []) {\n    const value = item[field];\n    if (value && String(value).toLowerCase().includes(lowerQuery)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction useStateBasedMentionProvider(config2) {\n  const registerMentionProvider = useCedarStore(s => s.registerMentionProvider);\n  const unregisterMentionProvider = useCedarStore(s => s.unregisterMentionProvider);\n  useEffect13(() => {\n    const cedarStateExists = Boolean(useCedarStore.getState().registeredStates[config2.stateKey]);\n    if (!cedarStateExists) {\n      console.warn(`[useStateBasedMentionProvider] State with key \"${config2.stateKey}\" was not found in Cedar store. Did you forget to register it with useCedarState()?`);\n    }\n    const provider = {\n      id: config2.stateKey,\n      // Use stateKey as provider ID\n      trigger: config2.trigger || \"@\",\n      label: config2.description || `${config2.stateKey} items`,\n      description: config2.description,\n      icon: config2.icon,\n      // Store icon at provider level\n      color: config2.color,\n      // Store color at provider level\n      getItems: query => {\n        const state = useCedarStore.getState();\n        const stateValue = state.getCedarState(config2.stateKey);\n        if (!Array.isArray(stateValue)) {\n          return [];\n        }\n        const filtered = query ? stateValue.filter(item => searchItem(item, query, config2)) : stateValue;\n        return filtered.slice(0, 10).map(item => ({\n          id: item.id || String(Math.random()),\n          label: getLabel(item, config2.labelField),\n          data: item,\n          metadata: {\n            ...item.metadata,\n            // Add icon, color, and order from config if provided\n            icon: config2.icon || item.metadata?.icon,\n            color: config2.color || item.metadata?.color,\n            order: config2.order\n            // Add order from config\n          }\n        }));\n      },\n      toContextEntry: item => ({\n        id: item.id || v42(),\n        source: \"mention\",\n        data: item.data,\n        metadata: {\n          label: item.label,\n          ...item.metadata,\n          // Ensure icon, color, and order are passed through\n          icon: item.metadata?.icon || config2.icon,\n          color: item.metadata?.color || config2.color,\n          order: config2.order\n          // Add order from config\n        }\n      }),\n      // Pass through optional renderers\n      renderMenuItem: config2.renderMenuItem,\n      renderEditorItem: config2.renderEditorItem,\n      renderContextBadge: config2.renderContextBadge\n    };\n    registerMentionProvider(provider);\n    return () => {\n      unregisterMentionProvider(config2.stateKey);\n    };\n  }, [config2, registerMentionProvider, unregisterMentionProvider]);\n}\nfunction useMentionProviders() {\n  const mentionProviders = useCedarStore(s => s.mentionProviders);\n  return Array.from(mentionProviders.values());\n}\nfunction useMentionProvidersByTrigger(trigger) {\n  const mentionProviders = useCedarStore(s => s.mentionProviders);\n  return Array.from(mentionProviders.values()).filter(provider => provider.trigger === trigger);\n}\n\n// src/components/chatInput/ChatMention.tsx\nimport { NodeViewWrapper } from \"@tiptap/react\";\nimport { jsx as jsx18, jsxs as jsxs8 } from \"react/jsx-runtime\";\nvar MentionNodeView = ({\n  node\n}) => {\n  const providers = useMentionProvidersByTrigger(\"@\");\n  const provider = node.attrs.providerId ? providers.find(p => p.id === node.attrs.providerId) : null;\n  if (provider?.renderEditorItem) {\n    const item = {\n      id: node.attrs.id,\n      label: node.attrs.label,\n      data: node.attrs.data,\n      metadata: node.attrs.metadata\n    };\n    return /* @__PURE__ */jsx18(NodeViewWrapper, {\n      className: \"inline\",\n      contentEditable: false,\n      children: provider.renderEditorItem(item, node.attrs)\n    });\n  }\n  const providerWithConfig = node.attrs.providerId ? providers.find(p => p.id === node.attrs.providerId) : null;\n  const icon = providerWithConfig?.icon;\n  const color = providerWithConfig?.color;\n  const bgStyle = color ? {\n    backgroundColor: `${color}80`\n  } : {\n    backgroundColor: \"rgba(30, 64, 175, 0.5)\"\n  };\n  return /* @__PURE__ */jsx18(NodeViewWrapper, {\n    className: \"inline\",\n    contentEditable: false,\n    children: /* @__PURE__ */jsxs8(\"span\", {\n      className: \"rounded-sm px-1 -mt-0.5 inline-flex items-center gap-0.5 select-none\",\n      style: bgStyle,\n      contentEditable: false,\n      children: [icon ? withClassName(icon, \"w-3 h-3\") : \"@\", node.attrs.label]\n    })\n  });\n};\n\n// src/components/chatInput/DiffExtension.ts\nimport { Mark as Mark3, mergeAttributes } from \"@tiptap/core\";\n\n// ../../node_modules/prosemirror-state/dist/index.js\nimport { Slice as Slice2, Fragment as Fragment4, Mark as Mark2, Node } from \"prosemirror-model\";\n\n// ../../node_modules/prosemirror-transform/dist/index.js\nimport { ReplaceError, Slice, Fragment as Fragment3, MarkType, Mark } from \"prosemirror-model\";\nvar lower16 = 65535;\nvar factor16 = Math.pow(2, 16);\nfunction makeRecover(index, offset2) {\n  return index + offset2 * factor16;\n}\nfunction recoverIndex(value) {\n  return value & lower16;\n}\nfunction recoverOffset(value) {\n  return (value - (value & lower16)) / factor16;\n}\nvar DEL_BEFORE = 1;\nvar DEL_AFTER = 2;\nvar DEL_ACROSS = 4;\nvar DEL_SIDE = 8;\nvar MapResult = class {\n  /**\n  @internal\n  */\n  constructor(pos, delInfo, recover) {\n    this.pos = pos;\n    this.delInfo = delInfo;\n    this.recover = recover;\n  }\n  /**\n  Tells you whether the position was deleted, that is, whether the\n  step removed the token on the side queried (via the `assoc`)\n  argument from the document.\n  */\n  get deleted() {\n    return (this.delInfo & DEL_SIDE) > 0;\n  }\n  /**\n  Tells you whether the token before the mapped position was deleted.\n  */\n  get deletedBefore() {\n    return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;\n  }\n  /**\n  True when the token after the mapped position was deleted.\n  */\n  get deletedAfter() {\n    return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;\n  }\n  /**\n  Tells whether any of the steps mapped through deletes across the\n  position (including both the token before and after the\n  position).\n  */\n  get deletedAcross() {\n    return (this.delInfo & DEL_ACROSS) > 0;\n  }\n};\nvar StepMap = class _StepMap {\n  /**\n  Create a position map. The modifications to the document are\n  represented as an array of numbers, in which each group of three\n  represents a modified chunk as `[start, oldSize, newSize]`.\n  */\n  constructor(ranges, inverted = false) {\n    this.ranges = ranges;\n    this.inverted = inverted;\n    if (!ranges.length && _StepMap.empty) return _StepMap.empty;\n  }\n  /**\n  @internal\n  */\n  recover(value) {\n    let diff = 0,\n      index = recoverIndex(value);\n    if (!this.inverted) for (let i = 0; i < index; i++) diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];\n    return this.ranges[index * 3] + diff + recoverOffset(value);\n  }\n  mapResult(pos, assoc = 1) {\n    return this._map(pos, assoc, false);\n  }\n  map(pos, assoc = 1) {\n    return this._map(pos, assoc, true);\n  }\n  /**\n  @internal\n  */\n  _map(pos, assoc, simple) {\n    let diff = 0,\n      oldIndex = this.inverted ? 2 : 1,\n      newIndex = this.inverted ? 1 : 2;\n    for (let i = 0; i < this.ranges.length; i += 3) {\n      let start = this.ranges[i] - (this.inverted ? diff : 0);\n      if (start > pos) break;\n      let oldSize = this.ranges[i + oldIndex],\n        newSize = this.ranges[i + newIndex],\n        end = start + oldSize;\n      if (pos <= end) {\n        let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;\n        let result = start + diff + (side < 0 ? 0 : newSize);\n        if (simple) return result;\n        let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);\n        let del = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;\n        if (assoc < 0 ? pos != start : pos != end) del |= DEL_SIDE;\n        return new MapResult(result, del, recover);\n      }\n      diff += newSize - oldSize;\n    }\n    return simple ? pos + diff : new MapResult(pos + diff, 0, null);\n  }\n  /**\n  @internal\n  */\n  touches(pos, recover) {\n    let diff = 0,\n      index = recoverIndex(recover);\n    let oldIndex = this.inverted ? 2 : 1,\n      newIndex = this.inverted ? 1 : 2;\n    for (let i = 0; i < this.ranges.length; i += 3) {\n      let start = this.ranges[i] - (this.inverted ? diff : 0);\n      if (start > pos) break;\n      let oldSize = this.ranges[i + oldIndex],\n        end = start + oldSize;\n      if (pos <= end && i == index * 3) return true;\n      diff += this.ranges[i + newIndex] - oldSize;\n    }\n    return false;\n  }\n  /**\n  Calls the given function on each of the changed ranges included in\n  this map.\n  */\n  forEach(f) {\n    let oldIndex = this.inverted ? 2 : 1,\n      newIndex = this.inverted ? 1 : 2;\n    for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {\n      let start = this.ranges[i],\n        oldStart = start - (this.inverted ? diff : 0),\n        newStart = start + (this.inverted ? 0 : diff);\n      let oldSize = this.ranges[i + oldIndex],\n        newSize = this.ranges[i + newIndex];\n      f(oldStart, oldStart + oldSize, newStart, newStart + newSize);\n      diff += newSize - oldSize;\n    }\n  }\n  /**\n  Create an inverted version of this map. The result can be used to\n  map positions in the post-step document to the pre-step document.\n  */\n  invert() {\n    return new _StepMap(this.ranges, !this.inverted);\n  }\n  /**\n  @internal\n  */\n  toString() {\n    return (this.inverted ? \"-\" : \"\") + JSON.stringify(this.ranges);\n  }\n  /**\n  Create a map that moves all positions by offset `n` (which may be\n  negative). This can be useful when applying steps meant for a\n  sub-document to a larger document, or vice-versa.\n  */\n  static offset(n) {\n    return n == 0 ? _StepMap.empty : new _StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);\n  }\n};\nStepMap.empty = new StepMap([]);\nvar stepsByID = /* @__PURE__ */Object.create(null);\nvar Step = class {\n  /**\n  Get the step map that represents the changes made by this step,\n  and which can be used to transform between positions in the old\n  and the new document.\n  */\n  getMap() {\n    return StepMap.empty;\n  }\n  /**\n  Try to merge this step with another one, to be applied directly\n  after it. Returns the merged step when possible, null if the\n  steps can't be merged.\n  */\n  merge(other) {\n    return null;\n  }\n  /**\n  Deserialize a step from its JSON representation. Will call\n  through to the step class' own implementation of this method.\n  */\n  static fromJSON(schema, json2) {\n    if (!json2 || !json2.stepType) throw new RangeError(\"Invalid input for Step.fromJSON\");\n    let type = stepsByID[json2.stepType];\n    if (!type) throw new RangeError(`No step type ${json2.stepType} defined`);\n    return type.fromJSON(schema, json2);\n  }\n  /**\n  To be able to serialize steps to JSON, each step needs a string\n  ID to attach to its JSON representation. Use this method to\n  register an ID for your step classes. Try to pick something\n  that's unlikely to clash with steps from other modules.\n  */\n  static jsonID(id, stepClass) {\n    if (id in stepsByID) throw new RangeError(\"Duplicate use of step JSON ID \" + id);\n    stepsByID[id] = stepClass;\n    stepClass.prototype.jsonID = id;\n    return stepClass;\n  }\n};\nvar StepResult = class _StepResult {\n  /**\n  @internal\n  */\n  constructor(doc, failed) {\n    this.doc = doc;\n    this.failed = failed;\n  }\n  /**\n  Create a successful step result.\n  */\n  static ok(doc) {\n    return new _StepResult(doc, null);\n  }\n  /**\n  Create a failed step result.\n  */\n  static fail(message) {\n    return new _StepResult(null, message);\n  }\n  /**\n  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given\n  arguments. Create a successful result if it succeeds, and a\n  failed one if it throws a `ReplaceError`.\n  */\n  static fromReplace(doc, from, to, slice) {\n    try {\n      return _StepResult.ok(doc.replace(from, to, slice));\n    } catch (e) {\n      if (e instanceof ReplaceError) return _StepResult.fail(e.message);\n      throw e;\n    }\n  }\n};\nfunction mapFragment(fragment, f, parent) {\n  let mapped = [];\n  for (let i = 0; i < fragment.childCount; i++) {\n    let child = fragment.child(i);\n    if (child.content.size) child = child.copy(mapFragment(child.content, f, child));\n    if (child.isInline) child = f(child, parent, i);\n    mapped.push(child);\n  }\n  return Fragment3.fromArray(mapped);\n}\nvar AddMarkStep = class _AddMarkStep extends Step {\n  /**\n  Create a mark step.\n  */\n  constructor(from, to, mark) {\n    super();\n    this.from = from;\n    this.to = to;\n    this.mark = mark;\n  }\n  apply(doc) {\n    let oldSlice = doc.slice(this.from, this.to),\n      $from = doc.resolve(this.from);\n    let parent = $from.node($from.sharedDepth(this.to));\n    let slice = new Slice(mapFragment(oldSlice.content, (node, parent2) => {\n      if (!node.isAtom || !parent2.type.allowsMarkType(this.mark.type)) return node;\n      return node.mark(this.mark.addToSet(node.marks));\n    }, parent), oldSlice.openStart, oldSlice.openEnd);\n    return StepResult.fromReplace(doc, this.from, this.to, slice);\n  }\n  invert() {\n    return new RemoveMarkStep(this.from, this.to, this.mark);\n  }\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1),\n      to = mapping.mapResult(this.to, -1);\n    if (from.deleted && to.deleted || from.pos >= to.pos) return null;\n    return new _AddMarkStep(from.pos, to.pos, this.mark);\n  }\n  merge(other) {\n    if (other instanceof _AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) return new _AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);\n    return null;\n  }\n  toJSON() {\n    return {\n      stepType: \"addMark\",\n      mark: this.mark.toJSON(),\n      from: this.from,\n      to: this.to\n    };\n  }\n  /**\n  @internal\n  */\n  static fromJSON(schema, json2) {\n    if (typeof json2.from != \"number\" || typeof json2.to != \"number\") throw new RangeError(\"Invalid input for AddMarkStep.fromJSON\");\n    return new _AddMarkStep(json2.from, json2.to, schema.markFromJSON(json2.mark));\n  }\n};\nStep.jsonID(\"addMark\", AddMarkStep);\nvar RemoveMarkStep = class _RemoveMarkStep extends Step {\n  /**\n  Create a mark-removing step.\n  */\n  constructor(from, to, mark) {\n    super();\n    this.from = from;\n    this.to = to;\n    this.mark = mark;\n  }\n  apply(doc) {\n    let oldSlice = doc.slice(this.from, this.to);\n    let slice = new Slice(mapFragment(oldSlice.content, node => {\n      return node.mark(this.mark.removeFromSet(node.marks));\n    }, doc), oldSlice.openStart, oldSlice.openEnd);\n    return StepResult.fromReplace(doc, this.from, this.to, slice);\n  }\n  invert() {\n    return new AddMarkStep(this.from, this.to, this.mark);\n  }\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1),\n      to = mapping.mapResult(this.to, -1);\n    if (from.deleted && to.deleted || from.pos >= to.pos) return null;\n    return new _RemoveMarkStep(from.pos, to.pos, this.mark);\n  }\n  merge(other) {\n    if (other instanceof _RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) return new _RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);\n    return null;\n  }\n  toJSON() {\n    return {\n      stepType: \"removeMark\",\n      mark: this.mark.toJSON(),\n      from: this.from,\n      to: this.to\n    };\n  }\n  /**\n  @internal\n  */\n  static fromJSON(schema, json2) {\n    if (typeof json2.from != \"number\" || typeof json2.to != \"number\") throw new RangeError(\"Invalid input for RemoveMarkStep.fromJSON\");\n    return new _RemoveMarkStep(json2.from, json2.to, schema.markFromJSON(json2.mark));\n  }\n};\nStep.jsonID(\"removeMark\", RemoveMarkStep);\nvar AddNodeMarkStep = class _AddNodeMarkStep extends Step {\n  /**\n  Create a node mark step.\n  */\n  constructor(pos, mark) {\n    super();\n    this.pos = pos;\n    this.mark = mark;\n  }\n  apply(doc) {\n    let node = doc.nodeAt(this.pos);\n    if (!node) return StepResult.fail(\"No node at mark step's position\");\n    let updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));\n    return StepResult.fromReplace(doc, this.pos, this.pos + 1, new Slice(Fragment3.from(updated), 0, node.isLeaf ? 0 : 1));\n  }\n  invert(doc) {\n    let node = doc.nodeAt(this.pos);\n    if (node) {\n      let newSet = this.mark.addToSet(node.marks);\n      if (newSet.length == node.marks.length) {\n        for (let i = 0; i < node.marks.length; i++) if (!node.marks[i].isInSet(newSet)) return new _AddNodeMarkStep(this.pos, node.marks[i]);\n        return new _AddNodeMarkStep(this.pos, this.mark);\n      }\n    }\n    return new RemoveNodeMarkStep(this.pos, this.mark);\n  }\n  map(mapping) {\n    let pos = mapping.mapResult(this.pos, 1);\n    return pos.deletedAfter ? null : new _AddNodeMarkStep(pos.pos, this.mark);\n  }\n  toJSON() {\n    return {\n      stepType: \"addNodeMark\",\n      pos: this.pos,\n      mark: this.mark.toJSON()\n    };\n  }\n  /**\n  @internal\n  */\n  static fromJSON(schema, json2) {\n    if (typeof json2.pos != \"number\") throw new RangeError(\"Invalid input for AddNodeMarkStep.fromJSON\");\n    return new _AddNodeMarkStep(json2.pos, schema.markFromJSON(json2.mark));\n  }\n};\nStep.jsonID(\"addNodeMark\", AddNodeMarkStep);\nvar RemoveNodeMarkStep = class _RemoveNodeMarkStep extends Step {\n  /**\n  Create a mark-removing step.\n  */\n  constructor(pos, mark) {\n    super();\n    this.pos = pos;\n    this.mark = mark;\n  }\n  apply(doc) {\n    let node = doc.nodeAt(this.pos);\n    if (!node) return StepResult.fail(\"No node at mark step's position\");\n    let updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));\n    return StepResult.fromReplace(doc, this.pos, this.pos + 1, new Slice(Fragment3.from(updated), 0, node.isLeaf ? 0 : 1));\n  }\n  invert(doc) {\n    let node = doc.nodeAt(this.pos);\n    if (!node || !this.mark.isInSet(node.marks)) return this;\n    return new AddNodeMarkStep(this.pos, this.mark);\n  }\n  map(mapping) {\n    let pos = mapping.mapResult(this.pos, 1);\n    return pos.deletedAfter ? null : new _RemoveNodeMarkStep(pos.pos, this.mark);\n  }\n  toJSON() {\n    return {\n      stepType: \"removeNodeMark\",\n      pos: this.pos,\n      mark: this.mark.toJSON()\n    };\n  }\n  /**\n  @internal\n  */\n  static fromJSON(schema, json2) {\n    if (typeof json2.pos != \"number\") throw new RangeError(\"Invalid input for RemoveNodeMarkStep.fromJSON\");\n    return new _RemoveNodeMarkStep(json2.pos, schema.markFromJSON(json2.mark));\n  }\n};\nStep.jsonID(\"removeNodeMark\", RemoveNodeMarkStep);\nvar ReplaceStep = class _ReplaceStep extends Step {\n  /**\n  The given `slice` should fit the 'gap' between `from` and\n  `to`—the depths must line up, and the surrounding nodes must be\n  able to be joined with the open sides of the slice. When\n  `structure` is true, the step will fail if the content between\n  from and to is not just a sequence of closing and then opening\n  tokens (this is to guard against rebased replace steps\n  overwriting something they weren't supposed to).\n  */\n  constructor(from, to, slice, structure = false) {\n    super();\n    this.from = from;\n    this.to = to;\n    this.slice = slice;\n    this.structure = structure;\n  }\n  apply(doc) {\n    if (this.structure && contentBetween(doc, this.from, this.to)) return StepResult.fail(\"Structure replace would overwrite content\");\n    return StepResult.fromReplace(doc, this.from, this.to, this.slice);\n  }\n  getMap() {\n    return new StepMap([this.from, this.to - this.from, this.slice.size]);\n  }\n  invert(doc) {\n    return new _ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to));\n  }\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1),\n      to = mapping.mapResult(this.to, -1);\n    if (from.deletedAcross && to.deletedAcross) return null;\n    return new _ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice, this.structure);\n  }\n  merge(other) {\n    if (!(other instanceof _ReplaceStep) || other.structure || this.structure) return null;\n    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {\n      let slice = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);\n      return new _ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure);\n    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {\n      let slice = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);\n      return new _ReplaceStep(other.from, this.to, slice, this.structure);\n    } else {\n      return null;\n    }\n  }\n  toJSON() {\n    let json2 = {\n      stepType: \"replace\",\n      from: this.from,\n      to: this.to\n    };\n    if (this.slice.size) json2.slice = this.slice.toJSON();\n    if (this.structure) json2.structure = true;\n    return json2;\n  }\n  /**\n  @internal\n  */\n  static fromJSON(schema, json2) {\n    if (typeof json2.from != \"number\" || typeof json2.to != \"number\") throw new RangeError(\"Invalid input for ReplaceStep.fromJSON\");\n    return new _ReplaceStep(json2.from, json2.to, Slice.fromJSON(schema, json2.slice), !!json2.structure);\n  }\n};\nStep.jsonID(\"replace\", ReplaceStep);\nvar ReplaceAroundStep = class _ReplaceAroundStep extends Step {\n  /**\n  Create a replace-around step with the given range and gap.\n  `insert` should be the point in the slice into which the content\n  of the gap should be moved. `structure` has the same meaning as\n  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.\n  */\n  constructor(from, to, gapFrom, gapTo, slice, insert, structure = false) {\n    super();\n    this.from = from;\n    this.to = to;\n    this.gapFrom = gapFrom;\n    this.gapTo = gapTo;\n    this.slice = slice;\n    this.insert = insert;\n    this.structure = structure;\n  }\n  apply(doc) {\n    if (this.structure && (contentBetween(doc, this.from, this.gapFrom) || contentBetween(doc, this.gapTo, this.to))) return StepResult.fail(\"Structure gap-replace would overwrite content\");\n    let gap = doc.slice(this.gapFrom, this.gapTo);\n    if (gap.openStart || gap.openEnd) return StepResult.fail(\"Gap is not a flat range\");\n    let inserted = this.slice.insertAt(this.insert, gap.content);\n    if (!inserted) return StepResult.fail(\"Content does not fit in gap\");\n    return StepResult.fromReplace(doc, this.from, this.to, inserted);\n  }\n  getMap() {\n    return new StepMap([this.from, this.gapFrom - this.from, this.insert, this.gapTo, this.to - this.gapTo, this.slice.size - this.insert]);\n  }\n  invert(doc) {\n    let gap = this.gapTo - this.gapFrom;\n    return new _ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);\n  }\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1),\n      to = mapping.mapResult(this.to, -1);\n    let gapFrom = this.from == this.gapFrom ? from.pos : mapping.map(this.gapFrom, -1);\n    let gapTo = this.to == this.gapTo ? to.pos : mapping.map(this.gapTo, 1);\n    if (from.deletedAcross && to.deletedAcross || gapFrom < from.pos || gapTo > to.pos) return null;\n    return new _ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);\n  }\n  toJSON() {\n    let json2 = {\n      stepType: \"replaceAround\",\n      from: this.from,\n      to: this.to,\n      gapFrom: this.gapFrom,\n      gapTo: this.gapTo,\n      insert: this.insert\n    };\n    if (this.slice.size) json2.slice = this.slice.toJSON();\n    if (this.structure) json2.structure = true;\n    return json2;\n  }\n  /**\n  @internal\n  */\n  static fromJSON(schema, json2) {\n    if (typeof json2.from != \"number\" || typeof json2.to != \"number\" || typeof json2.gapFrom != \"number\" || typeof json2.gapTo != \"number\" || typeof json2.insert != \"number\") throw new RangeError(\"Invalid input for ReplaceAroundStep.fromJSON\");\n    return new _ReplaceAroundStep(json2.from, json2.to, json2.gapFrom, json2.gapTo, Slice.fromJSON(schema, json2.slice), json2.insert, !!json2.structure);\n  }\n};\nStep.jsonID(\"replaceAround\", ReplaceAroundStep);\nfunction contentBetween(doc, from, to) {\n  let $from = doc.resolve(from),\n    dist = to - from,\n    depth = $from.depth;\n  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {\n    depth--;\n    dist--;\n  }\n  if (dist > 0) {\n    let next = $from.node(depth).maybeChild($from.indexAfter(depth));\n    while (dist > 0) {\n      if (!next || next.isLeaf) return true;\n      next = next.firstChild;\n      dist--;\n    }\n  }\n  return false;\n}\nvar AttrStep = class _AttrStep extends Step {\n  /**\n  Construct an attribute step.\n  */\n  constructor(pos, attr, value) {\n    super();\n    this.pos = pos;\n    this.attr = attr;\n    this.value = value;\n  }\n  apply(doc) {\n    let node = doc.nodeAt(this.pos);\n    if (!node) return StepResult.fail(\"No node at attribute step's position\");\n    let attrs = /* @__PURE__ */Object.create(null);\n    for (let name19 in node.attrs) attrs[name19] = node.attrs[name19];\n    attrs[this.attr] = this.value;\n    let updated = node.type.create(attrs, null, node.marks);\n    return StepResult.fromReplace(doc, this.pos, this.pos + 1, new Slice(Fragment3.from(updated), 0, node.isLeaf ? 0 : 1));\n  }\n  getMap() {\n    return StepMap.empty;\n  }\n  invert(doc) {\n    return new _AttrStep(this.pos, this.attr, doc.nodeAt(this.pos).attrs[this.attr]);\n  }\n  map(mapping) {\n    let pos = mapping.mapResult(this.pos, 1);\n    return pos.deletedAfter ? null : new _AttrStep(pos.pos, this.attr, this.value);\n  }\n  toJSON() {\n    return {\n      stepType: \"attr\",\n      pos: this.pos,\n      attr: this.attr,\n      value: this.value\n    };\n  }\n  static fromJSON(schema, json2) {\n    if (typeof json2.pos != \"number\" || typeof json2.attr != \"string\") throw new RangeError(\"Invalid input for AttrStep.fromJSON\");\n    return new _AttrStep(json2.pos, json2.attr, json2.value);\n  }\n};\nStep.jsonID(\"attr\", AttrStep);\nvar DocAttrStep = class _DocAttrStep extends Step {\n  /**\n  Construct an attribute step.\n  */\n  constructor(attr, value) {\n    super();\n    this.attr = attr;\n    this.value = value;\n  }\n  apply(doc) {\n    let attrs = /* @__PURE__ */Object.create(null);\n    for (let name19 in doc.attrs) attrs[name19] = doc.attrs[name19];\n    attrs[this.attr] = this.value;\n    let updated = doc.type.create(attrs, doc.content, doc.marks);\n    return StepResult.ok(updated);\n  }\n  getMap() {\n    return StepMap.empty;\n  }\n  invert(doc) {\n    return new _DocAttrStep(this.attr, doc.attrs[this.attr]);\n  }\n  map(mapping) {\n    return this;\n  }\n  toJSON() {\n    return {\n      stepType: \"docAttr\",\n      attr: this.attr,\n      value: this.value\n    };\n  }\n  static fromJSON(schema, json2) {\n    if (typeof json2.attr != \"string\") throw new RangeError(\"Invalid input for DocAttrStep.fromJSON\");\n    return new _DocAttrStep(json2.attr, json2.value);\n  }\n};\nStep.jsonID(\"docAttr\", DocAttrStep);\nvar TransformError = class extends Error {};\nTransformError = function TransformError2(message) {\n  let err = Error.call(this, message);\n  err.__proto__ = TransformError2.prototype;\n  return err;\n};\nTransformError.prototype = Object.create(Error.prototype);\nTransformError.prototype.constructor = TransformError;\nTransformError.prototype.name = \"TransformError\";\n\n// ../../node_modules/prosemirror-state/dist/index.js\nvar classesById = /* @__PURE__ */Object.create(null);\nvar Selection = class {\n  /**\n  Initialize a selection with the head and anchor and ranges. If no\n  ranges are given, constructs a single range across `$anchor` and\n  `$head`.\n  */\n  constructor($anchor, $head, ranges) {\n    this.$anchor = $anchor;\n    this.$head = $head;\n    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];\n  }\n  /**\n  The selection's anchor, as an unresolved position.\n  */\n  get anchor() {\n    return this.$anchor.pos;\n  }\n  /**\n  The selection's head.\n  */\n  get head() {\n    return this.$head.pos;\n  }\n  /**\n  The lower bound of the selection's main range.\n  */\n  get from() {\n    return this.$from.pos;\n  }\n  /**\n  The upper bound of the selection's main range.\n  */\n  get to() {\n    return this.$to.pos;\n  }\n  /**\n  The resolved lower  bound of the selection's main range.\n  */\n  get $from() {\n    return this.ranges[0].$from;\n  }\n  /**\n  The resolved upper bound of the selection's main range.\n  */\n  get $to() {\n    return this.ranges[0].$to;\n  }\n  /**\n  Indicates whether the selection contains any content.\n  */\n  get empty() {\n    let ranges = this.ranges;\n    for (let i = 0; i < ranges.length; i++) if (ranges[i].$from.pos != ranges[i].$to.pos) return false;\n    return true;\n  }\n  /**\n  Get the content of this selection as a slice.\n  */\n  content() {\n    return this.$from.doc.slice(this.from, this.to, true);\n  }\n  /**\n  Replace the selection with a slice or, if no slice is given,\n  delete the selection. Will append to the given transaction.\n  */\n  replace(tr, content = Slice2.empty) {\n    let lastNode = content.content.lastChild,\n      lastParent = null;\n    for (let i = 0; i < content.openEnd; i++) {\n      lastParent = lastNode;\n      lastNode = lastNode.lastChild;\n    }\n    let mapFrom = tr.steps.length,\n      ranges = this.ranges;\n    for (let i = 0; i < ranges.length; i++) {\n      let {\n          $from,\n          $to\n        } = ranges[i],\n        mapping = tr.mapping.slice(mapFrom);\n      tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? Slice2.empty : content);\n      if (i == 0) selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);\n    }\n  }\n  /**\n  Replace the selection with the given node, appending the changes\n  to the given transaction.\n  */\n  replaceWith(tr, node) {\n    let mapFrom = tr.steps.length,\n      ranges = this.ranges;\n    for (let i = 0; i < ranges.length; i++) {\n      let {\n          $from,\n          $to\n        } = ranges[i],\n        mapping = tr.mapping.slice(mapFrom);\n      let from = mapping.map($from.pos),\n        to = mapping.map($to.pos);\n      if (i) {\n        tr.deleteRange(from, to);\n      } else {\n        tr.replaceRangeWith(from, to, node);\n        selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);\n      }\n    }\n  }\n  /**\n  Find a valid cursor or leaf node selection starting at the given\n  position and searching back if `dir` is negative, and forward if\n  positive. When `textOnly` is true, only consider cursor\n  selections. Will return null when no valid selection position is\n  found.\n  */\n  static findFrom($pos, dir, textOnly = false) {\n    let inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);\n    if (inner) return inner;\n    for (let depth = $pos.depth - 1; depth >= 0; depth--) {\n      let found = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);\n      if (found) return found;\n    }\n    return null;\n  }\n  /**\n  Find a valid cursor or leaf node selection near the given\n  position. Searches forward first by default, but if `bias` is\n  negative, it will search backwards first.\n  */\n  static near($pos, bias = 1) {\n    return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));\n  }\n  /**\n  Find the cursor or leaf node selection closest to the start of\n  the given document. Will return an\n  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position\n  exists.\n  */\n  static atStart(doc) {\n    return findSelectionIn(doc, doc, 0, 0, 1) || new AllSelection(doc);\n  }\n  /**\n  Find the cursor or leaf node selection closest to the end of the\n  given document.\n  */\n  static atEnd(doc) {\n    return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1) || new AllSelection(doc);\n  }\n  /**\n  Deserialize the JSON representation of a selection. Must be\n  implemented for custom classes (as a static class method).\n  */\n  static fromJSON(doc, json2) {\n    if (!json2 || !json2.type) throw new RangeError(\"Invalid input for Selection.fromJSON\");\n    let cls = classesById[json2.type];\n    if (!cls) throw new RangeError(`No selection type ${json2.type} defined`);\n    return cls.fromJSON(doc, json2);\n  }\n  /**\n  To be able to deserialize selections from JSON, custom selection\n  classes must register themselves with an ID string, so that they\n  can be disambiguated. Try to pick something that's unlikely to\n  clash with classes from other modules.\n  */\n  static jsonID(id, selectionClass) {\n    if (id in classesById) throw new RangeError(\"Duplicate use of selection JSON ID \" + id);\n    classesById[id] = selectionClass;\n    selectionClass.prototype.jsonID = id;\n    return selectionClass;\n  }\n  /**\n  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,\n  which is a value that can be mapped without having access to a\n  current document, and later resolved to a real selection for a\n  given document again. (This is used mostly by the history to\n  track and restore old selections.) The default implementation of\n  this method just converts the selection to a text selection and\n  returns the bookmark for that.\n  */\n  getBookmark() {\n    return TextSelection.between(this.$anchor, this.$head).getBookmark();\n  }\n};\nSelection.prototype.visible = true;\nvar SelectionRange = class {\n  /**\n  Create a range.\n  */\n  constructor($from, $to) {\n    this.$from = $from;\n    this.$to = $to;\n  }\n};\nvar warnedAboutTextSelection = false;\nfunction checkTextSelection($pos) {\n  if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {\n    warnedAboutTextSelection = true;\n    console[\"warn\"](\"TextSelection endpoint not pointing into a node with inline content (\" + $pos.parent.type.name + \")\");\n  }\n}\nvar TextSelection = class _TextSelection extends Selection {\n  /**\n  Construct a text selection between the given points.\n  */\n  constructor($anchor, $head = $anchor) {\n    checkTextSelection($anchor);\n    checkTextSelection($head);\n    super($anchor, $head);\n  }\n  /**\n  Returns a resolved position if this is a cursor selection (an\n  empty text selection), and null otherwise.\n  */\n  get $cursor() {\n    return this.$anchor.pos == this.$head.pos ? this.$head : null;\n  }\n  map(doc, mapping) {\n    let $head = doc.resolve(mapping.map(this.head));\n    if (!$head.parent.inlineContent) return Selection.near($head);\n    let $anchor = doc.resolve(mapping.map(this.anchor));\n    return new _TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);\n  }\n  replace(tr, content = Slice2.empty) {\n    super.replace(tr, content);\n    if (content == Slice2.empty) {\n      let marks = this.$from.marksAcross(this.$to);\n      if (marks) tr.ensureMarks(marks);\n    }\n  }\n  eq(other) {\n    return other instanceof _TextSelection && other.anchor == this.anchor && other.head == this.head;\n  }\n  getBookmark() {\n    return new TextBookmark(this.anchor, this.head);\n  }\n  toJSON() {\n    return {\n      type: \"text\",\n      anchor: this.anchor,\n      head: this.head\n    };\n  }\n  /**\n  @internal\n  */\n  static fromJSON(doc, json2) {\n    if (typeof json2.anchor != \"number\" || typeof json2.head != \"number\") throw new RangeError(\"Invalid input for TextSelection.fromJSON\");\n    return new _TextSelection(doc.resolve(json2.anchor), doc.resolve(json2.head));\n  }\n  /**\n  Create a text selection from non-resolved positions.\n  */\n  static create(doc, anchor, head = anchor) {\n    let $anchor = doc.resolve(anchor);\n    return new this($anchor, head == anchor ? $anchor : doc.resolve(head));\n  }\n  /**\n  Return a text selection that spans the given positions or, if\n  they aren't text positions, find a text selection near them.\n  `bias` determines whether the method searches forward (default)\n  or backwards (negative number) first. Will fall back to calling\n  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document\n  doesn't contain a valid text position.\n  */\n  static between($anchor, $head, bias) {\n    let dPos = $anchor.pos - $head.pos;\n    if (!bias || dPos) bias = dPos >= 0 ? 1 : -1;\n    if (!$head.parent.inlineContent) {\n      let found = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);\n      if (found) $head = found.$head;else return Selection.near($head, bias);\n    }\n    if (!$anchor.parent.inlineContent) {\n      if (dPos == 0) {\n        $anchor = $head;\n      } else {\n        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;\n        if ($anchor.pos < $head.pos != dPos < 0) $anchor = $head;\n      }\n    }\n    return new _TextSelection($anchor, $head);\n  }\n};\nSelection.jsonID(\"text\", TextSelection);\nvar TextBookmark = class _TextBookmark {\n  constructor(anchor, head) {\n    this.anchor = anchor;\n    this.head = head;\n  }\n  map(mapping) {\n    return new _TextBookmark(mapping.map(this.anchor), mapping.map(this.head));\n  }\n  resolve(doc) {\n    return TextSelection.between(doc.resolve(this.anchor), doc.resolve(this.head));\n  }\n};\nvar NodeSelection = class _NodeSelection extends Selection {\n  /**\n  Create a node selection. Does not verify the validity of its\n  argument.\n  */\n  constructor($pos) {\n    let node = $pos.nodeAfter;\n    let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);\n    super($pos, $end);\n    this.node = node;\n  }\n  map(doc, mapping) {\n    let {\n      deleted,\n      pos\n    } = mapping.mapResult(this.anchor);\n    let $pos = doc.resolve(pos);\n    if (deleted) return Selection.near($pos);\n    return new _NodeSelection($pos);\n  }\n  content() {\n    return new Slice2(Fragment4.from(this.node), 0, 0);\n  }\n  eq(other) {\n    return other instanceof _NodeSelection && other.anchor == this.anchor;\n  }\n  toJSON() {\n    return {\n      type: \"node\",\n      anchor: this.anchor\n    };\n  }\n  getBookmark() {\n    return new NodeBookmark(this.anchor);\n  }\n  /**\n  @internal\n  */\n  static fromJSON(doc, json2) {\n    if (typeof json2.anchor != \"number\") throw new RangeError(\"Invalid input for NodeSelection.fromJSON\");\n    return new _NodeSelection(doc.resolve(json2.anchor));\n  }\n  /**\n  Create a node selection from non-resolved positions.\n  */\n  static create(doc, from) {\n    return new _NodeSelection(doc.resolve(from));\n  }\n  /**\n  Determines whether the given node may be selected as a node\n  selection.\n  */\n  static isSelectable(node) {\n    return !node.isText && node.type.spec.selectable !== false;\n  }\n};\nNodeSelection.prototype.visible = false;\nSelection.jsonID(\"node\", NodeSelection);\nvar NodeBookmark = class _NodeBookmark {\n  constructor(anchor) {\n    this.anchor = anchor;\n  }\n  map(mapping) {\n    let {\n      deleted,\n      pos\n    } = mapping.mapResult(this.anchor);\n    return deleted ? new TextBookmark(pos, pos) : new _NodeBookmark(pos);\n  }\n  resolve(doc) {\n    let $pos = doc.resolve(this.anchor),\n      node = $pos.nodeAfter;\n    if (node && NodeSelection.isSelectable(node)) return new NodeSelection($pos);\n    return Selection.near($pos);\n  }\n};\nvar AllSelection = class _AllSelection extends Selection {\n  /**\n  Create an all-selection over the given document.\n  */\n  constructor(doc) {\n    super(doc.resolve(0), doc.resolve(doc.content.size));\n  }\n  replace(tr, content = Slice2.empty) {\n    if (content == Slice2.empty) {\n      tr.delete(0, tr.doc.content.size);\n      let sel = Selection.atStart(tr.doc);\n      if (!sel.eq(tr.selection)) tr.setSelection(sel);\n    } else {\n      super.replace(tr, content);\n    }\n  }\n  toJSON() {\n    return {\n      type: \"all\"\n    };\n  }\n  /**\n  @internal\n  */\n  static fromJSON(doc) {\n    return new _AllSelection(doc);\n  }\n  map(doc) {\n    return new _AllSelection(doc);\n  }\n  eq(other) {\n    return other instanceof _AllSelection;\n  }\n  getBookmark() {\n    return AllBookmark;\n  }\n};\nSelection.jsonID(\"all\", AllSelection);\nvar AllBookmark = {\n  map() {\n    return this;\n  },\n  resolve(doc) {\n    return new AllSelection(doc);\n  }\n};\nfunction findSelectionIn(doc, node, pos, index, dir, text2 = false) {\n  if (node.inlineContent) return TextSelection.create(doc, pos);\n  for (let i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {\n    let child = node.child(i);\n    if (!child.isAtom) {\n      let inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text2);\n      if (inner) return inner;\n    } else if (!text2 && NodeSelection.isSelectable(child)) {\n      return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0));\n    }\n    pos += child.nodeSize * dir;\n  }\n  return null;\n}\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n  let last = tr.steps.length - 1;\n  if (last < startLen) return;\n  let step = tr.steps[last];\n  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) return;\n  let map2 = tr.mapping.maps[last],\n    end;\n  map2.forEach((_from, _to, _newFrom, newTo) => {\n    if (end == null) end = newTo;\n  });\n  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));\n}\nfunction bind(f, self) {\n  return !self || !f ? f : f.bind(self);\n}\nvar FieldDesc = class {\n  constructor(name19, desc, self) {\n    this.name = name19;\n    this.init = bind(desc.init, self);\n    this.apply = bind(desc.apply, self);\n  }\n};\nvar baseFields = [new FieldDesc(\"doc\", {\n  init(config2) {\n    return config2.doc || config2.schema.topNodeType.createAndFill();\n  },\n  apply(tr) {\n    return tr.doc;\n  }\n}), new FieldDesc(\"selection\", {\n  init(config2, instance) {\n    return config2.selection || Selection.atStart(instance.doc);\n  },\n  apply(tr) {\n    return tr.selection;\n  }\n}), new FieldDesc(\"storedMarks\", {\n  init(config2) {\n    return config2.storedMarks || null;\n  },\n  apply(tr, _marks, _old, state) {\n    return state.selection.$cursor ? tr.storedMarks : null;\n  }\n}), new FieldDesc(\"scrollToSelection\", {\n  init() {\n    return 0;\n  },\n  apply(tr, prev) {\n    return tr.scrolledIntoView ? prev + 1 : prev;\n  }\n})];\nfunction bindProps(obj, self, target) {\n  for (let prop in obj) {\n    let val = obj[prop];\n    if (val instanceof Function) val = val.bind(self);else if (prop == \"handleDOMEvents\") val = bindProps(val, self, {});\n    target[prop] = val;\n  }\n  return target;\n}\nvar Plugin = class {\n  /**\n  Create a plugin.\n  */\n  constructor(spec) {\n    this.spec = spec;\n    this.props = {};\n    if (spec.props) bindProps(spec.props, this, this.props);\n    this.key = spec.key ? spec.key.key : createKey(\"plugin\");\n  }\n  /**\n  Extract the plugin's state field from an editor state.\n  */\n  getState(state) {\n    return state[this.key];\n  }\n};\nvar keys = /* @__PURE__ */Object.create(null);\nfunction createKey(name19) {\n  if (name19 in keys) return name19 + \"$\" + ++keys[name19];\n  keys[name19] = 0;\n  return name19 + \"$\";\n}\nvar PluginKey = class {\n  /**\n  Create a plugin key.\n  */\n  constructor(name19 = \"key\") {\n    this.key = createKey(name19);\n  }\n  /**\n  Get the active plugin with this key, if any, from an editor\n  state.\n  */\n  get(state) {\n    return state.config.pluginsByKey[this.key];\n  }\n  /**\n  Get the plugin's state from an editor state.\n  */\n  getState(state) {\n    return state[this.key];\n  }\n};\n\n// src/components/chatInput/DiffExtension.ts\nvar AddedText = Mark3.create({\n  name: \"added\",\n  addOptions() {\n    return {\n      HTMLAttributes: {\n        class: \"text-added\"\n      }\n    };\n  },\n  parseHTML() {\n    return [{\n      tag: \"ins\"\n    }, {\n      tag: 'span[data-diff=\"added\"]'\n    }, {\n      style: \"background-color\",\n      getAttrs: value => {\n        if (typeof value === \"string\" && value.includes(\"34, 197, 94\")) {\n          return {};\n        }\n        return false;\n      }\n    }];\n  },\n  renderHTML({\n    HTMLAttributes\n  }) {\n    return [\"span\", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, {\n      \"data-diff\": \"added\",\n      style: `\n\t\t\t\t\tbackground-color: rgba(34, 197, 94, 0.15);\n\t\t\t\t\tcolor: rgb(34, 197, 94);\n\t\t\t\t\tborder-radius: 2px;\n\t\t\t\t\tpadding: 0 2px;\n\t\t\t\t\ttext-decoration: none;\n\t\t\t\t`\n    }), 0];\n  },\n  addCommands() {\n    return {\n      setAddedText: () => ({\n        commands\n      }) => {\n        return commands.setMark(this.name);\n      },\n      toggleAddedText: () => ({\n        commands\n      }) => {\n        return commands.toggleMark(this.name);\n      },\n      unsetAddedText: () => ({\n        commands\n      }) => {\n        return commands.unsetMark(this.name);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Shift-a\": () => this.editor.commands.toggleMark(this.name)\n    };\n  }\n});\nvar RemovedText = Mark3.create({\n  name: \"removed\",\n  addOptions() {\n    return {\n      HTMLAttributes: {\n        class: \"text-removed\"\n      }\n    };\n  },\n  parseHTML() {\n    return [{\n      tag: \"del\"\n    }, {\n      tag: \"s\"\n    }, {\n      tag: 'span[data-diff=\"removed\"]'\n    }, {\n      style: \"text-decoration\",\n      getAttrs: value => {\n        if (typeof value === \"string\" && value.includes(\"line-through\")) {\n          return {};\n        }\n        return false;\n      }\n    }];\n  },\n  renderHTML({\n    HTMLAttributes\n  }) {\n    return [\"span\", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, {\n      \"data-diff\": \"removed\",\n      style: `\n\t\t\t\t\tbackground-color: rgba(239, 68, 68, 0.15);\n\t\t\t\t\tcolor: rgba(239, 68, 68, 0.7);\n\t\t\t\t\tborder-radius: 2px;\n\t\t\t\t\tpadding: 0 2px;\n\t\t\t\t\ttext-decoration: line-through;\n\t\t\t\t`\n    }), 0];\n  },\n  addCommands() {\n    return {\n      setRemovedText: () => ({\n        commands\n      }) => {\n        return commands.setMark(this.name);\n      },\n      toggleRemovedText: () => ({\n        commands\n      }) => {\n        return commands.toggleMark(this.name);\n      },\n      unsetRemovedText: () => ({\n        commands\n      }) => {\n        return commands.unsetMark(this.name);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Shift-r\": () => this.editor.commands.toggleRemovedText()\n    };\n  }\n});\nvar DiffExtension = Mark3.create({\n  name: \"diff\",\n  addExtensions() {\n    return [AddedText, RemovedText];\n  },\n  addProseMirrorPlugins() {\n    return [new Plugin({\n      key: new PluginKey(\"diff\"),\n      props: {\n        // Optional: Add decorations or other visual feedback\n        decorations() {\n          return null;\n        }\n      }\n    })];\n  },\n  addCommands() {\n    return {\n      // Insert text with diff marking\n      insertDiff: ({\n        text: text2,\n        type\n      }) => ({\n        commands\n      }) => {\n        if (type === \"added\") {\n          return commands.insertContent({\n            type: \"text\",\n            text: text2,\n            marks: [{\n              type: \"added\"\n            }]\n          });\n        } else {\n          return commands.insertContent({\n            type: \"text\",\n            text: text2,\n            marks: [{\n              type: \"removed\"\n            }]\n          });\n        }\n      },\n      // Apply diff to selected text\n      markSelectionAsDiff: type => ({\n        commands\n      }) => {\n        if (type === \"added\") {\n          return commands.setMark(\"added\");\n        } else {\n          return commands.setMark(\"removed\");\n        }\n      },\n      // Clear all diff marks from selection\n      clearDiffMarks: () => ({\n        commands\n      }) => {\n        return commands.unsetMark(\"added\") && commands.unsetMark(\"removed\");\n      },\n      // Replace text with diff (shows both old and new)\n      replaceWithDiff: ({\n        oldText,\n        newText\n      }) => ({\n        commands\n      }) => {\n        return commands.insertContent({\n          type: \"text\",\n          text: oldText,\n          marks: [{\n            type: \"removed\"\n          }]\n        }) && commands.insertContent(\" \") && commands.insertContent({\n          type: \"text\",\n          text: newText,\n          marks: [{\n            type: \"added\"\n          }]\n        });\n      }\n    };\n  }\n});\n\n// src/components/chatInput/useCedarEditor.ts\nimport { useEffect as useEffect15, useState as useState7 } from \"react\";\n\n// src/components/chatInput/mentionSuggestion.ts\nimport { ReactRenderer } from \"@tiptap/react\";\nimport { computePosition, flip, shift, offset, autoUpdate } from \"@floating-ui/dom\";\n\n// src/components/chatInput/MentionList.tsx\nimport { forwardRef, useEffect as useEffect14, useImperativeHandle, useState as useState6, useRef as useRef7 } from \"react\";\nimport { jsx as jsx19, jsxs as jsxs9 } from \"react/jsx-runtime\";\nvar MentionList = forwardRef(({\n  items,\n  command\n}, ref) => {\n  const [selectedIndex, setSelectedIndex] = useState6(0);\n  const providers = useMentionProvidersByTrigger(\"@\");\n  const containerRef = useRef7(null);\n  const itemRefs = useRef7([]);\n  useEffect14(() => {\n    setSelectedIndex(0);\n  }, [items]);\n  useEffect14(() => {\n    const selectedItem = itemRefs.current[selectedIndex];\n    if (selectedItem && containerRef.current) {\n      const container = containerRef.current;\n      const itemTop = selectedItem.offsetTop;\n      const itemBottom = itemTop + selectedItem.offsetHeight;\n      const containerTop = container.scrollTop;\n      const containerBottom = containerTop + container.clientHeight;\n      if (itemBottom > containerBottom) {\n        container.scrollTop = itemBottom - container.clientHeight;\n      } else if (itemTop < containerTop) {\n        container.scrollTop = itemTop;\n      }\n    }\n  }, [selectedIndex]);\n  const selectItem = index => {\n    const item = items[index];\n    if (item) {\n      command(item);\n    }\n  };\n  const upHandler = () => {\n    setSelectedIndex((selectedIndex + items.length - 1) % items.length);\n  };\n  const downHandler = () => {\n    setSelectedIndex((selectedIndex + 1) % items.length);\n  };\n  const enterHandler = () => {\n    selectItem(selectedIndex);\n  };\n  useImperativeHandle(ref, () => ({\n    onKeyDown: ({\n      event\n    }) => {\n      if (event.key === \"ArrowUp\") {\n        upHandler();\n        return true;\n      }\n      if (event.key === \"ArrowDown\") {\n        downHandler();\n        return true;\n      }\n      if (event.key === \"Enter\") {\n        enterHandler();\n        return true;\n      }\n      return false;\n    }\n  }));\n  const renderItem = (item, index) => {\n    const provider = item.providerId ? providers.find(p => p.id === item.providerId) : void 0;\n    if (provider?.renderMenuItem) {\n      return /* @__PURE__ */jsx19(\"div\", {\n        ref: el => {\n          itemRefs.current[index] = el;\n        },\n        className: cn(\"text-left px-3 py-1 hover:bg-gray-200 cursor-pointer\", index === selectedIndex && \"bg-gray-200\"),\n        onClick: () => selectItem(index),\n        children: provider.renderMenuItem(item)\n      }, item.id);\n    }\n    const icon = item.metadata?.icon;\n    const color = item.metadata?.color;\n    const bgStyle = index === selectedIndex && color ? {\n      backgroundColor: `${color}80`\n    } : {};\n    return /* @__PURE__ */jsx19(\"button\", {\n      ref: el => {\n        itemRefs.current[index] = el;\n      },\n      type: \"button\",\n      className: cn(\"w-full text-left px-2 py-1.5 cursor-pointer text-black text-sm transition-colors\", index === selectedIndex && !color && \"bg-gray-200\"),\n      style: bgStyle,\n      onMouseEnter: e => {\n        if (color && index !== selectedIndex) {\n          e.currentTarget.style.backgroundColor = `${color}40`;\n        }\n      },\n      onMouseLeave: e => {\n        if (color && index !== selectedIndex) {\n          e.currentTarget.style.backgroundColor = \"\";\n        }\n      },\n      onClick: () => selectItem(index),\n      children: /* @__PURE__ */jsxs9(\"div\", {\n        className: \"flex items-center gap-1\",\n        children: [icon && withClassName(icon, \"w-4 h-4\"), /* @__PURE__ */jsx19(\"span\", {\n          className: \"\",\n          children: item.label\n        })]\n      })\n    }, item.id);\n  };\n  return /* @__PURE__ */jsx19(\"div\", {\n    ref: containerRef,\n    className: \"shadow-lg bg-white rounded-md max-h-60 overflow-y-auto scrollbar-hide\",\n    children: items.length > 0 ? items.map((item, index) => renderItem(item, index)) : /* @__PURE__ */jsx19(\"div\", {\n      className: \"px-3 py-1 text-gray-500\",\n      children: \"No results\"\n    })\n  });\n});\nMentionList.displayName = \"MentionList\";\nvar MentionList_default = MentionList;\n\n// src/components/chatInput/mentionSuggestion.ts\nvar mentionSuggestion = {\n  items: async ({\n    query\n  }) => {\n    const providers = useCedarStore.getState().getMentionProvidersByTrigger(\"@\");\n    const allItems = [];\n    for (const provider of providers) {\n      const items = await provider.getItems(query);\n      allItems.push(...items.map(item => ({\n        ...item,\n        providerId: provider.id\n      })));\n    }\n    return allItems;\n  },\n  render: () => {\n    let component;\n    let popupElement = null;\n    let cleanup = null;\n    return {\n      onStart: props => {\n        component = new ReactRenderer(MentionList_default, {\n          props,\n          editor: props.editor\n        });\n        if (!props.clientRect) {\n          return;\n        }\n        popupElement = document.createElement(\"div\");\n        popupElement.style.position = \"absolute\";\n        popupElement.style.zIndex = \"9999\";\n        popupElement.style.maxWidth = \"32rem\";\n        popupElement.style.minWidth = \"12rem\";\n        popupElement.style.width = \"fit-content\";\n        popupElement.appendChild(component.element);\n        document.body.appendChild(popupElement);\n        const virtualElement = {\n          getBoundingClientRect: () => {\n            const rect = props.clientRect?.();\n            return rect || new DOMRect();\n          }\n        };\n        const updatePosition = async () => {\n          if (!popupElement) return;\n          const {\n            x,\n            y\n          } = await computePosition(virtualElement, popupElement, {\n            placement: \"bottom-start\",\n            middleware: [offset(6), flip(), shift({\n              padding: 5\n            })]\n          });\n          Object.assign(popupElement.style, {\n            left: `${x}px`,\n            top: `${y}px`\n          });\n        };\n        cleanup = autoUpdate(virtualElement, popupElement, updatePosition);\n      },\n      onUpdate(props) {\n        component.updateProps(props);\n        if (!props.clientRect || !popupElement) {\n          return;\n        }\n        const virtualElement = {\n          getBoundingClientRect: () => {\n            const rect = props.clientRect?.();\n            return rect || new DOMRect();\n          }\n        };\n        computePosition(virtualElement, popupElement, {\n          placement: \"bottom-start\",\n          middleware: [offset(6), flip(), shift({\n            padding: 5\n          })]\n        }).then(({\n          x,\n          y\n        }) => {\n          if (popupElement) {\n            Object.assign(popupElement.style, {\n              left: `${x}px`,\n              top: `${y}px`\n            });\n          }\n        });\n      },\n      onKeyDown(props) {\n        if (props.event.key === \"Escape\") {\n          if (popupElement) {\n            popupElement.style.display = \"none\";\n          }\n          return true;\n        }\n        const mentionListRef = component.ref;\n        if (mentionListRef?.onKeyDown) {\n          const handled = mentionListRef.onKeyDown({\n            event: props.event\n          });\n          if (handled) {\n            props.event.preventDefault();\n            props.event.stopPropagation();\n          }\n          return handled;\n        }\n        return false;\n      },\n      onExit() {\n        if (cleanup) {\n          cleanup();\n        }\n        if (popupElement && popupElement.parentNode) {\n          popupElement.parentNode.removeChild(popupElement);\n        }\n        component.destroy();\n      }\n    };\n  },\n  command: ({\n    editor,\n    range,\n    props\n  }) => {\n    const item = props;\n    const provider = useCedarStore.getState().getMentionProvidersByTrigger(\"@\").find(p => p.id === item.providerId);\n    if (!provider) {\n      console.warn(\"No provider found for item:\", item);\n      return;\n    }\n    const contextEntry = provider.toContextEntry(item);\n    const contextKey = provider.id;\n    const state = useCedarStore.getState();\n    state.addContextEntry(contextKey, contextEntry);\n    editor.chain().focus().insertContentAt(range, [{\n      type: \"mention\",\n      attrs: {\n        id: item.id,\n        label: item.label,\n        providerId: provider.id,\n        contextKey,\n        contextEntryId: contextEntry.id\n      }\n    }, {\n      type: \"text\",\n      text: \" \"\n    }]).run();\n  }\n};\nvar mentionSuggestion_default = mentionSuggestion;\n\n// src/components/chatInput/useCedarEditor.ts\nvar useCedarEditor = (options = {}) => {\n  const {\n    placeholder = \"Tab to start typing. Ask me anything!\",\n    onSubmit,\n    onFocus,\n    onBlur,\n    stream = true,\n    sendMessageParams,\n    onEnterOverride\n  } = options;\n  const sendMessage = useCedarStore(state => state.sendMessage);\n  const {\n    chatInputContent,\n    overrideInputContent,\n    setChatInputContent,\n    setOverrideInputContent\n  } = useChatInput();\n  const [isEditorEmpty, setIsEditorEmpty] = useState7(true);\n  const editor = useEditor({\n    immediatelyRender: false,\n    extensions: [StarterKit.configure({\n      document: false,\n      hardBreak: {\n        keepMarks: true,\n        HTMLAttributes: {\n          class: \"hard-break\"\n        }\n      }\n    }), Document.extend({\n      content: \"block+\"\n    }), Placeholder.configure({\n      placeholder,\n      showOnlyWhenEditable: true,\n      showOnlyCurrent: true\n    }), AddedText, RemovedText, Mention.extend({\n      addAttributes() {\n        return {\n          id: {\n            default: null,\n            parseHTML: element => element.getAttribute(\"data-id\"),\n            renderHTML: attributes => {\n              if (!attributes.id) {\n                return {};\n              }\n              return {\n                \"data-id\": attributes.id\n              };\n            }\n          },\n          label: {\n            default: null,\n            parseHTML: element => element.getAttribute(\"data-label\"),\n            renderHTML: attributes => {\n              if (!attributes.label) {\n                return {};\n              }\n              return {\n                \"data-label\": attributes.label\n              };\n            }\n          },\n          providerId: {\n            default: null,\n            parseHTML: element => element.getAttribute(\"data-provider-id\"),\n            renderHTML: attributes => {\n              if (!attributes.providerId) {\n                return {};\n              }\n              return {\n                \"data-provider-id\": attributes.providerId\n              };\n            }\n          },\n          contextKey: {\n            default: null,\n            parseHTML: element => element.getAttribute(\"data-context-key\"),\n            renderHTML: attributes => {\n              if (!attributes.contextKey) {\n                return {};\n              }\n              return {\n                \"data-context-key\": attributes.contextKey\n              };\n            }\n          },\n          contextEntryId: {\n            default: null,\n            parseHTML: element => element.getAttribute(\"data-context-entry-id\"),\n            renderHTML: attributes => {\n              if (!attributes.contextEntryId) {\n                return {};\n              }\n              return {\n                \"data-context-entry-id\": attributes.contextEntryId\n              };\n            }\n          }\n        };\n      },\n      addNodeView() {\n        return ReactNodeViewRenderer(MentionNodeView);\n      },\n      addStorage() {\n        return {\n          mentionNodes: /* @__PURE__ */new Map()\n        };\n      },\n      onUpdate() {\n        const currentMentions = /* @__PURE__ */new Map();\n        const {\n          doc\n        } = this.editor.state;\n        doc.descendants(node => {\n          if (node.type.name === \"mention\" && node.attrs.contextEntryId) {\n            currentMentions.set(node.attrs.contextEntryId, {\n              contextKey: node.attrs.contextKey,\n              node\n            });\n          }\n        });\n        const previousMentions = this.storage?.mentionNodes || /* @__PURE__ */new Map();\n        previousMentions.forEach((value, contextEntryId) => {\n          if (!currentMentions.has(contextEntryId)) {\n            const state = useCedarStore.getState();\n            state.removeContextEntry(value.contextKey, contextEntryId);\n          }\n        });\n        if (this.storage) {\n          this.storage.mentionNodes = currentMentions;\n        }\n      }\n    }).configure({\n      suggestion: mentionSuggestion_default\n    })],\n    content: chatInputContent || \"\",\n    editable: true,\n    onFocus: () => {\n      onFocus?.();\n    },\n    onBlur: () => {\n      onBlur?.();\n    },\n    onUpdate: ({\n      editor: editor2\n    }) => {\n      const editorState = editor2.getJSON();\n      setChatInputContent(editorState);\n      setIsEditorEmpty(editor2.isEmpty);\n    },\n    editorProps: {\n      handleKeyDown: (view, event) => {\n        if (event.key === \"Enter\" && !event.shiftKey) {\n          const {\n            state\n          } = view;\n          const hasActiveSuggestion = state.plugins.some(plugin => {\n            const pluginState = plugin.getState?.(state);\n            return pluginState?.active || pluginState?.open;\n          });\n          if (hasActiveSuggestion) {\n            event.preventDefault();\n            event.stopPropagation();\n            return false;\n          }\n          if (onEnterOverride && onEnterOverride(event)) {\n            return true;\n          }\n          handleSubmit();\n          return true;\n        }\n        return false;\n      }\n    }\n  });\n  const getEditorTextWithChoices = () => {\n    if (!editor) return \"\";\n    const {\n      state\n    } = editor;\n    const {\n      doc\n    } = state;\n    let resultText = \"\";\n    doc.descendants(node => {\n      if (node.isText) {\n        resultText += node.text;\n      }\n      if (node.type.name === \"choice\") {\n        const attrs = node.attrs;\n        const options2 = attrs.options || [];\n        const selectedOption = attrs.selectedOption || \"\";\n        const optionValue = selectedOption || (options2.length > 0 ? options2[0] : \"\");\n        resultText += ` ${optionValue} `;\n      }\n      return true;\n    });\n    return resultText;\n  };\n  const handleSubmit = async () => {\n    if (!editor || isEditorEmpty) return;\n    const textContent = getEditorTextWithChoices();\n    if (textContent.trim()) {\n      if (onSubmit) {\n        onSubmit(textContent, editor, () => {\n          editor.commands.clearContent();\n          setIsEditorEmpty(true);\n          setOverrideInputContent(\"\");\n          setChatInputContent({\n            type: \"doc\",\n            content: [{\n              type: \"paragraph\",\n              content: []\n            }]\n          });\n        });\n      } else {\n        sendMessage({\n          stream,\n          ...sendMessageParams\n        });\n        editor.commands.clearContent();\n        setIsEditorEmpty(true);\n        setOverrideInputContent(\"\");\n        setChatInputContent({\n          type: \"doc\",\n          content: [{\n            type: \"paragraph\",\n            content: []\n          }]\n        });\n      }\n      editor.commands.focus();\n      onFocus?.();\n    }\n  };\n  useEffect15(() => {\n    if (!editor || !overrideInputContent?.input) return;\n    setIsEditorEmpty(false);\n    const input = overrideInputContent.input;\n    editor.commands.clearContent();\n    if (typeof input === \"string\") {\n      editor.commands.setContent(input);\n      return;\n    }\n    if (Array.isArray(input)) {\n      input.forEach(item => {\n        if (typeof item === \"string\") {\n          editor.commands.insertContent(item);\n        } else {\n          editor.commands.insertContent(item.chosenValue || \"\");\n        }\n      });\n    }\n  }, [editor, overrideInputContent]);\n  return {\n    editor,\n    isEditorEmpty,\n    handleSubmit,\n    getEditorText: getEditorTextWithChoices\n  };\n};\n\n// src/store/agentConnection/useTypedAgentConnection.ts\nfunction useTypedAgentConnection(providerType) {\n  const store = useCedarStore();\n  const currentProvider = store.providerConfig?.provider;\n  if (currentProvider !== providerType) {\n    console.warn(`Provider mismatch: expected ${providerType}, but current provider is ${currentProvider}`);\n  }\n  return {\n    callLLM: store.callLLM,\n    streamLLM: store.streamLLM,\n    isConnected: store.isConnected,\n    isStreaming: store.isStreaming\n  };\n}\nfunction useAgentConnection() {\n  const store = useCedarStore();\n  const provider = store.providerConfig?.provider;\n  if (!provider) {\n    throw new Error(\"No provider configured\");\n  }\n  return {\n    provider,\n    ...useTypedAgentConnection(provider)\n  };\n}\n\n// src/store/agentConnection/responseProcessors/humanInTheLoopTypes.ts\nvar HumanInTheLoopResponseSchema = StructuredResponseSchema(\"humanInTheLoop\").and(external_exports.object({\n  status: external_exports.literal(\"suspended\"),\n  runId: external_exports.string(),\n  stepPath: external_exports.array(external_exports.array(external_exports.string())).min(1),\n  // [string[], ...string[][]]\n  suspendPayload: external_exports.record(external_exports.unknown()).optional(),\n  message: external_exports.string().optional(),\n  timeoutMs: external_exports.number().optional(),\n  metadata: external_exports.record(external_exports.unknown()).optional()\n}));\n\n// src/store/agentConnection/responseProcessors/createResponseProcessor.ts\nfunction createResponseProcessor(p) {\n  return p;\n}\nfunction createSetStateResponseProcessor(config2) {\n  const {\n    namespace,\n    setterKey,\n    execute,\n    validate\n  } = config2;\n  const defaultValidate = obj => {\n    if (obj.type !== \"setState\") return false;\n    if (setterKey && obj.setterKey !== setterKey) return false;\n    return true;\n  };\n  return {\n    type: \"setState\",\n    namespace,\n    execute,\n    validate: validate ?? defaultValidate\n  };\n}\nfunction createLegacyActionResponseProcessor(config2) {\n  const {\n    namespace,\n    setterKey,\n    execute,\n    validate\n  } = config2;\n  const defaultValidate = obj => {\n    if (obj.type !== \"action\") return false;\n    if (setterKey && obj.setterKey !== setterKey) return false;\n    return true;\n  };\n  return {\n    type: \"action\",\n    namespace,\n    execute,\n    validate: validate ?? defaultValidate\n  };\n}\nvar SetStateResponseSchema = StructuredResponseSchema(\"setState\").and(external_exports.object({\n  stateKey: external_exports.string(),\n  setterKey: external_exports.string(),\n  args: external_exports.unknown().optional()\n}));\nvar LegacyActionResponseSchema = StructuredResponseSchema(\"action\").and(external_exports.object({\n  stateKey: external_exports.string(),\n  setterKey: external_exports.string(),\n  args: external_exports.unknown().optional()\n}));\n\n// src/store/messages/renderers/createMessageRenderer.ts\nfunction createMessageRenderer(p) {\n  return p;\n}\nfunction createSetStateMessageRenderer(config2) {\n  const {\n    namespace,\n    setterKey,\n    render,\n    validateMessage\n  } = config2;\n  const defaultValidate = msg => {\n    if (msg.type !== \"setState\") return false;\n    if (setterKey && msg.setterKey !== setterKey) return false;\n    return true;\n  };\n  const rendererFn = message => {\n    return render(message);\n  };\n  return {\n    type: \"setState\",\n    namespace,\n    render: rendererFn,\n    validateMessage: validateMessage ?? defaultValidate\n  };\n}\nfunction createLegacyActionMessageRenderer(config2) {\n  const {\n    namespace,\n    setterKey,\n    render,\n    validateMessage\n  } = config2;\n  const defaultValidate = msg => {\n    if (msg.type !== \"action\") return false;\n    if (setterKey && msg.setterKey !== setterKey) return false;\n    return true;\n  };\n  const rendererFn = message => {\n    return render(message);\n  };\n  return {\n    type: \"action\",\n    namespace,\n    render: rendererFn,\n    validateMessage: validateMessage ?? defaultValidate\n  };\n}\n\n// src/index.ts\nimport { Editor, EditorContent } from \"@tiptap/react\";\nexport { AISDKParamsSchema, ActivationMode, AdditionalContextParamSchema, AdditionalContextSchema, AnthropicParamsSchema, BackendMessageResponseSchema, BaseParamsSchema2 as BaseParamsSchema, BaseStructuredResponseSchema, CedarCopilot, Editor as CedarEditor, EditorContent as CedarEditorContent, ChatRequestSchema, ChatResponseSchema, ContextEntrySchema, CustomParamsSchema, DEFAULT_THREAD_ID, DebuggerPanel, FrontendToolResponseSchema, Hotkey, HumanInTheLoopResponseSchema, LLMResponseSchema, LegacyActionResponseSchema, MastraParamsSchema, MentionList_default as MentionList, MentionNodeView, MouseEvent, OpenAIParamsSchema, SelectionEvent, SetStateResponseSchema, StreamEventSchema, StructuredResponseSchema, VoiceLLMResponseSchema, addDiffToArrayObjs, addDiffToMapObj, addDiffToPrimitiveArray, cn, createAgentConnectionSlice, createAgentContextSlice, createBorderColor, createChatRequestSchema, createFrontendToolResponseProcessor, createLegacyActionMessageRenderer, createLegacyActionResponseProcessor, createMessageRenderer, createMessagesSlice, createResponseProcessor, createSetStateMessageRenderer, createSetStateResponseProcessor, createStateSlice, createStylingSlice, createToolsSlice, defaultFrontendToolMessageRenderer, desanitizeJson, desaturateColor, frontendToolResponseProcessor, getCedarState, getLightenedColor, getShadedColor, getTextColorForBackground, hexToRgb, humanInTheLoopMessageRenderer, humanInTheLoopResponseProcessor, isDarkMode, luminanceThreshold, messageResponseProcessor, registerState, sanitizeJson, setCedarState, setCedarStore, useAgentConnection, useCedarDiffState, useCedarEditor, useCedarState, useCedarStore, useChatInput, useDebugger, useDiffHistory, useDiffState, useDiffStateHelpers, useDiffStateOperations, useMentionProviders, useMentionProvidersByTrigger, useMessages, useMultipleSpells, useRegisterDiffState, useRegisterFrontendTool, useRegisterState, useRenderAdditionalContext, useSpell, useSpells, useStateBasedMentionProvider, useStyling, useSubscribeStateToAgentContext, useSubscribeToDiffValue, useSubscribeToDiffValues, useThreadController, useThreadMessages, useTools, useTypedAgentConnection, useVoice, withClassName };\n//# sourceMappingURL=index.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}