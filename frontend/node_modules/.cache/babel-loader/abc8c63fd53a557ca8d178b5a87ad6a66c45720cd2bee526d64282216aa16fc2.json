{"ast":null,"code":"import { PluginKey, Plugin } from '@tiptap/pm/state';\nimport { DecorationSet, Decoration } from '@tiptap/pm/view';\nimport { escapeForRegEx } from '@tiptap/core';\nfunction findSuggestionMatch(config) {\n  var _a;\n  const {\n    char,\n    allowSpaces: allowSpacesOption,\n    allowToIncludeChar,\n    allowedPrefixes,\n    startOfLine,\n    $position\n  } = config;\n  const allowSpaces = allowSpacesOption && !allowToIncludeChar;\n  const escapedChar = escapeForRegEx(char);\n  const suffix = new RegExp(`\\\\s${escapedChar}$`);\n  const prefix = startOfLine ? '^' : '';\n  const finalEscapedChar = allowToIncludeChar ? '' : escapedChar;\n  const regexp = allowSpaces ? new RegExp(`${prefix}${escapedChar}.*?(?=\\\\s${finalEscapedChar}|$)`, 'gm') : new RegExp(`${prefix}(?:^)?${escapedChar}[^\\\\s${finalEscapedChar}]*`, 'gm');\n  const text = ((_a = $position.nodeBefore) === null || _a === void 0 ? void 0 : _a.isText) && $position.nodeBefore.text;\n  if (!text) {\n    return null;\n  }\n  const textFrom = $position.pos - text.length;\n  const match = Array.from(text.matchAll(regexp)).pop();\n  if (!match || match.input === undefined || match.index === undefined) {\n    return null;\n  }\n  // JavaScript doesn't have lookbehinds. This hacks a check that first character\n  // is a space or the start of the line\n  const matchPrefix = match.input.slice(Math.max(0, match.index - 1), match.index);\n  const matchPrefixIsAllowed = new RegExp(`^[${allowedPrefixes === null || allowedPrefixes === void 0 ? void 0 : allowedPrefixes.join('')}\\0]?$`).test(matchPrefix);\n  if (allowedPrefixes !== null && !matchPrefixIsAllowed) {\n    return null;\n  }\n  // The absolute position of the match in the document\n  const from = textFrom + match.index;\n  let to = from + match[0].length;\n  // Edge case handling; if spaces are allowed and we're directly in between\n  // two triggers\n  if (allowSpaces && suffix.test(text.slice(to - 1, to + 1))) {\n    match[0] += ' ';\n    to += 1;\n  }\n  // If the $position is located within the matched substring, return that range\n  if (from < $position.pos && to >= $position.pos) {\n    return {\n      range: {\n        from,\n        to\n      },\n      query: match[0].slice(char.length),\n      text: match[0]\n    };\n  }\n  return null;\n}\nconst SuggestionPluginKey = new PluginKey('suggestion');\n/**\n * This utility allows you to create suggestions.\n * @see https://tiptap.dev/api/utilities/suggestion\n */\nfunction Suggestion({\n  pluginKey = SuggestionPluginKey,\n  editor,\n  char = '@',\n  allowSpaces = false,\n  allowToIncludeChar = false,\n  allowedPrefixes = [' '],\n  startOfLine = false,\n  decorationTag = 'span',\n  decorationClass = 'suggestion',\n  decorationContent = '',\n  decorationEmptyClass = 'is-empty',\n  command = () => null,\n  items = () => [],\n  render = () => ({}),\n  allow = () => true,\n  findSuggestionMatch: findSuggestionMatch$1 = findSuggestionMatch\n}) {\n  let props;\n  const renderer = render === null || render === void 0 ? void 0 : render();\n  const plugin = new Plugin({\n    key: pluginKey,\n    view() {\n      return {\n        update: async (view, prevState) => {\n          var _a, _b, _c, _d, _e, _f, _g;\n          const prev = (_a = this.key) === null || _a === void 0 ? void 0 : _a.getState(prevState);\n          const next = (_b = this.key) === null || _b === void 0 ? void 0 : _b.getState(view.state);\n          // See how the state changed\n          const moved = prev.active && next.active && prev.range.from !== next.range.from;\n          const started = !prev.active && next.active;\n          const stopped = prev.active && !next.active;\n          const changed = !started && !stopped && prev.query !== next.query;\n          const handleStart = started || moved && changed;\n          const handleChange = changed || moved;\n          const handleExit = stopped || moved && changed;\n          // Cancel when suggestion isn't active\n          if (!handleStart && !handleChange && !handleExit) {\n            return;\n          }\n          const state = handleExit && !handleStart ? prev : next;\n          const decorationNode = view.dom.querySelector(`[data-decoration-id=\"${state.decorationId}\"]`);\n          props = {\n            editor,\n            range: state.range,\n            query: state.query,\n            text: state.text,\n            items: [],\n            command: commandProps => {\n              return command({\n                editor,\n                range: state.range,\n                props: commandProps\n              });\n            },\n            decorationNode,\n            // virtual node for popper.js or tippy.js\n            // this can be used for building popups without a DOM node\n            clientRect: decorationNode ? () => {\n              var _a;\n              // because of `items` can be asynchrounous weâ€™ll search for the current decoration node\n              const {\n                decorationId\n              } = (_a = this.key) === null || _a === void 0 ? void 0 : _a.getState(editor.state); // eslint-disable-line\n              const currentDecorationNode = view.dom.querySelector(`[data-decoration-id=\"${decorationId}\"]`);\n              return (currentDecorationNode === null || currentDecorationNode === void 0 ? void 0 : currentDecorationNode.getBoundingClientRect()) || null;\n            } : null\n          };\n          if (handleStart) {\n            (_c = renderer === null || renderer === void 0 ? void 0 : renderer.onBeforeStart) === null || _c === void 0 ? void 0 : _c.call(renderer, props);\n          }\n          if (handleChange) {\n            (_d = renderer === null || renderer === void 0 ? void 0 : renderer.onBeforeUpdate) === null || _d === void 0 ? void 0 : _d.call(renderer, props);\n          }\n          if (handleChange || handleStart) {\n            props.items = await items({\n              editor,\n              query: state.query\n            });\n          }\n          if (handleExit) {\n            (_e = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _e === void 0 ? void 0 : _e.call(renderer, props);\n          }\n          if (handleChange) {\n            (_f = renderer === null || renderer === void 0 ? void 0 : renderer.onUpdate) === null || _f === void 0 ? void 0 : _f.call(renderer, props);\n          }\n          if (handleStart) {\n            (_g = renderer === null || renderer === void 0 ? void 0 : renderer.onStart) === null || _g === void 0 ? void 0 : _g.call(renderer, props);\n          }\n        },\n        destroy: () => {\n          var _a;\n          if (!props) {\n            return;\n          }\n          (_a = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _a === void 0 ? void 0 : _a.call(renderer, props);\n        }\n      };\n    },\n    state: {\n      // Initialize the plugin's internal state.\n      init() {\n        const state = {\n          active: false,\n          range: {\n            from: 0,\n            to: 0\n          },\n          query: null,\n          text: null,\n          composing: false\n        };\n        return state;\n      },\n      // Apply changes to the plugin state from a view transaction.\n      apply(transaction, prev, _oldState, state) {\n        const {\n          isEditable\n        } = editor;\n        const {\n          composing\n        } = editor.view;\n        const {\n          selection\n        } = transaction;\n        const {\n          empty,\n          from\n        } = selection;\n        const next = {\n          ...prev\n        };\n        next.composing = composing;\n        // We can only be suggesting if the view is editable, and:\n        //   * there is no selection, or\n        //   * a composition is active (see: https://github.com/ueberdosis/tiptap/issues/1449)\n        if (isEditable && (empty || editor.view.composing)) {\n          // Reset active state if we just left the previous suggestion range\n          if ((from < prev.range.from || from > prev.range.to) && !composing && !prev.composing) {\n            next.active = false;\n          }\n          // Try to match against where our cursor currently is\n          const match = findSuggestionMatch$1({\n            char,\n            allowSpaces,\n            allowToIncludeChar,\n            allowedPrefixes,\n            startOfLine,\n            $position: selection.$from\n          });\n          const decorationId = `id_${Math.floor(Math.random() * 0xffffffff)}`;\n          // If we found a match, update the current state to show it\n          if (match && allow({\n            editor,\n            state,\n            range: match.range,\n            isActive: prev.active\n          })) {\n            next.active = true;\n            next.decorationId = prev.decorationId ? prev.decorationId : decorationId;\n            next.range = match.range;\n            next.query = match.query;\n            next.text = match.text;\n          } else {\n            next.active = false;\n          }\n        } else {\n          next.active = false;\n        }\n        // Make sure to empty the range if suggestion is inactive\n        if (!next.active) {\n          next.decorationId = null;\n          next.range = {\n            from: 0,\n            to: 0\n          };\n          next.query = null;\n          next.text = null;\n        }\n        return next;\n      }\n    },\n    props: {\n      // Call the keydown hook if suggestion is active.\n      handleKeyDown(view, event) {\n        var _a;\n        const {\n          active,\n          range\n        } = plugin.getState(view.state);\n        if (!active) {\n          return false;\n        }\n        return ((_a = renderer === null || renderer === void 0 ? void 0 : renderer.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(renderer, {\n          view,\n          event,\n          range\n        })) || false;\n      },\n      // Setup decorator on the currently active suggestion.\n      decorations(state) {\n        const {\n          active,\n          range,\n          decorationId,\n          query\n        } = plugin.getState(state);\n        if (!active) {\n          return null;\n        }\n        const isEmpty = !(query === null || query === void 0 ? void 0 : query.length);\n        const classNames = [decorationClass];\n        if (isEmpty) {\n          classNames.push(decorationEmptyClass);\n        }\n        return DecorationSet.create(state.doc, [Decoration.inline(range.from, range.to, {\n          nodeName: decorationTag,\n          class: classNames.join(' '),\n          'data-decoration-id': decorationId,\n          'data-decoration-content': decorationContent\n        })]);\n      }\n    }\n  });\n  return plugin;\n}\nexport { Suggestion, SuggestionPluginKey, Suggestion as default, findSuggestionMatch };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}