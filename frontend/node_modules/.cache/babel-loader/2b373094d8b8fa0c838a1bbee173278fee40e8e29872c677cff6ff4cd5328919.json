{"ast":null,"code":"import { Node, mergeAttributes } from '@tiptap/core';\nimport { Node as Node$1 } from '@tiptap/pm/model';\nimport Suggestion from '@tiptap/suggestion';\nimport { PluginKey } from '@tiptap/pm/state';\n\n/**\n * Returns the suggestion options for a trigger of the Mention extension. These\n * options are used to create a `Suggestion` ProseMirror plugin. Each plugin lets\n * you define a different trigger that opens the Mention menu. For example,\n * you can define a `@` trigger to mention users and a `#` trigger to mention\n * tags.\n *\n * @param param0 The configured options for the suggestion\n * @returns\n */\nfunction getSuggestionOptions({\n  editor: tiptapEditor,\n  overrideSuggestionOptions,\n  extensionName,\n  char = '@'\n}) {\n  const pluginKey = new PluginKey();\n  return {\n    editor: tiptapEditor,\n    char,\n    pluginKey,\n    command: ({\n      editor,\n      range,\n      props\n    }) => {\n      var _a, _b, _c;\n      // increase range.to by one when the next node is of type \"text\"\n      // and starts with a space character\n      const nodeAfter = editor.view.state.selection.$to.nodeAfter;\n      const overrideSpace = (_a = nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.text) === null || _a === void 0 ? void 0 : _a.startsWith(' ');\n      if (overrideSpace) {\n        range.to += 1;\n      }\n      editor.chain().focus().insertContentAt(range, [{\n        type: extensionName,\n        attrs: {\n          ...props,\n          mentionSuggestionChar: char\n        }\n      }, {\n        type: 'text',\n        text: ' '\n      }]).run();\n      // get reference to `window` object from editor element, to support cross-frame JS usage\n      (_c = (_b = editor.view.dom.ownerDocument.defaultView) === null || _b === void 0 ? void 0 : _b.getSelection()) === null || _c === void 0 ? void 0 : _c.collapseToEnd();\n    },\n    allow: ({\n      state,\n      range\n    }) => {\n      const $from = state.doc.resolve(range.from);\n      const type = state.schema.nodes[extensionName];\n      const allow = !!$from.parent.type.contentMatch.matchType(type);\n      return allow;\n    },\n    ...overrideSuggestionOptions\n  };\n}\n\n/**\n * Returns the suggestions for the mention extension.\n *\n * @param options The extension options\n * @returns the suggestions\n */\nfunction getSuggestions(options) {\n  return (options.options.suggestions.length ? options.options.suggestions : [options.options.suggestion]).map(suggestion => getSuggestionOptions({\n    // @ts-ignore `editor` can be `undefined` when converting the document to HTML with the HTML utility\n    editor: options.editor,\n    overrideSuggestionOptions: suggestion,\n    extensionName: options.name,\n    char: suggestion.char\n  }));\n}\n/**\n * Returns the suggestion options of the mention that has a given character trigger. If not\n * found, it returns the first suggestion.\n *\n * @param options The extension options\n * @param char The character that triggers the mention\n * @returns The suggestion options\n */\nfunction getSuggestionFromChar(options, char) {\n  const suggestions = getSuggestions(options);\n  const suggestion = suggestions.find(s => s.char === char);\n  if (suggestion) {\n    return suggestion;\n  }\n  if (suggestions.length) {\n    return suggestions[0];\n  }\n  return null;\n}\n/**\n * This extension allows you to insert mentions into the editor.\n * @see https://www.tiptap.dev/api/extensions/mention\n */\nconst Mention = Node.create({\n  name: 'mention',\n  priority: 101,\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n      renderText({\n        node,\n        suggestion\n      }) {\n        var _a, _b;\n        return `${(_a = suggestion === null || suggestion === void 0 ? void 0 : suggestion.char) !== null && _a !== void 0 ? _a : '@'}${(_b = node.attrs.label) !== null && _b !== void 0 ? _b : node.attrs.id}`;\n      },\n      deleteTriggerWithBackspace: false,\n      renderHTML({\n        options,\n        node,\n        suggestion\n      }) {\n        var _a, _b;\n        return ['span', mergeAttributes(this.HTMLAttributes, options.HTMLAttributes), `${(_a = suggestion === null || suggestion === void 0 ? void 0 : suggestion.char) !== null && _a !== void 0 ? _a : '@'}${(_b = node.attrs.label) !== null && _b !== void 0 ? _b : node.attrs.id}`];\n      },\n      suggestions: [],\n      suggestion: {}\n    };\n  },\n  group: 'inline',\n  inline: true,\n  selectable: false,\n  atom: true,\n  addAttributes() {\n    return {\n      id: {\n        default: null,\n        parseHTML: element => element.getAttribute('data-id'),\n        renderHTML: attributes => {\n          if (!attributes.id) {\n            return {};\n          }\n          return {\n            'data-id': attributes.id\n          };\n        }\n      },\n      label: {\n        default: null,\n        parseHTML: element => element.getAttribute('data-label'),\n        renderHTML: attributes => {\n          if (!attributes.label) {\n            return {};\n          }\n          return {\n            'data-label': attributes.label\n          };\n        }\n      },\n      // When there are multiple types of mentions, this attribute helps distinguish them\n      mentionSuggestionChar: {\n        default: '@',\n        parseHTML: element => element.getAttribute('data-mention-suggestion-char'),\n        renderHTML: attributes => {\n          return {\n            'data-mention-suggestion-char': attributes.mentionSuggestionChar\n          };\n        }\n      }\n    };\n  },\n  parseHTML() {\n    return [{\n      tag: `span[data-type=\"${this.name}\"]`\n    }];\n  },\n  renderHTML({\n    node,\n    HTMLAttributes\n  }) {\n    const suggestion = getSuggestionFromChar(this, node.attrs.mentionSuggestionChar);\n    if (this.options.renderLabel !== undefined) {\n      console.warn('renderLabel is deprecated use renderText and renderHTML instead');\n      return ['span', mergeAttributes({\n        'data-type': this.name\n      }, this.options.HTMLAttributes, HTMLAttributes), this.options.renderLabel({\n        options: this.options,\n        node,\n        suggestion\n      })];\n    }\n    const mergedOptions = {\n      ...this.options\n    };\n    mergedOptions.HTMLAttributes = mergeAttributes({\n      'data-type': this.name\n    }, this.options.HTMLAttributes, HTMLAttributes);\n    const html = this.options.renderHTML({\n      options: mergedOptions,\n      node,\n      suggestion\n    });\n    if (typeof html === 'string') {\n      return ['span', mergeAttributes({\n        'data-type': this.name\n      }, this.options.HTMLAttributes, HTMLAttributes), html];\n    }\n    return html;\n  },\n  renderText({\n    node\n  }) {\n    const args = {\n      options: this.options,\n      node,\n      suggestion: getSuggestionFromChar(this, node.attrs.mentionSuggestionChar)\n    };\n    if (this.options.renderLabel !== undefined) {\n      console.warn('renderLabel is deprecated use renderText and renderHTML instead');\n      return this.options.renderLabel(args);\n    }\n    return this.options.renderText(args);\n  },\n  addKeyboardShortcuts() {\n    return {\n      Backspace: () => this.editor.commands.command(({\n        tr,\n        state\n      }) => {\n        let isMention = false;\n        const {\n          selection\n        } = state;\n        const {\n          empty,\n          anchor\n        } = selection;\n        if (!empty) {\n          return false;\n        }\n        state.doc.nodesBetween(anchor - 1, anchor, (node, pos) => {\n          if (node.type.name === this.name) {\n            isMention = true;\n            tr.insertText(this.options.deleteTriggerWithBackspace ? '' : this.options.suggestion.char || '', pos, pos + node.nodeSize);\n            return false;\n          }\n        });\n        // Store node and position for later use\n        let mentionNode = new Node$1();\n        let mentionPos = 0;\n        state.doc.nodesBetween(anchor - 1, anchor, (node, pos) => {\n          if (node.type.name === this.name) {\n            isMention = true;\n            mentionNode = node;\n            mentionPos = pos;\n            return false;\n          }\n        });\n        if (isMention) {\n          tr.insertText(this.options.deleteTriggerWithBackspace ? '' : mentionNode.attrs.mentionSuggestionChar, mentionPos, mentionPos + mentionNode.nodeSize);\n        }\n        return isMention;\n      })\n    };\n  },\n  addProseMirrorPlugins() {\n    // Create a plugin for each suggestion configuration\n    return getSuggestions(this).map(Suggestion);\n  }\n});\nexport { Mention, Mention as default };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}