{"ast":null,"code":"/*!\n * https://github.com/Starcounter-Jack/JSON-Patch\n * (c) 2017-2022 Joachim Wester\n * MIT licensed\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\nexport function hasOwnProperty(obj, key) {\n  return _hasOwnProperty.call(obj, key);\n}\nexport function _objectKeys(obj) {\n  if (Array.isArray(obj)) {\n    var keys_1 = new Array(obj.length);\n    for (var k = 0; k < keys_1.length; k++) {\n      keys_1[k] = \"\" + k;\n    }\n    return keys_1;\n  }\n  if (Object.keys) {\n    return Object.keys(obj);\n  }\n  var keys = [];\n  for (var i in obj) {\n    if (hasOwnProperty(obj, i)) {\n      keys.push(i);\n    }\n  }\n  return keys;\n}\n;\n/**\n* Deeply clone the object.\n* https://jsperf.com/deep-copy-vs-json-stringify-json-parse/25 (recursiveDeepCopy)\n* @param  {any} obj value to clone\n* @return {any} cloned obj\n*/\nexport function _deepClone(obj) {\n  switch (typeof obj) {\n    case \"object\":\n      return JSON.parse(JSON.stringify(obj));\n    //Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5\n    case \"undefined\":\n      return null;\n    //this is how JSON.stringify behaves for array items\n    default:\n      return obj;\n    //no need to clone primitives\n  }\n}\n//3x faster than cached /^\\d+$/.test(str)\nexport function isInteger(str) {\n  var i = 0;\n  var len = str.length;\n  var charCode;\n  while (i < len) {\n    charCode = str.charCodeAt(i);\n    if (charCode >= 48 && charCode <= 57) {\n      i++;\n      continue;\n    }\n    return false;\n  }\n  return true;\n}\n/**\n* Escapes a json pointer path\n* @param path The raw pointer\n* @return the Escaped path\n*/\nexport function escapePathComponent(path) {\n  if (path.indexOf('/') === -1 && path.indexOf('~') === -1) return path;\n  return path.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n/**\n * Unescapes a json pointer path\n * @param path The escaped pointer\n * @return The unescaped path\n */\nexport function unescapePathComponent(path) {\n  return path.replace(/~1/g, '/').replace(/~0/g, '~');\n}\nexport function _getPathRecursive(root, obj) {\n  var found;\n  for (var key in root) {\n    if (hasOwnProperty(root, key)) {\n      if (root[key] === obj) {\n        return escapePathComponent(key) + '/';\n      } else if (typeof root[key] === 'object') {\n        found = _getPathRecursive(root[key], obj);\n        if (found != '') {\n          return escapePathComponent(key) + '/' + found;\n        }\n      }\n    }\n  }\n  return '';\n}\nexport function getPath(root, obj) {\n  if (root === obj) {\n    return '/';\n  }\n  var path = _getPathRecursive(root, obj);\n  if (path === '') {\n    throw new Error(\"Object not found in root\");\n  }\n  return \"/\" + path;\n}\n/**\n* Recursively checks whether an object has any undefined values inside.\n*/\nexport function hasUndefined(obj) {\n  if (obj === undefined) {\n    return true;\n  }\n  if (obj) {\n    if (Array.isArray(obj)) {\n      for (var i_1 = 0, len = obj.length; i_1 < len; i_1++) {\n        if (hasUndefined(obj[i_1])) {\n          return true;\n        }\n      }\n    } else if (typeof obj === \"object\") {\n      var objKeys = _objectKeys(obj);\n      var objKeysLength = objKeys.length;\n      for (var i = 0; i < objKeysLength; i++) {\n        if (hasUndefined(obj[objKeys[i]])) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\nfunction patchErrorMessageFormatter(message, args) {\n  var messageParts = [message];\n  for (var key in args) {\n    var value = typeof args[key] === 'object' ? JSON.stringify(args[key], null, 2) : args[key]; // pretty print\n    if (typeof value !== 'undefined') {\n      messageParts.push(key + \": \" + value);\n    }\n  }\n  return messageParts.join('\\n');\n}\nvar PatchError = /** @class */function (_super) {\n  __extends(PatchError, _super);\n  function PatchError(message, name, index, operation, tree) {\n    var _newTarget = this.constructor;\n    var _this = _super.call(this, patchErrorMessageFormatter(message, {\n      name: name,\n      index: index,\n      operation: operation,\n      tree: tree\n    })) || this;\n    _this.name = name;\n    _this.index = index;\n    _this.operation = operation;\n    _this.tree = tree;\n    Object.setPrototypeOf(_this, _newTarget.prototype); // restore prototype chain, see https://stackoverflow.com/a/48342359\n    _this.message = patchErrorMessageFormatter(message, {\n      name: name,\n      index: index,\n      operation: operation,\n      tree: tree\n    });\n    return _this;\n  }\n  return PatchError;\n}(Error);\nexport { PatchError };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}