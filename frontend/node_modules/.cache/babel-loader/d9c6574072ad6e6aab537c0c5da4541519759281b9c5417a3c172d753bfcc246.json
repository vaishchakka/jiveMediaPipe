{"ast":null,"code":"import { isTextSelection, isNodeSelection, posToDOMRect, Extension } from '@tiptap/core';\nimport { Plugin, PluginKey } from '@tiptap/pm/state';\nimport tippy from 'tippy.js';\nclass BubbleMenuView {\n  constructor({\n    editor,\n    element,\n    view,\n    tippyOptions = {},\n    updateDelay = 250,\n    shouldShow\n  }) {\n    this.preventHide = false;\n    this.shouldShow = ({\n      view,\n      state,\n      from,\n      to\n    }) => {\n      const {\n        doc,\n        selection\n      } = state;\n      const {\n        empty\n      } = selection;\n      // Sometime check for `empty` is not enough.\n      // Doubleclick an empty paragraph returns a node size of 2.\n      // So we check also for an empty text size.\n      const isEmptyTextBlock = !doc.textBetween(from, to).length && isTextSelection(state.selection);\n      // When clicking on a element inside the bubble menu the editor \"blur\" event\n      // is called and the bubble menu item is focussed. In this case we should\n      // consider the menu as part of the editor and keep showing the menu\n      const isChildOfMenu = this.element.contains(document.activeElement);\n      const hasEditorFocus = view.hasFocus() || isChildOfMenu;\n      if (!hasEditorFocus || empty || isEmptyTextBlock || !this.editor.isEditable) {\n        return false;\n      }\n      return true;\n    };\n    this.mousedownHandler = () => {\n      this.preventHide = true;\n    };\n    this.dragstartHandler = () => {\n      this.hide();\n    };\n    this.focusHandler = () => {\n      // we use `setTimeout` to make sure `selection` is already updated\n      setTimeout(() => this.update(this.editor.view));\n    };\n    this.blurHandler = ({\n      event\n    }) => {\n      var _a;\n      if (this.preventHide) {\n        this.preventHide = false;\n        return;\n      }\n      if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {\n        return;\n      }\n      if ((event === null || event === void 0 ? void 0 : event.relatedTarget) === this.editor.view.dom) {\n        return;\n      }\n      this.hide();\n    };\n    this.tippyBlurHandler = event => {\n      this.blurHandler({\n        event\n      });\n    };\n    this.handleDebouncedUpdate = (view, oldState) => {\n      const selectionChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.selection.eq(view.state.selection));\n      const docChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.doc.eq(view.state.doc));\n      if (!selectionChanged && !docChanged) {\n        return;\n      }\n      if (this.updateDebounceTimer) {\n        clearTimeout(this.updateDebounceTimer);\n      }\n      this.updateDebounceTimer = window.setTimeout(() => {\n        this.updateHandler(view, selectionChanged, docChanged, oldState);\n      }, this.updateDelay);\n    };\n    this.updateHandler = (view, selectionChanged, docChanged, oldState) => {\n      var _a, _b, _c;\n      const {\n        state,\n        composing\n      } = view;\n      const {\n        selection\n      } = state;\n      const isSame = !selectionChanged && !docChanged;\n      if (composing || isSame) {\n        return;\n      }\n      this.createTooltip();\n      // support for CellSelections\n      const {\n        ranges\n      } = selection;\n      const from = Math.min(...ranges.map(range => range.$from.pos));\n      const to = Math.max(...ranges.map(range => range.$to.pos));\n      const shouldShow = (_a = this.shouldShow) === null || _a === void 0 ? void 0 : _a.call(this, {\n        editor: this.editor,\n        element: this.element,\n        view,\n        state,\n        oldState,\n        from,\n        to\n      });\n      if (!shouldShow) {\n        this.hide();\n        return;\n      }\n      (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({\n        getReferenceClientRect: ((_c = this.tippyOptions) === null || _c === void 0 ? void 0 : _c.getReferenceClientRect) || (() => {\n          if (isNodeSelection(state.selection)) {\n            let node = view.nodeDOM(from);\n            if (node) {\n              const nodeViewWrapper = node.dataset.nodeViewWrapper ? node : node.querySelector('[data-node-view-wrapper]');\n              if (nodeViewWrapper) {\n                node = nodeViewWrapper.firstChild;\n              }\n              if (node) {\n                return node.getBoundingClientRect();\n              }\n            }\n          }\n          return posToDOMRect(view, from, to);\n        })\n      });\n      this.show();\n    };\n    this.editor = editor;\n    this.element = element;\n    this.view = view;\n    this.updateDelay = updateDelay;\n    if (shouldShow) {\n      this.shouldShow = shouldShow;\n    }\n    this.element.addEventListener('mousedown', this.mousedownHandler, {\n      capture: true\n    });\n    this.view.dom.addEventListener('dragstart', this.dragstartHandler);\n    this.editor.on('focus', this.focusHandler);\n    this.editor.on('blur', this.blurHandler);\n    this.tippyOptions = tippyOptions;\n    // Detaches menu content from its current parent\n    this.element.remove();\n    this.element.style.visibility = 'visible';\n  }\n  createTooltip() {\n    const {\n      element: editorElement\n    } = this.editor.options;\n    const editorIsAttached = !!editorElement.parentElement;\n    this.element.tabIndex = 0;\n    if (this.tippy || !editorIsAttached) {\n      return;\n    }\n    this.tippy = tippy(editorElement, {\n      duration: 0,\n      getReferenceClientRect: null,\n      content: this.element,\n      interactive: true,\n      trigger: 'manual',\n      placement: 'top',\n      hideOnClick: 'toggle',\n      ...this.tippyOptions\n    });\n    // maybe we have to hide tippy on its own blur event as well\n    if (this.tippy.popper.firstChild) {\n      this.tippy.popper.firstChild.addEventListener('blur', this.tippyBlurHandler);\n    }\n  }\n  update(view, oldState) {\n    const {\n      state\n    } = view;\n    const hasValidSelection = state.selection.from !== state.selection.to;\n    if (this.updateDelay > 0 && hasValidSelection) {\n      this.handleDebouncedUpdate(view, oldState);\n      return;\n    }\n    const selectionChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.selection.eq(view.state.selection));\n    const docChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.doc.eq(view.state.doc));\n    this.updateHandler(view, selectionChanged, docChanged, oldState);\n  }\n  show() {\n    var _a;\n    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.show();\n  }\n  hide() {\n    var _a;\n    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.hide();\n  }\n  destroy() {\n    var _a, _b;\n    if ((_a = this.tippy) === null || _a === void 0 ? void 0 : _a.popper.firstChild) {\n      this.tippy.popper.firstChild.removeEventListener('blur', this.tippyBlurHandler);\n    }\n    (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.destroy();\n    this.element.removeEventListener('mousedown', this.mousedownHandler, {\n      capture: true\n    });\n    this.view.dom.removeEventListener('dragstart', this.dragstartHandler);\n    this.editor.off('focus', this.focusHandler);\n    this.editor.off('blur', this.blurHandler);\n  }\n}\nconst BubbleMenuPlugin = options => {\n  return new Plugin({\n    key: typeof options.pluginKey === 'string' ? new PluginKey(options.pluginKey) : options.pluginKey,\n    view: view => new BubbleMenuView({\n      view,\n      ...options\n    })\n  });\n};\n\n/**\n * This extension allows you to create a bubble menu.\n * @see https://tiptap.dev/api/extensions/bubble-menu\n */\nconst BubbleMenu = Extension.create({\n  name: 'bubbleMenu',\n  addOptions() {\n    return {\n      element: null,\n      tippyOptions: {},\n      pluginKey: 'bubbleMenu',\n      updateDelay: undefined,\n      shouldShow: null\n    };\n  },\n  addProseMirrorPlugins() {\n    if (!this.options.element) {\n      return [];\n    }\n    return [BubbleMenuPlugin({\n      pluginKey: this.options.pluginKey,\n      editor: this.editor,\n      element: this.options.element,\n      tippyOptions: this.options.tippyOptions,\n      updateDelay: this.options.updateDelay,\n      shouldShow: this.options.shouldShow\n    })];\n  }\n});\nexport { BubbleMenu, BubbleMenuPlugin, BubbleMenuView, BubbleMenu as default };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}