{"ast":null,"code":"import { memo } from 'motion-utils';\n\n/**\n * A list of values that can be hardware-accelerated.\n */\nconst acceleratedValues = new Set([\"opacity\", \"clipPath\", \"filter\", \"transform\"\n// TODO: Could be re-enabled now we have support for linear() easing\n// \"background-color\"\n]);\nconst supportsWaapi = /*@__PURE__*/memo(() => Object.hasOwnProperty.call(Element.prototype, \"animate\"));\nfunction supportsBrowserAnimation(options) {\n  const {\n    motionValue,\n    name,\n    repeatDelay,\n    repeatType,\n    damping,\n    type\n  } = options;\n  const subject = motionValue?.owner?.current;\n  /**\n   * We use this check instead of isHTMLElement() because we explicitly\n   * **don't** want elements in different timing contexts (i.e. popups)\n   * to be accelerated, as it's not possible to sync these animations\n   * properly with those driven from the main window frameloop.\n   */\n  if (!(subject instanceof HTMLElement)) {\n    return false;\n  }\n  const {\n    onUpdate,\n    transformTemplate\n  } = motionValue.owner.getProps();\n  return supportsWaapi() && name && acceleratedValues.has(name) && (name !== \"transform\" || !transformTemplate) &&\n  /**\n   * If we're outputting values to onUpdate then we can't use WAAPI as there's\n   * no way to read the value from WAAPI every frame.\n   */\n  !onUpdate && !repeatDelay && repeatType !== \"mirror\" && damping !== 0 && type !== \"inertia\";\n}\nexport { supportsBrowserAnimation };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}